<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统 3 内存管理</title>
    <link href="/2023/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%203%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/12/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%203%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学的时候发现王道考研这样说的是内存管理，而📕上的是存储器管理</p><p>导致笨🐭有点疑惑，所以就去搜了一下，搜到了一点资料，解答了这个疑惑，或者看一下补充的3.1.0</p><p>其实就一句话：内存又叫内部存储器（不知道这样理解对不对</p><p>其实就是计组里面的知识</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192202767.jpeg"alt="计算机存储系统（易懂版）" /><figcaption aria-hidden="true">计算机存储系统（易懂版）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192205771.png"alt="计算机系统的组成" /><figcaption aria-hidden="true">计算机系统的组成</figcaption></figure></blockquote><h1 id="内存管理">3.1 内存管理</h1><h2 id="存储器的层次结构">3.1.0 存储器的层次结构</h2><ul><li>几乎每条指令都涉及对存储器的访问</li><li>要求对存储器的访问速度能跟得上处理机运行速度</li><li>还要求存储器具有非常大的容量，并且价格便宜</li></ul><h3 id="多层结构的存储器系统">1. 多层结构的存储器系统</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192210636.png"alt="计算机存储系统（官方版）" /><figcaption aria-hidden="true">计算机存储系统（官方版）</figcaption></figure><h3 id="可执行存储器">2. 可执行存储器</h3><ul><li>寄存器和主存储器又被称为可执行存储器</li><li>访问可执行存储器中的信息较快<ul><li>访问寄存器or高速缓存：几十ns</li><li>访问主存：几百ns</li></ul></li><li>访问辅存中的信息较慢，需要I/O操作<ul><li>访问辅存：几十到几百ms</li></ul></li><li>访问机制不同<ul><li>可执行存储器：寄存器读取；内存寻址；数据总线</li><li>辅存：机械操作；I/O操作</li></ul></li></ul><h3 id="主存储器与寄存器">3. 主存储器与寄存器</h3><ol type="1"><li>主存储器</li></ol><p>主存储器简称内存或主存，用于<strong>保存进程运行时的程序和数据</strong>（这里™的又把主存储器给简称为内存了，测！</p><ol start="2" type="1"><li>寄存器</li></ol><p>寄存器具有与CPU相同的速度；故对寄存器的访问速度最快，但价格却十分昂贵，因此容量非常小</p><p>E.g.，Intel 8086 CPU有14个寄存器,<code>AX, BX, CX, DX, SP, BP, SI, DI, IP, FLAG, CS, DS, SS, ES</code></p><h3 id="高速缓存和磁盘缓存">4. 高速缓存和磁盘缓存</h3><ol type="1"><li>高速缓存</li></ol><ul><li><p>是介于寄存器和存储器之间的存储器，用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数；大幅提高程序执行速度</p></li><li><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192216159.png"alt="高速缓存" /><figcaption aria-hidden="true">高速缓存</figcaption></figure></li></ul><ol start="2" type="1"><li>磁盘缓存</li></ol><ul><li><p>为了缓和磁盘和内存在访问速度上的不匹配而设置了磁盘缓存</p></li><li><p>用于暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数</p></li><li><p><strong>注意</strong>：磁盘缓存与高速缓存不同，它本身并不是一种实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出(或写入)的信息</p></li></ul><h2 id="内存的基础知识">3.1.1 内存的基础知识</h2><h3 id="一些小知识">1. 一些小知识</h3><p>什么是内存，有何作用：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152153892.png"alt="内存" /><figcaption aria-hidden="true">内存</figcaption></figure><p>补充知识：几个常用的数量单位</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191144856.png"alt="几个常用的数量单位" /><figcaption aria-hidden="true">几个常用的数量单位</figcaption></figure><h4 id="相对地址-v-绝对地址">相对地址 v 绝对地址</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191206478.png"alt="相对地址vs绝对地址" /><figcaption aria-hidden="true">相对地址vs绝对地址</figcaption></figure><h4 id="从写程序到程序运行">从写程序到程序运行</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191159491.png"alt="编译、链接、装入" /><figcaption aria-hidden="true">编译、链接、装入</figcaption></figure><p>不修改装入模块中的指令地址就直接装入内存的话：</p><p>如果内存地址不是从0开始，那么就会出现错误</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191202515.png"alt="指令的工作原理" /><figcaption aria-hidden="true">指令的工作原理</figcaption></figure><p>装入模块装入内存时需要对指令中的地址进行处理，</p><p>下面介绍的装入的三种方式就是用三种不同的方法完成<strong>逻辑地址到物理地址</strong>的转换</p><h3 id="程序的装入-三种方式">2. 程序的装入-三种方式</h3><h4 id="绝对装入">绝对装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191153718.png"alt="绝对装入" /><figcaption aria-hidden="true">绝对装入</figcaption></figure><ul><li>早期计算机系统很小，仅能运行单道程序；完全有可能知道程序将驻留在内存的什么位置(地址)</li><li>此时可以采用绝对装入方式。用户程序经编译后，将产生绝对地址(即物理地址)的目标代码</li><li><strong>缺点</strong>：程序员要非常熟悉当前内存情况；程序发生修改时，必须修改程序中所有的绝对地址</li></ul><h4 id="可重定位装入">可重定位装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191210568.png"alt="image-20231219121050471" /><figcaption aria-hidden="true">image-20231219121050471</figcaption></figure><p>只适用于单道程序环境，在多道程序环境下，编译程序不可能预知经编译后所得到的目标模块应放在内存的何处</p><h4 id="动态运行时装入">动态运行时装入</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191213337.png"alt="动态运行时装入" /><figcaption aria-hidden="true">动态运行时装入</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191214221.png"alt="动态运行时装入" /><figcaption aria-hidden="true">动态运行时装入</figcaption></figure><ul><li>可将程序分配到不连续的存储区中；</li><li>在程序运行前只需装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存</li><li>便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191645271.png"alt="三种装入方式" /><figcaption aria-hidden="true">三种装入方式</figcaption></figure><h3 id="程序的链接-三种方式">3. 程序的链接-三种方式</h3><h4 id="静态链接">静态链接</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191622970.png"alt="静态链接" /><figcaption aria-hidden="true">静态链接</figcaption></figure><p>装配成可执行程序时要解决：</p><ol type="1"><li><p>对相对地址进行修改</p></li><li><p>变换外部调用符号</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191626954.png"alt="静态链接" /><figcaption aria-hidden="true">静态链接</figcaption></figure><p>#### 装入时动态链接</p><blockquote><p>所有的模块都装入内存</p></blockquote><p>是指在将一组目标模块装入内存时，采用边装入边链接的方式，然后再按照上图所示的方式来修改目标模块中的相对地址。</p><p>在装入时，若发生一个外部模块调用事件，则找出相应的外部目标模块并将其装入内存</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191631461.png"alt="装入时动态链接" /><figcaption aria-hidden="true">装入时动态链接</figcaption></figure><p><strong>优点</strong>：</p><ol type="1"><li><p>便于修改和更新。对于经静态链接装配在一起的装入模块，如果要修改或更新其中的某个目标模块，则要求重新打开装入模块。这不仅是低效的，而且有时是不可能的。若采用动态链接方式，由于各目标模块是分开存放的，所以要修改或更新各目标模块是件非常容易的事。</p></li><li><p>便于实现对目标模块的共享。在采用静态链接方式时，每个应用模块都必须含有其目标模块的拷贝，无法实现对目标模块的共享。但采用装入时动态链接方式，OS则很容易将一个目标模块链接到几个应用模块上，实现多个应用程序对该模块的共享。</p></li></ol><p><strong>缺点</strong>：</p><ol type="1"><li><p>有的模块在运行时没有被调用；浪费了内存</p></li><li><p>装入时间开销相对较大</p></li></ol><h4 id="运行时动态链接">运行时动态链接</h4><blockquote><p>需要某个模块时才装入内存</p></blockquote><p>在程序执行中需要该目标模块时，才对它进行链接。</p><ul><li>克服了装入时动态链接方式的缺点</li><li>仅在程序运行时需要调用相关模块时才将那些模块进行动态链接</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191634462.png"alt="运行时动态链接" /><figcaption aria-hidden="true">运行时动态链接</figcaption></figure><h2 id="内存管理的概念">3.1.2 内存管理的概念</h2><h3 id="内存管理管些什么">内存管理管些什么</h3><ul><li>操作系统负责内存空间的分配与回收</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191638056.png"alt="内存空间的分配与回收" /><figcaption aria-hidden="true">内存空间的分配与回收</figcaption></figure><ul><li>操作系统需要提供某种技术从逻辑上对内存空间进行扩充</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191641727.png"alt="内存空间的拓展" /><figcaption aria-hidden="true">内存空间的拓展</figcaption></figure><ul><li>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191642704.png"alt="地址转换" /><figcaption aria-hidden="true">地址转换</figcaption></figure><ul><li>操作系统需要提供内存保护功能。保证各进程在各自存储空间内运行，互不干扰</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191647331.png"alt="内存保护" /><figcaption aria-hidden="true">内存保护</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191648587.png"alt="内存保护" /><figcaption aria-hidden="true">内存保护</figcaption></figure><blockquote><p>这节主要是对内存管理有一个大体的框架</p></blockquote><h2 id="覆盖技术与交换技术">3.1.3 覆盖技术与交换技术</h2><blockquote><p>理解思想即可</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191652903.png"alt="内存管理的概念" /><figcaption aria-hidden="true">内存管理的概念</figcaption></figure><h3 id="覆盖技术">1. 覆盖技术</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191657305.png"alt="覆盖技术" /><figcaption aria-hidden="true">覆盖技术</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191659190.png"alt="覆盖技术" /><figcaption aria-hidden="true">覆盖技术</figcaption></figure><p>B，C不可能在同一个时间段被访问，覆盖区以B和C中较大的来计算</p><p>D，E，F也不能在同一个时间段来访问</p><h3 id="交换技术">2. 交换技术</h3><blockquote><p>中级调度就是为了实现交换技术</p></blockquote><p>对换(Swapping)</p><ul><li><p>也称为交换技术；最早用于麻省理工学院的单用户分时系统CTSS中</p></li><li><p>当时计算机内存非常小，为了使该系统能分时运行多个用户程序，把所有的用户作业存放在磁盘上，每次只能调入一个作业进入内存</p></li><li><p>当该作业的一个时间片用完时，将它调至外存的后备队列上等待，再从后备队列上将另一个作业调入内存</p></li></ul><h4 id="多道程序环境下的对换技术">多道程序环境下的对换技术</h4><ol type="1"><li>对换的引入</li></ol><ul><li><p>在内存中的某些进程由于阻塞而停止运行，但却占用了大量的内存空间，甚至有时可能内存中所有进程都被阻塞，而无可运行之进程，迫使CPU停止下来空等</p></li><li><p>另一方面，可能又有许多作业因内存空间不足，一直驻留在外存上而不能进入内存运行。显然这对系统资源是一种严重的浪费，且使系统吞吐量下降</p></li></ul><ol start="2" type="1"><li>对换的类型</li></ol><ul><li>在每次对换时，将一定数量的程序或数据换入或换出内存。根据每次对换时所对换的数量，可将对换分为：<ul><li>整体对换：将整个进程换入、换出</li><li>页面(分段)对换：以进程的“页面”或者“段”为单位进行换入、换出</li></ul></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191702389.png"alt="交换技术" /><figcaption aria-hidden="true">交换技术</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191703570.png"alt="回忆一下、" /><figcaption aria-hidden="true">回忆一下、</figcaption></figure><p>有关交换技术的一些问题</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191707656.png"alt="交换技术" /><figcaption aria-hidden="true">交换技术</figcaption></figure><p><strong>对换区空闲盘块管理中的数据结构</strong></p><ul><li><p>为了实现对对换区中的空闲盘块的管理，在系统中有<strong>对换进程</strong>，同时应配置相应的数据结构，用于记录外存对换区中的空闲盘块的使用情况</p></li><li><p>其数据结构的形式与内存在动态分区分配方式中所用数据结构相似，即同样可以用空闲分区表或空闲分区链</p></li><li><p>在空闲分区表的每个表目中，应包含两项：对换区的首址及其大小，分别用盘块号和盘块数表示</p></li></ul><p><strong>对换空间的分配与回收</strong></p><ul><li><p>由于对换分区的分配采用的是连续分配方式，因而对换空间的分配与回收与动态分区方式时的内存分配与回收方法雷同</p></li><li><p>其分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法等。具体的分配操作也与图4-8中内存的分配过程相同</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192233654.png"alt="内存分配流程" /><figcaption aria-hidden="true">内存分配流程</figcaption></figure><p><strong>进程的换出</strong></p><p>对换进程在实现进程换出时，是将内存中的某些进程调出至<strong>对换区</strong>，腾出内存空间。换出过程可分为：</p><ol type="1"><li>选择被换出的进程</li></ol><p>原则：选阻塞/睡眠进程、优先级低的进程</p><ol start="2" type="1"><li>进程换出过程</li></ol><p>原则：换出没有共享程序段/数据段的进程</p><p><strong>进程的换入</strong></p><ul><li><p>对换进程将定时执行换入操作，首先查看PCB集合中所有进程的状态，从中找出“就绪”状态但已换出的进程</p></li><li><p>当有许多这样的进程时，它将选择其中已换出到磁盘上时间最久的进程作为换入进程</p></li><li><p>为该进程申请内存，如申请成功，可直接将进程从外存调入内存；如失败，则需先将内存中的某些进程换出，腾出足够的内存空间后，再将磁盘上的进程调入</p></li><li><p>反复换入进程，直到无进程可换入</p></li></ul><h2 id="连续分配存储管理方式">3.1.4 连续分配存储管理方式</h2><blockquote><p>内存管理下面的三个作用已经讲过了，这节课我们来看连续分配管理方式</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191709113.png"alt="1702976962451" /><figcaption aria-hidden="true">1702976962451</figcaption></figure><h3 id="单一连续分配">1. 单一连续分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191713178.png"alt="单一连续分配" /><figcaption aria-hidden="true">单一连续分配</figcaption></figure><h3 id="固定分区分配">2. 固定分区分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191717812.png"alt="固定分区分配" /><figcaption aria-hidden="true">固定分区分配</figcaption></figure><p>操作系统应该怎么记录内存当中各个分区空闲或者分配的情况呢？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191720152.png"alt="分区说明表" /><figcaption aria-hidden="true">分区说明表</figcaption></figure><h3 id="动态分区分配">3. 动态分区分配</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191722334.png"alt="动态分区分配" /><figcaption aria-hidden="true">动态分区分配</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191723022.png"alt="分区分配的选择怎么做" /><figcaption aria-hidden="true">分区分配的选择怎么做</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191723348.png"alt="分区的分配与回收怎么做" /><figcaption aria-hidden="true">分区的分配与回收怎么做</figcaption></figure><h4 id="动态分区分配中的数据结构">1 动态分区分配中的数据结构</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191728955.png"alt="动态分区分配中的数据结构" /><figcaption aria-hidden="true">动态分区分配中的数据结构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191729048.png"alt="空闲链表结构" /><figcaption aria-hidden="true">空闲链表结构</figcaption></figure><h4 id="分区分配算法">2 分区分配算法</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191730284.png"alt="分区分配的选择怎么做" /><figcaption aria-hidden="true">分区分配的选择怎么做</figcaption></figure><h4 id="如何分配">3 如何分配</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191732614.png"alt="如何分配" /><figcaption aria-hidden="true">如何分配</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191733467.png"alt="如何分配" /><figcaption aria-hidden="true">如何分配</figcaption></figure><p>如果分配的进程大小和分区大小刚好相，就删除分区对应的表项，空闲分区链的话就把一个节点给删除</p><h4 id="如何回收">4 如何回收</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191742663.png"alt="如何回收1" /><figcaption aria-hidden="true">如何回收1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191743971.png"alt="如何回收2" /><figcaption aria-hidden="true">如何回收2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191743965.png"alt="如何回收3" /><figcaption aria-hidden="true">如何回收3</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191744348.png"alt="如何回收4" /><figcaption aria-hidden="true">如何回收4</figcaption></figure><h3 id="内部碎片与外部碎片">4. 内部碎片与外部碎片</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312191749148.png"alt="内部碎片与外部碎片" /><figcaption aria-hidden="true">内部碎片与外部碎片</figcaption></figure><p><strong>可以通过紧凑（拼凑，Compaction）技术来解决外部碎片</strong></p><h2 id="动态分区分配算法">3.1.5 动态分区分配算法</h2><blockquote><p>下面应该说是考研要求掌握的四种算法</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192044586.png"alt="1702989875184" /><figcaption aria-hidden="true">1702989875184</figcaption></figure><h3 id="首次适应first-fitff算法">首次适应(first fit，FF)算法</h3><p>算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。</p><p>如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192047480.png"alt="首次适应算法" /><figcaption aria-hidden="true">首次适应算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192048101.png"alt="首次适应算法" /><figcaption aria-hidden="true">首次适应算法</figcaption></figure><h3 id="最佳适应best-fitbf算法">最佳适应(best fit，BF)算法</h3><p>算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区即，优先使用更小的空闲区。</p><p>如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><ul><li>“最佳”含义：每次为作业分配内存时，总是把能满足要求、又是最小的空闲分区分配给作业，避免内存浪费</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192053532.png"alt="最佳适应算法" /><figcaption aria-hidden="true">最佳适应算法</figcaption></figure><p>缺点：每次都选最小的分区进行分配，会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。</p><h3 id="最坏适应worst-fitwf算法">最坏适应(worst fit，WF)算法</h3><blockquote><p>WF算法使得存储器中缺乏大的空闲分区，故把它称为是最坏适应算法</p></blockquote><p>算法思想：为了解决最佳适应算法的问题一一即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。</p><p>如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192100348.png"alt="1702990837242" /><figcaption aria-hidden="true">1702990837242</figcaption></figure><p>缺点：每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了</p><h3 id="邻近适应算法">邻近适应算法</h3><p>算法思想：首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。</p><p>如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。</p><p>首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(这隐含了最佳适应算法的优点)</p><p>邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用(这隐含了最大适应算法的缺点)</p><p>综合来看，四种算法中，首次适应算法的效果反而更好</p><p><strong>四种算法的比较总结</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192109218.png"alt="四种算法的比较总结" /><figcaption aria-hidden="true">四种算法的比较总结</figcaption></figure><p>这里是算法开销指的是对分区表或分区链表的重新排序和查找消费</p><hr /><blockquote><p>张老师的pipiti上面是这样分的，或者说书上是这样来分类的：</p></blockquote><p>🎈基于顺序搜索的动态分区分配算法：</p><ul><li>首次适应(first fit，FF)算法</li><li>循环首次适应(next fit，NF)算法<ul><li>目的：避免低址部分留下许多很小的空闲分区，以及减少查找可用空闲分区的开销</li><li>NF算法在为进程分配内存空间时，不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区，从中划出一块与请求大小相等的内存空间分配给作业。</li><li>其实就是上面提到的邻近适应算法</li></ul></li><li>最佳适应(best fit，BF)算法</li><li>最坏适应(worst fit，WF)算法</li></ul><p>🎈基于索引搜索的动态分区分配算法：</p><ul><li><strong>快速适应(quick fit)算法</strong></li></ul><p>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，这样系统中存在多个空闲分区链表</p><p>在内存中设立一张管理索引表，其中的每一个索引表项对应了一种空闲分区类型，并记录了该类型空闲分区链表表头的指针</p><ul><li><strong>伙伴系统(buddy system)</strong></li></ul><p>该算法规定，无论已分配分区或空闲分区，其大小均为2的k次幂(k为整数，k∈[1,m])。<spanclass="math inline">\(2^m\)</span>是整个可分配内存的大小</p><p>假设系统的可用空间容量为<spanclass="math inline">\(2^m\)</span>个字，则系统开始运行时整个内存区是一个大小为<spanclass="math inline">\(2^m\)</span>的空闲分区。在系统运行过程中，由于不断地划分，将会形成若干个不连续的空闲分区</p><p>将这些空闲分区按分区的大小进行分类。对于具有相司大小的所有空闲分区，单独设立一个空闲分区双向链表，这样，不同大小的空闲分区形成了多个空闲分区链表</p><p>在伙伴系统中，对于一个大小为<span class="math inline">\(2^k\)</span>，地址为<spanclass="math inline">\(x\)</span>的内存块，其伙伴块的地址则用<spanclass="math inline">\(buddy_k(x)\)</span>表示，其计算公式为： <spanclass="math display">\[buddy_k(x)=\left\{\begin{matrix}x+2^k（若x\mod2^{k+1}=0）\\x-2^k（若x\mod2^{k+1}=2^k）\end{matrix}\right.\]</span></p><ul><li><strong>哈希算法</strong></li></ul><p>上述算法中都是将空闲分区根据分区大小进行分类，对于每一类具有相同大小的空闲分区，单独设立一个空闲分区链表</p><p>在为进程分配空间时，需要在一张管理索引表中查找到所需空间大小所对应的表项，从中得到对应的空闲分区链表表头指针</p><p>建立哈希函数，以内存分区大小为查找关键字，加快查找合适大小分区的速度</p><hr /><h2 id="基本分页存储管理">3.1.6 基本分页存储管理</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312192259942.png"alt="内存管理" /><figcaption aria-hidden="true">内存管理</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络空间安全法律法规</title>
    <link href="/2023/12/11/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/"/>
    <url>/2023/12/11/%E7%BD%91%E7%BB%9C%E7%A9%BA%E9%97%B4%E5%AE%89%E5%85%A8%E6%B3%95%E5%BE%8B%E6%B3%95%E8%A7%84/</url>
    
    <content type="html"><![CDATA[<p><strong>关键信息基础设施</strong>是指公共通信和信息服务、能源、交通、水利、金融、公共服务、电子政务、国防科技工业等重要行业和领域的，以及其他一旦遭到破坏、丧失功能或者数据泄露，可能严重危害国家安全、国计民生、公共利益的重要网络设施、信息系统等</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络空间安全法律法规</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 7 分支界限法</title>
    <link href="/2023/12/06/%E7%AE%97%E6%B3%95%207-%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95/"/>
    <url>/2023/12/06/%E7%AE%97%E6%B3%95%207-%E5%88%86%E6%94%AF%E7%95%8C%E9%99%90%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>方法概述部分基本为老师PPT的内容，我™也有点看不懂，不知道是我太菜了，还是PPT不清楚🤧🤧🤧</p></blockquote><h2 id="方法概述">方法概述</h2><h3 id="与回溯法区别">与回溯法区别</h3><ul><li><p>求解目标不同</p><p>一般而言，回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是尽快地找出满足约束条件的一个解</p></li><li><p>搜索方法不同</p><p>回溯法使用深度优先方法搜索，而分支限界一般用宽度优先或最佳优先方法来搜索</p></li><li><p>对扩展结点的扩展方式不同</p><p>分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点;</p></li><li><p>存储空间的要求不同</p><p>分支限界法的存储空间比回溯法大得多，因此当内存容量有限时，回溯法解决问题成功的可能性更大。</p></li></ul><h3 id="分支界限法基本思想">分支界限法基本思想</h3><p>以广度优先或最小耗费（最大效益）优先的方式搜索问题的解空间树</p><ul><li>每个活结点只有一次机会成为扩展结点并一次性产生其所有儿子结点</li><li>儿子结点中导致不可行解或非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。如是最小耗费优先，活结点表需要重新排序</li><li>此后从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止</li></ul><blockquote><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。1. 对已处理的各结点根据限界函数估算目标函数的可能取值 2.从中选出目标函数取得极大(极小) 值的结点优先进行广度优先搜索 3.不断地调整搜索方向，尽快找到解，裁剪那些不能得到最优解的子树以提高搜索效率</p></blockquote><p>搜索策略：</p><p>在扩展结点处，首先生成其所有的儿子结点（分支），然后从当前的活结点表中选择下一个扩展结点。思考：如何代码实现？</p><p>为了有效地选择下一个扩展结点，以加速搜索的进程，<strong>在每一个活结点处，计算一个函数值(优先值)，并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解</strong>。</p><h3 id="branch-and-bound求解步骤">Branch and Bound求解步骤：</h3><ol type="1"><li>定义解空间（对解编码）</li><li>确定解空间的树结构</li><li>按BFS等方式搜索<ol type="1"><li>每个活结点仅有一次机会变成扩展结点</li><li>由扩展结点生成一步可达（即宽度搜索）的新结点C</li><li>在新结点中，删除不可能导出最优解的结点； // 限界策略</li><li>将剩余的新结点加入活动表（队列）中</li><li>从活动表中选择结点再扩展； //分支策略</li><li>直至活动表为空</li></ol></li></ol><h3 id="常见的两种分支限界法">常见的两种分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061720116.png"alt="image-20231206172054010" /><figcaption aria-hidden="true">image-20231206172054010</figcaption></figure><p>队列式（FIFO）分支限界法</p><ul><li>按照队列先进先出（FIFO）原则选取下一个结点为扩展结点</li><li>从活结点表中取出结点的顺序与加入结点的顺序相同，因此活结点表的性质与队列相同</li></ul><p>优先队列分支限界法（代价最小或效益最大）</p><ul><li>每个结点都有一个对应的耗费或收益，以此决定结点的优先级</li><li>从优先队列中选取优先级最高的结点成为当前扩展结点</li><li>如果查找一个具有最小耗费的解：则活结点表可用小顶堆来建立，下一个扩展结点就是具有最小耗费的活结点</li><li>如果希望搜索一个具有最大收益的解：则可用大顶堆来构造活结点表，下一个扩展结点是具有最大收益的活结点</li></ul><h2 id="背包问题">0-1背包问题</h2><h3 id="队列式fifo分支限界法">队列式（FIFO）分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061532327.png"alt="队列式（FIFO）分支限界法解决0-1背包问题" /><figcaptionaria-hidden="true">队列式（FIFO）分支限界法解决0-1背包问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061533668.png"alt="image-20231206153332482" /><figcaption aria-hidden="true">image-20231206153332482</figcaption></figure><p>通过判断重量加起来是否超过背包容量来判断是不是死节点</p><p>步骤：</p><p><strong>①</strong> 用一个队列存储活结点表，初始为空</p><p><strong>②</strong>A为当前扩展结点，其儿子结点B和C均为可行结点，将其按从左到右顺序加入活结点队列，并舍弃A。</p><p><strong>③</strong>按FIFO原则，下一扩展结点为B，其儿子结点D不可行，舍弃；E可行，加入。舍弃B</p><p><strong>④</strong>C为当前扩展结点，儿子结点F、G均为可行结点，加入活结点表，舍弃C</p><p><strong>⑤</strong>扩展结点E的儿子结点J不可行而舍弃；K为可行的叶结点，是问题的一个可行解，价值为45</p><p><strong>⑥</strong> 当前活结点队列的队首为F,儿子结点L、M为可行叶结点，价值为50、25</p><p><strong>⑦</strong>G为最后一个扩展结点，儿子结点N、O均为可行叶结点，其价值为25和0</p><p><strong>⑧</strong> 活结点队列为空，算法结束，其最优值为50</p><p>注：活结点就是不可再进行扩展的节点，也就是两个儿子还没有全部生成的节点</p><h3 id="优先队列分支限界法">优先队列分支限界法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061550206.png"alt="优先队列分支限界法求解0-1背包问题" /><figcaptionaria-hidden="true">优先队列分支限界法求解0-1背包问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312061551301.png"alt="image-20231206155119099" /><figcaption aria-hidden="true">image-20231206155119099</figcaption></figure><p>步骤：</p><p><strong>①</strong>用一个极大堆表示活结点表的优先队列，其优先级定义为活结点所获得的价值。初始为空。</p><p><strong>②</strong>由A开始搜索解空间树，其儿子结点B、C为可行结点，加入堆中，舍弃A。</p><p><strong>③</strong>B获得价值45，C为0。B为堆中价值最大元素，并成为下一扩展结点。</p><p><strong>④</strong>B的儿子结点D是不可行结点，舍弃。E是可行结点，加入到堆中。舍弃B。</p><p><strong>⑤</strong> E的价值为45，是堆中最大元素，为当前扩展结点。</p><p><strong>⑥</strong>E的儿子J是不可行叶结点，舍弃。K是可行叶结点，为问题的一个可行解价值为45。</p><p><strong>⑦</strong>继续扩展堆中唯一活结点C，直至存储活结点的堆为空，算法结束。</p><p><strong>⑧</strong>算法搜索得到最优值为50，最优解为从根结点A到叶结点L的路径（0，1，1）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//优先队列分支限界法解决0-1背包问题</span><br>branchknap(<span class="hljs-type">float</span> w[],<span class="hljs-type">float</span> v[])&#123;<br>    根结点入队<br>    <span class="hljs-keyword">while</span>(队列不为空)&#123;<br>        Node *current = 单位重量价值最大元素出队<span class="hljs-comment">//扩展结点</span><br> <br>        <span class="hljs-keyword">if</span>(current为叶子结点)&#123;<br>            <span class="hljs-keyword">if</span>(current路径能得到最优值)<br>                更新bestv和bestx;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(current的左孩子可行并有可能产生最优解)<br>                左孩子入队<br>            <span class="hljs-keyword">if</span>(current的右孩子有可能产生最优解)<br>                右孩子入队<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://www.cnblogs.com/yuanqingwen/p/12906285.html">分支限界法0-1背包问题-队列式 - 沅清的小窝 - 博客园 (cnblogs.com)</a></p><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/RB26DETT/p/10982687.html">分支限界法解决01背包问题- boobo - 博客园 (cnblogs.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分支界限法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 5 树</title>
    <link href="/2023/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205%20%E6%A0%91/"/>
    <url>/2023/12/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205%20%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071554974.png"alt="树" /><figcaption aria-hidden="true">树</figcaption></figure><h2 id="树和二叉树的定义">5.1 树和二叉树的定义</h2><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051041647.png" alt="image-20231205104108565" style="zoom:80%;" /></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051042626.png" alt="树的概述" style="zoom:80%;" /></p><h3 id="树的定义">5.1.1 树的定义</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051044789.png"alt="树的定义" /><figcaption aria-hidden="true">树的定义</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051047068.png"alt="树" /><figcaption aria-hidden="true">树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051049136.jpg"alt="树的其它表示方式" /><figcaption aria-hidden="true">树的其它表示方式</figcaption></figure><p>比如课本的目录就是凹入表示</p><h3 id="树的基本术语">5.1.2 树的基本术语</h3><p>树的结点(node)： 包含一个数据元素及若干指向其子树的分支</p><p>结点的度(degree)：结点具有子树的个数</p><p>树的度：树中所有结点的度的最大值</p><p>分支结点(或者叫非终端结点)：度大于0的结点，根结点以外的分支节点称为内部结点</p><p>叶子(或者叫终端结点)：度为0的结点</p><p>结点的孩子：结点子树的根，该结点为孩子的双亲</p><p>兄弟：同一双亲的孩子</p><p>堂兄弟：其双亲在同一层的结点间互称堂兄弟</p><p>结点的祖先：从根到该结点所经分支上的所有结点</p><p>结点的子孙：一个结点的所有子树中的结点.</p><p>结点的层次：根为第一层，其孩子结点为第二层，如此类推到每个结点层次</p><p>树的层数(或者叫结点的层次)：根节点的层数为1，其他结点的层数为根节点到该结点的分支数+1</p><p>树的高度(或者叫深度)：树中结点的最大层数</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051102148.png"alt="树的基本术语" /><figcaption aria-hidden="true">树的基本术语</figcaption></figure><p>A结点的三个孩子：B、C、D</p><p>B、C、D的双亲：A</p><p>D结点的三个孩子：H、I、J</p><p>M结点的祖先：A、D、H</p><p>A结点的子孙：除了A之外的所有结点</p><p>有序树：若将树中结点的各子树看成从左至右是有序的(不能互换)，则称该树为有序树，否则为无序树。</p><p>森林：0个或多个互不相交的树的集合</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051110990.png"alt="image-20231205111033912" /><figcaption aria-hidden="true">image-20231205111033912</figcaption></figure><h3 id="二叉树的定义">5.1.3 二叉树的定义</h3><p>为何要重点研究每结点最多只有两个“叉” 的树？</p><ul><li><p>二叉树的结构最简单，规律性最强</p></li><li><p>可以证明，所有树都能转为唯一对应的二叉树，不失一般性</p></li></ul><p>普通树 (多叉树) 若不转化为二叉树，则运算很难实现</p><p>二叉树在树结构的应用中起着非常重要的作用，因为对二叉的许多操作算法简单，而任何树都可以与二叉树相互转换，这样就解决了树的存储结构及其运算中存在的复杂性</p><p><strong>定义</strong>：二叉树是<spanclass="math inline">\(n(n≥0)\)</span> 个结点的有限集，它或者是空集<spanclass="math inline">\((n=0)\)</span>，或者由一个根结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成</p><p><strong>特点</strong></p><p>1、每个结点最多有俩孩子(二叉树中不存在度大于 2 的结点)</p><p>2、子树有左右之分，其次序不能颠倒<strong>（次序颠倒了就是另外一棵树）</strong></p><p>3、二叉树可以是空集合，根可以有空的左子树或空的右子树</p><p>注⭐：</p><p>二叉树不是树的特殊情况，它们是两个概念</p><p>二叉树结点的子树要区分左子树和右子树，即使只有一棵子树也要进行区分，说明它是左子树，还是右子树</p><p>树当结点只有一个孩子时，就无须区分它是左还是右的次序。因此二者是不同的。这是二又树与树的最主要的差别。</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051420627.png" alt="具有两个结点的二叉树有两种状态" style="zoom:50%;" /></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051420636.png" alt="具有两个结点的树只有一种状态" style="zoom:50%;" /></p><p>(也就是二叉树每个结点位置或者说次序都是固定的，可以是空，但是不可以说它没有位置，而树的结点位置是相对于别的结点来说的，没有别的结点时，它就无所谓左右了)，可以理解为二叉树不是树不是有序树，是一个独立的概念</p><p>虽然二叉树与树的概念不同，但有关树的基本术语对二叉树都适用</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051423517.png" alt="思考" style="zoom:50%;" /></p><p>二叉树的五种基本形态：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051425443.png"alt="二叉树的五种基本形态" /><figcaption aria-hidden="true">二叉树的五种基本形态</figcaption></figure><h2 id="树和二叉树的抽象数据类型定义">5.2树和二叉树的抽象数据类型定义</h2><p>(以二叉树为例来学习)</p><p>二叉树的抽象数据类型定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++">ADT BinaryTree&#123;<br><br>  数据对象 D：具有相同特性的数据元素集合。<br>  数据关系 R：若D为空集，则称为空树。否则R=&#123;H&#125;, H是如下关系：<br>    （<span class="hljs-number">1</span>）在D中存在唯一的称为根的数据元素root；<br>    （<span class="hljs-number">2</span>）若D除了根结点外，D中还有其它结点，则其余结点可分为<span class="hljs-built_in">m</span> (m&gt;<span class="hljs-number">0</span>)个互不相交的有限集T1, T2, …, Tm，其中每一棵子集本身又是一棵符合本定义的树，称为根root的子树。<br>基本操作P:<br>    <br>    <span class="hljs-built_in">CreateBiTree</span>(&amp;T, definition)     <br>    初始条件: definition给出二叉树T的定义<br>        (后面会学二叉树的遍历方法,对于不同的建立方式definition 指的是建立方式)<br>        操作结果: 按definition构造二叉树T<br><span class="hljs-built_in">PreOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 先序遍历T，对每个结点访问一次<br>    <span class="hljs-built_in">InOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 中序遍历T，对每个结点访问一次<br>   <span class="hljs-built_in">PostOrderTraverse</span>(T)<br>        初始条件: 二叉树T存在<br>        操作结果: 后序遍历T，对每个结点访问一次<br>……<br>    ……<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二叉树的性质和存储结构">5.3 二叉树的性质和存储结构</h2><h3 id="基本的性质">5.3.1 基本的性质</h3><p><strong>性质1</strong>：在二叉树的第 <spanclass="math inline">\(i\)</span> 层上至多有<spanclass="math inline">\(2^{i-1}\)</span>个结点<spanclass="math inline">\((i≥1)\)</span></p><p>第一层：<span class="math inline">\(2^0=1\)</span></p><p>第二层：<span class="math inline">\(2^1=2\)</span></p><p>第三层：<span class="math inline">\(2^2=4\)</span></p><p>第四层：<span class="math inline">\(2^3=8\)</span></p><p>……</p><p>提问：第 <span class="math inline">\(i\)</span>层上至少有几个结点？---------1个</p><p><strong>性质2</strong>：深度为 <span class="math inline">\(k\)</span>的二叉树至多有<span class="math inline">\(2^k-1\)</span>个结点<spanclass="math inline">\((k≥1)\)</span></p><p>（都怪第一层只有一个结点</p><p>提问：深度为 <span class="math inline">\(k\)</span>的二叉树至少有几个结点？---------k个</p><p><strong>性质3</strong>：对任何一颗二叉树T，如果其叶子结点数为<spanclass="math inline">\(n_0\)</span>，度为2的结点数为<spanclass="math inline">\(n_2\)</span>，则<spanclass="math inline">\(n_0=n_2+1\)</span>，</p><p>（度为2的结点数又称双分支结点数）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051505422.png"alt="非空二叉树上叶子结点数等于双分支结点数加1" /><figcaptionaria-hidden="true">非空二叉树上叶子结点数等于双分支结点数加1</figcaption></figure><p>性质3的本身的用处其实不是很大，用处大的是我们分析证明的过程</p><h3 id="满二叉树">5.3.2 满二叉树</h3><p>两种特殊形式的二叉树：满二叉树和完全二叉树</p><p>为什么要研究这两种特殊形式？</p><p>——因为它们在顺序存储方式下可以复原</p><p><strong>满二叉树</strong>：</p><p>一棵深度为 <span class="math inline">\(k\)</span> 且有 <spanclass="math inline">\(2^k -1\)</span> 个结点的二叉树称为满二叉树</p><p>即所有分支结点都存在左子树和右子树，并且所有叶子结点都在最底层上，其特点是每一层上的结点数都是最大结点数。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051510897.png"alt="满二叉树" /><figcaption aria-hidden="true">满二叉树</figcaption></figure><p>对满二叉树结点位置进行编号：</p><ul><li>编号规则：从根结点开始，自上而下，自左而右。</li><li>每一结点位置都有元素</li></ul><p>满二叉树在同样深度的二叉树中结点个数最多</p><p>满二叉树在同样深度的二叉树中叶子结点个数最多</p><h3 id="完全二叉树">5.3.3 完全二叉树</h3><p><strong>完全二叉树</strong>：</p><p>深度为k，有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中<strong>编号从1至n的结点一一对应</strong>时，称之为完全二叉树。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051516842.png"alt="完全二叉树例子" /><figcaption aria-hidden="true">完全二叉树例子</figcaption></figure><p>注：在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树</p><p>一定是连续的去掉！！！</p><p>特点：</p><p>（1）叶子结点只可能在层次最大的两层上出现，即最下层和次最下层；</p><p>（2）对任一结点，如果其右子树的最大层次为 <spanclass="math inline">\(i\)</span>，则其左子树的最大层次必为 <spanclass="math inline">\(i\)</span> 或 <spanclass="math inline">\(i+1\)</span>，即最下层的叶子结点集中在树的左部。</p><h3 id="完全二叉树的性质">5.3.4 完全二叉树的性质</h3><p><strong>性质4</strong>：具有n个结点的完全二叉树的深度为 <spanclass="math inline">\(\lfloor log_2n \rfloor+1\)</span></p><p>注意：<span class="math inline">\(\lfloor x\rfloor\)</span>：称作x的底，表示不大于x的最大整数（向下取整），例如：<spanclass="math inline">\(\lfloor 3.5 \rfloor=3\)</span></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051528063.png" alt="性质4" style="zoom:50%;" /></p><p>比如上图，<spanclass="math inline">\(n=12\)</span>，所以完全二叉树的深度为 <spanclass="math inline">\(\lfloor log_212 \rfloor+1=4\)</span></p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051531812.png" alt="性质4证明" style="zoom:80%;" /></p><p><strong>性质5</strong>：对有n个结点的完全二叉树的结点按层序编号(从上至下，从左至右)，则<strong>对任一结点<span class="math inline">\(i(1≤ i≤n)\)</span></strong> ，有：</p><ul><li>如果<span class="math inline">\(i=1\)</span>，则结点为根；如果<spanclass="math inline">\(i&gt;1\)</span>，则其<strong>双亲是结点<spanclass="math inline">\(\lfloor i/2 \rfloor\)</span></strong></li><li>如果 <span class="math inline">\(2i&gt;n\)</span>，则结点 <spanclass="math inline">\(i\)</span>为叶子结点，无左孩子；否则其<strong>左孩子是结点 <spanclass="math inline">\(2i\)</span></strong></li><li>如果 <span class="math inline">\(2i+1&gt;n\)</span>，则结点 <spanclass="math inline">\(i\)</span>为叶子结点，无右孩子；否则其<strong>右孩子是结点 <spanclass="math inline">\(2i+1\)</span></strong></li></ul><p>这里大部分情况下就只看标粗的部分，</p><p>举例：5，双亲是<span class="math inline">\(\lfloor 5/2\rfloor=2\)</span>，左孩子是结点 <spanclass="math inline">\(2*5=10\)</span>，右孩子是结点 <spanclass="math inline">\(2*5+1=11\)</span>，，就是这么easy的性质</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051539780.png" alt="image-20231205153905734" style="zoom:80%;" /></p><p>性质5表明了完全二叉树中双亲结点编号与孩子结点编号之间的关系</p><p>具体证明先不用了解</p><p>作用：在顺序存储的时候，操作下标为i的结点的双亲或者后继的时候</p><h3 id="二叉树的存储结构">5.3.5 二叉树的存储结构</h3><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051544960.png" alt="二叉树的存储结构" style="zoom:50%;" /></p><h4 id="二叉树的顺序存储">二叉树的顺序存储</h4><p>实现：按满二叉树的结点层次编号，依次存放二叉树中的数据元素</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051554301.png"alt="二叉树的顺序存储例子" /><figcaption aria-hidden="true">二叉树的顺序存储例子</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树顺序存储表示，Binary Tree</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXTSIZE 100</span><br>Typedef TELemType SqBiTree[MAXTSIZE]; <span class="hljs-comment">//TELemType根据具体情况换，比如char、int</span><br>SqBiTree bt; <span class="hljs-comment">//定义了一个数组bt</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051559459.png"alt="二叉树的顺序存储例子2" /><figcaption aria-hidden="true">二叉树的顺序存储例子2</figcaption></figure><p>其实这里不是给0，是给一个空值NULL，</p><p>优点：简单</p><p>缺点：</p><p>①顺序存储通用的缺点：大小固定，数组中元素个数变化特别大，就不适用了</p><p>② 对二叉树的存储，还有一个缺点：</p><p>本来顺序存储的存储密度可以达到1，因为它只存数据元素本身，存储密度很大，但对于二叉树，为了描绘出双亲和孩子的关系，必须把对应的元素放到对应的位置，导致必须空一些元素，导致了空间的浪费</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051604892.png" alt="二叉树的顺序存储的缺点" style="zoom:80%;" /></p><p>后面的堆排序其实就用这种方法存取</p><h4 id="二叉树的链式存储结构">二叉树的链式存储结构</h4><p>（1）二叉链表存储（含有两个指针域的结点结构）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051611367.png"alt="二叉链表存储结构" /><figcaption aria-hidden="true">二叉链表存储结构</figcaption></figure><p>链表中的每个结点由三个域组成：数据域、左指针域、右指针域，其形式定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiNode</span> &#123;   <span class="hljs-comment">// 结点结构</span><br>TElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiTNode</span> *lchild, *rchild;   <span class="hljs-comment">// 左右孩子指针，定义是典中之典的递归定义，跟定义单链表一样</span><br>&#125;BiNode, *BiTree; <br><span class="hljs-comment">//为了用起来方便，又typedef，定义了一个普通的结点类型BiNode，定义了一个指向这种有三个成员的结点类型的指针*BiTree</span><br><br></code></pre></td></tr></table></figure><blockquote><p>如果操作经常要操作结点的后继（左右孩子），可以用这种存储结构</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051616645.png"alt="二叉链表存储" /><figcaption aria-hidden="true">二叉链表存储</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051621657.png"alt="小性质喵" /><figcaption aria-hidden="true">小性质喵</figcaption></figure><blockquote><p>这里的小性质学到线索二叉树会用，这些空的指针域还可以利用起来</p></blockquote><p>（2）三叉链表存储（含有三个指针域的结点结构）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051626786.png"alt="三叉链表存储结构" /><figcaption aria-hidden="true">三叉链表存储结构</figcaption></figure><p>每个结点由四个域组成：数据域、左指针域、右指针域和双亲域，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//形式定义如下:</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span> &#123;<br>TElemType data;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span>  *lchild, *rchild; <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TriTNode</span>  *parent;  <span class="hljs-comment">//双亲指针  </span><br>&#125; TriTNode, *TriTree;<br></code></pre></td></tr></table></figure><blockquote><p>如果操作经常要操作结点的前驱，可以用这种存储结构</p></blockquote><p>双亲指针就是指向它的前驱结点，大部分数据结构中的图都画的乱七八糟，不用管</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051632647.png"alt="三叉链表存储" /><figcaption aria-hidden="true">三叉链表存储</figcaption></figure><h2 id="遍历二叉树">⭐5.4 遍历二叉树</h2><h3 id="遍历二叉树概述">5.4.1 遍历二叉树概述</h3><p>遍历定义：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，而且仅被访问一次(又称周游)</p><ul><li>”访问”的含义很广，可以是对结点作各种处理，如：输出结点的信息、修改结点的数据值等，但要求这种访问不破坏原来的数据结构，即不插入结点和删除结点</li></ul><p>遍历目的：得到树中所有结点的一个线性排列</p><p>遍历用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。</p><p>遍历方法：</p><p>依次遍历二叉树中的三个组成部分，便是遍历了整个二叉树</p><p>假设：L：遍历左子树，D：访问根结点，R：遍历右子树，则遍历整个二叉树方案共有：DLR、LDR、LRD、DRL、RDL、RLD</p><p>若规定先左后右，则只有前三种情况</p><p>DLR——先(根) 序遍历</p><p>LDR——中(根) 序遍历</p><p>LRD——后(根) 序遍历</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312051751563.png"alt="遍历二叉树方法" /><figcaption aria-hidden="true">遍历二叉树方法</figcaption></figure><h4 id="先序遍历-dlr">5.4.1.1 先序遍历-DLR</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>先访问根结点</li><li>再先序遍历左子树</li><li>最后先序遍历右子树</li></ol><p>访问二叉树中所有结点，且每个结点只访问一次</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052037066.png"alt="先序遍历-DLR例子" /><figcaption aria-hidden="true">先序遍历-DLR例子</figcaption></figure><h4 id="中序遍历-ldr">5.4.1.2 中序遍历-LDR</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>中序遍历左子树</li><li>访问根结点</li><li>中序遍历右子树</li></ol><p>例子：还是上面的图：E L B A M H I D J</p><h4 id="后序遍历-lrd">5.4.1.3 后序遍历-LRD</h4><p>若二叉树为空，则空操作；否则：</p><ol type="1"><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根结点</li></ol><p>例子：还是上面的图：L E B M I H J D A</p><h3 id="根据遍历序列确定二叉树">5.4.2 根据遍历序列确定二叉树</h3><ul><li><p>若二叉树中各结点的值均不同，则二叉树结点的先序序列、中序序列和后序序列都是唯一的</p></li><li><p>由中序和先序，或中序和后序遍历序列可以唯一确定一棵二叉树</p><p>但由先序和后序遍历不能唯一确定一棵二叉树。因为对二叉树的先序和后序遍历序列来说，无法根据根结点唯一地划分出左子树和右子树的遍历序列，因此也就不能唯一确定这棵二叉树，除非二叉树为空二叉树或只有一个结点。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052053118.png"alt="根据遍历序列确定二叉树" /><figcaption aria-hidden="true">根据遍历序列确定二叉树</figcaption></figure><h3 id="二叉树遍历的递归算法">5.4.3 二叉树遍历的递归算法</h3><p>实现一个算法前先确定存储结构一一二叉链表（通过指针T访问根节点）</p><p><strong>先序遍历算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树先序遍历，递归算法</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">至于这里为什么是Status，我现在是这样理解的：</span><br><span class="hljs-comment">这里面有个状态码返回，所以void不行，一般也确实需要状态码来确定是否成功执行，所以挺有用的，想用void看下一个代码</span><br><span class="hljs-comment">等后面代码实现的时候验证一下~</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">Status <span class="hljs-title">PreOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点，visit函数自己定义，看你的访问需求是什么</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树，递归调用进入下一层了</span><br>        <span class="hljs-built_in">PreOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//这个是用void的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preorderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T)&#123;<br>        <span class="hljs-built_in">printf</span>(T-&gt;data);<br>        <span class="hljs-built_in">preorderTraverse</span>(T-&gt;lchild);<br>        <span class="hljs-built_in">preorderTraverse</span>(T-&gt;rchild);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归调用中具体的执行过程：</p><blockquote><p>这里看弹幕讨论BiTree <em>T 有错误，不应该带</em>，这里等我写代码的时候实践一下看看</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052258026.png"alt="递归调用中具体的执行过程" /><figcaption aria-hidden="true">递归调用中具体的执行过程</figcaption></figure><p><strong>中序遍历算法</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052301466.png"alt="中序遍历算法" /><figcaption aria-hidden="true">中序遍历算法</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树中序遍历，递归算法</span><br><span class="hljs-function">Status <span class="hljs-title">InOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点</span><br>        <span class="hljs-built_in">InOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后序遍历算法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树后序遍历，递归算法</span><br><span class="hljs-function">Status <span class="hljs-title">PostOrderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (T == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> OK;<span class="hljs-comment">//空二叉树</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;lchild); <span class="hljs-comment">//递归遍历左子树</span><br>        <span class="hljs-built_in">PostOrderTraverse</span>(T-&gt;rchild); <span class="hljs-comment">//递归遍历右子树</span><br>        <span class="hljs-built_in">visit</span>(T); <span class="hljs-comment">//访问根结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>遍历算法的分析</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052306327.png"alt="遍历算法的分析" /><figcaption aria-hidden="true">遍历算法的分析</figcaption></figure><p>时间复杂度：<span class="math inline">\(O(3n)=O(n)\)</span></p><p>空间复杂度：<spanclass="math inline">\(O(n)\)</span>，栈占用的最大辅助空间</p><p>解释：栈要记录下，虽然我路过它了，但是没有访问，记录下这个结点，访问之后就能从栈中拿出来，最坏的情况下单支的树，每个结点路过的时候都不访问，要存储n个结点</p><h3 id="二叉树遍历的非递归算法">5.4.4 二叉树遍历的非递归算法</h3><p>以中序遍历非递归算法为例</p><blockquote><p>当遇到根的时候不能访问，先遍历左子树，遍历完左子树之后回来还能找到它，那就需要一个地方把这个根存起来</p></blockquote><p>二叉树中序遍历的非递归算法的关键：在中序遍历过某结点的整个左子树后，如何找到该结点的根以及右子树</p><p>基本思想：</p><ol type="1"><li>建立一个栈</li><li>根结点进栈，遍历左子树</li><li>根结点出栈，输出根结点，遍历右子树</li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312052326364.gif"alt="中序遍历非递归算法gif" /><figcaption aria-hidden="true">中序遍历非递归算法gif</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//中序遍历非递归算法，二叉链表上实现</span><br><span class="hljs-function">Status <span class="hljs-title">InorderTraverse</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    BiTree p,q;<br>    P=T;  <span class="hljs-comment">//要操作的结点，指针变量p表示，初值指向根结点</span><br>    <span class="hljs-built_in">InitStack</span>(S);  <span class="hljs-comment">//初始化栈</span><br>    <span class="hljs-keyword">while</span> (P||!<span class="hljs-built_in">StackEmpty</span>(S))&#123;<br>        <span class="hljs-keyword">if</span> (P)&#123;<br>            <span class="hljs-built_in">Push</span>(S, p);  <span class="hljs-comment">//不为空，就当前根结点入栈</span><br>            q = p; <br>            p = p-&gt;lchild;<span class="hljs-comment">//然后去访问它的左子树，再进入第6句循环 </span><br>        &#125;<br>      <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//左子树为空，但是栈还不为空</span><br>            <span class="hljs-built_in">Pop</span>(S, q);  <span class="hljs-comment">//将当前栈顶元素弹出</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>,q-&gt;data);<br>            p = q-&gt;rchild; <span class="hljs-comment">//其实全用p就行了，感觉这里有点小复杂了 </span><br>        &#125;<br>    &#125;<span class="hljs-comment">//while</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二叉树的层次遍历">5.4.5 二叉树的层次遍历</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312060022760.png"alt="二叉树的层次遍历" /><figcaption aria-hidden="true">二叉树的层次遍历</figcaption></figure><p>对于一颗二叉树，从根结点开始，按从上到下、从左到右的顺序访问每一个结点。每一个结点仅仅访问一次</p><p>上图层次遍历结果为：A B C D E F G</p><blockquote><p>这个算法看起来是很简单的，甚至说第一次接触二叉树我想的就是这种遍历算法，一层一层遍历不就行了，但是实现起来其实不是那么简单，或者说让我自己实现我都想不到怎么实现，是有点小巧妙在里面的</p></blockquote><p>算法设计思路：使用一个队列</p><ol type="1"><li>将根结点进队</li><li>队不空时循环：从队列中出列一个结点*p，访问它<ol type="1"><li>若它有左孩子结点，将左孩子结点进队</li><li>若它有右孩子结点，将右孩子结点进队</li></ol></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312060025826.png"alt="二叉树的层次遍历算法" /><figcaption aria-hidden="true">二叉树的层次遍历算法</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//使用队列（顺序循环队列）类型定义如下</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    BTNode data[MaxSize]; <span class="hljs-comment">//存放队中元素</span><br><span class="hljs-type">int</span> front, rear; <span class="hljs-comment">//队头和队尾指针</span><br>&#125;SqQueue;   <span class="hljs-comment">//顺序循环队列类型</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉树层次遍历算法，这里只是类c语言，只提供思路（可能因为用的不太多？后面就不实现了</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LevelOrder</span><span class="hljs-params">(BTNode *b)</span></span>&#123;<br>    BTNode *p;<br>    SqQueue *qu;<br>    <span class="hljs-built_in">InitQueue</span>(qu);  <span class="hljs-comment">//初始化队列</span><br>    <span class="hljs-built_in">enQueue</span>(qu, b); <span class="hljs-comment">//根结点指针进入队列</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">QueueEmpty</span>(qu))&#123;   <span class="hljs-comment">//队不为空，则循环</span><br>        <span class="hljs-built_in">deQueue</span>(qu, p);  <span class="hljs-comment">//出队结点p</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, p-&gt;data);<span class="hljs-comment">//访问结点p</span><br>        <span class="hljs-keyword">if</span> (p-&gt;lchild != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">enQueue</span>(qu, p-&gt;lchild); <span class="hljs-comment">//有左孩子时将其进队</span><br>        <span class="hljs-keyword">if</span> (p-&gt;rchild != <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">enQueue</span>(qu, p-&gt;rchild)<span class="hljs-comment">//有右孩子时将其进队</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>层次遍历也可以用栈实现但比队列麻烦些不细说有兴趣下去了解</p></blockquote><h3 id="二叉树遍历算法的应用">5.4.6 二叉树遍历算法的应用</h3><h4 id="二叉树的建立">5.4.6.1 二叉树的建立</h4><p>按先序遍历序列建立二叉树的二叉链表</p><p>例：已知先序序列为ABCDEGF</p><p>（1）从键盘输入二叉树的结点信息，建立二叉树的存储结构</p><p>（2）在建立二叉树的过程中按照二叉树先序方式建立</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">Status <span class="hljs-title">CreateBiTree</span><span class="hljs-params">(BiTree &amp;T)</span></span>&#123;   <span class="hljs-comment">//按先序次序创建二叉树</span><br>    <span class="hljs-built_in">scanf</span>(&amp;ch); <span class="hljs-comment">//cin &gt;&gt; ch;</span><br>    <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">&#x27;#&#x27;</span>) T=<span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// *可用空格或一个特殊字符</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (!(T=(BiTNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(BiTNode))))<br>            <span class="hljs-built_in">exit</span> (OVERFLOW);   <span class="hljs-comment">//c++语法:T=new BiTNode;</span><br>        T-&gt;data=ch;                 <span class="hljs-comment">//生成根结点</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;lchild);   <span class="hljs-comment">//构造左子树</span><br>        <span class="hljs-built_in">CreateBiTree</span>(T-&gt;rchild);  <span class="hljs-comment">//构造右子树</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;     <br>    <br><span class="hljs-comment">//若按中序或后序呢?</span><br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071553229.png"alt="二叉树的建立" /><figcaption aria-hidden="true">二叉树的建立</figcaption></figure><h4 id="复制二叉树">5.4.6.2 复制二叉树</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071619419.png"alt="复制二叉树" /><figcaption aria-hidden="true">复制二叉树</figcaption></figure><h4 id="计算二叉树的深度">5.4.6.3 计算二叉树的深度</h4><p>如果是空树，则深度为0</p><p>否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071622351.png"alt="计算二叉树的深度" /><figcaption aria-hidden="true">计算二叉树的深度</figcaption></figure><p><del>md全是递归，全是套娃</del></p><h4 id="计算结点总数">5.4.6.4 计算结点总数</h4><p>如果是空树，则结点个数为0</p><p>否则，结点个数为左子树的结点个数+右子树的结点个数再+1.</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071626996.png"alt="计算结点总数" /><figcaption aria-hidden="true">计算结点总数</figcaption></figure><h4 id="计算叶子结点数">5.4.6.5 计算叶子结点数</h4><p>如果是空树，则叶子结点个数为0</p><p>否则，为左子树的叶子结点个数+右子树的叶子结点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LeadCount</span><span class="hljs-params">(BiTree T)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(T==<span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//如果是空树返回0</span><br>    <span class="hljs-keyword">if</span>(T-&gt;lchild == <span class="hljs-literal">NULL</span> &amp;&amp; T-&gt;rchild == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//如果是叶子结点返回1</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">LeafCount</span>(T-&gt;lchild) + <span class="hljs-built_in">LeafCount</span>(T-&gt;rchild);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="线索二叉树">5.5 线索二叉树</h2><p>问题：为什么要研究线索二叉树？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071633544.png"alt="问题：为什么要研究线索二叉树？" /><figcaptionaria-hidden="true">问题：为什么要研究线索二叉树？</figcaption></figure><p>提出的问题：如何寻找特定遍历序列中二叉树结点的前驱和后继???</p><p>解决的方法</p><p>1、通过遍历寻找——费时间</p><p>2、再增设前驱、后继指针域——增加了存储负担</p><p>3、利用二叉链表中的空指针域（※）</p><p>回顾：二叉链表中的空指针域的数量：具有n个结点的二叉链表中，有n+1个空指针域</p><p>那么能不能把这n+1个空指针域利用起来呢？答案是肯定的</p><p>利用二叉链表中的空指针域</p><ul><li>如果某个结点的左孩子为空，则将空的左孩子指针域改为指向其前驱</li><li>如果某结点的右孩子为空，则将空的右孩子指针域改为指向其后继</li><li>这种改变指向的指针称为“线索“</li></ul><p>加上了线索的二叉树称为<strong>线索二叉树 (Threaded BinaryTree)</strong></p><p>对二叉树按某种遍历次序使其变为线索二叉树的过程叫线索化</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071650949.png"alt="中序线索二叉树例子" /><figcaption aria-hidden="true">中序线索二叉树例子</figcaption></figure><p>为区分<code>Irchid</code>和<code>rchild</code>指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中每个结点增设两个标志域<code>ltag</code> 和 <code>rtag</code> ，并约定如下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071655554.png"alt="线索二叉树结点结构" /><figcaption aria-hidden="true">线索二叉树结点结构</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-type">int</span> LTag,RTag; <span class="hljs-comment">//左右标志</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">BiThrNode</span> *lchild, *rchild;  <span class="hljs-comment">//左右孩子指针</span><br>                                      <br>&#125;BiThrNode, *BiThrTree;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071658884.png"alt="线序线索二叉树" /><figcaption aria-hidden="true">线序线索二叉树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071701982.png"alt="后序线索二叉树" /><figcaption aria-hidden="true">后序线索二叉树</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071705688.png"alt="中序线索二叉树" /><figcaption aria-hidden="true">中序线索二叉树</figcaption></figure><p>为了避免悬空状态，增设一个头结点，让操作更加方便</p><p>增设了一个头结点<code>thrt</code>：</p><p><code>ltag=0</code>，<code>lchild</code>指向根结点</p><p><code>rtag=1</code>，<code>rchild</code>指向遍历序列中最后一个结点</p><p>遍历序列中第一个结点的<code>lc</code>域和最后一个结点的<code>rc</code>域都指向头结点</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071708028.png"alt="中序线索二叉树" /><figcaption aria-hidden="true">中序线索二叉树</figcaption></figure><h2 id="树和森林">5.6 树和森林</h2><p>由二叉树推而广之，研究一下树和森林</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312071711195.png"alt="树和森林" /><figcaption aria-hidden="true">树和森林</figcaption></figure><h3 id="树的存储结构">5.6.1 树的存储结构</h3><p>1、双亲表示法：</p><p>用一个数组连续存储结点,各结点中附设一个指示其双亲的结点位置(下标).</p><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】_数据结构树_UniqueUnit的博客-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——对称密码（一）</title>
    <link href="/2023/12/05/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/12/05/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94%E5%AF%B9%E7%A7%B0%E5%AF%86%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>DES</tag>
      
      <tag>AES</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto刷题</title>
    <link href="/2023/12/04/Crypto%E5%88%B7%E9%A2%98/"/>
    <url>/2023/12/04/Crypto%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="nssround11-basicez_signin">[NSSRound#11 Basic]ez_signin</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><span class="hljs-keyword">assert</span> p &gt; q<br>n = p*q<br>e = <span class="hljs-number">65536</span><br>m = bytes_to_long(flag)<br>num1 = (<span class="hljs-built_in">pow</span>(p,e,n)-<span class="hljs-built_in">pow</span>(q,e,n)) % n<br>num2 = <span class="hljs-built_in">pow</span>(p-q,e,n)<br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num1=&quot;</span>,num1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;num2=&quot;</span>,num2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n=&quot;</span>,n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c=&quot;</span>,c)<br><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041139338.png"alt="求p，q" /><figcaption aria-hidden="true">求p，q</figcaption></figure><p>二式可转化为<span class="math inline">\((p^e + q^e)\%n\)</span>，是因为中间项同时带pq被模掉了，所以两式相加与 n 取 gcd可以得到p</p><p>此时<span class="math inline">\(e = 65536=2^{16}\)</span>，且经计算p和q都属于4k+3型素数，直接16次Rabin算法解密即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br>num1= <span class="hljs-number">134186458247304184975418956047750205959249518467116558944535042073046353646812210914711656218265319503240074967140027248278994209294869476247136854741631971975560846483033205230015783696055443897579440474585892990793595602095853960468928457703619205343030230201261058516219352855127626321847429189498666288452</span><br>num2= <span class="hljs-number">142252615203395148320392930915384149783801592719030740337592034613073131106036364733480644482188684184951026866672011061092572389846929838149296357261088256882232316029199097203257003822750826537629358422813658558008420810100860520289261141533787464661186681371090873356089237613080052677646446751824502044253</span><br>n= <span class="hljs-number">154128165952806886790805410291540694477027958542517309121222164274741570806324940112942356615458298064007096476638232940977238598879453357856259085001745763666030177657087772721079761302637352680091939676709372354103177660093164629417313468356185431895723026835950366030712541994019375251534778666996491342313</span><br>c= <span class="hljs-number">9061020000447780498751583220055526057707259079063266050917693522289697419950637286020502996753375864826169562714946009146452528404466989211057548905704856329650955828939737304126685040898740775635547039660982064419976700425595503919207903099686497044429265908046033565745195837408532764433870408185128447965</span><br><br>p = GCD(num1+num2,n)<br>q = n//p<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_4k_plus_3</span>(<span class="hljs-params">p</span>):<br>    <span class="hljs-keyword">return</span> p % <span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br><br><span class="hljs-keyword">if</span> is_4k_plus_3(p):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;p&#125;</span> 是一个4k+3型的整数&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;p&#125;</span> 不是一个4k+3型的整数&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> is_4k_plus_3(q):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;q&#125;</span> 是一个4k+3型的整数&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;q&#125;</span> 不是一个4k+3型的整数&quot;</span>)<br><br>x0=gmpy2.invert(p,q)<br>x1=gmpy2.invert(q,p)<br>cs = [c]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">16</span>):<br>    ps = []<br>    <span class="hljs-keyword">for</span> c2 <span class="hljs-keyword">in</span> cs:<br>        r = <span class="hljs-built_in">pow</span>(c2, (p + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, p)<br>        s = <span class="hljs-built_in">pow</span>(c2, (q + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, q)<br><br>        x = (r * x1 * q + s * x0 * p) % n<br>        y = (r * x1 * q - s * x0 * p) % n<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(x)<br>        <span class="hljs-keyword">if</span> n - x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - x)<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(y)<br>        <span class="hljs-keyword">if</span> n - y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - y)<br>    cs = ps<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ps:<br>    flag = long_to_bytes(m)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;nssctf&quot;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法 6 回溯法</title>
    <link href="/2023/12/03/%E7%AE%97%E6%B3%95%206-%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <url>/2023/12/03/%E7%AE%97%E6%B3%95%206-%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="方法概述">方法概述</h2><h3 id="搜索算法介绍">搜索算法介绍</h3><ol type="1"><li><p>穷举搜索</p></li><li><p>盲目搜索</p></li></ol><ul><li>深度优先( DFS ) 或 回溯搜索 (Backtracking)；</li><li>广度优先搜索(BFS)；</li><li>分支限界法(Branch &amp; Bound)</li><li>博奔树搜索 (α-β Search)</li></ul><ol start="3" type="1"><li>启发式搜索</li></ol><ul><li><p>A* 算法和最佳优先(Best-First Search)</p></li><li><p>迭代加深的A* 算法</p></li><li><p>B* ，AO* ，SSS*等算法</p></li><li><p>Local Search，GA等算法</p></li></ul><h3 id="搜索空间的三种表示">搜索空间的三种表示</h3><p>表序表示：搜索对象用线性表数据结构表示</p><p>显示图表示：搜索对象在搜索前就用图(树)的数据结构表示</p><p>隐式图表示：除了初始结点，其他结点在搜索过程中动态生成。缘于搜索空间大，难以全部存储。</p><h3 id="回溯法backtracking">回溯法(Backtracking)</h3><p>回溯法(Backtracking)又称为试探法：</p><ul><li>回溯法是一个既带有系统性又带有跳跃性的搜索算法；</li><li>它在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。——系统性</li><li>算法搜索至解空间树的任一结点时，判断该结点为根的子树是否包含问题的解，如果肯定不包含，则跳过以该结点为根的子树的搜索逐层向其祖先结点回溯。否则，进入该子树，继续深度优先的策略进行搜索。——跳跃性</li><li><strong>这种以深度优先的方式系统地搜索问题的解的算法称为回溯法</strong>。它适用于解一些组合数较大的问题。许多复杂的、规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</li><li>递归(Recursion)、迭代(lteration)、回溯??区别与联系</li></ul><h4 id="基本思想">基本思想</h4><p>（上面的概念也是属于基本思想的）</p><ul><li>搜索从开始结点(根结点) 出发，以深度优先搜索整个解空间。</li><li>这个开始结点成为活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为新的活结点，并成为当前扩展结点。</li><li>如果在当前的扩展结点处不能再向纵深方向扩展，则当前扩展结点就成为死结点。</li><li>此时，应往回移动(回溯)至最近的一个活结点处(回溯点)，并使这个活结点成为当前的扩展结点;直到找到一个解或全部解。</li></ul><h4 id="基本步骤">基本步骤：</h4><ol type="1"><li>针对所给问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构；</li><li>以深度优先方式搜索解空间，并在搜索过程中用前枝函数避免无效搜索。</li></ol><p><strong>常用剪枝函数：</strong></p><p>① 用约束函数在扩展结点处剪去不满足约束的子树；</p><p>② 用限界函数剪去得不到最优解的子树。</p><h3 id="二类常见的解空间树">二类常见的解空间树：</h3><h4 id="子集树">子集树</h4><p>当所给的问题是从n个元素的集合S中找出满足某种性质的子集时，相应的解空间树称为子集树。子集树通常有<spanclass="math inline">\(2^n\)</span>个叶子结点，其总结点个数为<spanclass="math inline">\(2^{n+1}-1\)</span>，遍历子集树时间为<spanclass="math inline">\(Ω(2^n)\)</span>。如0-1背包问题，叶结点数为<spanclass="math inline">\(2^n\)</span>，总结点数<spanclass="math inline">\(2^{n+1}\)</span>。</p><p>假设现在有一列数 <span class="math inline">\(a[0],a[1],...a[n-1]\)</span>，如果一个问题的解的长度不是固定的，并且解和元素顺序无关，即可以从中选择0个或多个，那么解空间的个数将是指数级别的，为<spanclass="math inline">\(2^n\)</span>,可以用下面的子集树来表示所有的解(假设这里n=4)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032047861.png"alt="子集树" /><figcaption aria-hidden="true">子集树</figcaption></figure><p>这里一共有<span class="math inline">\(2^4=16\)</span>种情况</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032051625.png"alt="0-1背包问题（1）" /><figcaption aria-hidden="true">0-1背包问题（1）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032051520.png"alt="0-1背包问题（2）" /><figcaption aria-hidden="true">0-1背包问题（2）</figcaption></figure><h4 id="排列树">排列树</h4><p>当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有<spanclass="math inline">\(n!\)</span>个叶子结点，因此，遍历排列树需要<spanclass="math inline">\(Ω(n!)\)</span>的计算时间。如TSP问题(TravelingSalesman Problem，推销员问题)，叶结点数为<spanclass="math inline">\(n!\)</span>，遍历时间为<spanclass="math inline">\(Ω(n!)\)</span>。</p><p>如果解空间是由n个元素的排列形成，即n个元素的每一个排列都是解空间中的一个元素，那么，最后解空间的组织形式是排列树。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032048478.png"alt="排列树" /><figcaption aria-hidden="true">排列树</figcaption></figure><p>这里每一个元素有<spanclass="math inline">\(3*2*1=6\)</span>种情况，一共就有<spanclass="math inline">\(4*6=24\)</span>种情况，也就是<spanclass="math inline">\(4*3*2*1=24\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312032053917.png"alt="TSP问题" /><figcaption aria-hidden="true">TSP问题</figcaption></figure><p>因为这里规定了从A出发，所以一共就有<spanclass="math inline">\(3*2*1=6\)</span>种情况</p><h2 id="背包问题">0-1背包问题</h2><h3 id="问题描述">问题描述</h3><p>给定n种物品和一背包。物品i的重量是<spanclass="math inline">\(w_i&gt;0\)</span>，其价值为<spanclass="math inline">\(v_i&gt;0\)</span>，背包的容量为c。问应如何选择装入背包中的物品，使得装入背包中物品的总价值最大？</p><p>如：</p><p><img src="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312031926719.png" alt="0-1背包问题例题" style="zoom:80%;" /></p><p>肉眼可算出答案是[1,3,4]，结果是20</p><h3 id="复杂度分析">复杂度分析</h3><p><strong>时间复杂度分析：</strong></p><p>回溯法的时间复杂度通常随着问题规模的增加而指数级增长。在每一步，算法需要考虑选择或不选择当前物品，因此复杂度为<span class="math inline">\(O(2^n)\)</span>，其中 n是物品的数量。这是因为对于每个物品，都有两种选择：选择或不选择。因此，总共有<span class="math inline">\(2^n\)</span> 种组合需要考虑。</p><p><strong>空间复杂度分析：</strong></p><p>空间复杂度主要取决于递归调用的深度。在回溯法中，递归调用堆栈的深度是问题的规模。因为在每一步中都有两个分支（选择或不选择），递归树的深度是n，其中 n 是物品的数量。因此，空间复杂度为 <spanclass="math inline">\(O(n)\)</span>。</p><p>需要注意的是，这里的空间复杂度并不考虑输入数据的空间占用，仅仅是算法本身的空间占用。</p><p>需要注意的是，虽然回溯法的时间复杂度很高，但在实际应用中，可以通过一些优化策略（例如剪枝）来减少搜索空间，提高算法效率。对于0-1背包问题，通常更推荐使用动态规划来获得更高效的解决方案。</p><h3 id="代码">代码</h3><p><strong>python：</strong></p><p>要我说，这玩意真要好好调试一下吧，不然🐭🐭是真理解不了啊</p><p>这真有人第一次能自己写出来吗，我怎么不信呢😭😭😭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># python</span><br>max_V, now_W, now_V, best_X, goods = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, [], []  <span class="hljs-comment"># 最大价值、当前重量、当前价值、最优解、商品列表</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;请输入物品数量、背包容量，空格隔开：&#x27;</span>)<br>n, c = <span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;请输入第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>个物品的重量和价值，空格隔开：&#x27;</span>)<br>    goods.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, <span class="hljs-built_in">input</span>().split())))<br>x = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]  <span class="hljs-comment"># 初始化当前解</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">backtrack</span>(<span class="hljs-params">i</span>):  <span class="hljs-comment"># i是层数，n个物品，共有n+1层</span><br>    <span class="hljs-keyword">global</span> max_V, now_V, now_W, best_X, x  <span class="hljs-comment"># 引入全局变量</span><br>    <span class="hljs-keyword">if</span> i &gt;= n:  <span class="hljs-comment"># 当层数超过物品总数量的时候</span><br>        <span class="hljs-keyword">if</span> max_V &lt; now_V:  <span class="hljs-comment"># 当最大值小于当前价值时，更新最大值</span><br>            max_V = now_V<br>            best_X = x[:]  <span class="hljs-comment"># 同步更新最优解</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">if</span> now_W + goods[i][<span class="hljs-number">0</span>] &lt;= c:  <span class="hljs-comment"># 如果当前重量加上该层对应物品的重量，可以装在背包里</span><br>            x[i] = <span class="hljs-number">1</span>  <span class="hljs-comment"># 那么就装入这个物品（当前物品的状态为1）</span><br>            now_W += goods[i][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 更新当前重量和价值</span><br>            now_V += goods[i][<span class="hljs-number">1</span>]<br>            backtrack(i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进入下一个节点（如果符合条件就到底了）</span><br>            now_W -= goods[i][<span class="hljs-number">0</span>]  <span class="hljs-comment"># 另一侧节点</span><br>            now_V -= goods[i][<span class="hljs-number">1</span>]<br>        x[i] = <span class="hljs-number">0</span>  <span class="hljs-comment"># 初始化物品状态</span><br>        backtrack(i + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 进入下一层</span><br><br><br>backtrack(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 从第0层开始搜索</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;最大价值为：<span class="hljs-subst">&#123;max_V&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;应装物品编号为：<span class="hljs-subst">&#123;[i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n) <span class="hljs-keyword">if</span> best_X[i]]&#125;</span>&#x27;</span>)<br><br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/xym4869/p/8513801.html">0-1背包问题—— 四种解法解题 - Shaw_喆宇 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>回溯法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（四）</title>
    <link href="/2023/12/02/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/12/02/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa4p1">[RSA4]P1</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*p*q<br>e = n<br><br>c = <span class="hljs-built_in">pow</span>(bytes_to_long(flag), e, n)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 539403894871945779827202174061302970341082455928364137444962844359039924160163196863639732747261316352083923762760392277536591121706270680734175544093484423564223679628430671167864783270170316881238613070741410367403388936640139281272357761773388084534717028640788227350254140821128908338938211038299089224967666902522698905762169859839320277939509727532793553875254243396522340305880944219886874086251872580220405893975158782585205038779055706441633392356197489</span><br><span class="hljs-string">d = 58169755386408729394668831947856757060407423126014928705447058468355548861569452522734305188388017764321018770435192767746145932739423507387500606563617116764196418533748380893094448060562081543927295828007016873588530479985728135015510171217414380395169021607415979109815455365309760152218352878885075237009</span><br><span class="hljs-string">c = 192900246089028524753714085947506209686933390275949638288635203069117504901164350538204619142802436833736532680210208373707687461486601253665313637541968852691434282584934523173439632554783111037594035333325446559685553119339191110056283203940511701992217372405369575376549738295022767068810511670144120539082403063406787770958515441813335548550876818218065412869322721395317537328975187612606437225577060414403223288106406471061759010085578263501971809720648827</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp">*exp</h3><h2 id="rsa4p2">[RSA4]P2</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>m = bytes_to_long(flag)<br><br>a = getPrime(<span class="hljs-number">512</span>)<br>b = getPrime(<span class="hljs-number">512</span>)<br>c = getPrime(<span class="hljs-number">512</span>)<br>d = getPrime(<span class="hljs-number">512</span>)<br>x = getPrime(<span class="hljs-number">128</span>)<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br><br>y = a*x**<span class="hljs-number">3</span> + b*x**<span class="hljs-number">2</span> + c*x + d<br>y = y%p<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;a = <span class="hljs-subst">&#123;a&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;b = <span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;y = <span class="hljs-subst">&#123;y&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;h = <span class="hljs-subst">&#123;x*m&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 133497915779382863191750985139274661777547262395290628161924420897772911005538338729076080701700641387222690295548776566406640902391412661622674862629221960258683570655393881212072865809598640669325347893228617784548982886334708010706482958773921901369314425694414231562752232070402056445403762485870067804611</span><br><span class="hljs-string">a = 9956367951694116871507184264812038680047685394446603010101493156120195118634053526664122377707243776744926630820373051608195739431033785355316509320690639</span><br><span class="hljs-string">b = 10372715760267086803036635068149481902075294943354407472550232447612611381527989796797133302495652064200149218004252582942179771677307157495328484190016267</span><br><span class="hljs-string">c = 6954444546090251351899752282258945069765577103755637726562318645879810909547057855773433206441550954298878711294660493586907360045986061150306446126101573</span><br><span class="hljs-string">d = 12708905621484064085174866220764918657140490021181156214236692898034114314742314389460399916798129560082685314351680895409634875081403212130502800572290391</span><br><span class="hljs-string">y = 89881957270704175663646084308402351944545222001266778194637035700540903495792268004845278611707036762628657152963392762363015748904045511650663013086598899685992255568758440781657480520250399778976982455784259655683731183717562593121780657623767804362641533930566522430</span><br><span class="hljs-string">h = 584447473604416360596641349947186936435346265446590336271443321812736224750414727189483734666053582372219773206703655293254283559436185831581631</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#sage:</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">133497915779382863191750985139274661777547262395290628161924420897772911005538338729076080701700641387222690295548776566406640902391412661622674862629221960258683570655393881212072865809598640669325347893228617784548982886334708010706482958773921901369314425694414231562752232070402056445403762485870067804611</span><br>a = <span class="hljs-number">9956367951694116871507184264812038680047685394446603010101493156120195118634053526664122377707243776744926630820373051608195739431033785355316509320690639</span><br>b = <span class="hljs-number">10372715760267086803036635068149481902075294943354407472550232447612611381527989796797133302495652064200149218004252582942179771677307157495328484190016267</span><br>c = <span class="hljs-number">6954444546090251351899752282258945069765577103755637726562318645879810909547057855773433206441550954298878711294660493586907360045986061150306446126101573</span><br>d = <span class="hljs-number">12708905621484064085174866220764918657140490021181156214236692898034114314742314389460399916798129560082685314351680895409634875081403212130502800572290391</span><br>y = <span class="hljs-number">89881957270704175663646084308402351944545222001266778194637035700540903495792268004845278611707036762628657152963392762363015748904045511650663013086598899685992255568758440781657480520250399778976982455784259655683731183717562593121780657623767804362641533930566522430</span><br>h = <span class="hljs-number">584447473604416360596641349947186936435346265446590336271443321812736224750414727189483734666053582372219773206703655293254283559436185831581631</span><br><br>PR.&lt;x&gt; = PolynomialRing(GF(p))<br>f = a*x^<span class="hljs-number">3</span> + b*x^<span class="hljs-number">2</span> + c*x + d - y<br>f = f.monic()<br>res = f.small_roots()<br>m = h // <span class="hljs-built_in">int</span>(res[<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-5-贪心算法</title>
    <link href="/2023/12/02/%E7%AE%97%E6%B3%95%205-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2023/12/02/%E7%AE%97%E6%B3%95%205-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="最优化问题">最优化问题</h2><p>一般特征：问题有n个输入，问题的解是由这n个输入的某个子集组成，这个子集必须满足某些事先给定的条件。</p><ul><li><p>约束条件：子集必须满足的条件</p></li><li><p>可行解：满足约束条件的子集；可行解可能不唯一</p></li><li><p>目标函数：用来衡量可行解优劣的标准，一般以函数形式给出</p></li><li><p>最优解：能够使目标函数取极值 (极大或极小)的可行解、</p></li></ul><p>最优化问题求解分类：根据描述问题约束条件和目标函数的数学模型的特性和问题的求解方法的不同，可分为：线性规划、整数规划、非线性规划、动态规划、分支限界法等<strong>精确算法</strong></p><p>贪心方法：一种改进的分级的处理方法，可对满足上述特征的某些问题方便地求解，属于<strong>近似算法</strong>。即每次在做选择时，总是先选择具有相同特征的那个解，即“贪心解”</p><h2 id="贪心算法">贪心算法</h2><h3 id="概述">概述</h3><p>当某问题具有最优子结构性质时，可用动态规划法求解(精解确、大规模等问题效率低)，但有时用贪心算法求解会更简单、更有效。</p><p>顾名思义，<strong>贪心算法总是作出在当前看来最好的选择</strong>，并不从整体最优考虑，它所作出的选择只是在某种意义上的局部最优选择。当然，其希望得到的最终结果是整体最优的。</p><p>虽然不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。如单源最短路经问题，最小生成树问题等。在一些情况下，贪心算法不能得到整体最优解，但其最终结果是最优解的近似。</p><h3 id="基本思想">基本思想</h3><ul><li>从问题的某一个初始解出发，通过一系列的贪心选择，即当前状态下的局部最优选择，逐步逼近给定的目标，尽可能快地求得更好的解。</li><li>在贪心算法(GreedyMethod)中采用逐步构造/分级最优解的方法。在每个阶段，都作出一个按某个评价函数最优的决策，该最优评价函数称为贪心准则(GreedyCriterion)</li><li>贪心算法的正确性，要证明按贪心准则求得的解是全局最优解</li></ul><h3 id="基本步骤">基本步骤</h3><ol type="1"><li>决定问题的最优子结构</li><li>设计出一个递归解</li><li>证明在递归的任一阶段，最优选择之一总是贪心选择，那么做贪心选择总是安全的。</li><li>证明通过做贪心选择，所有子问题(除一个以外)都为空，即只产生一个子问题</li><li>设计出一个实现贪心策略的递归算法。</li><li>(性能角度) 将递归算法转换成迭代算法。</li></ol><h3 id="贪心算法的基本要素">贪心算法的基本要素</h3><p>对于一个具体的问题，怎么知道是否可用贪心算法解此问题，以及能否得到问题的最优解呢？这个问题很难给予肯定的回答。但是，从许多可以用贪心算法求解的问题中看到这类问题一般具有2个重要的性质：贪心选择性质和最优子结构性质</p><p><strong>贪心选择性质</strong></p><p>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到。这是贪心算法可行的第一个基本要素，也是贪心算法与动态规划算法的主要区别。</p><p>动态规划算法通常以自底向上的方式解各子问题，而贪心算法则通常以自顶向下的方式进行，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</p><p>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解，否则得到的是近优解。</p><p><strong>最优子结构性质</strong></p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。</p><p>问题的最优子结构性质是该问题可用动态规划算法或贪心算法求解的关键特征。但是，需要注意的是，并非所有具有最优子结构性质的问题都可以采用贪心策略来得到最优解</p><p>贪心算法只需考虑一个选择(即贪心的选择)；在做贪心选择时，子问题之一必须是空的，因此只留下一个非空子问题。（是什么意思🙄</p><h3 id="贪心算法-vs-动态规划">贪心算法 vs 动态规划</h3><p>贪心算法和动态规划算法都要求问题具有最优子结构性质，但是两者存在着巨大的差别</p><p>(1)动态规划是先分析子问题，再做选择。而贪心算法是先做贪心选择，做完选择后，生成子问题，然后再去求解子问题</p><ol start="2" type="1"><li>动态规划每一步可能会产生多个子问题，而贪心算法每一步只会产生一个子问题(为非空)</li></ol><p>(3)从特点上看，动态规划是自底向上解决问题，而贪心算法是自顶向下解决问题</p><h3 id="与递归分治的联系">与递归、分治的联系</h3><p>分治策略用于解决原问题与子问题结构相似的问题，对于各子问题相互独立的情况，一般用递归实现</p><p>动态规划用于解决子问题有重复求解的情况，既可以用递归实现，也可以用迭代实现</p><p>贪心算法用于解决具有贪心选择性质的问题，既可以用递归实现，也可以用迭代实现，因为很多递归贪心算法都是尾递归，很容易改成迭代贪心算法</p><p>递归是实现手段，分治策略是解决问题的思想，动态规划和贪心算法很多时候会使用记录子问题运算结果的递归实现</p><h2 id="最小生成树prim算法">最小生成树—Prim算法</h2><h3 id="最小生成树问题">最小生成树问题</h3><h4 id="问题描述">问题描述</h4><ul><li>设<spanclass="math inline">\(G=(V,E)\)</span>是无向连通带权图，即一个网络。（V是顶点集合，E是边集合，E中每条边(v,w)的权为<spanclass="math inline">\(c[v][w]\)</span>）。</li><li>如果G的子图G’是一棵包含G的所有顶点的树，则称G’为G的生成树。生成树上各边权的总和称为该生成树的耗费。</li><li>在G的所有生成树中，耗费最小的生成树称为G的最小生成树(MST:minimumcost spanning tree)</li></ul><p><strong>Prim算法</strong>和<strong>Kruskal算法</strong>：都是解最小生成树问题的贪心算法；它们做<strong>贪心选择的方式不同</strong>，但都利用了下面的最小生成树性质。</p><h4 id="最小生成树性质">最小生成树性质</h4><ul><li>设<spanclass="math inline">\(G=(V,E)\)</span>是连通带权图，U是V的真子集。</li><li>如果<span class="math inline">\((i,j)∈E\)</span>，且<spanclass="math inline">\(i∈U，j∈V-U\)</span>，且在所有这样的边中，<spanclass="math inline">\((i,j)\)</span>的权<spanclass="math inline">\(c[i][j]\)</span>最小，那么必存在一棵包含边<spanclass="math inline">\((i,j)\)</span>的最小生成树。</li><li>这个性质也称为<strong>MST</strong>（Minimum SpanningTree）<strong>性质</strong>。</li></ul><h3 id="prim算法">Prim算法</h3><p>贪心选择策略： 每次都选择到下一顶点权最小的边。</p><p>普里姆算法的实现思路是：</p><ol type="1"><li>将连通网中的所有顶点分为两类（假设为 A 类和 B类）。初始状态下，所有顶点位于 B 类；</li><li>选择任意一个顶点，将其从 B 类移动到 A 类；</li><li>从 B 类的所有顶点出发，找出一条连接着 A类中的某个顶点且权值最小的边，将此边连接着的 A 类中的顶点移动到 B类；</li><li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到N-1 条边。</li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312031052117.png"alt="Prim算法例子" /><figcaption aria-hidden="true">Prim算法例子</figcaption></figure><h4 id="代码实现">代码实现</h4><p>真的有点难度吧哥</p><p><ahref="http://data.biancheng.net/view/40.html">普里姆算法(Prim算法)求最小生成树(biancheng.net)</a></p><p><ahref="http://data.biancheng.net/view/41.html">克鲁斯卡尔算法(Kruskal算法)求最小生成树(biancheng.net)</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">flags</span>轲限梭畴坫他浛<br><span class="hljs-attribute">0264D9A0</span>                                                                                                   <span class="hljs-number">66</span>                                  f<br><span class="hljs-attribute">0264D9C0</span>   <span class="hljs-number">6</span>C <span class="hljs-number">61</span> <span class="hljs-number">67</span> <span class="hljs-number">73</span> E9 F0 CF DE  FE <span class="hljs-number">8</span>F FD F3 CB F3 AB FB  B3 EB DB E3 CB FB <span class="hljs-number">9</span>B BF                            lags轲限?梭畴坫他浛<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 3 栈和队列</title>
    <link href="/2023/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%203%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%203%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="栈和队列的定义和特点">3.1 栈和队列的定义和特点</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（三）</title>
    <link href="/2023/11/29/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/11/29/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa3p1">[RSA3]P1</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;******&#x27;</span><br><br>m1 = bytes_to_long(flag[:<span class="hljs-built_in">len</span>(flag)//<span class="hljs-number">2</span>])<br>m2 = bytes_to_long(flag[<span class="hljs-built_in">len</span>(flag)//<span class="hljs-number">2</span>:])<br><br><span class="hljs-keyword">assert</span> <span class="hljs-number">18608629446895353521310408885845687520013234781800558</span>*m1-<span class="hljs-number">14258810472138345414555137649316815272478951117940067</span>*m2 == <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p>本题非常直白，将flag分成两部分后给了一个约束式，让我们求解flag。</p><p>约束是一个二元一次方程，显然我们知道二元一次方程在实数域上会有无数个解，但注意我们很少会在实数域上进行运算，我们所有的操作都是在一个整数域或者有限域（可以理解为取模的域）中进行运算。而这里我们便有一个非常常用的<strong>裴蜀定理</strong></p><p><strong>裴蜀定理</strong>：对于整数域中的不定方程<spanclass="math inline">\(ax+by=m\)</span>，其有解的充要条件为<spanclass="math inline">\(gcd(a,b)\ | \ m\)</span></p><blockquote><p>裴蜀定理，又称贝祖定理。是一个关于最大公约数的定理。其内容定义为：对于不全为零的任意整数a 和 b，记二者的最大公约数为 g 即 gcd(a,b) = g，则对于任意整数 x 和 y都一定满足 ax+by 是 g 的倍数。</p><p>特别地，一定存在整数 x 和 y 的解，使得 <spanclass="math inline">\(ax+by=gcd(a,b)\)</span> 成立。</p><p>它的一个重要推论为：a,b互质的充分必要条件是存在整数x,y 使 ax+by=1;或者说对于方程 ax+by=1 只有整数a和b互质时，方程才有整数解x,y。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br> <br>a = <span class="hljs-number">18608629446895353521310408885845687520013234781800558</span><br>b = <span class="hljs-number">14258810472138345414555137649316815272478951117940067</span><br>g, m1, m2 = gmpy2.gcdext(a, b)<br><span class="hljs-comment"># gcdext 函数,该函数计算两个整数的最大公约数，并返回扩展欧几里得算法的解。</span><br><span class="hljs-comment">#g 是最大公约数。m1 和 m2 是扩展欧几里得算法的解，满足方程 a * m1 + b * m2 = g。</span><br><span class="hljs-comment"># print(m1,m2)</span><br> <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    mh = long_to_bytes(m1 + i*b)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> mh:<br>        ml = long_to_bytes(-m2 + i*a)<br>        <span class="hljs-built_in">print</span>(mh + ml)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>至于算完m1和m2为什么还有下面的部分：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    mh = long_to_bytes(m1 + i*b)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> mh:<br>        ml = long_to_bytes(-m2 + i*a)<br>        <span class="hljs-built_in">print</span>(mh + ml)<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>这简直是一头🐖都能想到问题了吖（说的是博主本人是🐖</p><p>当然是因为<span class="math inline">\(a(m1 + i*b)+b(-m2 +i*a)=g\)</span>，</p><p>那为什么是<span class="math inline">\(-m_2\)</span>呢</p><p>因为<span class="math inline">\(m_2\)</span>是一个负数，你写<spanclass="math inline">\(m_2\)</span>会报错，写成<spanclass="math inline">\(-m_2\)</span>就好了</p><p><ahref="https://blog.csdn.net/weixin_51216553/article/details/117000599">浅谈扩展欧几里得算法-CSDN博客</a></p><h2 id="rsa3p2高次rabin">[RSA3]P2(高次Rabin)</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br><span class="hljs-keyword">assert</span> p%<span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q%<span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br>n = p*q<br>e = <span class="hljs-number">4</span><br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 59146104467364373868799971411233588834178779836823785905639649355194168174467</span><br><span class="hljs-string">q = 78458230412463183024731868185916348923227701568297699614451375213784918571587</span><br><span class="hljs-string">e = 4</span><br><span class="hljs-string">c = 1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><p>高次Rabin，这里是两次，如果是16次把<code>for i in range(2):</code>中的2改成16即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 脚本喵，只会脚本了说是😭</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br><br>p = <span class="hljs-number">59146104467364373868799971411233588834178779836823785905639649355194168174467</span><br>q = <span class="hljs-number">78458230412463183024731868185916348923227701568297699614451375213784918571587</span><br>e = <span class="hljs-number">4</span><br>c = <span class="hljs-number">1203393285445255679455330581174083350744414151272999693874069337386260499408999133487149585390696161509841251500970131235102423165932460197848215104528310</span><br><br>n = p*q<br><br>x0=gmpy2.invert(p,q)<br>x1=gmpy2.invert(q,p)<br>cs = [c]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>    ps = []<br>    <span class="hljs-keyword">for</span> c2 <span class="hljs-keyword">in</span> cs:<br>        r = <span class="hljs-built_in">pow</span>(c2, (p + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, p)<br>        s = <span class="hljs-built_in">pow</span>(c2, (q + <span class="hljs-number">1</span>) // <span class="hljs-number">4</span>, q)<br><br>        x = (r * x1 * q + s * x0 * p) % n<br>        y = (r * x1 * q - s * x0 * p) % n<br>        <span class="hljs-keyword">if</span> x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(x)<br>        <span class="hljs-keyword">if</span> n - x <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - x)<br>        <span class="hljs-keyword">if</span> y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(y)<br>        <span class="hljs-keyword">if</span> n - y <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> ps:<br>            ps.append(n - y)<br>    cs = ps<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ps:<br>    flag = long_to_bytes(m)<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&quot;NSSCTF&quot;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br>        <span class="hljs-keyword">break</span><br><br><br></code></pre></td></tr></table></figure><h2 id="rsa3p3">[RSA3]P3</h2><h3 id="main-2">main</h3><h3 id="exp-2">exp</h3><h2 id="rsa3p4">[RSA3]P4</h2><h3 id="main-3">main</h3><h3 id="exp-3">exp</h3><h2 id="rsa3p5crt">[RSA3]P5(CRT)</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br>flag = <span class="hljs-string">b&#x27;******&#x27;</span><br>flag = bytes_to_long(flag)<br>nl = []<br>cl = []<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getn</span>(<span class="hljs-params">bits</span>):<br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n.bit_length() &lt; bits:<br>        n *= random.choice(sieve_base)<br>    <span class="hljs-keyword">return</span> n<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>):<br>    n = getn(flag.bit_length())<br>    c = <span class="hljs-built_in">pow</span>(flag, <span class="hljs-number">7</span>, n)<br><br>    nl.append(n)<br>    cl.append(c)<br><br><span class="hljs-built_in">print</span>(nl)<br><span class="hljs-built_in">print</span>(cl)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">nl = [48900330639594979739701067783234903348599405413588466525574910520196852415104874636276388006189258357683981763, 52184798260918956005878710130354843122927544013692595240956998112200987084814453592388074200951779840156511, 57591305346419909943538345276263585821186563609432856462492112562586368230163591993342956384688555395772999, 1391052858660682537388264601016075339528373211889618359237336378385137832855656756800539626220549334300176727, 8401669052993451281764489325068020625937224410830694438332016050030698435746929661939302694116817188225591, 66809775375777747860816961274643428927028556487820183599747024350362932190079439298182707730302976119988715497, 41209230281867957743385705727577318625405890894626062454495908709761427062490881938652489884059847194603237277, 31140089821370202352241944402736292072447365626312703496944186462246895695650729682254970622208848300946861]</span><br><span class="hljs-string">cl = [26617913696414745819584063604277199673357890677059949687794606743781436349829925794253672010780125661705587071, 6332739614121961923948917957498597962902897015582697635859365080803944882904908423983706426654363433337197, 46154051334276357655176765655327305918368830821288083739892570534253190653909520953027859629573215723954424, 2800905135165447908315158053695706832127646195243072751493365013371469263897970241141686022109978485359114, 3597083928897756955519089479028751799504001377334447013725903377254761160933418420625119547713455139382114, 17032086144873551648611964054579542303630306316746409528107026138674853298939194425805809444921339677455174485, 36111201824253386572496248461433786832561483450731317363761227351689971628309683994429845284904292821369745345, 28548175317543234723297895187238113463350377151401226415566179373530461612253257137535830491771909906093171]</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><h2 id="rsa3p6">[RSA3]P6</h2><h3 id="main-5">main</h3><h3 id="exp-5">exp</h3><h2 id="rsa3p7">[RSA3]P7</h2><h3 id="main-6">main</h3><h3 id="exp-6">exp</h3><h2 id="rsa3p8">[RSA3]P8</h2><h3 id="main-7">main</h3><h3 id="exp-7">exp</h3><h2 id="rsa3p9">[RSA3]P9</h2><h3 id="main-8">main</h3><h3 id="exp-8">exp</h3><h2 id="rsa3p10">[RSA3]P10</h2><h3 id="main-9">main</h3><h3 id="exp-9">exp</h3><h2 id="rsa3p11">[RSA3]P11</h2><h3 id="main-10">main</h3><h3 id="exp-10">exp</h3><h2 id="rsa3p12">[RSA3]P12</h2><h3 id="main-11">main</h3><h3 id="exp-11">exp</h3>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 排序</title>
    <link href="/2023/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/11/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>下面这个网站动态的演示了各种排序算法，可以更加直观的了解一下</p><p><ahref="https://visualgo.net/zh/sorting?slide=1">排序（冒泡排序，选择排序，插入排序，归并排序，快速排序，计数排序，基数排序）- VisuAlgo</a></p></blockquote><h2 id="十个经典排序算法">十个经典排序算法</h2><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312010909399.png"alt="排序算法总结" /><figcaption aria-hidden="true">排序算法总结</figcaption></figure><h3 id="名词解释">名词解释：</h3><p><strong>n</strong>：数据规模</p><p><strong>k</strong>：“桶”的个数</p><p><strong>In-place</strong>：占用常数内存，不占用额外内存</p><p><strong>Out-place</strong>：占用额外内存</p><p><strong>排序算法稳定性</strong>：</p><p>假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的。</p><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><ul><li><strong>时间复杂度：</strong> 一个算法执行所耗费的时间。</li><li><strong>空间复杂度</strong>：运行完一个程序所需内存的大小（辅助空间）。</li></ul><p><strong>关于稳定性</strong>：</p><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</p><p>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p><h2 id="选择排序分类">选择排序分类</h2><ul><li><p>简单选择排序</p></li><li><p>树型选择排序</p></li><li><p>堆排序</p></li></ul><h2 id="简单选择排序">简单选择排序</h2><h3 id="算法思想">算法思想</h3><p>对于具有 n 个记录的无序表遍历 n-1 次，第 i 次从无序表中第 i个记录开始，找出后序关键字中最小的记录，然后放置在第 i 的位置上。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280906775.gif"alt="简单选择排序动图演示" /><figcaption aria-hidden="true">简单选择排序动图演示</figcaption></figure><h3 id="算法代码">算法代码</h3><h2 id="堆排序">堆排序</h2><h3 id="堆の概念">堆の概念</h3><p>首先要了解一下堆的含义：在含有 n个元素的序列中，如果序列中的元素满足下面其中一种关系时，此序列可以称之为堆。</p><ul><li><span class="math inline">\(k_i ≤ k_{2i}\)</span>且 <spanclass="math inline">\(k_i ≤ k_{2i+1}\)</span>（在 n 个记录的范围内，第<span class="math inline">\(i\)</span> 个关键字的值小于第 <spanclass="math inline">\(2i\)</span> 个关键字，同时也小于第 <spanclass="math inline">\(2i+1\)</span> 个关键字）</li><li><span class="math inline">\(k_i ≥ k_{2i}\)</span>且 <spanclass="math inline">\(k_i ≥ k_{2i+1}\)</span>（在 n 个记录的范围内，第<span class="math inline">\(i\)</span> 个关键字的值大于第 <spanclass="math inline">\(2i\)</span> 个关键字，同时也大于第 <spanclass="math inline">\(2i+1\)</span> 个关键字）</li></ul><p>对于堆的定义也可以使用完全二叉树来解释，因为在完全二叉树中第 i个结点的左孩子恰好是第 2i 个结点，右孩子恰好是 2i+1 个结点</p><p>如果该序列可以被称为堆，则使用该序列构建的完全二叉树中，每个根结点的值都必须不小于（或者不大于）左右孩子结点的值。</p><p>如果满足每个结点的值都<strong>大于</strong>其左孩子和右孩子结点的值，则是<strong>大根堆（大顶堆）</strong>；</p><p>如果满足每个结点的值都<strong>小于</strong>其左孩子和右孩子结点的值，则是<strong>小根堆（小顶堆）</strong>。</p><p>总结就是：</p><p>堆是一种特殊的树，只要满足下面两个条件，它就是一个堆：</p><p>（1）堆是一颗完全二叉树；</p><p>（2）堆中某个节点的值总是不大于（或不小于）其父节点的值。</p><h3 id="算法思想-1">算法思想</h3><p>通过将无序表转化为堆，可以直接找到表中最大值或者最小值，然后将其提取出来，令剩余的记录再重建一个堆，取出次大值或者次小值，如此反复执行就可以得到一个有序序列，此过程为<strong>堆排序</strong>。</p><p>以利用<strong>大根堆</strong>排序为例：</p><p>（1）首先将待排序列<spanclass="math inline">\(a[1…n]\)</span>调整为大根堆（此过程为建初堆），交换<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[n]\)</span>，则<spanclass="math inline">\(a[n]\)</span>为关键字最大的记录</p><p>（2）将<spanclass="math inline">\(a[1…n-1]\)</span>重新调整为大根堆，交换<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[n-1]\)</span>，则<spanclass="math inline">\(a[n-1]\)</span>为关键字次大的记录</p><p>（3）循环<span class="math inline">\(n-1\)</span>次，直到交换了<spanclass="math inline">\(a[1]\)</span>和<spanclass="math inline">\(a[2]\)</span>，得到一个非递减的有序序列<spanclass="math inline">\(a[1…n]\)</span></p><p>堆排序过程的代码实现需要解决两个问题：</p><ol type="1"><li>如何将得到的无序序列转化为一个堆？</li><li>在输出堆顶元素之后（完全二叉树的树根结点），如何调整剩余元素构建一个新的堆？</li></ol><p><strong>大根堆建堆</strong></p><p>①从最后一个分支结点开始，与其孩子结点的值比较。如果不符合特性，则交换；如果是大根堆，选择孩子结点中的较大值</p><p>② 交换之后如果孩子结点也是分支结点，继续向下比较；</p><p>③ 反复利用上述过程构造下一级的堆，直至根结点。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311281001541.gif"alt="大根堆建堆过程演示" /><figcaption aria-hidden="true">大根堆建堆过程演示</figcaption></figure><p><strong>如何调整剩余元素构建一个新的堆</strong></p><p>①输出堆顶元素后，将最后一个元素与之交换，此时堆的结构特性被破坏，需要向下筛选；</p><p>② 从上向下逐级比较，使每一级都符合特性。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311281007400.gif"alt="堆排序过程演示" /><figcaption aria-hidden="true">堆排序过程演示</figcaption></figure><h3 id="算法分析">算法分析</h3><p><strong>空间负责度</strong>：使用常数个辅助单元，空间复杂度为<spanclass="math inline">\(O(1)\)</span></p><p><strong>时间复杂度</strong>：建堆时间为<spanclass="math inline">\(O(n)\)</span>，之后有n-1次向下调整，调整操作的时间复杂度为<spanclass="math inline">\(O(h)\)</span>也就是<spanclass="math inline">\(O(log_2n)\)</span>，所以堆排序的时间复杂度为<spanclass="math inline">\(O(n*log_2n)\)</span>。</p><p><strong>稳定性</strong>：不稳定</p><p><strong>适用性</strong>：适用于线性表为顺序存储的情况，不能用于链式结构</p><p><strong>优点</strong>：初始建堆所需比较次数较多，因此对小文件效果不明显，但对大文件有效</p><p>堆排序在最坏情况下时间复杂度为<spanclass="math inline">\(O(n*log_2n)\)</span>，对于快速排序最坏情况下的<spanclass="math inline">\(O(n^2)\)</span>言是一个优点，当记录较多时较为高效</p><h3 id="算法代码-1">算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100 <span class="hljs-comment">// 定义堆的最大长度</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> key; <span class="hljs-comment">// 关键字</span><br>&#125; ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    ElemType r[MAXSIZE]; <span class="hljs-comment">// 用于存储堆元素的数组</span><br>    <span class="hljs-type">int</span> length; <span class="hljs-comment">// 当前堆的长度</span><br>&#125; SqList;<br><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;H)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(SqList &amp;H)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    SqList H;<br>    H.length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 初始化堆元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入堆的长度：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;H.length);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入堆元素的关键字：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= H.length; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;H.r[i].key);<br>    &#125;<br><br>    <span class="hljs-comment">// 执行堆排序</span><br>    <span class="hljs-built_in">HeapSort</span>(H);<br><br>    <span class="hljs-comment">// 打印排序后的堆元素</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;堆排序后的结果：\n&quot;</span>);<br>    <span class="hljs-built_in">printArray</span>(H);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 函数：对以s为根的子树进行堆调整，m为子树的长度</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList &amp;H, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    ElemType rc = H.r[s]; <span class="hljs-comment">// 当前堆顶记录</span><br>    <span class="hljs-type">int</span> j;<br><br>    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; H.r[j].key &lt; H.r[j + <span class="hljs-number">1</span>].key) &#123;<br>            ++j; <span class="hljs-comment">// j为key较大的儿子记录下标</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!(rc.key &lt; H.r[j].key)) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        H.r[s] = H.r[j];<br>        s = j;<br>    &#125;<br>    H.r[s] = rc; <span class="hljs-comment">// 原堆顶记录交换到s位置</span><br>&#125;<br><br><span class="hljs-comment">// 函数：堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(SqList &amp;H)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    ElemType temp;<br><br>    <span class="hljs-comment">// 将H.r[1..H.length]建成大顶堆</span><br>    <span class="hljs-keyword">for</span> (i = H.length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(H, i, H.length);<br>    &#125;<br><br>    <span class="hljs-comment">// 将堆顶记录和当前子序列最后一个记录交换，然后重新调整为大顶堆</span><br>    <span class="hljs-keyword">for</span> (i = H.length; i &gt; <span class="hljs-number">1</span>; --i) &#123;<br>        temp = H.r[<span class="hljs-number">1</span>];<br>        H.r[<span class="hljs-number">1</span>] = H.r[i];<br>        H.r[i] = temp;<br>        <span class="hljs-built_in">HeapAdjust</span>(H, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数：打印数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(SqList &amp;H)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= H.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, H.r[i].key);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="基数排序">基数排序</h2><h3 id="算法思想-2">算法思想</h3><p>基数排序是一种很特别的排序，它<strong>不基于比较和移动</strong>，而是<strong>基于各个位上关键字的大小进行排序</strong>。</p><p>假设长度为n的线性表由d元组<span class="math inline">\((k_{d-1},k_{d-2}, …, k_1, k_0)\)</span>组成，其中<spanclass="math inline">\(k_{d-1}\)</span>为最主位关键字，<spanclass="math inline">\(k_0\)</span>为最次位关键字。</p><p>关键字排序有两种方法：</p><p>①最高位优先法(MSD)：按关键字权重递减依次逐层划分成子序列，然后依次连接成有序序列。</p><p>②最低位优先法(LSD)：按关键字权重递增依次逐层划分成子序列，然后依次连接成有序序列。</p><blockquote><p>MSD( Most Significant Digit ) LSD ( Least Significant Digit )</p></blockquote><p><em>由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</em></p><p><strong>LSD 基数排序动图演示</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312010907103.gif"alt="LSD 基数排序动图演示" /><figcaption aria-hidden="true">LSD 基数排序动图演示</figcaption></figure><h3 id="算法分析-1">算法分析</h3><h3 id="代码实现">代码实现</h3><blockquote><p>参考：</p><p><ahref="https://github.com/hustcc/JS-Sorting-Algorithm/tree/master">hustcc/JS-Sorting-Algorithm:一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。(github.com)</a></p><p><ahref="https://developer.aliyun.com/article/1295236">数据结构各内部排序算法总结对比及动图演示（插入排序、冒泡和快速排序、选择排序、堆排序、归并排序和基数排序等）2-阿里云开发者社区(aliyun.com)</a></p><p><ahref="https://blog.csdn.net/qq_44807176/article/details/118661354">【数据结构】内部排序-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 6 面向对象编程（基础）</title>
    <link href="/2023/11/25/Java%206%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <url>/2023/11/25/Java%206%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面向对象是一种开发软件的方法，使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。包括三个方面：面向对象分析、面向对象设计、面向对象程序设计。</p><p>Java语言是纯面向对象的语言。其所有数据类型都有相应的类，程序可以完全基于对象编写。</p></blockquote><h2 id="类与对象oop">6.1 类与对象（OOP）</h2><blockquote><p>类 就是数据类型。可以是 <code>int</code> 也可以是<code>人类</code></p><p>对象 就是其中具体的实例。可以是 <code>100</code> 也可以是<code>顶真</code></p><p>从类到对象，可以称为 创建一个对象，也可以说 实例化一个对象，或者把对象实例化</p><ol type="1"><li>类是抽象的、概念的，代表一类事物</li><li>对象是具体的、实际的，代表一个个具体事物，即是实例</li><li>类是对象的模板，对象是类的一个个体，对应一个实例</li></ol></blockquote><h3 id="类与对象引出">6.1.1 类与对象引出</h3><p><strong>6.1.1 看一个养猫猫问题</strong></p><p>张老太养了两只猫猫：一只名字叫小白，今年 3岁，白色。还有一只叫小花，今年 100岁，花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示张老太没有这只猫猫。</p><p><strong>6.1.2 使用现有技术解决 Object01.java</strong></p><ol type="1"><li>单独的定义变量解决</li><li>使用数组解决</li></ol><p><strong>6.1.3 现有技术解决的缺点分析</strong></p><p>不利于数据的管理</p><p>效率低 ===&gt; 引出我们的新知识点 类与对象</p><p>java 设计者 引入 类与对象(OOP)，根本原因就是现有的技术，不能完美的解决新的新的需求.</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251759724.png"alt="image-20231125175919546" /><figcaption aria-hidden="true">image-20231125175919546</figcaption></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">//使用 OOP 面向对象解决上述问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <br>        <span class="hljs-comment">//实例化一只猫[创建一只猫对象]</span><br>        <span class="hljs-comment">//1. new Cat() 创建一只猫(猫对象)</span><br>        <span class="hljs-comment">//2. Cat cat1 = new Cat(); 把创建的猫赋给 cat1</span><br>        <span class="hljs-comment">//3. cat1 就是一个对象</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat1.name = <span class="hljs-string">&quot;小白&quot;</span>;<br>        cat1.age = <span class="hljs-number">3</span>;<br>        cat1.color = <span class="hljs-string">&quot;白色&quot;</span>;<br>        cat1.weight = <span class="hljs-number">10</span>;<br>        <span class="hljs-comment">//创建了第二只猫，并赋给 cat2</span><br>        <span class="hljs-comment">//cat2 也是一个对象(猫对象)</span><br>        <span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br>        cat2.name = <span class="hljs-string">&quot;小花&quot;</span>;<br>        cat2.age = <span class="hljs-number">100</span>;<br>        cat2.color = <span class="hljs-string">&quot;花色&quot;</span>;<br>        cat2.weight = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//怎么访问对象的属性呢</span><br>        System.out.println(<span class="hljs-string">&quot;第 1 只猫信息: &quot;</span> + cat1.name<br>                + <span class="hljs-string">&quot; &quot;</span> + cat1.age + <span class="hljs-string">&quot; &quot;</span> + cat1.color + <span class="hljs-string">&quot; &quot;</span> + cat1.weight);<br>        System.out.println(<span class="hljs-string">&quot;第 2 只猫信息: &quot;</span> + cat2.name<br>                + <span class="hljs-string">&quot; &quot;</span> + cat2.age + <span class="hljs-string">&quot; &quot;</span> + cat2.color + <span class="hljs-string">&quot; &quot;</span> + cat2.weight);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//定义一个猫类 Cat -&gt; 自定义的数据类型</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-comment">//属性/成员变量</span><br>    String name; <span class="hljs-comment">//名字</span><br>    <span class="hljs-type">int</span> age; <span class="hljs-comment">//年龄</span><br>    String color; <span class="hljs-comment">//颜色</span><br>    <span class="hljs-type">double</span> weight; <span class="hljs-comment">//体重</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="对象内存布局">6.1.2 对象内存布局</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251814354.png"alt="image-20231125181407271" /><figcaption aria-hidden="true">image-20231125181407271</figcaption></figure><h3 id="属性成员变量">6.1.3 属性/成员变量</h3><blockquote><p>从概念或叫法上看：成员变量 = 属性 = field（字段）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>&#123;<br>String name;<br><span class="hljs-type">int</span> age;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>String name;</code> 就是一个成员变量（属性）。</p><p>属性是类的一个组成部分，一般是基本数据类型，也可以是引用数据类型（对象，数组）。</p><ol type="1"><li><p>属性的定义语法同变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">访问修饰符 属性类型 属性名<br></code></pre></td></tr></table></figure><p>访问修饰符：控制属性的访问范围。有四种：<code>public</code>，<code>protected</code>， <code>默认(空)</code>，<code>private</code></p></li><li><p>属性的定义类型可以为任意类型，包含基本类型或引用类型</p></li><li><p>属性如果不赋值，有默认值。规则同数组</p></li></ol><h3 id="创建对象">6.1.4 创建对象</h3><ul><li><p>先声明再创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">Cat cat1;      <span class="hljs-comment">//声明对象cat1</span><br>cat1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<span class="hljs-comment">//创建对象，new会开空间</span><br></code></pre></td></tr></table></figure></li><li><p>直接创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">Cat</span> <span class="hljs-variable">cat2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();<br></code></pre></td></tr></table></figure></li></ul><p>注意事项：</p><ol type="1"><li><p>声明对象时，只是在内存中建立了一个引用。此时，该地址引用不指向任何内存空间（NULL）。对象的引用，也被称为对象的句柄。</p></li><li><p>使用 new运算符创建对象实例时，会为对象分配空间。之后，会将该段内存的首地址赋给刚才建立的引用。</p></li></ol><h3 id="访问对象">6.1.5 访问对象</h3><p>基本语法：<code>对象名.属性名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">System.out.println(cat1.name);<br></code></pre></td></tr></table></figure><h3 id="类与对象的内存分配机制">6.1.6 类与对象的内存分配机制</h3><blockquote><p>Java内存的结构分析</p><p>栈：一般存放基本数据类型（局部变量）</p><p>堆：存放对象（如<code>Cat cat1 = new Cat()</code>，是在这里开辟的空间）</p><p>方法区：常量池（常量，比如字符串），类加载信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p.name = “jack”;<br>p.age = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>先加载 Person 类信息(属性和方法信息，只会加载一次)</p></li><li><p>在堆中分配空间，进行默认初始化(看规则)</p></li><li><p>把地址赋给 p , p 就指向对象</p></li><li><p>进行指定初始化， 比如 <code>p.name =”jack”</code>，<code>p.age = 10</code></p></li></ol><h2 id="成员方法">6.2 成员方法</h2><p>在某些情况下，我们要需要定义成员方法(简称方法)。比如人类：除了有一些属性外(年龄，姓名……)，我们人类还有一些行为，比如：可以说话、跑步..，通过学习，还可以做算术题。这时就要用<strong>成员方法</strong>才能完成。现在要求对Person 类完善。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初步认识的例子</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//方法使用</span><br>        <span class="hljs-comment">//1. 方法写好后，如果不去调用(使用)，不会输出</span><br>        <span class="hljs-comment">//2. 先创建对象 ,然后调用方法即可</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p1.speak(); <span class="hljs-comment">//调用方法</span><br>        p1.cal01(); <span class="hljs-comment">//调用 cal01 方法</span><br>        p1.cal02(<span class="hljs-number">5</span>); <span class="hljs-comment">//调用 cal02 方法，同时给 n = 5</span><br>        p1.cal02(<span class="hljs-number">10</span>); <span class="hljs-comment">//调用 cal02 方法，同时给 n = 10</span><br>        <span class="hljs-comment">//调用 getSum 方法，同时 num1=10, num2=20</span><br>        <span class="hljs-comment">//把 方法 getSum 返回的值，赋给 变量 returnRes</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">returnRes</span> <span class="hljs-operator">=</span> p1.getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(<span class="hljs-string">&quot;getSum 方法返回的值=&quot;</span> + returnRes);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//方法(成员方法)</span><br>    <span class="hljs-comment">//添加 speak 成员方法,输出 “我是一个好人”</span><br>    <span class="hljs-comment">//1. public 表示方法是公开</span><br>    <span class="hljs-comment">//2. void ： 表示方法没有返回值</span><br>    <span class="hljs-comment">//3. speak() : speak 是方法名， () 形参列表，目前是空</span><br>    <span class="hljs-comment">//4. &#123;&#125; 方法体，可以写我们要执行的代码</span><br>    <span class="hljs-comment">//5. System.out.println(&quot;我是一个好人&quot;); 表示我们的方法就是输出一句话</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">speak</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我是一个好人&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 cal01 成员方法,可以计算从 1+..+1000 的结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cal01</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>            res += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;cal01 方法 计算结果=&quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 cal02 成员方法,该方法可以接收一个数 n，计算从 1+..+n 的结果</span><br>    <span class="hljs-comment">//1. (int n) 形参列表， 表示当前有一个形参 n, 可以接收用户输入</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cal02</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            res += i;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;cal02 方法 计算结果=&quot;</span> + res);<br>    &#125;<br><br>    <span class="hljs-comment">//添加 getSum 成员方法,可以计算两个数的和</span><br>    <span class="hljs-comment">//1. public 表示方法是公开的</span><br>    <span class="hljs-comment">//2. int :表示方法执行后，返回一个 int 值</span><br>    <span class="hljs-comment">//3. getSum 方法名</span><br>    <span class="hljs-comment">//4. (int num1, int num2) 形参列表，2 个形参，可以接收用户传入的两个数</span><br>    <span class="hljs-comment">//5. return res; 表示把 res 的值， 返回</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num1 + num2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="成员方法的定义">6.2.1 成员方法的定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">修饰符 返回数据类型 方法名(形参列表)&#123;<br>方法体语句;<br><span class="hljs-keyword">return</span> 返回值;<span class="hljs-comment">//返回数据类型是 void 的场合，return语句不是必须的</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>方法名必须是一个合法的标识符</p></li><li><p>返回类型即返回值的类型。如果方法没有返回值，应声明为void</p></li><li><p>修饰符段可以有几个不同的修饰符。（还没学到</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">strictfp</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;~~~~~&quot;</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中 public（访问修饰符）、static（static 关键字）、final（final关键字）</p></li><li><p>参数列表是传递给方法的参数表。各个元素间以 <code>,</code>分隔。每个元素由一个类型和一个标识符表示的参数组成。</p></li></ol><blockquote><ol type="1"><li>方法写好后，不去调用就不会输出</li><li>先创建对象，然后调用方法即可</li><li>使用成员方法，能提高代码的复用性。而且能把实现的细节封装起来，供其他用户调用。</li></ol></blockquote><h3 id="方法调用机制">6.2.2 方法调用机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA">...<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num1, <span class="hljs-type">int</span> num2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> num1 + num2;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><ol type="1"><li>当程序执行到方法时，在 栈 中开辟一个新的栈空间。该空间里储存<code>num1 = 10</code> <code>num2 = 20</code>，之后计算并储存结果<code>res = 30</code></li><li>当方法执行完毕，或执行到 <code>return</code> 语句时，就会返回</li><li>把 新栈空间 中的 <code>res = 30</code> 返回到调用方法的地方</li><li>返回后，继续执行该方法的后续代码</li><li>当main方法（栈）执行完毕，整个程序退出</li></ol><h3 id="方法使用细节">6.2.3 方法使用细节</h3><ol type="1"><li><p>访问修饰符：作用是控制方法的使用范围。</p><ul><li>不写（默认访问控制范围）</li><li>public：公共</li><li>protected：受保护</li><li>private：私有</li></ul></li><li><p>返回数据类型：</p><ul><li>一个方法最多有一个返回值。要返回多个结果可以使用数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AA</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        <span class="hljs-type">int</span>[] res = a.getSumAndSub(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>        System.out.println(<span class="hljs-string">&quot;和=&quot;</span> + res[<span class="hljs-number">0</span>]);<br>        System.out.println(<span class="hljs-string">&quot;差=&quot;</span> + res[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//返回多个结果可以使用数组</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getSumAndSub(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2) &#123;<br>        <span class="hljs-type">int</span>[] resArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>        resArr[<span class="hljs-number">0</span>] = n1 + n2;<br>        resArr[<span class="hljs-number">1</span>] = n1 - n2;<br>        <span class="hljs-keyword">return</span> resArr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>返回类型为任意类型。包括 基本数据类型和引用数据类型。</li><li>如果方法要求有返回数据类型，则方法体中最后的执行语句必为<code>return 值</code>，且返回值类型必须和 return的值类型一致或兼容。</li><li>如果方法是 void，则方法体中可以没有 return 语句，或者 只写 return。</li></ul></li><li><p>方法名：</p><ul><li>遵循驼峰命名法，最好见名知意，表达出该功能的意思。</li></ul></li><li><p>参数列表（形参列表）：</p><ul><li>一个方法可以有 0 个参数，也可以有多个参数。参数间用 <code>,</code>间隔。</li><li>参数类型可以为任意类型，包含基本类型和引用类型。</li><li>调用带参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数。</li><li>方法定义时的参数称为形式参数，简称形参；方法调用时的参数（传入的参数）称为实际参数，简称实参。实参与形参的类型、个数、顺序必须一致。</li></ul></li><li><p>方法体：</p><ul><li>里面写完成功能的具体的语句，可以为输入、输出、变量、运算、分支、循环、方法调用，但里面不能再定义方法，即：方法不能嵌套定义！</li></ul></li><li><p>调用细节：</p><ul><li><p>同一个类中的方法调用，可以直接调用。</p></li><li><p>跨类的方法调用，需要创建新对象，然后再调用方法。</p></li><li><p>特别说明一下：跨类的方法调用和方法的访问修饰符相关，先暂时这么提一下，后面我们讲到访问修饰符时，还要再细说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        a.sayOk();<br>        a.m1();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//同一个类中的方法调用：直接调用即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;print()方法被调用 n=&quot;</span> + n);<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayOk</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">//sayOk 调用 print(直接调用即可)</span><br>        print(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;继续执行 sayOK()~~~&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//跨类中的方法 A 类调用 B 类方法：需要通过对象名调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//创建 B 对象, 然后再调用方法即可</span><br>        System.out.println(<span class="hljs-string">&quot;m1() 方法被调用&quot;</span>);<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        b.hi();<br>        System.out.println(<span class="hljs-string">&quot;m1() 继续执行:)&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;B 类中的 hi()被执行&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131739434.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><p>#### 两个小练习</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1.编写类 A ，有一个方法：判断一个数是奇数 odd 还是偶数, 返回 boolean</span><br><span class="hljs-comment">//2.根据行、列、字符打印 对应行数和列数的字符，比如：行：4，列：4，字符#,则打印相应的效果</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;输入一个数字&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>        <span class="hljs-keyword">if</span>(a.isOdd(num))&#123;<br>            System.out.println(<span class="hljs-string">&quot;是奇数&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;不是奇数&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        bb.print(<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-string">&#x27;+&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOdd</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>&#123;<br>        <span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(<span class="hljs-type">int</span> row,<span class="hljs-type">int</span> col,<span class="hljs-type">char</span> c)</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; row; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; col ; j++)&#123;<br>                System.out.print(c);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131741777.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><h3 id="方法传参机制">6.2.4 方法传参机制</h3><blockquote><p>Java 语言对对象采用的是<strong>值传递</strong>，方法得到的总是那个传入对象的副本。</p></blockquote><h4 id="基本数据类型的传参机制">基本数据类型的传参机制</h4><p>方法不能修改基本数据类型的参数。基本数据类型传递的是一个值（值拷贝），形参的任何改变不影响实参！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodParameter01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-comment">//创建 AA 对象 名字 obj</span><br>        <span class="hljs-type">AA</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AA</span>();<br>        obj.swap(a, b); <span class="hljs-comment">//调用 swap</span><br>        System.out.println(<span class="hljs-string">&quot;main 方法 a=&quot;</span> + a + <span class="hljs-string">&quot; b=&quot;</span> + b);<span class="hljs-comment">//a=10 b=20</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AA</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;\na 和 b 交换前的值\na=&quot;</span> + a + <span class="hljs-string">&quot;\tb=&quot;</span> + b);<span class="hljs-comment">//a=10 b=20</span><br>        <span class="hljs-comment">//完成了 a 和 b 的交换</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> a;<br>        a = b;<br>        b = tmp;<br>        System.out.println(<span class="hljs-string">&quot;\na 和 b 交换后的值\na=&quot;</span> + a + <span class="hljs-string">&quot;\tb=&quot;</span> + b);<span class="hljs-comment">//a=20 b=10</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131742667.png"alt="上述程序执行结果" /><figcaption aria-hidden="true">上述程序执行结果</figcaption></figure><h4 id="引用数据类型的传参机制">引用数据类型的传参机制</h4><p>引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参！</p><p>引用类型传递的是一个地址，形参和实参指向一处，两者总会相关。</p><p>但改变那个形参地址指向的场合，实参的指向不会改变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.name = <span class="hljs-string">&quot;jack&quot;</span>;<br>        p.age = <span class="hljs-number">10</span>;<br>        b.test200(p);<br>        <span class="hljs-comment">//测试题, 如果 test200 执行的是 p = null ,下面的结果是 10</span><br>        <span class="hljs-comment">//测试题, 如果 test200 执行的是 p = new Person();..., 下面输出的是 10</span><br>        System.out.println(<span class="hljs-string">&quot;main的p.age = &quot;</span> + p.age + <span class="hljs-string">&quot;\t&quot;</span> + p.name);<span class="hljs-comment">//10000</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test200</span><span class="hljs-params">(Person p)</span> &#123;<br>        p.age = <span class="hljs-number">10000</span>; <span class="hljs-comment">//修改对象属性</span><br>        <span class="hljs-comment">//思考</span><br><span class="hljs-comment">//        p = new Person();</span><br><span class="hljs-comment">//        p.name = &quot;tom&quot;;</span><br><span class="hljs-comment">//        p.age = 99;</span><br>        <span class="hljs-comment">//思考</span><br><span class="hljs-comment">//        p = null;</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="一个lj练习">一个lj练习</h4><p>编写一个方法 copyPerson，可以复制一个 Person对象，返回复制的对象。克隆对象，注意要求得到新对象和原来的对象是两个独立的对象，只是他们的属性相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p.name = <span class="hljs-string">&quot;milan&quot;</span>;<br>        p.age = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//创建 tools</span><br>        <span class="hljs-type">MyTools</span> <span class="hljs-variable">tools</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTools</span>();<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> tools.copyPerson(p);<br><span class="hljs-comment">//到此 p 和 p2 是 Person 对象，但是是两个独立的对象，属性相同</span><br>        System.out.println(<span class="hljs-string">&quot;p 的属性 age=&quot;</span> + p.age + <span class="hljs-string">&quot; 名字=&quot;</span> + p.name);<br>        System.out.println(<span class="hljs-string">&quot;p2 的属性 age=&quot;</span> + p2.age + <span class="hljs-string">&quot; 名字=&quot;</span> + p2.name);<br><span class="hljs-comment">//比较看看是否为同一个对象</span><br>        System.out.println(p == p2);<span class="hljs-comment">//false</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTools</span> &#123;<br>    <span class="hljs-comment">//编写方法的思路</span><br>    <span class="hljs-comment">//1. 方法的返回类型 Person</span><br>    <span class="hljs-comment">//2. 方法的名字 copyPerson</span><br>    <span class="hljs-comment">//3. 方法的形参 (Person p)</span><br>    <span class="hljs-comment">//4. 方法体, 创建一个新对象，并复制属性，返回即可</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">copyPerson</span><span class="hljs-params">(Person p)</span> &#123;<br><span class="hljs-comment">//创建一个新的对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>        p2.name = p.name; <span class="hljs-comment">//把原来对象的名字赋给 p2.name</span><br>        p2.age = p.age; <span class="hljs-comment">//把原来对象的年龄赋给 p2.age</span><br>        <span class="hljs-keyword">return</span> p2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131813303.png"alt="上面程序执行的结果" /><figcaption aria-hidden="true">上面程序执行的结果</figcaption></figure><h2 id="方法递归调用">6.3 方法递归调用</h2><blockquote><p><strong>递归就是方法自己调用自己</strong>，每次调用时传入不同的变量。递归有助于编程者解决复杂问题，同时可以让代码变得简洁</p></blockquote><ol type="1"><li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)</li><li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等</li><li>将用栈解决的问题<code>--&gt;</code>递归代码比较简洁</li></ol><h3 id="几个引例">6.3.1 几个引例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1. 打印问题</span><br><span class="hljs-comment">//2. 阶乘问题</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        t1.test(<span class="hljs-number">4</span>);<span class="hljs-comment">//输出什么？ n=2 n=3 n=4，加个else只输出 n=2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> t1.factorial(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;5 的阶乘 res =&quot;</span> + res);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) &#123;<br>            test(n - <span class="hljs-number">1</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;n=&quot;</span> + n);<br>    &#125;<br><br>    <span class="hljs-comment">//factorial 阶乘</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">factorial</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> factorial(n - <span class="hljs-number">1</span>) * n;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312131815568.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><p>下面，示范一个斐波那契数列方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> (fib(n - <span class="hljs-number">1</span>)) + (fib(n - <span class="hljs-number">2</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节">6.3.2 使用细节</h3><ol type="1"><li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）。</li><li>方法的局部变量是独立的，不会相互影响。</li><li>如果方法中使用的是引用类型变量（比如数组，对象），就会共享数据。</li><li>递归必须向退出递归的条件逼近，否则就是无限递归，会提示<code>StackOverflowError</code> “死龟”</li><li>当一个方法执行完毕，或遇到 <code>return</code>就会返回。遵守谁调用，就将结果返回给谁。同时当方法执行完毕或返回时，该方法也就执行完毕。</li></ol><h3 id="递归斐波那契">6.3.3 递归斐波那契</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;<span class="hljs-comment">//这里选择输出第几个斐波那契数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> t1.fibonacci(n);<br>        <span class="hljs-keyword">if</span>(res &gt;= -<span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;当n = &quot;</span> + n + <span class="hljs-string">&quot; 对应的斐波那契数为：&quot;</span> + res);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    请使用递归的方式求出斐波那契数 1,1,2,3,5,8,13...给你一个整数 n，求出它的斐波那契数</span><br><span class="hljs-comment">    1. 当 n = 1 斐波那契数 是 1</span><br><span class="hljs-comment">    2. 当 n = 2 斐波那契数 是 1</span><br><span class="hljs-comment">    3. 当 n &gt;= 3 斐波那契数 是前两个数的和</span><br><span class="hljs-comment">    4. 这里就是一个递归的思路</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>( n &gt;= <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span>( n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> fibonacci(n-<span class="hljs-number">1</span>) + fibonacci(n-<span class="hljs-number">2</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;要求输入的 n&gt;=1 的整数&quot;</span>);<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="猴子吃桃">*6.3.4 猴子吃桃</h3><h3 id="老鼠出迷宫">*6.3.5 老鼠出迷宫</h3><p>### 6.3.6 汉诺塔问题</p><p>汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Tower</span> <span class="hljs-variable">tower</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tower</span>();<br>        tower.move(<span class="hljs-number">5</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tower</span> &#123;<br>    <span class="hljs-comment">//方法</span><br>    <span class="hljs-comment">//num 表示要移动的个数, a, b, c 分别表示 A 塔，B 塔, C 塔</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">int</span> num , <span class="hljs-type">char</span> a, <span class="hljs-type">char</span> b ,<span class="hljs-type">char</span> c)</span> &#123;<br>    <span class="hljs-comment">//如果只有一个盘 num = 1</span><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-number">1</span>) &#123;<br>            System.out.println(a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果有多个盘，可以看成两个 , 最下面的和上面的所有盘(num-1)</span><br>            <span class="hljs-comment">//(1)先移动上面所有的盘到 b, 借助 c</span><br>            move(num - <span class="hljs-number">1</span> , a, c, b);<br><br>            <span class="hljs-comment">//(2)把最下面的这个盘，移动到 c</span><br>            System.out.println(a + <span class="hljs-string">&quot;-&gt;&quot;</span> + c);<br>            <span class="hljs-comment">//(3)再把 b 塔的所有盘，移动到 c ,借助 a</span><br>            move(num - <span class="hljs-number">1</span>, b, a, c);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>不得不承认递归的妙处，真的是有点太妙了</p></blockquote><h3 id="八皇后">*6.3.7 八皇后</h3><h2 id="方法重载">6.4 方法重载</h2><blockquote><p>方法重载（Overload）：Java 中允许同一类中，多个同名方法的存在，但要求形参列表 不一致。</p><p>比如：System.out.println()，out 是 PrintStream 类型</p><p>重载的好处：减轻了起名和记名的麻烦。</p></blockquote><p>一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyCalculator</span> <span class="hljs-variable">mc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCalculator</span>();<br>        System.out.println(mc.calculate(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));<br>        System.out.println(mc.calculate(<span class="hljs-number">1.1</span>, <span class="hljs-number">2</span>));<br>        System.out.println(mc.calculate(<span class="hljs-number">1</span>, <span class="hljs-number">2.1</span>));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalculator</span> &#123;<br>    <span class="hljs-comment">//下面的四个 calculate 方法构成了重载</span><br>    <span class="hljs-comment">//两个整数的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;calculate(int n1, int n2) 被调用&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//没有构成方法重载, 仍然是错误的，因为是方法的重复定义</span><br>    <span class="hljs-comment">// public double calculate(int n1, int n2) &#123;</span><br>    <span class="hljs-comment">// System.out.println(&quot;calculate(int n1, int n2) 被调用&quot;);</span><br>    <span class="hljs-comment">// return n1 + n2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">//看看下面是否构成重载, 没有构成，而是方法的重复定义</span><br>    <span class="hljs-comment">// public int calculate(int a1, int a2) &#123;</span><br>    <span class="hljs-comment">// System.out.println(&quot;calculate(int n1, int n2) 被调用&quot;);</span><br>    <span class="hljs-comment">// return a1 + a2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <br>    <span class="hljs-comment">//一个整数，一个 double 的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">double</span> n2)</span> &#123;<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//一个 double ,一个 Int 和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">double</span> n1, <span class="hljs-type">int</span> n2)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;calculate(double n1, int n2) 被调用..&quot;</span>);<br>        <span class="hljs-keyword">return</span> n1 + n2;<br>    &#125;<br>    <span class="hljs-comment">//三个 int 的和</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calculate</span><span class="hljs-params">(<span class="hljs-type">int</span> n1, <span class="hljs-type">int</span> n2,<span class="hljs-type">int</span> n3)</span> &#123;<br><br>        <span class="hljs-keyword">return</span> n1 + n2 + n2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节-1">6.4.1 使用细节</h3><ol type="1"><li>方法名：必须相同</li><li>形参列表：必须不同（形参的类型、个数、顺序，这其中至少一个不同，参数名无要求）</li><li>返回值：无要求</li></ol><h2 id="可变参数">6.5 可变参数</h2><blockquote><p>Java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。</p></blockquote><p>语法：<code>访问修饰符 返回类型 方法名（数据类型... 形参名）&#123;代码块;&#125;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HspMethod</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HspMethod</span>();<br>        System.out.println(m.sum(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)); <span class="hljs-comment">//106</span><br>        System.out.println(m.sum(<span class="hljs-number">1</span>,<span class="hljs-number">19</span>)); <span class="hljs-comment">//20</span><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HspMethod</span> &#123;<br>    <span class="hljs-comment">//可以计算 2 个数的和，3 个数的和 ， 4. 5， 。。</span><br>    <span class="hljs-comment">//可以使用方法重载</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2) &#123;//2 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2, int n3) &#123;//3 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2 + n3;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">// public int sum(int n1, int n2, int n3, int n4) &#123;//4 个数的和</span><br>    <span class="hljs-comment">// return n1 + n2 + n3 + n4;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-comment">//.....</span><br>    <span class="hljs-comment">//上面的三个方法名称相同，功能相同, 参数个数不同-&gt; 使用可变参数优化</span><br><br>    <span class="hljs-comment">//1. int... 表示接受的是可变参数，类型是 int ,即可以接收多个 int(0-多)</span><br>    <span class="hljs-comment">//2. 使用可变参数时，可以当做数组来使用 即 nums 可以当做数组</span><br>    <span class="hljs-comment">//3. 遍历 nums 求和即可</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;接收的参数个数=&quot;</span> + nums.length);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            res += nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312141658183.png"alt="程序执行结果" /><figcaption aria-hidden="true">程序执行结果</figcaption></figure><h3 id="使用细节-2">6.5.1 使用细节</h3><ol type="1"><li><p>可变参数 的实参可以是 0 个，也可以是 任意多 个。</p></li><li><p>可变参数 的实参可以是数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//细节: 可变参数的实参可以为数组</span><br>       <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>();<br>        t1.f1(arr);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f1</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + nums.length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变参数本质就是数组</p><p>因此，出现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>... n)</span>&#123;<span class="hljs-comment">//这个方法与下面的方法不能构成重载</span><br>&#125;<br></code></pre></td></tr></table></figure><p>的场合，不能有方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">int</span>[] n)</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可变参数 和 普通参数 可以一起放在形参列表，但必须保证 可变参数在最后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">(<span class="hljs-type">double</span> dou, <span class="hljs-type">int</span>... n)</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>一个形参列表最多出现 一个 可变参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面的写法是错的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f3</span><span class="hljs-params">(<span class="hljs-type">int</span>... nums1, <span class="hljs-type">double</span>... nums2)</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="一个练习">6.5.2 一个练习</h3><p>有三个方法，分别实现返回姓名和两门课成绩(总分)，返回姓名和三门课成绩(总分)，返回姓名和五门课成绩(总分)。封装成一个可变参数的方法，类名 HspMethod，方法名 showScore</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">HspMethod</span> <span class="hljs-variable">hm</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HspMethod</span>();<br>        System.out.println(hm.showScore(<span class="hljs-string">&quot;milan&quot;</span> , <span class="hljs-number">90.1</span>, <span class="hljs-number">80.0</span> ));<br>        System.out.println(hm.showScore(<span class="hljs-string">&quot;terry&quot;</span> , <span class="hljs-number">90.1</span>, <span class="hljs-number">80.0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">30.5</span>,<span class="hljs-number">70</span> ));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HspMethod</span> &#123;<br>    <span class="hljs-comment">//分析 1. 方法名 showScore 2. 形参(String ,double... ) 3. 返回 String</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">showScore</span><span class="hljs-params">(String name ,<span class="hljs-type">double</span>... scores )</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">totalScore</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++) &#123;<br>            totalScore += scores[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; 有 &quot;</span> +scores.length + <span class="hljs-string">&quot; 门课的成绩总分为 = &quot;</span> + totalScore;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="作用域">6.6 作用域</h2><ol type="1"><li>在 Java 编程中，主要的变量就是属性（成员变量）和 局部变量。</li><li>我们说的 局部变量 一般是指在成员方法中定义的变量。</li><li>作用域的分类<ul><li>全局变量：也就是属性，作用域为整个类体</li><li>局部变量：除了属性外的其他变量。作用域为定义它的代码块中</li></ul></li><li>全局变量（属性）可以不赋值直接使用，因为有默认值。局部变量必须赋值使用</li></ol><h3 id="使用细节-3">6.6.1 使用细节</h3><ol type="1"><li><p>属性 和 局部变量 可以重名，访问时遵循就近原则</p></li><li><p>在同一作用域中，两个局部变量不能重名</p></li><li><p>属性的生命周期较长。其伴随对象的创建而创建，伴随对象的销毁而销毁。</p><p>局部变量生命周期较短。其伴随代码块的执行而创建，伴随代码块的结束而销毁。</p></li><li><p>作用域不同：</p><ul><li>全局变量/属性 可以被本类使用，也可以被其他类（通过对象）使用。</li><li>局部变量 只能被本类的对应方法中调用</li></ul></li><li><p>全局变量/属性 <strong>可以加</strong> 修饰符（publicprivate....）</p><p>局部变量 <strong>不能加</strong> 修饰符</p></li></ol><h2 id="构造方法构造器">6.7 构造方法、构造器</h2><blockquote><p>构造方法又叫构造器（constructor），是类的一种特殊的方法。它的主要作用是完成对新对象的初始化。它有几个特点：</p><ol type="1"><li>方法名和类名相同</li><li>没有返回值</li><li>在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。</li></ol></blockquote><p>语法：<code>[修饰符] 方法名(形参列表)&#123; 方法体; &#125;</code></p><ol type="1"><li>构造器的修饰符可以默认， 也可以是 public protected private</li><li>构造器没有返回值</li><li>方法名和类名字必须一样</li><li>参数列表 和 成员方法一样的规则</li><li>构造器的调用，由系统完成</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//当我们 new 一个对象时，直接通过构造器指定名字和年龄</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;smith&quot;</span>, <span class="hljs-number">80</span>);<br>        System.out.println(<span class="hljs-string">&quot;p1 的信息如下&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;p1 对象 name = &quot;</span> + p1.name);<span class="hljs-comment">//smith</span><br>        System.out.println(<span class="hljs-string">&quot;p1 对象 age = &quot;</span> + p1.age);<span class="hljs-comment">//80</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//在创建人类的对象时，就直接指定这个对象的年龄和姓名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">//构造器</span><br><br>    <span class="hljs-comment">//1. 构造器没有返回值, 也不能写 void</span><br>    <span class="hljs-comment">//2. 构造器的名称和类 Person 一样</span><br>    <span class="hljs-comment">//3. (String pName, int pAge) 是构造器形参列表，规则和成员方法一样</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName, <span class="hljs-type">int</span> pAge)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造器被调用~~ 完成对象的属性初始化&quot;</span>);<br>        name = pName;<br>        age = pAge;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312141726586.png"alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure><h3 id="使用细节-4">6.7.1 使用细节</h3><ol type="1"><li><p>构造器本质也是方法。所以，可以构造器重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    String name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName, <span class="hljs-type">int</span> pAge)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;构造器被调用~~ 完成对象的属性初始化&quot;</span>);<br>        name = pName;<br>        age = pAge;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String pName)</span> &#123;<br>        name = pName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造器名 和 类名 相同</p></li><li><p>构造器无返回值</p></li><li><p>构造器是完成对象的初始化，而不是创建</p></li><li><p>创建对象时，系统自动调用该类的构造方法，像上面的，不能<code>p1.Person()</code></p></li><li><p>如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器（也叫默认构造器）</p></li><li><p>一旦定义了自己的构造器，就不能用无参构造器了。除非显式的定义一个无参构造器</p></li></ol><h3 id="流程分析">6.7.2 流程分析</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Person p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Amy&quot;</span>, <span class="hljs-number">10</span>);<br><br>...<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>&#123;<br><span class="hljs-type">String</span> name;<br><span class="hljs-type">int</span> age = <span class="hljs-number">20</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-type">String</span> pName, <span class="hljs-type">int</span> pAge)</span></span>&#123;<br>name = pName;<br>age = pAge;<br>&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><ol type="1"><li><p>加载 类信息（方法区）</p></li><li><p>在 堆 中开辟空间（地址）</p></li><li><p>完成对象初始化</p><ul><li><p>首先默认初始化。<code>age = 0; name = null</code></p></li><li><p>之后显式初始化。<code>age = 20; name = null</code></p><p>其中，显式初始化和代码块初始化按编写的先后顺序依次进行。</p></li><li><p>之后构造器的初始化。<code>age = 10; name = "Amy"</code></p></li></ul></li><li><p>把对象在 堆 中的 地址，返回给 <code>p1</code></p></li></ol><h2 id="this-关键字">6.8 <code>this</code> 关键字</h2><blockquote><p>JVM 会给每个对象分配 this 代表当前对象。</p><p>相当于在 堆 中，this 指向自己（对象）</p><p>在类定义的方法中，Java 会自动用 this关键字把所有变量和方法引用结合在一起。</p><p>遇到有同名的局部变量的场合，需要程序员加入 this关键字进行区分。不加入 this 关键字的场合，Java 遵循就近原则。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Example</span>&#123;<br>    <span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> act(<span class="hljs-built_in">int</span> n) &#123;&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><p>上面这个类的 <code>act()</code> 方法实际有 2 个参数。对其调用：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Example e <span class="hljs-operator">=</span> new Exmaple()<span class="hljs-comment">;</span><br>e.act(<span class="hljs-number">100</span>)<span class="hljs-comment">;JAVA</span><br></code></pre></td></tr></table></figure><p>可见，出现在方法名前的参数<code>e</code>，以及出现在方法名后的括号中的参数 <code>100</code></p><p>出现在方法名前的参数被称为 <strong>隐式参数</strong>（也称为方法调用的 目标 或 接收者）</p><p>出现在方法名后的参数被称为<strong>显式参数</strong>，就是所谓的实参</p><p>在每一个方法中，用 this 指代隐式参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">act</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.n = n;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><p>此时，再以相同方式调用方法：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">e</span>.act(<span class="hljs-number">100</span>);// &lt;———— 相当于 e.n = <span class="hljs-number">100</span>;<br><span class="hljs-attribute">JAVA</span><br></code></pre></td></tr></table></figure><h3 id="使用方法">6.8.1 使用方法</h3><ol type="1"><li><p><code>this</code>关键字可以用来访问本类的属性、方法、构造器</p></li><li><p><code>this</code> 用于区分当前类的 属性 和 局部变量</p></li><li><p>访问本类中成员方法的语法：<code>this.方法名</code></p></li><li><p>访问构造器的语法：<code>this(参数列表);</code></p><p>注意：只能在构造器中访问另一个构造器。而且，如果有这个语法，必须放置在第一条语句。</p></li><li><p><code>this</code> 不能在类定义的 外部 使用，只能在类定义的 方法中使用</p></li></ol><h2 id="附录">附录</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 5 数组、排序和查找</title>
    <link href="/2023/11/24/Java%205%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/24/Java%205%20%E6%95%B0%E7%BB%84%E3%80%81%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>数组：可以存放多个同一类型的数据。数组也是一种数据，是引用类型。</p><p>即：数组就是一组数据。</p></blockquote><h2 id="一维数组">5.1 一维数组</h2><h3 id="数组基础">5.1.1 数组基础</h3><blockquote><p>数组可以是多个相同类型数据的组合，实现对这些数据的统一管理。</p><p>数组中的元素可以是任何数据类型。包括基本类型和引用类型，但是不能混用</p><p>数组的下标的从0开始的</p><p>数组创建后，如果没有赋值，有默认值：int（0），short（0），byte（0），long（0L），float（0.0F），double（0.0），char（000），boolean（false），String（null），Object（null）</p><p>使用数组的步骤：</p><ol type="1"><li>声明数组并开辟空间</li><li>给数组各个元素赋值</li><li>使用数组</li></ol><p>数组属于引用类型，数组型数据是对象（object）</p></blockquote><p><strong>数组的构造方法：</strong></p><ul><li><p>构造方式1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">// 创建了数组 name，存放5个int</span><br><span class="hljs-type">int</span> a2[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<span class="hljs-comment">// 这种写法也行</span><br>a[<span class="hljs-number">2</span>] = <span class="hljs-number">15</span>;<span class="hljs-comment">// 访问数组第3个数</span><br></code></pre></td></tr></table></figure></li><li><p>构造方式2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">double</span>[] scores;<span class="hljs-comment">// 先声明数组 name，此时数组是 null</span><br><span class="hljs-type">double</span> scores[];<br>scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span>];<span class="hljs-comment">// 分配内存空间，可以存放数据了</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入一组数据</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">double</span> scores[];<br>        scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">5</span>];<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素的值&quot;</span>);<br>            scores[i] = myScanner.nextDouble();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===数组的元素的清空如下：===&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; scores.length; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i+<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素的值= &quot;</span> + scores[i]);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>构造方式3：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">50</span>,<span class="hljs-number">60</span>,<span class="hljs-number">77</span>&#125;<br></code></pre></td></tr></table></figure><p>确切知道数组每个元素的场合可以用这个方法。</p></li></ul><p><strong>数组的使用方法：</strong></p><ul><li><p>访问数组元素：数组名[元素下标]</p><p>其中，元素下标从 0 开始编号。如：访问 strs 数组的第一个元素<code>strs[0]</code></p></li><li><p>数组长度：<code>数组名.length</code></p><p>是一个 int 值。不能通过试图改变该值来改变数组容量</p></li></ul><h3 id="数组赋值机制">5.1.2 数组赋值机制</h3><ol type="1"><li><p>基本数据类型赋值，赋值方式是值拷贝。这个值就是具体的数据，且互不影响</p></li><li><p>数组在默认情况下是引用传递，赋的值是地址，赋值方式为引用传达。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span>[] array2 = array1;<br>array2[<span class="hljs-number">0</span>] = <span class="hljs-number">100</span>; <span class="hljs-comment">//array2的变化会影响到array1</span><br></code></pre></td></tr></table></figure><p>上述情况下，<code>array1[0]</code> 也会变成<code>100</code>。因为数组在 JVM 的 <strong>栈</strong>里是一个地址，指向 <strong>堆</strong>里的一个空间。这两个数组在上述情况下指向同一空间。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311251126139.png"alt="image-20231125112653956" /><figcaption aria-hidden="true">image-20231125112653956</figcaption></figure></li></ol><h3 id="数组拷贝">5.1.3 数组拷贝</h3><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[] array1 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>&#125;;<br><span class="hljs-type">int</span>[] array2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[array1.length];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; array1.length;i++) &#123;<br>    array2[i] = array1[i];<br>&#125;<br><span class="hljs-comment">//但是按照上述方式拷贝后，两数组相互独立。</span><br></code></pre></td></tr></table></figure></p><h3 id="数组反转">5.1.4 数组反转</h3><p>方式 1：通过找规律反转，（临时变量）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayReverse</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br><br>        <span class="hljs-comment">//规律</span><br>        <span class="hljs-comment">//1. 把 arr[0] 和 arr[5] 进行交换 &#123;66,22,33,44,55,11&#125;</span><br>        <span class="hljs-comment">//2. 把 arr[1] 和 arr[4] 进行交换 &#123;66,55,33,44,22,11&#125;</span><br>        <span class="hljs-comment">//3. 把 arr[2] 和 arr[3] 进行交换 &#123;66,55,44,33,22,11&#125;</span><br>        <span class="hljs-comment">//4. 一共要交换 3 次 = arr.length / 2</span><br>        <span class="hljs-comment">//5. 每次交换时，对应的下标 是 arr[i] 和 arr[arr.length - 1 -i]</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> arr.length; <span class="hljs-comment">//计算数组的长度</span><br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len / <span class="hljs-number">2</span>; i++) &#123;<br>            temp = arr[len - <span class="hljs-number">1</span> - i];<span class="hljs-comment">//保存</span><br>            arr[len - <span class="hljs-number">1</span> - i] = arr[i];<br>            arr[i] = temp;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;===翻转后数组===&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<span class="hljs-comment">//66,55,44,33,22,11</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方式 2：使用逆序赋值方式，（创建一个新数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">66</span>&#125;;<br>        <span class="hljs-comment">//使用逆序赋值方式</span><br>        <span class="hljs-comment">//1. 先创建一个新的数组 arr2 ,大小 arr.length</span><br>        <span class="hljs-comment">//2. 逆序遍历 arr ,将 每个元素拷贝到 arr2 的元素中(顺序拷贝)</span><br>        <span class="hljs-comment">//3. 建议增加一个循环变量 j -&gt; 0 -&gt; 5</span><br>        <span class="hljs-type">int</span>[] arr2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length];<br><span class="hljs-comment">//逆序遍历 arr</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> arr.length - <span class="hljs-number">1</span>, j = <span class="hljs-number">0</span>; i &gt;= <span class="hljs-number">0</span>; i--, j++) &#123;<br>            arr2[j] = arr[i];<br>        &#125;<br>        <span class="hljs-comment">//4. 当 for 循环结束，arr2 就是一个逆序的数组 &#123;66, 55, 44,33, 22, 11&#125;</span><br>        <span class="hljs-comment">//5. 让 arr 指向 arr2 数据空间, 此时 arr 原来的数据空间就没有变量引用</span><br>        <span class="hljs-comment">// 会被当做垃圾，销毁</span><br>        arr = arr2;<br>        System.out.println(<span class="hljs-string">&quot;====arr 的元素情况=====&quot;</span>);<br><span class="hljs-comment">//6. 输出 arr 看看</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br><br>            System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的扩容">5.1.5 数组的扩容</h3><p>当数组达到上限时，创建一个容量更大的新数组。将旧数组的元素依次放入，之后替换旧数组。</p><p>以下是一个扩容方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        要求：实现动态的给数组添加元素效果，实现对数组扩容。ArrayAdd.java</span><br><span class="hljs-comment">        1.原始数组使用静态分配 int[] arr = &#123;1,2,3&#125;</span><br><span class="hljs-comment">        2.增加的元素 4，直接放在数组的最后 arr = &#123;1,2,3,4&#125;</span><br><span class="hljs-comment">        3.用户可以通过如下方法来决定是否继续添加，添加成功，是否继续？y/n</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 定义初始数组 int[] arr = &#123;1,2,3&#125;//下标 0-2</span><br><span class="hljs-comment">        2. 定义一个新的数组 int[] arrNew = new int[arr.length+1];</span><br><span class="hljs-comment">        3. 遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组</span><br><span class="hljs-comment">        4. 将 4 赋给 arrNew[arrNew.length - 1] = 4;把 4 赋给 arrNew 最后一个元素</span><br><span class="hljs-comment">        5. 让 arr 指向 arrNew ; arr = arrNew; 那么 原来 arr 数组就被销毁</span><br><span class="hljs-comment">        6. 创建一个 Scanner 可以接受用户输入</span><br><span class="hljs-comment">        7. 因为用户什么时候退出，不确定，老师使用 do-while + break 来控制</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-comment">//初始化数组</span><br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">int</span>[] arrNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length + <span class="hljs-number">1</span>];<br><br>            <span class="hljs-comment">//遍历 arr 数组，依次将 arr 的元素拷贝到 arrNew 数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                arrNew[i] = arr[i];<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;请输入你要添加的元素：&quot;</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">addNum</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>    <br>            arrNew[arrNew.length - <span class="hljs-number">1</span>] = addNum;<br>            <span class="hljs-comment">//让 arr 指向 arrNew,</span><br>            arr = arrNew;<br>            System.out.println(<span class="hljs-string">&quot;====arr 扩容后元素情况====&quot;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>                System.out.print(arr[i] + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//问用户是否继续</span><br>            System.out.println(<span class="hljs-string">&quot;是否继续添加 y/n&quot;</span>);<br>            <span class="hljs-type">char</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">if</span>( key == <span class="hljs-string">&#x27;n&#x27;</span>) &#123; <span class="hljs-comment">//如果输入 n ,就结束</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;你退出了添加...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="排序算法">5.2 排序算法</h2><blockquote><p>排序也叫排序算法。是将一组数据，依指定的顺序进行排列的过程</p></blockquote><p>排序分为两类：</p><ul><li><p>内部排序：将所有要处理的数据加载到内部存储器中进行排序</p><p>内部排序主要有以下几种：</p><ul><li>插入排序：直接插入排序、希儿排序</li><li>选择排序：简单选择排序、堆排序</li><li>交换排序：冒泡排序、快速排序</li><li>归并排序</li><li>基数排序</li></ul></li><li><p>外部排序：数据量庞大，无法全部加载到内存中，需要借助外部存储进行排序</p><p>如：合并排序法、直接合并排序法</p></li></ul><h3 id="排序算法的时间复杂度">5.2.1 排序算法的时间复杂度</h3><table><thead><tr class="header"><th>排序法</th><th>平均时间</th><th>最差情形</th><th>稳定性</th><th>额外空间</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>冒泡排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="even"><td>交换排序</td><td>O(n2)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="odd"><td>选择排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="even"><td>插入排序</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>稳定</td><td>O(1)</td><td>大部分已排序时较好</td></tr><tr class="odd"><td>基数排序</td><td>O(n × k)</td><td>O(n × k)</td><td>稳定</td><td>O(n)</td><td>k 是 “桶” 的个数</td></tr><tr class="even"><td>Shell 排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2^2n\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr><tr class="odd"><td>快速排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(n^2\)</span>)</td><td>不稳定</td><td>O(n㏒n)</td><td>n 大时较好</td></tr><tr class="even"><td>归并排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>稳定</td><td>O(1)</td><td>n 小时较好</td></tr><tr class="odd"><td>堆排序</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>O(<span class="math inline">\(nlog_2n\)</span>)</td><td>不稳定</td><td>O(1)</td><td>n 大时较好</td></tr></tbody></table><p><strong>稳定性：</strong>排序后，那些原本相等元素的相对顺序不改变</p><h3 id="冒泡排序">5.2.2 冒泡排序</h3><p><strong>冒泡排序：</strong>通过对待排序序列从左向右遍历，依次比较相邻元素的值。若发现<strong>前面的值比后面的值大则交换</strong>。</p><p>如此，各元素不断接近自己的位置。值较大的元素逐渐向后移动，就像水下的气泡一样逐渐上浮。</p><p>特别地：如果在某次排序中没有发生过任何交换，则此时是已完成排序，可提前结束排序过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">52</span>,<span class="hljs-number">16</span>,<span class="hljs-number">32</span>,<span class="hljs-number">88</span>,<span class="hljs-number">64</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length - <span class="hljs-number">1</span>; i++) &#123;<span class="hljs-comment">//外层循环是 4 次</span><br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length - <span class="hljs-number">1</span> - i; j++) &#123;<span class="hljs-comment">//4 次比较-3 次-2 次-1 次</span><br>                <span class="hljs-comment">//如果前面的数&gt;后面的数，就交换</span><br>                <span class="hljs-keyword">if</span>(arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    temp = arr[j];<br>                    arr[j] = arr[j+<span class="hljs-number">1</span>];<br>                    arr[j+<span class="hljs-number">1</span>] = temp;<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;\n==第&quot;</span>+(i+<span class="hljs-number">1</span>)+<span class="hljs-string">&quot;轮==&quot;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr.length; j++) &#123;<br>                System.out.print(arr[j] + <span class="hljs-string">&quot;\t&quot;</span>);<br><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="选择排序">*5.2.3 选择排序……</h3><h2 id="查找算法">5.3 查找算法</h2><p>在 Java 中，常用的查找有 4 种：</p><ul><li>顺序查找（遍历）</li><li>二分查找</li><li>插值查找</li><li>斐波那契查找</li></ul><h3 id="线性查找">5.3.1 线性查找</h3><p>逐一比对，直到发现目标值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">seqSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (array[i] == target) <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏：</span><br><span class="hljs-comment">        从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】</span><br><span class="hljs-comment">        要求: 如果找到了，就提示找到，并给出下标值</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 定义一个字符串数组</span><br><span class="hljs-comment">        2. 接收用户输入, 遍历数组，逐一比较，如果有，则提示信息，并退出</span><br><span class="hljs-comment">        */</span><br>        <br>        <span class="hljs-comment">//定义一个字符串数组</span><br>        String[] names = &#123;<span class="hljs-string">&quot;白眉鹰王&quot;</span>, <span class="hljs-string">&quot;金毛狮王&quot;</span>, <span class="hljs-string">&quot;紫衫龙王&quot;</span>, <span class="hljs-string">&quot;青翼蝠王&quot;</span>&#125;;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入名字&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">findName</span> <span class="hljs-operator">=</span> myScanner.next();<br>        <span class="hljs-comment">//遍历数组，逐一比较，如果有，则提示信息，并退出</span><br>        <span class="hljs-comment">//这里老师给大家一个编程思想/技巧, 一个经典的方法</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;<br>        <span class="hljs-comment">//比较 字符串比较 equals, 如果要找到名字就是当前元素</span><br>            <span class="hljs-keyword">if</span>(findName.equals(names[i])) &#123;<br>                System.out.println(<span class="hljs-string">&quot;恭喜你找到 &quot;</span> + findName);<br>                System.out.println(<span class="hljs-string">&quot;下标为= &quot;</span> + i);<br>        <span class="hljs-comment">//把 i 保存到 index</span><br>                index = i;<br>                <span class="hljs-keyword">break</span>;<span class="hljs-comment">//退出</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//没有找到</span><br>            System.out.println(<span class="hljs-string">&quot;sorry ,没有找到 &quot;</span> + findName);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分查找">*5.3.2 二分查找</h3><p>二分查找要求数组必须是有序数组。</p><p>递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">return</span> binarySearch(array, target, <span class="hljs-number">0</span>, array.length);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> &#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (l + r) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) &#123;<br>        <span class="hljs-keyword">return</span> binarySearch(array, target, p + <span class="hljs-number">1</span>, r);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> binarySearch(array, target, l, p - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归方式二分查找：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-keyword">while</span> (r &gt; l) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (r + l) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = p - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -l - <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="插值查找">*5.3.3 插值查找</h3><p>插值查找类似于二分查找，但其不是取出中位数，而是从自适应的位置取出一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertSearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] array, <span class="hljs-type">int</span> target)</span> &#123;<br>    <span class="hljs-keyword">if</span> (target &gt; array[array.length - <span class="hljs-number">1</span>]) <span class="hljs-keyword">return</span> -array.length;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; array[<span class="hljs-number">0</span>]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (r &gt;= l) &#123;<br>        p = l + (target - array[l]) * (r - <span class="hljs-number">1</span> - l) / (array[r - <span class="hljs-number">1</span>] - array[l]);<br>        <span class="hljs-keyword">if</span> (target == array[p]) <span class="hljs-keyword">return</span> p;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; array[p]) l = p + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> r = p - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -p;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="斐波那契查找">*5.3.4 斐波那契查找</h3><p>斐波那契查找原理与前两种类似，仅仅改变了中间节点的位置。其中间节点不是中位或插值，而是位于黄金分割点附近。</p><h2 id="二维数组">5.4 二维数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        请用二维数组输出如下图形</span><br><span class="hljs-comment">        0 0 0 0 0 0</span><br><span class="hljs-comment">        0 0 1 0 0 0</span><br><span class="hljs-comment">        0 2 0 3 0 0</span><br><span class="hljs-comment">        0 0 0 0 0 0</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-comment">//什么是二维数组：</span><br>        <span class="hljs-comment">//1. 从定义形式上看 int[][]</span><br>        <span class="hljs-comment">//2. 可以这样理解，原来的一维数组的每个元素是一维数组, 就构成二维数组</span><br>        <span class="hljs-type">int</span>[][] arr = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125; &#125;;<br>        <span class="hljs-comment">//关于二维数组的关键概念</span><br>        <span class="hljs-comment">//(1)</span><br>        System.out.println(<span class="hljs-string">&quot;二维数组的元素个数=&quot;</span> + arr.length);<br>        <span class="hljs-comment">//(2) 二维数组的每个元素是一维数组, 所以如果需要得到每个一维数组的值还需要再次遍历</span><br>        <span class="hljs-comment">//(3) 如果我们要访问第 (i+1)个一维数组的第 j+1 个值 arr[i][j];</span><br>        <span class="hljs-comment">// 举例 访问 3, =》 他是第 3 个一维数组的第 4 个值 arr[2][3]</span><br>        System.out.println(<span class="hljs-string">&quot;第 3 个一维数组的第 4 个值=&quot;</span> + arr[<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]); <br><span class="hljs-comment">//3. 输出二维图形</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-comment">//遍历二维数组的每个元素</span><br>        <span class="hljs-comment">//1. arr[i] 表示 二维数组的第 i+1 个元素 比如 arr[0]：二维数组的第一个元素</span><br>        <span class="hljs-comment">//2. arr[i].length 得到 对应的 每个一维数组的长度</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>                System.out.print(arr[i][j] + <span class="hljs-string">&quot; &quot;</span>); <span class="hljs-comment">//输出了一维数组</span><br>            &#125;<br>            System.out.println();<span class="hljs-comment">//换行</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] ints;<span class="hljs-comment">// 声明一个二维数组</span><br><span class="hljs-type">int</span>[] ints2[];<span class="hljs-comment">// 也能这样声明</span><br><span class="hljs-type">int</span> ints3[][];<span class="hljs-comment">// 这样也行</span><br><span class="hljs-type">int</span>[] x,y[];<span class="hljs-comment">// 声明了两个数组，一个是 int[] x 一个是 int[][] y</span><br><span class="hljs-comment">// 把 int[] 视作一个类型，就能很好地理解这个写法</span><br></code></pre></td></tr></table></figure><p>二维数组实际是由多个一维数组组成的，它的各个元素的长度可以相同，也可以不同。</p><p>数组是一个对象，所以二维数组的元素存放的是一维数组的地址。</p><h3 id="二维数组构造方法">二维数组构造方法</h3><ul><li><p>构造方法1：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<span class="hljs-comment">// 创建 有3个 包含4个元素的一维数组 的二维数组</span><br><span class="hljs-type">int</span> a[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure></li><li><p>构造方法2：动态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">double</span>[][] many_doubles;<span class="hljs-comment">// 先声明变量</span><br>many_doubles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[<span class="hljs-number">3</span>][<span class="hljs-number">4</span>];<span class="hljs-comment">// 再开辟空间</span><br></code></pre></td></tr></table></figure></li><li><p>构造方法3：动态初始化-列数不确定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>][];<span class="hljs-comment">//创建 二维数组，一个有 3 个一维数组，但是每个一维数组还没有开数据空间</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<span class="hljs-comment">//遍历 arr 每个一维数组</span><br>    <span class="hljs-comment">//给每个一维数组开空间 new</span><br>    <span class="hljs-comment">//如果没有给一维数组 new ,那么 arr[i]就是 null</span><br>arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[i + <span class="hljs-number">1</span>];<br><span class="hljs-comment">//遍历一维数组，并给一维数组的每个元素赋值</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>arr[i][j] = i + <span class="hljs-number">1</span>;<span class="hljs-comment">//赋值</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>构造方法4：静态初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">int</span>[][] m = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">95</span>&#125;&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="二维数组使用方法">二维数组使用方法</h3><ul><li><code>arr.length</code>：该二维数组的长度</li><li><code>arr[0]</code>：该二维数组的第一个子数组</li><li><code>arr[0].length</code>：该二维数组的第一个子数组的长度</li><li><code>arr[1][0]</code>：该二维数组第二个子数组的第一个元素的值</li></ul><h2 id="一些题目">5.5 一些题目</h2><p>1.已知有个升序的数组，要求插入个元素，该数组顺序依然是升序,比如:[10，12，45，90]，添加23 后, 数组为 [10，12，23，45，90]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">45</span>, <span class="hljs-number">90</span>&#125;;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">insertNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">23</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">//先定位到应该插入的位置</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(insertNum &lt; arr[i])&#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index == -<span class="hljs-number">1</span>)&#123;<br>            index = arr.length;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;应该插入的位置,arr[i]中的i为：&quot;</span> + index);<br><br><span class="hljs-comment">//然后扩容数组</span><br>        <span class="hljs-type">int</span>[] arrNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[arr.length + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i &lt; arrNew.length; i++)&#123;   <span class="hljs-comment">//这里的j很巧妙</span><br>            <span class="hljs-keyword">if</span>(index != i)&#123;<br>                arrNew[i] = arr[j];<br>                j++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                arrNew[index] = insertNum;<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;下面即为定位+扩容后的数组：&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrNew.length; i++)&#123;<br>            System.out.print(arrNew[i] + <span class="hljs-string">&quot;\t&quot;</span> );<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信原理与安全技术概述</title>
    <link href="/2023/11/17/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/11/17/%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大三上选的一门选修课——《通信原理与安全》的部分笔记</p></blockquote><h2 id="第一章-绪论">第一章 绪论</h2><h3 id="通信的基本概念">1.1 通信的基本概念</h3><p>通信（Communication）——沟通信息。</p><p>通信系统——发送器、信道、接收器。</p><p>信源（发信者）：把各种消息转换成原始电信号。该信号含有丰富的低频成分甚至直流分量，因此又称基带信号。</p><p>信道：信号传输的通道。</p><p>信宿（收信者）：将复原的原始电信号转换成相应的消息。</p><p>噪声源：噪声源不是人为加入的设备，而是通信系统中各种设备以及信道中所固有的，并且是人们所不希望的。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171411669.png"alt="image-20231117141146493" /><figcaption aria-hidden="true">image-20231117141146493</figcaption></figure><p><strong>知识</strong>是一种具有普遍和概括性质的高层次信息</p><p><strong>消息</strong>是信息的载体，而不是信息本身</p><p>消息变换成适合信道传输的物理量（电磁波、光），就是<strong>信号</strong>。</p><blockquote><p>1949年，香农在Bell System TechnicalJournal上发表了著名论文《通信的数学原理》（ A mathematical theory ofcommunication ）以及《噪声下的通信》（ Communication in the presence ofnoise），对信息作出定义，并阐明了通信的基本问题，给出了通信系统的模型，提出了信息量的数学表达式，并探讨了信道容量，信源编码，信道编码等一系列基本问题，是通信的奠基性著作。</p></blockquote><p><strong>香农对信息的定义</strong></p><p>香农给出定义：信息是对事物运动状态或存在方式的不确定性的描述</p><p>首先，香农注意到消息的信息量与消息本身的不确定性有关。例如，抛一枚硬币，如果正面出现的概率是99%，那么当我们得知抛掷的结果是反面时得到的信息量会比得知是正面时得到的信息量大。</p><p>其次，他发现<strong>通信的目的就是要消除不确定性</strong>。具体地讲，信息传递过程是一个从不知到知的过程（理想信道）或者是一个从知之甚少到知之甚多的过程（有噪信道）</p><h3 id="几个数学概念">1.2 几个数学概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171416779.png"alt="image-20231117141604674" /><figcaption aria-hidden="true">image-20231117141604674</figcaption></figure><p><strong>单个消息信息量的数学定义</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171417003.png"alt="image-20231117141746926" /><figcaption aria-hidden="true">image-20231117141746926</figcaption></figure><p>信息量的单位：</p><ul><li>a = 2，则为比特（bit），<strong>最常用</strong></li><li>a = e，则为奈特（nat）</li></ul><p>信息源信息量的数学定义：熵</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171429188.png"alt="image-20231117142925095" /><figcaption aria-hidden="true">image-20231117142925095</figcaption></figure><h3 id="现代通信的发展">1.3 现代通信的发展</h3><p>按照通信方式：</p><ul><li>原始通信：烽火、驿站、邮政</li><li>有线通信：计算机网络，有线电话，光纤通信</li><li>无线通信 (本课程的重点)：蜂窝网（移动通信）、WIFI、蓝牙等</li></ul><p>按照信号类型：</p><ul><li>模拟通信：系统传输模拟信号</li><li>数字通信：系统传输数字信号</li></ul><p>#### 无线通信的发展史</p><p>移动通信（蜂窝网）</p><ul><li>第一代（1G）：模拟通信（大哥大）</li><li>第二代（2G）：GSM（FDMA频分多址），数字通信的开始</li><li>第三代（3G）：CDMA2000（电信），WCDMA（联通），TD-SCDMA（移动，我国自主研发）</li><li>第四代（4G）：LTE （TD-LTE，FD-LTE），OFDM+MIMO</li><li>第五代（5G）：NR (NewRadio)，三大场景：增强的移动宽带，海量接入，超可靠低时延（eMBB, mMTC,URLLC）</li><li>第六代（6G）：正在理论探讨阶段</li></ul><p>局域网：WLAN (WiFi)</p><p>蓝牙、ZigBee</p><h4 id="无线通信系统的基本构成">无线通信系统的基本构成</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171445127.png"alt="image-20231117144535016" /><figcaption aria-hidden="true">image-20231117144535016</figcaption></figure><h4 id="无线通信系统的性能指标">无线通信系统的性能指标</h4><ul><li><p>有效性---速度指标</p></li><li><p>可靠性---质量指标，与有效性相矛盾</p></li><li><p>安全性</p></li></ul><h4 id="无线通信安全简史">无线通信安全简史</h4><p>移动通信方面</p><p>第一代：几乎没有安全措施，用户（手机）把自己的序列号发送至网络（例如基站），网络查一下有这个序列号就允许其连接，一旦手机序列号被克隆，别人就可以使用相应的网络服务</p><p>第二代（GSM）：</p><p>特点：</p><ul><li><p>采用基于私钥密码体制的安全机制</p></li><li><p>通过鉴权（认证）来防止非法用户使用网络</p></li><li><p>通过加密技术防止无线信道的窃听</p></li></ul><p>缺点：</p><ul><li>所使用的身份认证和加密算法存在许多安全隐患</li><li>安全密钥太短可能被短时间破译</li><li>SIM卡可能被克隆</li><li>没有考虑数据完整性保护，难以发现数据被篡改</li></ul><p>3G, 4G, 5G：</p><p>特点：</p><ul><li><p>重新设计安全算法</p></li><li><p>增加密钥长度</p></li><li><p>提供双向认证（用户与网络）</p></li><li><p>保证数据的完整性</p></li><li><p>安全体系趋于稳定</p></li></ul><p>挑战：超级计算机，密钥分发和管理</p><p>WLAN：非商用，不盈利，所以研究人员只关注速率、时延等性能，安全性考虑较少，目前常用的是RC4和AES算法</p><h4 id="无线通信网面临的主要安全威胁">无线通信网面临的主要安全威胁</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171500921.png"alt="image-20231117150033846" /><figcaption aria-hidden="true">image-20231117150033846</figcaption></figure><p>首先来明确几个概念</p><ul><li>无线终端：手机，pad，笔记本电脑等</li><li>无线接入点：小基站、路由器等</li><li>网络基础设施：大基站，交换机</li><li>空中接口：无线终端与无线接入点之间的接口</li></ul><p>移动通信系统面临的威胁可以分成三大类</p><ul><li>对传递信息的威胁：这类威胁针对系统中传输的个人信息（语音、短信等）</li><li>对用户的威胁：这类威胁针对用户的行为（用户在哪，在做什么等）</li><li>对通信系统的威胁破坏系统的完整，访问权限等</li></ul><p>对传递信息的威胁</p><ul><li><p>侦听</p><ul><li><p>可以理解为非法窃听</p></li><li><p>无线通信的广播特性使得任何具有天线的设备都能收到其他用户的数据</p></li></ul></li><li><p>篡改：非授权方更改系统中的各种信息，伪装成合法用户进行信息的修改</p></li><li><p>抵赖：通信一方否认自己的行为</p></li></ul><p>对用户的威胁</p><ul><li>流量分析：分析信息速率，消息长度，接收者或者发送者标识等</li><li>监视：了解用户在何时何地进行通信</li></ul><p>对通信系统的威胁</p><ul><li>拒绝服务<ul><li>非法攻击使系统无法提供服务</li><li>例如发送大量垃圾信息造成网络拥堵，阻止系统对正常用户的服务</li></ul></li><li>资源的非授权访问<ul><li>越权使用超过其职权范围的资源</li><li>例如学信网学生注册信息丢失</li><li>强行占用不属于自己的信道</li></ul></li></ul><h4 id="移动通信系统的安全要求">移动通信系统的安全要求</h4><p>1）能唯一地标识用户</p><p>2）冒充合法用户是困难的</p><p>3）双向认证。用户和服务器之间相互信任</p><p>4）机密性。保证传输数据的安全</p><p>5）用户身份的匿名性。不向第三方暴露自己的身份</p><p>6）不可否认性。防止抵赖</p><p>7）完整性</p><h3 id="专有名词缩略表">1.4 专有名词缩略表</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">GSM：<span class="hljs-keyword">Global</span> system <span class="hljs-keyword">for</span> mobile communications<br>W-CDMA: wideband-code division multiple access<br>TD-SCDMA: time division-synchronous code division multiple access<br><span class="hljs-symbol">LTE:</span> <span class="hljs-type">long</span> term evolusion<br><span class="hljs-symbol">NR:</span> <span class="hljs-built_in">new</span> radio<br><span class="hljs-symbol">eMBB:</span> Enhanced Mobile Broadband<br><span class="hljs-symbol">mMTC:</span> Massive Machine Type Communication<br><span class="hljs-symbol">URLLC:</span> Ultra Reliable Low Latency Communication<br></code></pre></td></tr></table></figure><h2 id="第二章-信源编码">第二章 信源编码</h2><h3 id="采样定理">2.1 采样定理</h3><p>信源有两种，离散源和模拟源（连续源）</p><p>1、为了使数字电路能够处理模拟信号，必须将模拟信号转成数字信号。将模拟信号到数字信号的转换称为模-数转换（A/D）。实现A/D的电路称为ADC。</p><p>2、模拟信号与数字信号之间的桥梁是什么呢？什么时候它们可以相互转换呢？</p><p>---回忆一下你在地铁里见到的广告牌？<del>啥意思？我也没看懂😮😮</del></p><p>--- 回忆一下你在纸上按照“点”描摹一条曲线</p><p>采样定理：<span class="math inline">\(f_s≥2f_{amax}\)</span></p><p><span class="math inline">\(f_s\)</span>为采样频率， <spanclass="math inline">\(f_{amax}\)</span>为奈奎斯特频率，它是模拟信号中的最高频率成分(谐波)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171532196.png"alt="image-20231117153211124" /><figcaption aria-hidden="true">image-20231117153211124</figcaption></figure><h3 id="量化和编码">2.2 量化和编码</h3><p>通过采样后，我们得到了一个离散的数值。因为得到的数值有可能有无穷多位的小数，所以总是要进行近似，这个近似的过程就称为量化</p><p><strong>量化</strong>：将采样的数值用一个最小单元的整数倍来表示。这个最小单元记为Δ</p><p><strong>编码</strong>：将量化后的数值用二进制代码表示的过程。</p><p>量化误差：在量化过程中（数值近似），不可避免地会引入误差。不同的量化方法引入的量化误差不同。</p><h3 id="信源编码">2.3 信源编码</h3><blockquote><p>编码？说白了就是取名字（给信号或消息等取名字）</p><p>将一号给予班长，二号给予学委，三号….对A,B两个字母编码，可分别为0,1….</p></blockquote><h4 id="举例">举例</h4><p>某事件有四种可能，你会如何对这四种情况进行编码？ <spanclass="math display">\[\begin{array}{|l|l|}\hline X &amp; P(x) \\\hline \text { a } &amp; 0.6 \\\hline \text { b } &amp; 0.39 \\\hline \text { c } &amp; 0.009 \\\hline \text { d } &amp; 0.001 \\\hline\end{array}\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171648677.png"alt="image-20231117164758584" /><figcaption aria-hidden="true">image-20231117164758584</figcaption></figure><p>码1是否可行？ 可行</p><p>码2是否可行？0010，译码是否唯一？不可行</p><p>码3是否可行？可行，但是当我们收到一串码符号10时，我们能否判断该码字是否传完？所以还是不建议这样</p><p>码4是否可行？</p><ul><li>当收到一串码符号01时，能否判断该码字是否传完？出现00，能否判断？</li><li>第一问答案是肯定的。因为只要出现1，对应的码字就结束了。第二问的答案也是肯定的。没有出现1，则该码字还没有传完。</li><li>码4在译码时无需依赖于后续的码符号就可以判断该码字有没传完。这种类型的码就是即时码。</li></ul><p>对所选编码的要求：</p><ul><li>唯一可译性（必须满足）</li><li>即时性（尽量满足）</li></ul><p>目前满足以上两个要求的码有码1和码4，请问实际中你会选哪一种，为什么？</p><p>计算码1的平均长度，答案：2</p><p>计算码4的平均长度，答案：1×0.6 + 2×0.39 + 3×0.009 + 4×0.001 = 1.411&lt; 2</p><p>以上例子告诉我们一个什么道理？<strong>概率越大，码元编码越短，则信源的平均编码长度越短</strong></p><p><strong><em>这就是数据压缩的原理！</em></strong></p><h4 id="huffman码哈夫曼编码">Huffman码(哈夫曼编码)</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011516231.png"alt="霍夫曼码的定义" /><figcaption aria-hidden="true">霍夫曼码的定义</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011520803.png"alt="例题1" /><figcaption aria-hidden="true">例题1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011521450.png"alt="解决方案1" /><figcaption aria-hidden="true">解决方案1</figcaption></figure><p><span class="math inline">\(\overline L\)</span>为平均长度</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011523348.png"alt="解决方案2" /><figcaption aria-hidden="true">解决方案2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011523108.png"alt="两种方案的对比" /><figcaption aria-hidden="true">两种方案的对比</figcaption></figure><p>所以我们总是用第二种方法来进行哈夫曼编码</p><p><strong>Huffman码的特点：</strong></p><p>1、 Huffman码是最佳码（在所有码中平均码长最小）</p><p>2、概率大的符号对应于短码，概率小的符号对应于长码</p><p>3、两个概率最小的码字具有相同的码长，且只有最后一位不同</p><h3 id="小结">2.4 小结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011525963.png"alt="本章小结" /><figcaption aria-hidden="true">本章小结</figcaption></figure><h2 id="第三章-无线信道">第三章 无线信道</h2><ul><li><p>一条水管能输送多少自来水？</p></li><li><p>一条高压线能传输多少电？</p></li></ul><p>学完本章，我们能够回答一个问题：无线信道究竟能传输多少信息？</p><h3 id="无线信道模型">3.1 无线信道模型</h3><p>无线信道是该课程接下来所有内容的基础</p><p>无线信道最主要的特征：随时间、频率而发生强度和相位的变化</p><p>无线信道的变化可以粗略地分为两大类：大尺度衰落、小尺度衰落</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312011530153.png"alt="无线信道的变化" /><figcaption aria-hidden="true">无线信道的变化</figcaption></figure><p>大尺度衰落一般与路径损耗以及阴影有关，变化幅度较小，实际中主要影响的是基站的位置</p><p>小尺度衰落一般由多径和干扰引起，变化幅度剧烈，实际中主要影响传输的可靠性和有效性，是本课程研究的重点</p><h2 id="第四章-信道编码">第四章 信道编码</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151413647.png"alt="无线通信系统的基本构成" /><figcaption aria-hidden="true">无线通信系统的基本构成</figcaption></figure><h3 id="香农定理">4.1 香农定理</h3><p><strong>有噪信道编码定理（香农第二定理）</strong></p><p>某一信道的信道容量为C。当信息传输速率<spanclass="math inline">\(R≤C\)</span>时，总能找到一种信道编码方法，使信道输出端的平均译码错误概率任意小。</p><p>结论：信道容量是在信道中可靠传输信息的最大信息传输速率。</p><p>问题：香农第二定理只告诉我们存在一种编码方式使错误概率趋于零，但却没有告诉我们这种编码具体是什么？当传输速率小于C时，采用什么方式进行编码可以实现香农第二定理呢？</p><p>答：信道纠错码</p><h3 id="纠错码">4.2 纠错码</h3><p><strong>基本概念1：</strong></p><p>有<span class="math inline">\(k\)</span>个信息，记为<spanclass="math inline">\(m=(m_{k-1},m_{k-2},…,m_0)\)</span>。称m为信息组，<spanclass="math inline">\(m_i\)</span>为信息元</p><p>这k个信息元一共有<spanclass="math inline">\(2^k\)</span>种组合方式（二元通信系统）</p><p>为了纠错，在<spanclass="math inline">\(k\)</span>个信息的基础上引入额外的<spanclass="math inline">\(r\)</span>个符号（称为校验元），形成 <spanclass="math inline">\(n=k+r\)</span> 长的序列，并记为<spanclass="math inline">\(C=(c_{n-1},c_{n-2},…,c_0)\)</span>，称<spanclass="math inline">\(C\)</span>为码字， <spanclass="math inline">\(c_i\)</span>为码元，<spanclass="math inline">\(n\)</span>是码长，<spanclass="math inline">\(k\)</span>是信息元的个数，<spanclass="math inline">\(n-k=r\)</span>是校验元的个数</p><ul><li><p>如果增加的<spanclass="math inline">\(r\)</span>个校验元只与本组的<spanclass="math inline">\(k\)</span>个信息元有关，而与其他信息组无关，则这样的码称为分组码，记为(n,k)码。</p></li><li><p>如果增加的<spanclass="math inline">\(r\)</span>个校验元不仅与本组的<spanclass="math inline">\(k\)</span>个信息元有关，还与之前的信息组有关，则这样的码称为卷积码。</p></li><li><p>对二进制<span class="math inline">\((n,k)\)</span>线性分组码<span class="math inline">\(C\)</span> ，<spanclass="math inline">\(k\)</span>个信息元对应产生 <spanclass="math inline">\(2^k\)</span>个许用码字，其他<spanclass="math inline">\(2^n- 2^k\)</span>个为禁用码字。</p></li></ul><p><strong>基本概念2：码字的汉明重量、汉明距离</strong></p><p>码字的汉明重量是指码字中非零码元的个数，记为<spanclass="math inline">\(W(C)\)</span>。对于二元码，汉明重量就是<spanclass="math inline">\(1\)</span>的个数。</p><p>因此, 两个码字 <span class="math inline">\(C_k\)</span> 和 <spanclass="math inline">\(C_j\)</span> 之间的汉明距离为 <spanclass="math display">\[D\left(C_k, C_j\right)=W\left(C_k \oplus C_j\right)\]</span> <span class="math inline">\(\oplus\)</span> 表示模二相加,或者异或</p><p><span class="math display">\[\begin{array}{r}\text {1101与1010之间的汉明距离: } \\1101 \\+1010 \\\hline 0111\end{array}\]</span></p><p><strong>基本概念3：错误图样</strong> <span class="math display">\[E=\left(e_{n-1} e_{n-2} \cdots e_0\right)\]</span></p><p>当 <span class="math inline">\(e_i=0\)</span> 时，表示第 <spanclass="math inline">\(\mathrm{i}\)</span> 位无差错发生； <spanclass="math inline">\(e_i=1\)</span> 时，表示第 <spanclass="math inline">\(\mathrm{i}\)</span> 位出错</p><p>假设传输的序列为 <span class="math inline">\(C\)</span>, 接收的序列为<span class="math inline">\(R\)</span>, 则 <span class="math display">\[E=C \oplus R \quad R=C \oplus E \quad C=R \oplus E\]</span></p><p>即，任意两个的模二和等于第三个</p><p><span class="math inline">\(W(E)\)</span> 就表示出现错误的个数。</p><p>发送1101，接收1010，判断哪些位出错：后三位都有错误</p><h3 id="线性分组码">4.3 线性分组码</h3><blockquote><p>定义：线性分组码是指分组码中信息元和校验元是用线性方程联系起来的一种差错控制码</p></blockquote><p>线性分组码的构成步骤：</p><p>1、信道编码器将信息序列分成 <span class="math inline">\(k\)</span>长的信息组, 记为 <spanclass="math inline">\(\mathrm{m}=\left(\mathrm{m}_{\mathrm{k}-1},\mathrm{~m}_{\mathrm{k}-2}, \ldots, \mathrm{m}_0\right)\)</span> 。</p><p>2、用 <span class="math inline">\(\mathrm{k}\)</span>个信息元线性组合产生 <span class="math inline">\(\mathrm{r}\)</span>个校验元</p><p>3、将 <span class="math inline">\(k\)</span> 个信息元与 <spanclass="math inline">\(\mathrm{r}\)</span> 个校验元组合成长度为 <spanclass="math inline">\(n\)</span> 的码字 <spanclass="math inline">\(\mathrm{C}=\left(\mathrm{c}_{\mathrm{n}-1},\mathrm{c}_{\mathrm{n}-2}, \ldots, \mathrm{c}_0\right)\)</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151427463.png"alt="线性分组码" /><figcaption aria-hidden="true">线性分组码</figcaption></figure><h3 id="汉明码">4.4 汉明码</h3><blockquote><p>最简单的线性分组码：汉明码</p></blockquote><p>汉明码可以用来纠正 1 比特错误</p><p>汉明码的核心在于两个矩阵：生成矩阵G和校验矩阵H</p><ul><li>生成矩阵G用来生成码字</li><li>校验矩阵H用来验证某个码字是否传输正确</li></ul><h4 id="一生成矩阵">一、生成矩阵</h4><p>（用来生成码字）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151430772.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151431837.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151432782.png"alt="生成矩阵" /><figcaption aria-hidden="true">生成矩阵</figcaption></figure><p>下面是信息论与编码中的一点东西</p><p>（7，4）汉明码的标准校验矩阵</p><p><span class="math display">\[\begin{aligned}&amp;\begin{array}{|l|l|l|l|l|l|l|l|l|}\hline s 0=000 &amp; \mathrm{c} 0=0000000 &amp; \mathrm{c} 1=0001011&amp; \mathrm{c} 2=0010110 &amp; \mathrm{c} 3=0011101 &amp; \mathrm{c}4=0100111 &amp; \mathrm{c5}=0101100 &amp; \mathrm{c} 6=0110001 &amp;\mathrm{c} 7=0111010 \\\hline \mathrm{s} 1=101 &amp; \mathrm{e} 1=1000000 &amp; 1001011 &amp;1010110 &amp; 1011101 &amp; 1100111 &amp; 1101100 &amp; 1110001 &amp;1111010 \\\mathrm{~s} 2=111 &amp; \mathrm{e} 2=0100000 &amp; 0101011 &amp; 0110110&amp; 0111101 &amp; 0000111 &amp; 0001100 &amp; 0010001 &amp; 0011010 \\\mathrm{~s} 3=110 &amp; \mathrm{e} 3=0010000 &amp; 0011011 &amp; 0000110&amp; 0001101 &amp; 0110111 &amp; 0111100 &amp; 0100001 &amp; 0101010 \\\mathrm{~s} 4=011 &amp; \mathrm{e} 4=0001000 &amp; 0000011 &amp; 0011110&amp; 0010101 &amp; 0101111 &amp; 0100100 &amp; 0111001 &amp; 0110010 \\\mathrm{~s} 5=100 &amp; \mathrm{e} 5=0000100 &amp; 0001111 &amp; 0010010&amp; 0011001 &amp; 0100011 &amp; 0101000 &amp; 0110101 &amp; 011110 \\\mathrm{~s} 6=010 &amp; \mathrm{e} 6=0000010 &amp; 0001001 &amp; 0010100&amp; 0011111 &amp; 0100101 &amp; 0101110 &amp; 0110011 &amp; 0111000 \\\mathrm{~s} 7=001 &amp; \mathrm{e} 7=0000001 &amp; 0001010 &amp; 0010110&amp; 0011100 &amp; 0100110 &amp; 0101101 &amp; 0110000 &amp; 0111011 \\\hline\end{array}\\&amp;\begin{array}{|l|l|l|l|l|l|l|l|l|}\hline s 0=000 &amp; c 8=1000101 &amp; c 9=1001110 &amp; c 10=1010011&amp; c 11=1011000 &amp; c 12=1100010 &amp; c 13=1101001 &amp; c14=1110100 &amp; c 15=1111111 \\\hline s 1=101 &amp; 0000101 &amp; 0001110 &amp; 0010011 &amp; 0011000&amp; 0100010 &amp; 0101001 &amp; 0110100 &amp; 0111111 \\s 2=111 &amp; 1100101 &amp; 1101110 &amp; 1110011 &amp; 1111000 &amp;1000010 &amp; 1001001 &amp; 1010100 &amp; 1011111 \\s 3=110 &amp; 1010101 &amp; 1011110 &amp; 1000011 &amp; 1001000 &amp;1110010 &amp; 1111001 &amp; 1100100 &amp; 1101111 \\s 4=011 &amp; 1001101 &amp; 1000110 &amp; 1011011 &amp; 1010000 &amp;1101010 &amp; 1100001 &amp; 1111100 &amp; 1110111 \\s 5=100 &amp; 1000001 &amp; 1001010 &amp; 1010111 &amp; 1011100 &amp;1100110 &amp; 1101101 &amp; 1110000 &amp; 1111011 \\s 6=010 &amp; 1000111 &amp; 1001100 &amp; 1010001 &amp; 1011010 &amp;1100000 &amp; 1101011 &amp; 1110110 &amp; 1111101 \\s 7=001 &amp; 1000100 &amp; 1001111 &amp; 1010010 &amp; 1011001 &amp;1100011 &amp; 1101000 &amp; 1110101 &amp; 1111110 \\\hline\end{array}\end{aligned}\]</span></p><p>……</p><p>……</p><p>……</p><p>……</p><h2 id="第十章-无线通信安全">第十章 无线通信安全</h2><p>通信：</p><p>有线：光纤</p><p>无线：</p><ul><li>光通信</li><li>分子通信——药物</li><li>量子通信</li></ul><h3 id="安全性原则">安全性原则</h3><p>假设A要通过信封向B邮寄一个100元的支票。通常，A和B会考虑什么因素？</p><p>A要保证只有B能收到信封，即使别人收到，也不知道支票的细节。这是<strong>保密性原则</strong></p><p>A和B还要保证别人不会篡改支票内容（如金额、日期、签名、收款人等）。这是<strong>完整性原则</strong></p><p>B要保证支票是来自A，而不是别人假装A（否则就是假支票）。这是<strong>认证原则</strong>。</p><p>如果B把支票转入账号中，钱从A账户转到B账户之后，A否认签发了支票呢？法院要用A的签名否认A的抵赖，解决争端。这是<strong>不可抵赖性原则</strong>。</p><h4 id="保密性">保密性</h4><p>保密性要求做到只有发送人和期望接收人才能访问消息内容。如果非法人员能够访问消息内容，则破坏了保密性原则。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171424504.png"alt="image-20231117142405434" /><figcaption aria-hidden="true">image-20231117142405434</figcaption></figure><p>例如该图中，A向B发送一封邮件，C未经B的允许却可以进行访问。这种攻击称为截获（Interception）</p><h4 id="认证">认证</h4><p>认证机制用于证明身份。例如，用户C假装成用户A向B发送转账请求（实际收款账户是C的而不是A的），B以为这是A的请求，于是错误地将钱打给C。这种攻击称为伪造(fabrication)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171425490.png"alt="image-20231117142504430" /><figcaption aria-hidden="true">image-20231117142504430</figcaption></figure><h4 id="完整性">完整性</h4><p>消息内容在发送方发出后到达期望接收方时发生改变，就会失去消息的完整性。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171425051.png"alt="image-20231117142530983" /><figcaption aria-hidden="true">image-20231117142530983</figcaption></figure><p>C篡改了A发送的信息，然后将改变的信息发给B。A，B都不知道消息被篡改。这种攻击称为篡改(modification)</p><h4 id="不可抵赖">不可抵赖</h4><p>有时用户发送了这个消息，又想否认发送了这个消息。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171426920.png"alt="image-20231117142604861" /><figcaption aria-hidden="true">image-20231117142604861</figcaption></figure><p>例如，用户A向银行B发送一个转账请求。银行按A的请求转账之后，A声称没有发送这个转账请求</p><h3 id="无线通信的开放性">无线通信的开放性</h3><p>无线信道的开放性导致任何装有天线的用户都可以收到发送给其他用户的信息</p><p>这种特性被称为广播特性，例如，上课、讲座等</p><h3 id="信息论安全完美安全">信息论安全（完美安全）</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171427787.png"alt="image-20231117142757724" /><figcaption aria-hidden="true">image-20231117142757724</figcaption></figure><p>M是隐私信息（明文），K是密钥，C是M被K加密后的信息（密文）</p><p>香农证明：要实现完美安全，M与C必须满足如下关系：</p><p><span class="math display">\[I(M;C)=0  ---互信息\]</span></p><p>意味着窃听者收到C后得到关于M的信息量为0；又或者理解为M与C没有任何共有的信息。</p><p>加密的性质：知道了M，K，C 中的任何两个，第三个就会知道，因此：<spanclass="math inline">\(H(M|KC) = H(K|MC) = H(C|KM)=0\)</span></p><p>完美安全的条件：一次一密，即每一比特的隐私信息至少需要一比特的密钥进行加密</p><h4 id="互信息">互信息</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171438095.png"alt="image-20231117143815037" /><figcaption aria-hidden="true">image-20231117143815037</figcaption></figure><p><strong>熵 H(X)</strong>：熵的本质是不确定性的多少</p><p><strong>条件熵 H(X|Y)</strong>：已知Y后，X还剩下多少不确定性 <spanclass="math display">\[H(X \mid Y)=-\sum_i \sum_j P\left(x_i, y_j\right) \log P\left(x_j \midy_i\right)\]</span> 在没有收到Y时，X的不确定性为多少？ H(X)</p><p>在收到Y后，X的不确定性为多少？H(X|Y) 。<em>这个对 X尚存在的不确定性是由干扰（噪声）引起的。</em></p><p>在这个过程中，接收机获得了多少信息量？H(X)-H(X|Y)</p><p><strong>互信息</strong>： <span class="math display">\[I(X;Y)=H(X)-H(X|Y)\]</span>互信息I(X;Y)的本质：接收机获取来自发射机的信息量的多少。或者理解为：接收信号Y与发送信号X共有的信息量</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171444008.png"alt="image-20231117144412928" /><figcaption aria-hidden="true">image-20231117144412928</figcaption></figure><p>H(X|Y)：去掉包含Y的部分后，X剩下的不确定性</p><p>H(Y|X)：去掉包含X的部分后，Y剩下的不确定性</p><p>如果发送了X，接收机准确地获取了X，则得到的互信息为多少？H(X)</p><p>如果发送了X，收到了一个完全不相干的Y，则得到的互信息为多少？0</p><h3 id="diffie-hellman密钥交换协议">Diffie-Hellman密钥交换协议</h3><p>1976年，Diffie和Hellman这两个人提出了一种奇妙的密钥交换方法来解决通信双方密钥共享的问题。该方案是后续非对称密码学的基础</p><p>算法描述：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171517405.png"alt="image-20231117151709336" /><figcaption aria-hidden="true">image-20231117151709336</figcaption></figure><p>第一步：Alice和Bob公开两个大的素数n,g。意味着Alice，Bob，Eve都知道这两个数</p><p>第二步：Alice生成一个很大的数x（只有Alice自己知道），并计算<spanclass="math inline">\(A=g^x \bmod n\)</span></p><p>第三步：将A发送给Bob（意味着Bob，Eve都知道A）</p><p>第四步：Bob生成一个很大的数y（只有Bob自己知道），并计算<spanclass="math inline">\(B=g^y \bmod n\)</span></p><p>第五步：将B发送给Alice（意味着Alice，Eve都知道B）</p><p>第六步：Alice计算秘密密钥K1；Bob计算秘密密钥K2</p><p><span class="math display">\[\begin{align}&amp;K_1=B^x \bmod n----B是来自Bob，x是Alice生成\\&amp;K_2=A^y \bmod n----A是来自Alice，y是Bob生成\\\end{align}\]</span></p><p>证明1：K1=K2 <span class="math display">\[\begin{aligned} &amp; K 1=B^x \bmod n \\ &amp; \because B=g^y \bmod n \\&amp; \therefore g^y=r n+B(r \text { 是一个整数 }) \\ &amp;\therefore\left(g^y\right)^x \bmod n=(r n+B)^x \bmod n=B^x \bmod n=K 1\\ &amp; K 1=g^{y x} \bmod n \\ &amp; K 2=g^{x y} \bmod n \\ &amp; K 1=K2=K\end{aligned}\]</span> 证明2：Eve很难算出K</p><p>Eve要解出K，必须知道x或者y，<span class="math inline">\(K_1=B^x \bmodn\)</span>，<span class="math inline">\(K_2=A^y \bmod n\)</span></p><p>而要算出x和y只能从以下两个方程入手：<span class="math inline">\(A=g^x\bmod n\)</span>，<span class="math inline">\(B=g^y \bmod n\)</span></p><p>因为x,y是整数且n很大，从这两个方程求出x和y非常困难</p><p>看个小例子：<span class="math inline">\(2=3^y \bmod17\)</span>，遍历得<span class="math inline">\(x=14\)</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>通信原理与安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 4 程序控制结构</title>
    <link href="/2023/11/15/Java%204%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/"/>
    <url>/2023/11/15/Java%204%20%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>程序运行的流程控制决定程序是如何执行的，是我们必须掌握的。主要分为：顺序控制、分支控制、循环控制。</p></blockquote><h2 id="顺序控制">4.1 顺序控制</h2><blockquote><p>程序从上到下逐行执行，中间没有任何判断和跳转（默认的控制顺序）</p><p>比如：Java 定义变量时采用合法的前向引用。</p></blockquote><p>语句：Java 中最小的执行单位。语句分为 单语句 和 复合语句。</p><ul><li><p>单语句：通常意义的一条语句。语句间以分号 <code>;</code>分隔。</p></li><li><p>复合语句：一对大括号括起来的语句组。也称为 “块”</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&#123;<br>    语句<span class="hljs-number">1</span><span class="hljs-comment">; </span><br>    语句<span class="hljs-number">2</span><span class="hljs-comment">;</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>块中可以有多条语句。块后没有分号 <code>;</code></p></li></ul><h2 id="分支控制-if-else">4.2 分支控制 <code>if-else</code></h2><blockquote><p>让程序有选择的执行。主要分为：单分支控制、双分支控制</p></blockquote><h3 id="单分支控制">4.2.1 单分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) 语句;<br></code></pre></td></tr></table></figure><p>特别地，把代码块（复合语句）作为语句的场合也能这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br> 执行代码块;<br>&#125;<br></code></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块;&#125;</code>；如果为 <code>false</code>则不执行。特别地：如果 <code>&#123;执行代码块;&#125;</code>中只有一条代码，也可以不写 <code>&#123; &#125;</code>（但还是建议写上）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">If01</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//编写一个程序,可以输入人的年龄,如果该同志的年龄大于 18 岁, 则输出 &quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//1. 接收输入的年龄, 应该定义一个 Scanner 对象</span><br>        <span class="hljs-comment">//2. 把年龄保存到一个变量 int age</span><br>        <span class="hljs-comment">//3. 使用 if 判断，输出对应信息</span><br>        <span class="hljs-comment">//应该定义一个 Scanner 对象</span><br><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄:&quot;</span>);<br>        <span class="hljs-comment">//把年龄保存到一个变量 int age</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-comment">//使用 if 判断，输出对应信息</span><br>        <span class="hljs-keyword">if</span>(age &gt; <span class="hljs-number">18</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;你年龄大于 18,要对自己的行为负责,送入监狱&quot;</span>);<br>        &#125;<br>        <br>        System.out.println(<span class="hljs-string">&quot;程序继续...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双分支控制">4.2.2 双分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br>执行代码块;<br>&#125; <br><span class="hljs-keyword">else</span> &#123;<br>执行代码块<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当条件表达式为 <code>ture</code>，就会执行<code>&#123;执行代码块1;&#125;</code>；如果为 <code>false</code> 则执行<code>&#123;执行代码块2;&#125;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-comment">//编写一个 main 方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//判断一个年份是否是闰年，闰年的条件是符合下面二者之一：</span><br>        <span class="hljs-comment">//(1)年份能被 4 整除，但不能被 100 整除；(2)能被 400 整除</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//1. 定义 int year 保存年</span><br>        <span class="hljs-comment">//2. 年份能被 4 整除，但不能被 100 整除, // =&gt; year % 4 == 0 &amp;&amp; year % 100 != 0</span><br>        <span class="hljs-comment">//3. 能被 400 整除 =&gt; year % 400 == 0</span><br>        <span class="hljs-comment">//4. 上面的 2 和 3 是 或的关系</span><br>        <span class="hljs-comment">//代码实现</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年份：&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">year</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        <span class="hljs-keyword">if</span>( (year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span> ) &#123;<br>            System.out.println(year + <span class="hljs-string">&quot; 是 闰年&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(year + <span class="hljs-string">&quot; 不是 闰年&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="多分支控制">4.2.3 多分支控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">if</span> (条件表达式) &#123;<br> 执行代码块;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123;<br> 执行代码块<span class="hljs-number">2</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123;<br> 执行代码块<span class="hljs-number">3</span>;<br>&#125;<br>...<br><span class="hljs-keyword">else</span> &#123;<br> 执行代码块n；<br>&#125;<br></code></pre></td></tr></table></figure><p>特别地：多分支可以没有<code>else</code>。此时如果条件都不成立，则无执行入口</p><h3 id="嵌套分支">4.2.4 嵌套分支</h3><blockquote><p>在一个分支结构中又完整嵌套了另一个完整的分支结构。里面的分支称为内层分支，外面的分支称为外层分支。</p></blockquote><p>Java 规定，else 子句属于逻辑上距其最近，且没有匹配 else 的 if语句</p><p><strong>规范：嵌套尽量不超过 3 层（可读性不好）</strong></p><h2 id="switch-分支结构">4.3 <code>switch</code> 分支结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">switch</span>(表达式)&#123;<br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">1</span>:<br>语句块<span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br><span class="hljs-keyword">case</span> 常量<span class="hljs-number">2</span>:<br>语句块<span class="hljs-number">2</span>;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br>...<br><span class="hljs-keyword">default</span>:<span class="hljs-comment">//default 语句可选</span><br><span class="hljs-keyword">default</span>语句块;<br><span class="hljs-keyword">break</span>;<span class="hljs-comment">//break 语句可选</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>switch</code> 关键字，表示 switch 分支。</li><li><code>表达式</code> 对应一个值。<strong>该值必须是 int 或char</strong>（char 可以转化为 int）。是 byte 或 short 的场合，要提升为int。不允许 long、double 或 float</li><li><code>case 常量1;</code> 表示：当 <code>表达式</code> 的值等于<code>常量1</code> ，则执行 <code>语句块1</code>。</li><li><code>break;</code> 表示退出 switch 分支。</li><li>当 <code>表达式</code> 的值匹配 <code>常量1</code> ，则执行<code>语句块1</code>，如果不匹配，则继续匹配 <code>常量2</code>，以此类推。</li><li>如果全都不匹配，则执行 <code>default</code>。</li><li>如果不写 <code>break;</code>，则会发生<strong>穿透</strong>，即不进行判断而继续执行下一语句块。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        请编写一个程序，该程序可以接收一个字符，比如:a,b,c,d,e,f,g</span><br><span class="hljs-comment">        a 表示星期一，b 表示星期二 …</span><br><span class="hljs-comment">        根据用户的输入显示相应的信息.要求使用 switch 语句完成</span><br><span class="hljs-comment">        思路分析</span><br><span class="hljs-comment">        1. 接收一个字符 , 创建 Scanner 对象</span><br><span class="hljs-comment">        2. 使用 switch 来完成匹配,并输出对应信息</span><br><span class="hljs-comment">        代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符(a-c)&quot;</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//</span><br>        <span class="hljs-comment">//在 java 中，只要是有值返回，就是一个表达式</span><br>        <span class="hljs-keyword">switch</span>(c1) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期一,猴子穿新衣&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期二,猴子当小二&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span> :<br>                System.out.println(<span class="hljs-string">&quot;今天星期三,猴子爬雪山..&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                System.out.println(<span class="hljs-string">&quot;你输入的字符不正确，没有匹配的&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;退出了 switch ,继续执行程序&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用细节">4.3.1 使用细节</h3><ol type="1"><li>表达式数据类型，应和 <code>case</code>后的常量类型一致，或者是可以自动转换成可以比较的类型。如：输入的是<code>char</code> 而 常量是 <code>int</code></li><li>switch 中 <code>表达式</code>的返回值必须是：(<code>byte, short, int, char,enum[枚举] ,String</code>)</li><li><code>case</code>语句中的值必须是常量或常量表达式，不能是变量。</li><li><code>default</code> 是可选的。没有就不执行。</li><li><code>break;</code> 用来跳出 switch分支。如果不写，会持续执行语句，直到分支结束或遇到下一个<code>break;</code></li></ol><h3 id="与-if-else-分支结构的取舍">4.3.2 与 <code>if-else</code>分支结构的取舍</h3><ul><li>如果<strong>判断的具体数值不多</strong>，而且符合 byte、 short、int、 char, enum[枚举], String 这 6种类型。虽然两个语句都可以使用，建议使用 swtich 语句。</li><li>其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if的使用范围更广</li></ul><h2 id="for-循环控制">4.4 <code>for</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">for</span>(循环变量初始化;循环条件;循环变量迭代)&#123;<br>循环操作（代码块）;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>for</code> 关键字，表示循环控制</p></li><li><p>四个要素：1. 循环变量初始化 2. 循环的条件 3. 循环的操作 4.循环变量迭代</p></li><li><p>循环操作可以有多条语句</p></li><li><p>如果循环操作只有一条语句，可以省略<code>&#123;&#125;</code>，但<strong>建议不省略</strong></p></li></ul><h3 id="使用细节-1">4.4.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</li><li><code>for(;循环条件;)&#123; &#125;</code>其中的初始化和变量迭代可以写在别处，但 <code>;</code>不能省略。如果不写在别处，那个循环变量初始化中声明的变量只能在该 for循环中使用。</li><li>控制台用 ctrl + c 强制结束一个流程</li><li>循环初始值可以有多条初始化语句，但要求类型一样，并用 <code>,</code>隔开。变量迭代也可以有多条代码，用 <code>,</code> 隔开。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>; i &lt; count; i++, j+=<span class="hljs-number">2</span>)&#123;<br>System.out.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot; j = &quot;</span> + j);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="化繁为简-先死后活">4.4.2 化繁为简 先死后活</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//练习</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和.[化繁为简,先死后活]</span><br>        <span class="hljs-comment">//老韩的两个编程思想(技巧)</span><br>        <span class="hljs-comment">//1. 化繁为简 : 即将复杂的需求，拆解成简单的需求，逐步完成</span><br>        <span class="hljs-comment">//2. 先死后活 : 先考虑固定的值，然后转成可以灵活变化的值</span><br>        <span class="hljs-comment">//思路分析</span><br>        <span class="hljs-comment">//打印 1~100 之间所有是 9 的倍数的整数，统计个数 及 总和</span><br>        <span class="hljs-comment">//化繁为简</span><br>        <span class="hljs-comment">//(1) 完成 输出 1-100 的值</span><br>        <span class="hljs-comment">//(2) 在输出的过程中，进行过滤，只输出 9 的倍数 i % 9 ==0</span><br>        <span class="hljs-comment">//(3) 统计个数 定义一个变量 int count = 0; 当 条件满足时 count++;</span><br>        <span class="hljs-comment">//(4) 总和 , 定义一个变量 int sum = 0; 当条件满足时累积 sum += i;</span><br>        <span class="hljs-comment">//先死后活</span><br>        <span class="hljs-comment">//(1) 为了适应更好的需求，把范围的开始的值和结束的值，做出变量</span><br>        <span class="hljs-comment">//(2) 还可以更进一步 9 倍数也做成变量 int t = 9;</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//统计 9 的倍数个数 变量</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//总和</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>; <span class="hljs-comment">// 倍数</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>            <span class="hljs-keyword">if</span>( i % t == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>                count++;<br>                sum += i;<span class="hljs-comment">//累积</span><br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;count=&quot;</span> + count);<br>        System.out.println(<span class="hljs-string">&quot;sum=&quot;</span> + sum);<br><br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="while-循环控制">4.5 <code>while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">while</span>(循环条件)&#123;<br>循环体(代码块);<br>循环变量迭代;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code> 也有四要素，只是位置和 <code>for</code> 不同</p><h3 id="使用细节-2">4.5.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。while 循环中，循环条件不能为空。</li><li><code>while</code> 循环是先判断再执行语句。</li></ol><h2 id="do..while-循环控制">4.6 <code>do..while</code> 循环控制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">do</span>&#123;<br>循环体;<br>循环变量迭代;<br>&#125;<span class="hljs-keyword">while</span>(循环条件);<br></code></pre></td></tr></table></figure><ol type="1"><li><code>do..while</code> 是关键字</li><li>也有四要素，位置不同</li><li>先执行，再判断。也就是说，一定会至少执行一次</li><li><strong>最后有一个 <code>;</code></strong></li><li><code>while</code> 与 <code>do..while</code>区别：“要账”<code>do..while</code>先打一顿</li></ol><h3 id="使用细节-3">4.6.1 使用细节</h3><ol type="1"><li>循环条件是返回一个 boolean 值（<code>ture</code> 或<code>false</code>）的公式。</li><li><code>do..while</code>循环是先执行再判断的语句。因此至少执行一次。</li></ol><h2 id="多重循环控制">4.7 多重循环控制</h2><ol type="1"><li>将一个循环放在另一个循环体内，就形成了嵌套循环。建议一般使用两层，最多不超过三层。</li><li>嵌套循环是把内层循环当成外层循环的循环体。只有内层<code>false</code> 时才结束当层循环。</li><li>若内层执行 n 次，外层 m 次，则合计会循环 n*m 次</li></ol><h3 id="空心金字塔问题">4.7.1 空心金字塔问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">totalLevel</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= totalLevel; i++)&#123;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> totalLevel; m &gt; i; m--)&#123;<br>                System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">2</span>*i-<span class="hljs-number">1</span>; j++)&#123;<br>                <span class="hljs-keyword">if</span> (j == <span class="hljs-number">1</span> || j == <span class="hljs-number">2</span>*i-<span class="hljs-number">1</span> || i == totalLevel) &#123;<br>                    System.out.print(<span class="hljs-string">&quot;*&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span><br>                    System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br><br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311241736554.png"alt="image-20231124173638347" /><figcaption aria-hidden="true">image-20231124173638347</figcaption></figure><h3 id="九九乘法表问题">4.7.2 九九乘法表问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j&lt;=i; j++)&#123;<br>                System.out.print(j + <span class="hljs-string">&quot;*&quot;</span> + i +  <span class="hljs-string">&quot;=&quot;</span> + i*j + <span class="hljs-string">&quot;\t&quot;</span>);<br>            &#125;<br>            System.out.println();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311241819925.png"alt="image-20231124181958866" /><figcaption aria-hidden="true">image-20231124181958866</figcaption></figure><h2 id="跳转控制语句">4.8 跳转控制语句</h2><blockquote><p>跳转控制语句用于分支或循环中，以便程序员更好控制程序执行方向</p></blockquote><h3 id="break">4.8.1 break</h3><blockquote><p>用于中止一个语句块的执行</p></blockquote><p>语法：<code>break;</code></p><p>break 可以被用在三种场合中</p><ul><li><p>switch 语句中，以跳出判断（结束穿透）</p></li><li><p>for、while、do…while 循环语句中，以跳出循环</p></li><li><p>语句块中，以跳过本块中所有剩余语句</p><p><code>break</code> 语句出现在多层嵌套的语句块中时，可以通过<strong>标签</strong> 指明要终止的时哪一层语句块。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span>:&#123;<br><span class="hljs-selector-tag">b</span>:&#123;<br>c:&#123;<br>   ...<br> berak <span class="hljs-selector-tag">b</span>;<br>&#125;<br>&#125;<br>&#125;JAVA<br></code></pre></td></tr></table></figure><ol type="1"><li><code>a:</code> <code>b:</code> <code>c:</code>是标签，名字由程序员指定</li><li><code>break</code> 后指定哪个标签就退出到哪里</li><li><strong>实际开发中，尽量不要使用标签</strong></li></ol></li></ul><h3 id="continue">4.8.3 continue</h3><blockquote><p>在循环中出现。用于结束本次循环，继续下一次循环</p></blockquote><p>语法：<code>continue;</code></p><p>进行下次循环前，仍会判断循环条件是否满足</p><p>在多层嵌套循环中，可以通过标签指出跳出哪次循环（同<code>break</code>）</p><h3 id="return">4.8.4 return</h3><blockquote><p>用于方法。表示跳出所在的方法</p></blockquote><p>语法：<code>return;</code></p><p>方法有返回值的场合，将返回值写在 return后：<code>return 值;</code></p><p>后面会再讲~</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 2 线性表</title>
    <link href="/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202%20%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/11/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202%20%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B站王卓老师数据结构的课程学习记录</p><p>其中2.5的小结基本实现了线性表的所有功能（Vscode，c/c++）</p><p>2.6的小结基本实现了单链表的所有功能（Vscode，c/c++）</p><p>有师傅像我一样c没学好，代码有点看不懂的可以看一下2.4，王卓老师的补充讲解很友好</p><p>同时也能参考一下下面这篇文章，来进行数据结构的学习</p><p><ahref="https://www.cnblogs.com/linfangnan/p/17089709.html">数据结构个人学习推荐- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p></blockquote><h2 id="线性表的定义和特点">2.1 线性表的定义和特点</h2><p>定义：<strong>由n(n ≥0)个数据特性相同的元素构成的有限序列称为线性表。</strong></p><p>特点：</p><ol type="1"><li>线性表中元素的个数n(n ≥ 0)定义为线性表的长度，n = 0时称为空表。</li><li>将非空的线性表(n &gt; 0)记作(a1，a2，a3，...，an)</li><li>这里的数据元素ai(1 ≤ i ≤n)只是个抽象的符号，其具体含义在不同情况下可以不同。</li><li>在非空的线性表，有且仅有一个开始结点a1,它没有直接前趋，而仅有一个直接后继a2；有且仅有一个终端结点an,它没有直接后继，而仅有一个直接前趋an-1；其余的内部结点ai,(2&lt; i &lt; n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1</li></ol><h2 id="线性表的类型定义">2.2 线性表的类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT List &#123;<br>数据对象：D=&#123;ai| ai ∈ElemSet, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：R=&#123; &lt; ai<span class="hljs-number">-1</span> , ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n&#125; <br>基本操作： <br>InitList (&amp; L )      <br>    <span class="hljs-comment">//(Initialization) 形参或者定义时&amp;是引用，实参或者使用时&amp;是取地址！跟C语言还是C++没有关系！但是引用这个概念只存在于C++</span><br>操作结果：构造一个空的线性表L。 <br>DestroyList ( &amp;L )    <br>初始条件：线性表L已存在。     <br>操作结果：销毁线性表L。<br>ClearList ( &amp;L )   <br>初始条件：线性表L已存在。    <br>操作结果：将L重置为空表。<br>ListEmpty ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：若L为空表，则返回TRUE, 否则返回FALSE。  <br>Listlenght ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：返回L中数据元素个数。  <br>GetElem (L, i, &amp;e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)。   <br>操作结果：用e返回L中第 i 个数据元素的值。<br>LocateElem (L, e, compare() )   <br>初始条件：线性表L已存在,compare()是数据元素判定函数。    <br>操作结果：返回L中第<span class="hljs-number">1</span>个与e满足关系compare()的数据元素的位序，  若这样的数据元素不存在，则返回值为<span class="hljs-number">0</span>。 <br>PriorElem (L, cur_e, &amp;pre_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是第一，则用pre_e返回它的前驱,否则操作失败,pre_e无定义。<br>NextElem (L, cur_e, &amp;next_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。<br>ListInsert (&amp;L, i, e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)+<span class="hljs-number">1</span>。<br>操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="hljs-number">1</span>。 <br>ListDelete (&amp;L, i, &amp;e )     <br>初始条件：线性表L已存在且非空,<span class="hljs-number">1</span> ≤i≤ListLength(L)。     <br>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减<span class="hljs-number">1</span>。  <br>ListTraverse (L, visit () )     <br>初始条件：线性表L已存在。     <br>操作结果：依次对L的每个数据元素调用函数visit( )。一旦visit( )失败，则操作失败。   <br>&#125;ADT List<br></code></pre></td></tr></table></figure><h2 id="线性表的顺序表示">2.3 线性表的顺序表示</h2><p>把线性表中的所有元素，按照其逻辑顺序依次存储到计算机中的从指定存储位置开始的一块连续的存储空间中</p><ul><li><p>是一种紧凑结构</p></li><li><p><spanclass="math inline">\(Loc(a_{i+1})=loc(a_i)+sizeof(ElemType)\)</span></p></li><li><p>是一种<strong>随机存储</strong>的结构</p></li><li><p>通常用数组来描述顺序存储结构</p></li><li><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311070000696.png"alt="顺序表示意图" /><figcaption aria-hidden="true">顺序表示意图</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 20   <span class="hljs-comment">//储空间初始分配量</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType; <span class="hljs-comment">//ElemType类型根据实际情况而定，这里假设为int</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[MAXSIZE];  <span class="hljs-comment">//数组存储数据元素，最大值为MAXSIZE</span><br>    <span class="hljs-type">int</span> length  <span class="hljs-comment">//线性表当前长度</span><br>&#125;SqList;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">这里，我们就发现描述顺序存储结构需要三个属性:</span><br><span class="hljs-comment">存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置</span><br><span class="hljs-comment">线性表的最大存储容量：数组长度MaxSize。</span><br><span class="hljs-comment">线性表的当前长度：length。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></li><li><p>计算地址只算一次与处理数据的规模无关数量级是O(1)这种运算叫<strong>随机存取</strong>。</p></li></ul><h2 id="类c语言有关操作">2.4 类c语言有关操作</h2><h3 id="元素类型说明">2.4.1 元素类型说明</h3><p>顺序表类型定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p><code>ElemType</code>是根据实际问题，你需要什么类型的数组就定义成什么，一般是根据问题定义一个结构体或者是<code>typedef char ElemType</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如，data[]中是abcde，那就能这样</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br><br><span class="hljs-comment">//或者：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>如果表中元素类型不单一，可以定义一个复杂的结构类型（结构体的嵌套使用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">float</span> p;<br>    <span class="hljs-type">int</span> e;<br>&#125;Polynomial;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Polynomial *elem; <span class="hljs-comment">//首地址，elem保存地址，这行代码意思是定义了一个Polynomial型的指针变量</span><br><span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><br></code></pre></td></tr></table></figure><h3 id="数组定义">2.4.2 数组定义</h3><p>数组静态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>    ElemType data[MaxSize]; <br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组动态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//数组名其实就是首元素的地址，所以也可以直接定义一个指针，也可以表示一个数组，用来存放数组首地址。数组的大小用相应的函数来动态分配内存</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *data;<span class="hljs-comment">//数组首地址</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>这种方式我们不知道内存到底有多大，接下来将用内存分配函数来分配空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <span class="hljs-comment">//L就是要操作的顺序表，即SqList</span><br><span class="hljs-comment">//L就有两个成员L.data，用来存放顺序表的元素，另一个是L.length</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><h3 id="c语言的内存动态分配">2.4.3 C语言的内存动态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><ul><li><code>malloc(m)</code>函数，开辟m字节长度的地址空间，并返回这段空间的首地址，参数m要求是一个整数</li><li><code>sizeof(x)</code>运算，计算变量x的长度，即变量需占的字节数×变量个数</li><li><code>L.data</code>是数组的首地址（无空间），<code>ElemType*</code>使新分配的空间首地址的元素类型为数组的元素类型，一个“=”就能将放置数组元素类型的空间分配给L了</li><li><code>free(p)</code>函数，释放指针p所指变量的存储空间，即彻底删除一个变量</li><li><code>L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);</code><ul><li>后面这个<code>*</code>意思是乘号</li><li>前面的<code>()</code>的意思是强制类型转换，<ul><li><code>(int)</code>强制转换为整数</li><li><code>(int *)</code>强制转换为指向整型的一个指针</li><li><code>(ElemType*)</code>意思是强制转换成指向数据元素类型<code>ElemType</code>的一个指针，</li></ul></li><li>后面的<code>ElemType</code>表示字节数，比如<code>char</code>需要1个字节，<code>int</code>需要8个字节，那如果<code>MaxSize</code>为100，为<code>char</code>时就需要开辟100字节长度的地址空间，<code>int</code>时就需要开辟800字节长度的地址空间</li><li>前面的<code>ElemType</code>是告诉计算机存成什么类型的，比如后面的<code>ElemType</code>为<code>int</code>，<code>MaxSize</code>为100，那一共800个字节要怎么分配呢，如果为<code>char</code>，就被分为800块，如果是<code>int</code>，就被分为200块，划分成什么类型看我们线性表里面的元素是什么类型</li></ul></li><li>需要加载的头文件：<code>&lt;stdlib.h&gt;</code></li></ul><h3 id="c内容">2.4.4 C++内容</h3><h4 id="c的动态存储分配">C++的动态存储分配</h4><p><code>new 类型名T（初值列表)</code></p><p>功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值</p><p>结果值：</p><ul><li>成功：T类型的指针，指向新分配的内存</li><li>失败：0（NULL)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>;  <span class="hljs-comment">//从内存当中动态的分配一块空间，放一个int型，赋给一个指针变量</span><br><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//给空间赋上初值</span><br></code></pre></td></tr></table></figure><p><code>delete 指针P</code></p><p>功能：释放指针P所指向的内存。P必须是new操作的返回值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">delete p1<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="c-的参数传递">C++ 的参数传递</h4><p>传值方式（参数为整型、实型、字符型等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> m,<span class="hljs-type">float</span> n)</span></span>&#123;<br>    <span class="hljs-type">float</span> temp;<br>    temp = m;<br>    m = n;<br>    n = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a, b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">swap</span>(a, b);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//Enter two numbers: 5 9</span><br><span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br><span class="hljs-comment">//After swapping: a = 5, b = 9</span><br></code></pre></td></tr></table></figure><ul><li>说明：函数修改的是形参的值，释放空间后，形参释放，实参的值不变</li></ul><p>传地址方式-----指针变量作参数</p><ul><li><p>参数为指针变量</p><ol type="1"><li>形参变化影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> t;<br>    t = *m;<br>    *m = *n;<br>    *n = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br>  <br>  <span class="hljs-comment">//Enter two numbers: 5 9</span><br>  <span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br>  <span class="hljs-comment">//After swapping: a = 9, b = 5</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>形参变化不影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> *t;<br>    t = m;<br>    m = n;<br>    n = t;<span class="hljs-comment">//交换的是m和n指向的地址不是地址中的内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//swap(p1,p2)后没交换</span><br></code></pre></td></tr></table></figure></li><li><p>参数为数组名(传递的是数组的首地址，对形参数组所做的任何改变都将反映到实参数组中)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span> <span class="hljs-comment">// 包含字符串处理函数的头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-type">char</span> b[])</span></span>&#123;<br>    <span class="hljs-built_in">strcpy</span>(b, <span class="hljs-string">&quot;world&quot;</span>); <span class="hljs-comment">// 使用strcpy函数将字符串拷贝到数组中</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-type">char</span> a[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-built_in">sub</span>(a);<br>    cout &lt;&lt; a &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//输出world</span><br><span class="hljs-comment">//在C++中，你不能直接对整个数组进行赋值操作。正确的方式是使用字符串库函数（如 strcpy）将字符串拷贝到数组中。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>参数为引用变量</strong>（引用，即给一个对象提供一个替代的名字）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j = i;<br>i = <span class="hljs-number">7</span>;<span class="hljs-comment">//公用同一个空间，但是同时有i、j两个名字，因此改变一个值时，另一个值也会改变</span><br>cout&lt;&lt;<span class="hljs-string">&quot;i = &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;<span class="hljs-string">&quot;j = &quot;</span>&lt;&lt;j;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//引用类型作参数，用的是同一块空间</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span>&amp; m, <span class="hljs-type">float</span>&amp; n)</span></span>&#123;<br>    <span class="hljs-type">float</span> temp;<br>    temp = m;<br>    m = n;<br>    n = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a, b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    <span class="hljs-built_in">swap</span>(a, b);<br>    cout &lt;&lt; a &lt;&lt; endl &lt;&lt; b &lt;&lt; endl;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 添加 return 0; 语句</span><br>&#125;<br><span class="hljs-comment">//能成功交换a，b</span><br></code></pre></td></tr></table></figure><p>引用类型作形参的说明：</p><ul><li>传递引用给函数与传递指针的效果是一样的，形参变化实参也发生变化</li><li>引用类型作形参，在内存中并没有产生实参的副本，它直接对实参操作；而一般变量作参数，形参与实参就占用不同的存储单元，所以形参变量的值是实参变量的副本。因此，当参数传递的数据量较大时，用引用比用一般变量传递参数的时间和空间效率都好。</li><li>指针参数虽然也能达到与使用引用的效果，但在被调函数中需要重复使用“*指针变量名”的形式进行运算，这很容易产生错误且程序的阅读性较差，另一方面，在主调函数的调用点处，必须用变量的地址作为实参</li><li>所以<strong>后面用引用类型作形参比较多</strong></li></ul></li></ul><h2 id="线性表的顺序表示和实现">2.5 线性表的顺序表示和实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INFEASIBLE -1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br></code></pre></td></tr></table></figure><h3 id="线性表l的初始化">2.5.1 线性表L的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//（参数用引用）</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <span class="hljs-comment">//构造一个空的顺序表L</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-comment">// L.elem = (ElemType *)malloc(MAXSIZE*sizeof(ElemType)); 也可以</span><br>    <br>    <span class="hljs-comment">// 而下面这句是不行的：L -&gt; elem = (ElemType *)malloc(MAXSIZE*sizeof(ElemType));</span><br>    <span class="hljs-comment">//在 C++ 中，使用 -&gt; 运算符来访问指针类型的结构成员，而不是引用。对于结构体 SqList，你应该使用 . 运算符来访问其成员，而不是 -&gt; 运算符。</span><br>    <br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span></span>&#123;<br>    <span class="hljs-comment">//构造一个空的线性表L</span><br>    L -&gt; elem = (ElemType *)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span>(!L -&gt; elem)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    L -&gt; length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//第一种c++实现</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <span class="hljs-comment">//构造一个空的顺序表L</span><br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">// Function to print the elements of SqList</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Length: %d, Elements: &quot;</span>, L.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(L);  <span class="hljs-comment">//注意观察这条语句的差别！！！</span><br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191102529.png"alt="程序运行截图" /><figcaption aria-hidden="true">程序运行截图</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//第二种c++实现</span><br><br><span class="hljs-comment">/* ………… </span><br><span class="hljs-comment">跟前面一样</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList* L)</span></span>&#123;<br>    <span class="hljs-comment">//构造一个空的线性表L</span><br>    L -&gt; elem = (ElemType *)<span class="hljs-built_in">malloc</span>(MAXSIZE*<span class="hljs-built_in">sizeof</span>(ElemType));<br>    <span class="hljs-keyword">if</span>(!L -&gt; elem)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    L -&gt; length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br><span class="hljs-comment">//跟前面一样</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(&amp;L);   <span class="hljs-comment">//@@@@@@@@@@</span><br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191103127.png"alt="程序运行截图" /><figcaption aria-hidden="true">程序运行截图</figcaption></figure><h3 id="销毁清空求长度判断是否为空">2.5.2销毁、清空、求长度，判断是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//销毁线性表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DestoryList</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.elem) <span class="hljs-keyword">delete</span> L.elem;<br>&#125;<br><br><span class="hljs-comment">//清空线性表L</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ClearList</span><span class="hljs-params">(Sqlist &amp;L)</span></span>&#123;<br>L.length = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//求线性表长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">//判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取顺序表某一位置上的元素">2.5.3获取顺序表某一位置上的元素</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 初始条件：顺序表L已存在</span><br><span class="hljs-comment">   操作结果：用e返回L中第i个数据元素的值 */</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的查找">2.5.4 顺序表的查找</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,ElemType e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表中查找值为e的数据元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt;L.length; i++)<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的插入">2.5.5 顺序表的插入</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 2 当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j = L.length<span class="hljs-number">-1</span>; j &gt;= i<span class="hljs-number">-1</span>; j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<span class="hljs-comment">// 3 插入位置及以后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>] = e;<span class="hljs-comment">// 4 将新元素e放入第i个位置</span><br>    L.length++;<span class="hljs-comment">// 5 表长增1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="顺序表的删除">2.5.6 顺序表的删除</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">for</span>(j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j]; <span class="hljs-comment">// 2 被删除元素之后的元素前移</span><br>    L.length--; <span class="hljs-comment">// 3 表长减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="线性表小结">线性表小结</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对上面功能的全部实现，c++代码，但主要还是c语言的东西</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OVERFLOW -2</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 100  <span class="hljs-comment">//线性表存储空间的初始分配量</span></span><br><br><span class="hljs-comment">//Status 是函数的类型，其值是函数结果状态代码</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><span class="hljs-comment">//顺序表数据结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    ElemType *elem;<br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><span class="hljs-comment">// Function to print the elements of SqList</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(SqList L)</span> </span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Length: %d, Elements: &quot;</span>, L.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, L.elem[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//构造一个空的顺序表L</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;   <br>    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE]; <span class="hljs-comment">//为顺序表分配空间， </span><br>    <span class="hljs-keyword">if</span>(!L.elem) <span class="hljs-built_in">exit</span>(OVERFLOW);<br>    L.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//插入操作</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert_Sq</span><span class="hljs-params">(SqList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span>||i&gt;L.length+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    <span class="hljs-keyword">if</span>(L.length == MAXSIZE)<span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 2 当前存储空间已满</span><br>    <span class="hljs-keyword">for</span>(j = L.length<span class="hljs-number">-1</span>; j &gt;= i<span class="hljs-number">-1</span>; j--)<br>        L.elem[j+<span class="hljs-number">1</span>] = L.elem[j];<span class="hljs-comment">// 3 插入位置及以后的元素后移</span><br>    L.elem[i<span class="hljs-number">-1</span>] = e;<span class="hljs-comment">// 4 将新元素e放入第i个位置</span><br>    L.length++;<span class="hljs-comment">// 5 表长增1</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//删除操作</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete_Sq</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span>((i&lt;<span class="hljs-number">1</span>)||(i&gt;L.length)) <span class="hljs-keyword">return</span> ERROR;<span class="hljs-comment">// 1 i值不合法</span><br>    e = L.elem[i];<br>    <span class="hljs-keyword">for</span>(j=i; j&lt;=L.length<span class="hljs-number">-1</span>; j++)<br>        L.elem[j<span class="hljs-number">-1</span>]=L.elem[j]; <span class="hljs-comment">// 2 被删除元素之后的元素前移</span><br>    L.length--; <span class="hljs-comment">// 3 表长减1</span><br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//获取顺序表某一位置上的元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">1</span> || i&gt;L.length)&#123;<br>        <span class="hljs-keyword">return</span> ERROR;<br>    &#125;<br>    e = L.elem[i<span class="hljs-number">-1</span>];<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//顺序表的查找，暂时有点问题</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L,<span class="hljs-type">int</span> e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表中查找值为e的数据元素，返回其序号（是第几个元素）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i++)<br>        <span class="hljs-keyword">if</span>(L.elem[i] == e) <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">//求线性表长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">GetLength</span><span class="hljs-params">(SqList L)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> L.length;<br>&#125;<br><br><span class="hljs-comment">//判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqList L)</span></span>&#123;<br><span class="hljs-keyword">if</span>(L.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">int</span> i, j;<br>    SqList L;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------构造一个空的线性表L------\n&quot;</span>);<br>    <span class="hljs-built_in">InitList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------测试插入10个数------\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= <span class="hljs-number">10</span>; i++)&#123;<br>        <span class="hljs-built_in">ListInsert_Sq</span>(L,i,i);<br>    &#125;<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------在第三位之前插入0------\n&quot;</span>);<br>    <span class="hljs-built_in">ListInsert_Sq</span>(L,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------删除第6位的数据------\n&quot;</span>);<br>    <br>    <span class="hljs-type">int</span> e;<br>    <span class="hljs-built_in">ListDelete_Sq</span>(L,<span class="hljs-number">6</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的数据为：%d\n&quot;</span>, e);<br>    <span class="hljs-built_in">OutPut</span>(L);  <span class="hljs-comment">//打印结果</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------获取元素操作------\n&quot;</span>);<br>    <span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">5</span>,e);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;得到第5个元素：%d\n&quot;</span>, e);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------查找元素操作------\n&quot;</span>);<br>    i = <span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;8在顺序表的序号是：%d\n&quot;</span>, i);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------线性表的长度------\n&quot;</span>);<br>    i = <span class="hljs-built_in">GetLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线性表的长度是：%d\n&quot;</span>, i);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------线性表是否为空------\n&quot;</span>);<br>    i = <span class="hljs-built_in">IsEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线性表是否为空（1空0不空）：%d&quot;</span>, i);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311191256344.png"alt="运行截图" /><figcaption aria-hidden="true">运行截图</figcaption></figure><p>优点</p><ul><li><p>存储密度大(结点本身所占用的空间/结点结构所占存储量)</p></li><li><p>可以随机存取表中任意位置的元素</p></li></ul><p>缺点</p><ul><li><p>插入、删除某一元素需移动大量元素</p></li><li><p>浪费存储空间</p></li><li><p>属于静态存储形式，当线性表长度变化较大时，难以确定存储空间的容量，数据元素的个数不能自由扩充</p></li></ul><h2 id="线性表的链式表示">2.6 线性表的链式表示</h2><p>用一组任意的存储单元存储线性表的数据元素(这组存储单元可以是连续的，也可以是不连续的，甚至是零散的分布在内存的任意位置，链表中元素的逻辑次序与物理次序不一定相同)</p><p>那怎么表示数据元素之间的逻辑关系呢？</p><p>在存储自己内容的同时也存储下一个元素的地址。</p><p>各结点由两个域组成：</p><ul><li>数据域：存储元素数值数据</li><li>指针域：存储直接后继结点的存储位置，指针域中存储的信息称作指针或链。</li></ul><h3 id="链式存储有关的术语">2.6.1 链式存储有关的术语</h3><ol type="1"><li><p>结点: 数据元素的存储映像。由数据域和指针域两部分组成</p></li><li><p>n个结点由指针链组成一个链表，它是线性表的链式存储映像，称为线性表的链式存储结构</p></li><li><p>单链表、双向链表、循环链表</p><ul><li>结点只有一个指针域的链表称为单链表或线性链表</li><li>结点有两个指针域的链表称为双链表</li><li>首尾相接的链表叫循环链表</li></ul></li><li><p>头结点：为了更加方便对链表进行操作，会在单链表的第1个结点前附设一个头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向线性表第1个元素的结点。</p></li><li><p>头指针：指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针;头指针具有标识作用，所以常用头指针冠以链表的名字;无论链表是否为空，头指针均不为空。头指针是链表的必要元素</p></li><li><p>头结点：头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度）有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了头结点不一定是链表必须要素</p></li><li><p>首元结点：是指链表中存储第一个数据元素的结点</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201008349.png"alt="头指针，头结点，首元结点" /><figcaption aria-hidden="true">头指针，头结点，首元结点</figcaption></figure><p>讨论1：表示空表</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201008372.png"alt="如何表示空表" /><figcaption aria-hidden="true">如何表示空表</figcaption></figure><p>讨论2：有头结点有什么好处？</p><ol type="1"><li>便于首元结点的处理首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理</li><li>便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针因此空表和非空表的处理也就统一了</li></ol><blockquote><p>当链表不设头结点时，假设L为单链表的头指针，它应该指向首元结点，则当单链表为长度n为0的空表时，L指针为空（判定空表的条件可记为：L==NULL)。增加头结点后，无论链表是否为空，头指针都是指向头结点的非空指针。头指针指向头结点。若为空表，则头结点的指针域为空（判定空表的条件可记为：L-&gt;next== NULL)</p></blockquote><p>讨论3: 头结点的数据域内装的是什么?</p><p>头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。</p><blockquote><p>顺序表每个元素的存储位置都可从线性表的起始位置计算得到。</p><p>而在单链表中，各个元素的存储位置都是随意的。取得第i个数据元素必须从头指针出发顺链进行寻找，也称为顺序存取的存取结构。</p><p><strong>顺序表是随机存取而链表是顺序存储</strong></p></blockquote><h3 id="单链表的定义和表示">2.6.2 单链表的定义和表示</h3><p>带头节点的单链表</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311211621933.png"alt="带头节点的单链表" /><figcaption aria-hidden="true">带头节点的单链表</figcaption></figure><p>单链表是由若干个结点构成，所以先定义一下结点。每一个结点都是有两部分组成，一部分是数据元素本身(<strong>数据域data</strong>)，其数据类型根据实际问题的需要确定。另一部分是指向下一个元素(结点)的指针(<strong>指针域next</strong>)存放下一个元素的地址，结点可以用C语言中的结构体实现当中包含两个成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*线性表的单链表存储结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;                <br><span class="hljs-comment">// LNode 就表示定义了一个结点，如LNode a，那么可以操作a.data,a.next</span><br><span class="hljs-comment">// LinkList为指向结构体Lnode的指针类型 </span><br><span class="hljs-comment">// 比如头指针，它是指向这种节点的（有数据域有指针域）一个指针，那可以定义为：LNode *L，或者可以LinkList L</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">struct LNode&#123;  </span><br><span class="hljs-comment">    ElemType data;          </span><br><span class="hljs-comment">    struct LNode *next;     </span><br><span class="hljs-comment">&#125;; //这一部分我们是定义了一个结构类型</span><br><span class="hljs-comment">//加上typedef是将这种结构类型重新起了一个名字</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 定义链表L</span><br>LinkList L;  <span class="hljs-comment">//或者LNode *L，通常用LinkList定义单链表，强调定义的是某个单链表的头指针</span><br><span class="hljs-comment">// 定义结点指针p</span><br>LNode *p； <span class="hljs-comment">//或者LinkList p，通常用LNode *定义指向单链表中任意结点的指针变量</span><br><br><br></code></pre></td></tr></table></figure><p>例如，存储学生学号、姓名、成绩的单链表结点类型定义如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span>&#123;<br>    <span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];   <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>];  <span class="hljs-comment">//数据域</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//数据域</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span> *next; <span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311211644294.png"alt="存储学生学号、姓名、成绩的单链表结点示意图" /><figcaptionaria-hidden="true">存储学生学号、姓名、成绩的单链表结点示意图</figcaption></figure><p>为了统一链表的操作，通常这样定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">char</span> num[<span class="hljs-number">8</span>];  <span class="hljs-comment">//数据域</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">8</span>]; <span class="hljs-comment">//数据域</span><br><span class="hljs-type">int</span> score;    <span class="hljs-comment">//数据域</span><br>&#125;ElemType;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span>&#123;<br>    ElenType data;      <span class="hljs-comment">//数据域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Lnode</span> *next; <span class="hljs-comment">//指针域</span><br>&#125;Lnode,*LinkList;<br></code></pre></td></tr></table></figure><h2 id="单链表基本操作的实现带头节点">2.7单链表基本操作的实现（带头节点）</h2><h3 id="单链表的初始化">2.7.1 单链表的初始化</h3><p>[算法步骤]</p><ol type="1"><li><p>生成新结点作为头结点，用头指针L指向头结点。</p></li><li><p>头结点的指针域置空</p></li></ol><p>[算法描述]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//LinkList定义如上</span><br><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode; <span class="hljs-comment">//或者用c语法：L = (LinkList)malloc(sizeof(LNode));(LinkList)是强制类型转换</span><br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点的指针域置空，指针域就是这个指针所指的结点的next域</span><br>    <span class="hljs-comment">//指针变量怎么操作它所指的结点的next的域呢，指针变量要操作某个成员，用-&gt;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="判断是否为空销毁清空">2.7.2 判断是否为空、销毁、清空</h3><p><strong>[补充算法1]</strong></p><p>判断链表是否为空</p><p>空表：链表中没有元素，但头指针和头结点仍存在，只是头结点的指针域为空</p><p>[算法思路]</p><p>判断头结点的指针域是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;  <span class="hljs-comment">//若L为空表返回1，非空返回0</span><br>    <span class="hljs-keyword">if</span>(L-&gt;next)   <span class="hljs-comment">//非空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>[补充算法2]</strong></p><p>单链表的销毁：链表销毁后不存在</p><p>[算法思路]</p><p>从头指针开始，依次释放所有结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//销毁单链表L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    <span class="hljs-keyword">while</span>(L)&#123;<br>        p = L;  <span class="hljs-comment">//从头结点开始</span><br>        L = L -&gt; next;  <span class="hljs-comment">//让一个指针指向下一个结点，L -&gt; next的值就是下一个结点的地址</span><br>        <span class="hljs-keyword">delete</span> p; <br>        <span class="hljs-comment">//c++：L = new LNode，delete p</span><br>        <span class="hljs-comment">//c：L = (LinkList)malloc(sizeof(LNode))，free(p)</span><br>     <br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>[补充算法3]</strong></p><p>清空链表：链表仍然存在，但链表中无元素，成为空链表（头结点和头指针仍然存在）</p><p>[算法思路]</p><p>依次释放所有结点，并将头结点指针域设置为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//将L重置为空表</span><br>    LNode *p,*q;   <span class="hljs-comment">//或者LinkList p,q;</span><br>    p = L -&gt;next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q = p -&gt; next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>        <br>    &#125;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>[补充算法4]</strong></p><p>求单链表的表长</p><p>[算法思路]</p><p>从 首元结点开始，依次计数所有结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(LinkList L)</span></span>&#123;   <span class="hljs-comment">//返回L中数据元素的个数</span><br>    <span class="hljs-comment">//会对表的内容改变用&amp;L，不改变就用L</span><br>    Lnode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    p = L -&gt; next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(p)&#123;<br>        i ++;<br>        p = p -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//类型定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;   <br><br><span class="hljs-comment">//变量定义</span><br>LinkList L;<br>LNode *p,*s;<br><br><span class="hljs-comment">//重要操作</span><br>p = L;  <span class="hljs-comment">//p指向头结点 </span><br>s = L-&gt;next;  <span class="hljs-comment">//s指向首元结点</span><br>p = p-&gt;next;  <span class="hljs-comment">//p指向下一结点</span><br></code></pre></td></tr></table></figure><h3 id="获取单链表某一位置上的元素">2.7.3获取单链表某一位置上的元素</h3><p>【算法步骤】</p><ol type="1"><li>从第1个结点 (L-&gt;next)顺链扫描，用指针p指向当前扫描到的结点，p初值p = L-&gt;next。</li><li>j 做计数器，累计当前扫描过的结点数，j 初值为1</li><li>当 p 指向扫描到的下一结点时，计数器 j 加1</li><li>当 j==i 时，p所指的结点就是要找的第 i 个结点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始条件：L已存在</span><br><span class="hljs-comment">//操作结果：用e返回L中第i个数据元素的值</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p;<br>    p = L-&gt;next;  <span class="hljs-comment">//让p指向链表L的第一个结点</span><br>    j = <span class="hljs-number">1</span>;   <span class="hljs-comment">//j为计数器</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;    <span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//第i个元素不存在</span><br>    e = p -&gt; data;  <span class="hljs-comment">//第i个元素的数据</span><br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的按值查找">2.7.4 单链表的按值查找</h3><p>根据直到数据获取该数据所在的位置（地址）</p><p>【算法步骤】</p><ol type="1"><li>从第1个节点依次与e比较</li><li>如果找到一个与e值相等的数据，则返回在列表中的地址或位置</li><li>如果查遍整个链表都没有找到和e相等的元素，返回0/NULL</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Lnode *<span class="hljs-title">LocateELem_L</span> <span class="hljs-params">(LinkList L, Elemtype e)</span></span>&#123;<br>    <span class="hljs-comment">//在线性表L中查找值为e的数据元素</span><br>    <span class="hljs-comment">//找到，则返回L中值为e的数据元素的地址，查找失败返回NULL</span><br>    p=L-&gt;next;<br>    <span class="hljs-keyword">while</span>(p &amp;&amp; p-&gt;data!=e)<br>        p=p-&gt;next;<br><span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-comment">//代码不是很完整</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在线性表L中查找值为e的数据元素的位置序号</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, Elemtype e)</span></span>&#123;<br>    LinkList p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e) &#123;<br>p = p-&gt;next;<br>        j++;<br>&#125;<br><span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> j; <br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的插入">2.7.5 单链表的插入</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311221629330.png"alt="单链表的插入步骤" /><figcaption aria-hidden="true">单链表的插入步骤</figcaption></figure><blockquote><p>互换后：我指向我自己，ai的地址会丢失</p><p>想互换，可以多加一个指针</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初试条件：L存在</span><br><span class="hljs-comment">//操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    LNode *p,*s;<br>    p=L;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j&lt; i<span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//寻找第i-1个结点</span><br>        p = p -&gt; next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    s = <span class="hljs-keyword">new</span> LNode;<br>    s -&gt; data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> OK;<br>        <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的删除">2.7.6 单链表的删除</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311230918793.png"alt="删除第i个结点" /><figcaption aria-hidden="true">删除第i个结点</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//初始条件：L存在</span><br><span class="hljs-comment">//操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p,*q;<br>    p = L;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">whlie</span>(p-&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//遍历寻找第i-1个元素</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//第i个元素不存在</span><br>    q = p-&gt;next;   <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//q的后继赋值给p的后继</span><br>    e = q-&gt;data;  <span class="hljs-comment">//将q结点中的数据给e</span><br>    <span class="hljs-keyword">delete</span> q;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表的建立">2.7.7 单链表的建立</h3><h4 id="头插法前插法">头插法（前插法）</h4><p>——元素插入在链表头部</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311230958117.png"alt="头插法" /><figcaption aria-hidden="true">头插法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301745948.png"alt="头插法建立单链表" /><figcaption aria-hidden="true">头插法建立单链表</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_L</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    <span class="hljs-keyword">for</span>(i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p-&gt;next = L-&gt;next; <span class="hljs-comment">//插入到表头</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125;<br>    <br></code></pre></td></tr></table></figure><h4 id="尾插法后插法">尾插法（后插法）</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301803598.png"alt="尾插法建立单链表" /><figcaption aria-hidden="true">尾插法建立单链表</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//正位序输入n个元素的值，尾插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *r;<br>    r = L;  <span class="hljs-comment">//尾指针r指向头结点</span><br>    <span class="hljs-keyword">for</span>(i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p -&gt; next = <span class="hljs-literal">NULL</span>;<br>        r -&gt; next = p; <span class="hljs-comment">//插入到表尾</span><br>        r = p; <span class="hljs-comment">//r指向新的尾结点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="单链表小结">※单链表小结</h3><p>下面是在Vscode上写的代码，实现了上面所述的单链表的所有功能</p><p>注意销毁单链表的操作，笨📕这里把它注释掉了，不然还要改，想测试的话可以ctrl+ /</p><p>还要注意在讨论链表的状态时，"链表为空" 和 "链表不存在"是两种不同的情况：</p><ol type="1"><li><strong>链表为空（Linked List is Empty）：</strong>这指的是链表被创建了，但没有添加任何元素，或者之前的元素都被删除了。在这种情况下，链表的头结点存在，但头结点的<code>next</code> 指针为空，没有其他有效的结点。</li><li><strong>链表不存在（Linked List does not exist）：</strong>这指的是链表根本没有被创建。在这种情况下，头结点都没有被分配内存，链表没有被初始化。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TRUE 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FALSE 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> OK 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ERROR 0</span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;   <span class="hljs-comment">//ElemType的类型根据实际情况而定，这里假定为int</span><br><br><br><span class="hljs-comment">/*线性表的单链表存储结构*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;  <span class="hljs-comment">//声明结点的类型和指向结点的指针类型</span><br>    ElemType data;          <span class="hljs-comment">// 结点的数据域       </span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;     <span class="hljs-comment">// 结点的指针域,这里用自己来定义自己</span><br>&#125;LNode,*LinkList;    <br><br><br><br><span class="hljs-comment">// 输出链表中各个结点的元素，区分链表为空和链表不存在</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OutPut</span><span class="hljs-params">(LNode* p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表不存在（已被销毁\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (p-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表为空\n&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    p = p-&gt;next;<br>    <span class="hljs-keyword">while</span> (p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);<br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">//初始化</span><br><span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode; <span class="hljs-comment">//或者用c语法：L = (LinkList)malloc(sizeof(LNode));(LinkList)是强制类型转换</span><br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//头结点的指针域置空，指针域就是这个指针所指的结点的next域</span><br>    <span class="hljs-comment">//指针变量怎么操作它所指的结点的next的域呢，指针变量要操作某个成员，用-&gt;</span><br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-comment">//头插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_L</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *p;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;   <span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data); <span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p-&gt;next = L-&gt;next; <span class="hljs-comment">//插入到表头</span><br>        L-&gt;next = p;<br>    &#125;<br>&#125; <br><br><span class="hljs-comment">//尾插法创建单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    L = <span class="hljs-keyword">new</span> LNode;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">//先建立一个带头结点的单链表</span><br>    LNode *r,*p;<br>    r = L;  <span class="hljs-comment">//尾指针r指向头结点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n; i&gt;<span class="hljs-number">0</span>; --i)&#123;<br>        p = <span class="hljs-keyword">new</span> LNode;<span class="hljs-comment">//生成新结点，c语言是：p = (LNode*)malloc(sizeof(LNode))</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;p-&gt;data);<span class="hljs-comment">// c++是 cin&gt;&gt;p-&gt;data;</span><br>        p -&gt; next = <span class="hljs-literal">NULL</span>;<br>        r -&gt; next = p; <span class="hljs-comment">//插入到表尾</span><br>        r = p; <span class="hljs-comment">//r指向新的尾结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 尾插法，在已经插入的基础上进行</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateList_R2</span><span class="hljs-params">(LinkList  &amp;L, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    LNode *r = L;  <span class="hljs-comment">// 尾指针r指向头结点</span><br><br>    <span class="hljs-comment">// 找到链表的尾节点</span><br>    <span class="hljs-keyword">while</span> (r-&gt;next) &#123;<br>        r = r-&gt;next;<br>    &#125;<br><br>    LNode *p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        p = <span class="hljs-keyword">new</span> LNode;  <span class="hljs-comment">// 生成新结点</span><br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;p-&gt;data);  <span class="hljs-comment">// 读取数据</span><br>        p-&gt;next = <span class="hljs-literal">NULL</span>;<br>        r-&gt;next = p;  <span class="hljs-comment">// 插入到尾部</span><br>        r = p;  <span class="hljs-comment">// r指向新的尾结点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//判断是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;  <span class="hljs-comment">//若L为空表返回1，非空返回0</span><br>    <span class="hljs-keyword">if</span>(L-&gt;next)   <span class="hljs-comment">//非空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//销毁单链表</span><br><span class="hljs-function">Status <span class="hljs-title">DestoryList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//销毁单链表L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    <span class="hljs-keyword">while</span>(L)&#123;<br>        p = L;  <span class="hljs-comment">//从头结点开始</span><br>        L = L -&gt; next;  <span class="hljs-comment">//让一个指针指向下一个结点，L -&gt; next的值就是下一个结点的地址</span><br>        <span class="hljs-keyword">delete</span> p; <br>        <span class="hljs-comment">//c++：L = new LNode，delete p</span><br>        <span class="hljs-comment">//c：L = (LinkList)malloc(sizeof(LNode))，free(p)</span><br>     <br>    &#125;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//清空单链表</span><br><span class="hljs-function">Status <span class="hljs-title">ClearList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;  <span class="hljs-comment">//将L重置为空表</span><br>    LNode *p,*q;   <span class="hljs-comment">//或者LinkList p,q;</span><br>    p = L -&gt;next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-keyword">while</span>(p)&#123;<br>        q = p -&gt; next;<br>        <span class="hljs-keyword">delete</span> p;<br>        p = q;<br>        <br>    &#125;<br>    L -&gt; next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><span class="hljs-comment">//求链表的表长</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(LinkList L)</span></span>&#123;   <span class="hljs-comment">//返回L中数据元素的个数</span><br>    <span class="hljs-comment">//会对表的内容改变用&amp;L，不改变就用L</span><br>    LNode *p;   <span class="hljs-comment">//或者LinkList p</span><br>    p = L -&gt; next;  <span class="hljs-comment">//p指向第一个结点</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">while</span>(p)&#123;<br>        i ++;<br>        p = p -&gt; next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br><br><br><br><span class="hljs-comment">//获取单链表某一位置上的元素</span><br><span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L,<span class="hljs-type">int</span> i,ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p;<br>    p = L-&gt;next;  <span class="hljs-comment">//让p指向链表L的第一个结点</span><br>    j = <span class="hljs-number">1</span>;   <span class="hljs-comment">//j为计数器</span><br>    <span class="hljs-keyword">while</span>(p &amp;&amp; j&lt;i)&#123;    <span class="hljs-comment">//向后扫描，直到p指向第i个元素或p为空</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j&gt;i) <span class="hljs-keyword">return</span> ERROR;   <span class="hljs-comment">//第i个元素不存在</span><br>    e = p -&gt; data;  <span class="hljs-comment">//第i个元素的数据</span><br>    <span class="hljs-keyword">return</span> OK;<br>    <br>&#125;<br><br><span class="hljs-comment">//单链表的按值查找</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> e)</span></span>&#123;<br>    LinkList p = L-&gt;next;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (p &amp;&amp; p-&gt;data != e) &#123;<br>p = p-&gt;next;<br>        j++;<br>&#125;<br>    <span class="hljs-keyword">if</span> (p) <span class="hljs-keyword">return</span> j; <br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><br><span class="hljs-comment">//单链表的插入</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(LinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    LNode *p,*s;<br>    p=L;<br>    <span class="hljs-keyword">while</span> (p &amp;&amp; j&lt; i<span class="hljs-number">-1</span>)&#123;  <span class="hljs-comment">//寻找第i-1个结点</span><br>        p = p -&gt; next;<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!p || j &gt; i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR;<br>    s = <span class="hljs-keyword">new</span> LNode;<br>    s -&gt; data = e;<br>    s-&gt;next = p-&gt;next;<br>    p-&gt;next=s;<br>    <span class="hljs-keyword">return</span> OK;<br>        <br>&#125;<br><br><br><span class="hljs-comment">//单链表的删除</span><br><span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(LinkList &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    LNode *p,*q;<br>    p = L;<br>    j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(p-&gt;next &amp;&amp; j&lt;i<span class="hljs-number">-1</span>)&#123; <span class="hljs-comment">//遍历寻找第i-1个元素</span><br>        p = p-&gt;next;<br>        ++j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!(p-&gt;next) || j&gt;i<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> ERROR; <span class="hljs-comment">//第i个元素不存在</span><br>    q = p-&gt;next;   <span class="hljs-comment">//临时保存被删结点的地址以备释放</span><br>    p-&gt;next = q-&gt;next; <span class="hljs-comment">//q的后继赋值给p的后继</span><br>    e = q-&gt;data;  <span class="hljs-comment">//将q结点中的数据给e</span><br>    <span class="hljs-keyword">delete</span> q;<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> empty;<br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//存储从单链表中获取的某一位置上的元素</span><br>    <span class="hljs-type">int</span> n; <span class="hljs-comment">//存储某一元素在单链表中的位置</span><br>    <span class="hljs-type">int</span> a; <span class="hljs-comment">//删除操作中删除的那个元素的值</span><br><br>    LinkList L;<br>    <span class="hljs-comment">//构造单链表</span><br>    <span class="hljs-built_in">InitList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------头插法5个数------\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_L</span>(L,<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);  <br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------清空单链表------\n&quot;</span>);<br>    <span class="hljs-built_in">ClearList</span>(L);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    empty = <span class="hljs-built_in">isEmpty</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;判断是否为空(1空0非空)：%d&quot;</span>,empty);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------尾插法6个数------\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_R</span>(L,<span class="hljs-number">6</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    length = <span class="hljs-built_in">ListLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表的长度为：%d&quot;</span>,length);<br><br>    <span class="hljs-comment">// printf(&quot;------销毁单链表------\n&quot;);</span><br>    <span class="hljs-comment">// DestoryList(L);</span><br>    <span class="hljs-comment">// OutPut(L);</span><br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n----用尾插法，在前面插入的基础上再插入3个数----\n&quot;</span>);<br>    <span class="hljs-built_in">CreateList_R2</span>(L,<span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    length = <span class="hljs-built_in">ListLength</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;链表的长度为：%d&quot;</span>,length);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------获取单链表某一位置上的元素------\n&quot;</span>);<br>    <span class="hljs-built_in">GetElem</span>(L,<span class="hljs-number">3</span>,m);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;第三个元素的值为：%d&quot;</span>,m);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------获取某一元素在单链表中的位置------\n&quot;</span>);<br>    n = <span class="hljs-built_in">LocateElem</span>(L,<span class="hljs-number">88</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;88的位置为：%d&quot;</span>,n);<br><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------单链表的插入------\n&quot;</span>);<br>    <span class="hljs-built_in">ListInsert</span>(L,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">OutPut</span>(L);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------单链表的删除------\n&quot;</span>);<br>    <span class="hljs-built_in">ListDelete</span>(L,<span class="hljs-number">1</span>,a);<br>    <span class="hljs-built_in">OutPut</span>(L);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的第一个位置上的元素为：%d&quot;</span>,a);<br>&#125;<br><span class="hljs-comment">//虽然什么都没干，但还是忙死我了😎</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301926438.png"alt="单链表的所有操作总结" /><figcaption aria-hidden="true">单链表的所有操作总结</figcaption></figure><h2 id="循环链表">2.8 循环链表</h2><p>循环链表是头尾相接的链表(即表中最后一个结点的指针域指向头结点，整个链表形成一个环(circularlinked list)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301931444.png"alt="循环链表" /><figcaption aria-hidden="true">循环链表</figcaption></figure><p>优点：从表中任一结点出发均可访问全部结点</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301932054.png"alt="image-20231130193234977" /><figcaption aria-hidden="true">image-20231130193234977</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301932891.png"alt="image-20231130193247819" /><figcaption aria-hidden="true">image-20231130193247819</figcaption></figure><p>如果我们经常要操作首尾结点，用尾指针更方便</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301935244.png"alt="image-20231130193518153" /><figcaption aria-hidden="true">image-20231130193518153</figcaption></figure><p>带尾指针循环链表的合并(将Tb合并在Ta之后)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301940915.png"alt="image-20231130194030814" /><figcaption aria-hidden="true">image-20231130194030814</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">LinkList <span class="hljs-title">Connect</span><span class="hljs-params">(LinkList Ta, LinkList Tb)</span></span>&#123;<br>    LNode *ptr;<br>    <br>    p = Ta-&gt;next;    <span class="hljs-comment">//p保存 Ta 的头结点</span><br>    Ta-&gt;next = Tb-&gt;next-&gt;next;    <span class="hljs-comment">//Tb表头链接Ta表尾</span><br>    <span class="hljs-keyword">delete</span> Tb-&gt;next;    <span class="hljs-comment">//释放 Tb 的头结点</span><br>    Tb-&gt;next = p;    <span class="hljs-comment">//修改 Tb 尾结点的后继为 Ta 的头结点</span><br><br>    <span class="hljs-keyword">return</span> Tb;    <span class="hljs-comment">//返回合并后的头结点</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="双向链表">2.9 双向链表</h2><h3 id="双向链表-1">2.9.1 双向链表</h3><p>单链表的结点<code>---&gt;</code>有指示后继的指针域<code>---&gt;</code>找后继结点方便；</p><p>即：查找某结点的后继结点的执行时间为 O(1)</p><p><code>---&gt;</code>无指示前驱的指针域<code>---&gt;</code>找前驱结点难:从表头出发查找</p><p>即：查找某结点的前驱结点的执行时间为 O(n)</p><p>为了克服单链表的这一缺点，设计了双向链表(double linked list)，</p><p>双向链表是在单链表的每个结点中再设计一个指向其前驱结点的指针域。所以在双向链表中的结点有两个指针域，一个指向直接后继，另一个指向直接前驱。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301952903.png"alt="双向链表结点结构" /><figcaption aria-hidden="true">双向链表结点结构</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双向链表的存储结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span>&#123;<br>    ElemType data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *prior;    <span class="hljs-comment">//前驱指针域</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DuLNode</span> *next;    <span class="hljs-comment">//后继指针域</span><br>&#125;DuLNode,*DuLinkList;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301952720.png"alt="双向链表的存储结构" /><figcaption aria-hidden="true">双向链表的存储结构</figcaption></figure><h3 id="双向循环链表">2.9.2 双向循环链表</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311301954974.png"alt="image-20231130195409888" /><figcaption aria-hidden="true">image-20231130195409888</figcaption></figure><p>双向链表结构有对称性(设指针p指向某一个结点)<code>p-&gt;prior-&gt;next = p = p-&gt;next-&gt;prior</code>(前进一步后退一步相当于原地踏步)</p><p>在双向链表中有些操作(ListLength，GetElemment)等因为只涉及一个方向的指针，他们的算法与线性表的相同。</p><p>但在插入和删除需要修改两个方向上的指针，两者的算法复杂度均为O(n)</p><h3 id="双向链表的插入">2.9.3 双向链表的插入</h3><p>其实双向链表的结构是下面这样的：</p><p>上面的那种经典教程中的经典结构我个人认为有点有失偏颇，会在一定程度上误导我这种笨学生</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302013225.png"alt="双向链表的结构" /><figcaption aria-hidden="true">双向链表的结构</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302015995.png"alt="双向链表的插入" /><figcaption aria-hidden="true">双向链表的插入</figcaption></figure><p>同时这里王卓老师讲的双向链表的插入可以用上面那种结构自己画一下示意图，会更好的理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//或者void ListInsert_DuL(DuLinkList &amp;L,int i,ElemType e)&#123;&#125;</span><br><span class="hljs-function">Status <span class="hljs-title">ListInsert_DuL</span><span class="hljs-params">(DuLinkList &amp;L,<span class="hljs-type">int</span> i,ElemType e)</span></span>&#123;<br><span class="hljs-comment">//在带头结点的双向链表中第i个位置之前插入元素 e</span><br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;  <span class="hljs-comment">//在L中确定第 i个元素的位置指针 p，p为 NULL时，第i个元素不存在</span><br>    s = <span class="hljs-keyword">new</span> DuLNode;  <span class="hljs-comment">//生成新结点*s</span><br>    s-&gt;data=e;   <span class="hljs-comment">//将结点*s 数据域置为 e</span><br>    s-&gt;prior = p-&gt;prior;   <span class="hljs-comment">//将结点*s 插人L中，对应上图中①</span><br>    p-&gt;prior-&gt;next = s;  <span class="hljs-comment">//对应上图中②</span><br>    s-&gt;next = p;   <span class="hljs-comment">//对应上图中③</span><br>    p-&gt;prior = s;   <span class="hljs-comment">//对应上图中④</span><br>   <br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双向链表的删除">2.9.4 双向链表的删除</h3><p>假设要删除双向链表的结点 ptr，只需要把 ptr结点的前驱和后继安排明白即可。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302023648.png"alt="双向链表的删除" /><figcaption aria-hidden="true">双向链表的删除</figcaption></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ListDelete_DuL</span><span class="hljs-params">(DuLink &amp;L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span> </span>&#123;<br>    <span class="hljs-comment">// 删除带头结点的双向循环链表 L 的第 i个元素，并用 e 返回</span><br>    <span class="hljs-keyword">if</span>(!(p=<span class="hljs-built_in">GetElem_DuL</span>(L,i))) <span class="hljs-keyword">return</span> ERROR;<br>    e = p -&gt; data;<br>p -&gt; prior -&gt; next = p -&gt; next;<br>    p -&gt; next -&gt; prior = p -&gt; prior;<br>    <span class="hljs-built_in">free</span>(p);<br>    <span class="hljs-keyword">return</span> OK;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="顺序表和链表的比较">2.10 顺序表和链表的比较</h2><p>链式存储结构的优点：</p><ul><li>结点空间可以动态申请和释放；</li><li>数据元素的逻辑次序靠结点的指针来指示，插入和删除不需要移动元素。</li></ul><p>链式存储结构的缺点：</p><ul><li>存储密度小，每个结点的指针域需额外占用存储空间。当每个结点的数据域所占的字节数不多时，指针域所占的存储空间的比重显得很大。存储密度是指结点数据本身占用的空间/结点占用的空间总量</li><li>链式存储结构是非随机存取结构。对任一结点的操作都要从头指针依指针链查找到该结点，这增加了算法的复杂度。(对某个结点操作一般要先找到该结点)</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302125275.png"alt="存储密度的概念" /><figcaption aria-hidden="true">存储密度的概念</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302125600.png"alt="存储密度的例子" /><figcaption aria-hidden="true">存储密度的例子</figcaption></figure><p>顺序表和链表的比较</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311302127947.png"alt="顺序表和链表的比较" /><figcaption aria-hidden="true">顺序表和链表的比较</figcaption></figure><h2 id="应用">*2.11 应用</h2><blockquote><p>ptr -- pointer （即指针）的缩写。</p><p>参考资料：</p><p><ahref="https://www.cnblogs.com/linfangnan/p/12316614.html">数据结构：链表结构和例题详解- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.zhihu.com/tardis/zm/art/421431276?source_id=1005">LinkListL、LinkList&amp; L、和LinkList *L这三者的区别 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/529817686">关于linklist L和linklist &amp;L的区别 - 知乎 (zhihu.com)</a></p><p><ahref="https://www.bilibili.com/read/readlist/rl241105?share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1615722826&amp;unique_k=376Uh5">数据结构-文集 哔哩哔哩专栏 (bilibili.com)</a></p><p><ahref="https://blog.csdn.net/Real_Fool_/article/details/113463997?ops_request_misc=%7B%22request%5Fid%22%3A%22169897557216800211564576%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169897557216800211564576&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-113463997-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=线性表&amp;spm=1018.2226.3001.4187">数据结构：线性表(List)【详解】-CSDN博客</a></p><p><ahref="http://data.biancheng.net/view/161.html">链表的基本操作（C语言）详解(biancheng.net)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 图</title>
    <link href="/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/"/>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图结构常用来存储逻辑关系为“多对多”的数据。比如说，一个学生可以同时选择多门课程，而一门课程可以同时被多名学生选择，学生和课程之间的逻辑关系就是“多对多”。</p></blockquote><h2 id="图的基本概念">图的基本概念</h2><h3 id="弧头和弧尾">1、弧头和弧尾</h3><p>有向图中，无箭头一端的顶点通常被称为"初始点"或"弧尾"，箭头一端的顶点被称为"终端点"或"弧头"。</p><h3 id="入度和出度">2、入度和出度</h3><p>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V的出度（OutDegree，记为OD(V)）。</p><h3 id="v1v2-和-v1v2-的区别">3、(V1,V2) 和 &lt;V1,V2&gt; 的区别</h3><p>无向图中描述两顶点 V1 和 V2 之间的关系可以用 <code>(V1, V2)</code>来表示；有向图中描述从 V1 到 V2 的"单向"关系可以用<code>&lt;V1,V2&gt;</code> 来表示。</p><p>由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2)还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt;也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。</p><h3 id="集合-vr">4、集合 VR</h3><p>图中习惯用 VR表示图中所有顶点之间关系的集合。例如，下图中有向图的集合<code>VR=&#123;&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;&#125;</code>。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101725825.png"alt="image-20231110172523787" /><figcaption aria-hidden="true">image-20231110172523787</figcaption></figure><h3 id="路径和回路">5、路径和回路</h3><p>无论是无向图还是有向图，从一个顶点到另一顶点途经的所有顶点组成的序列（包含这两个顶点），称为一条<strong>路径</strong>。如果路径中第一个顶点和最后一个顶点相同，则此路径称为<strong>"回路"</strong>（或<strong>"环"</strong>）。</p><p>在此基础上，若路径中各顶点都不重复，此路径被称为"简单路径"；若回路中的顶点互不重复，此回路被称为"简单回路"（或简单环）。</p><p>拿上图来说，从 V1 存在一条路径还可以回到 V1，此路径为<code>&#123;V1,V3,V4,V1&#125;</code>，这是一个回路（环），而且还是一个简单回路（简单环）。</p><blockquote><p>在有向图中，每条路径或回路都是有方向的。</p></blockquote><h3 id="权和网">6、权和网</h3><p>有些场景中，可能会为图中的每条边赋予一个实数表示一定的含义，这种与边（或弧）相匹配的实数被称为"权"，而<strong>带权的图</strong>通常称为<strong>网</strong>。例如，下图就是一个网结构：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101727237.png"alt="image-20231110172730210" /><figcaption aria-hidden="true">image-20231110172730210</figcaption></figure><h3 id="子图">7、子图</h3><p>指的是由图中一部分顶点和边构成的图，称为原图的子图。</p><h2 id="图存储结构的分类">图存储结构的分类</h2><p>根据不同的特征，图又可细分为完全图，连通图，稀疏图和稠密图：</p><ul><li><p>完全图：若图中各个顶点都与除自身外的其他顶点有直接关系，这样的无向图称为<strong>完全图</strong>（如图5a)）。同时，满足此条件的有向图则称为<strong>有向完全图</strong>（图5b)）。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101728235.gif"alt="完全图示意图" /><figcaption aria-hidden="true">完全图示意图</figcaption></figure><blockquote><p>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n个顶点的有向完全图，图中弧的数量为 n(n-1)。</p></blockquote></li><li><p>稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。</p><blockquote><p>稀疏和稠密的判断条件是：e&lt;nlogn，其中 e表示图中边（或弧）的数量，n表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p></blockquote></li></ul><h2 id="连通图">连通图</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 查找</title>
    <link href="/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="哈希表">哈希表</h2><p>哈希表查找：通过关键字值进行某种运算，直接求出记录文件的地址，是关键字到地址的直接转换方法，不需反复比较。</p><p>两个问题：</p><ul><li>如何构造哈希（或散列）函数？</li><li>如何解决冲突？</li></ul><p>哈希函数是一个映像，使得： Addr(<spanclass="math inline">\(R_i\)</span>)=H(<spanclass="math inline">\(key_i\)</span>) 其中：</p><ul><li><span class="math inline">\(key_i\)</span>为记录<spanclass="math inline">\(R_i\)</span>的关键字；</li><li>H(<span class="math inline">\(key_i\)</span>)为哈希函数；</li><li>Addr(<span class="math inline">\(R_i\)</span>)为记录<spanclass="math inline">\(R_i\)</span>的存储地址</li><li>冲突：对不同的关键字可能得到同一哈希地址。</li></ul><h3 id="哈希函数的构造方法">哈希函数的构造方法</h3><p>目标：使关键字经过哈希函数得到一个“随机地址”，以便使一组关键字的哈希地址均匀分布在整个地址区间中，减少冲突。</p><h4 id="直接定址法">直接定址法</h4><p>H(key)=a.key+b 其中：a,b为常数</p><p>不同的关键字不会发生冲突，但在记录长度不等的情况下浪费一些存储空间。</p><h4 id="数字分析法">数字分析法</h4><p>假设有一组关键字，每个关键字由n位数字组成，如：k1k2…kn,从中提取数字分布比较均匀的若干位作为哈希地址。</p><p><strong>平方取中法</strong>：取关键字平方后的中间几位哈希地址例：</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深信服学习</title>
    <link href="/2023/11/10/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/10/%E6%B7%B1%E4%BF%A1%E6%9C%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一些不知道到底有没有的学习内容</p><p>⚽⚽⚽</p></blockquote><p>Linux系统使用（ ）命令更改文件权限。</p><p>chmod</p><p>Linux系统使用（ ）命令更改文件所有者。</p><p>chown</p><p>Linux系统使用（ ）命令从最后一行开始向前显示文件</p><p>tac</p><p>Linux系统使用cat命令时，使用（ ）选项可以显示行号。</p><p>n</p><p>Linux系统使用（ ）命令可以动态查看到文件的实时更新的信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -f<br></code></pre></td></tr></table></figure><h2 id="linux文件目录及权限实验">Linux文件目录及权限实验</h2><h3 id="实验目的">实验目的：</h3><p>通过实验加深对linux文件目录的理解 掌握Linux下ls、pwd、cd等命令用法理解linux文件和文件夹权限配置</p><h3 id="实验环境">实验环境：</h3><p>一台Linux服务器</p><h3 id="实验原理">实验原理</h3><p>通过实际操作，加深对Linux操作系统基本操作的理解</p><h3 id="实验步骤">实验步骤</h3><p>一、查看linux 根目录下的文件夹，理解并记住文件夹对应的用途 命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201120160.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>二、新建目录和文件 1、新建目录</p><p>使用mkdir命令新建文件夹，这里文件夹名为wenjianjian</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">mkdir wenjianjian<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121518.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>2、新建文件 使用touch命令新建文件，这里文件名为wenjian</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span>  wenjian<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121563.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>3、查看刚才新建的文件夹和文件 使用ls 命令即可</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121550.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>进一步查看详细信息，使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure><p><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121540.png"alt="image.png" /> <strong>以 d 开头</strong>的行，表示文件夹 <strong>以- 开头</strong>的行，表示文件</p><p>三、学会查看与修改当前目录</p><p>1、查看当前目录</p><p>linux用户登录进系统后，默认会在用户的家目录。root用户的家目录就是/root。</p><p>使用pwd命令，查看当前所处的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">pwd</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121559.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>2、切换不同目录 比如进入日志存放目录/var/log</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121532.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>四、理解相对路径与绝对路径</p><p>1、绝对路径</p><p>绝对路径是Linux操作系统对某一目录从根目录开始的完整且唯一表示，如/var/log目录</p><p>绝对路径是完整的且严谨的</p><p><strong>绝对路径的起点是以 /开始（即根目录开始），或者理解为绝对路径的参照物是根目录</strong></p><p>比如，我们从/var/log 进入日志文件的审计日志目录</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> /<span class="hljs-keyword">var</span>/<span class="hljs-keyword">log</span>/audit<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121409.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>2、相对路径</p><p>相对路径的起点是当前的工作目录，即用pwd显示的路径，当前工作目录也可以用点. 表示</p><p>还是刚才的例子，我们从/var/log 进入日志文件的审计日志目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> audit<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121194.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong><em>或者</em></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ./audit<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121249.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>五、复制文件</p><p>复制文件我们使用cp 命令，命令格式如下：</p><p>cp 源文件路径 目标文件路径</p><p>复制/var/log/audit/audit.log 日志文件到/root/audit.log，有以下几种写法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">完整写法<br>cp <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/audit/</span>audit.log   <span class="hljs-regexp">/root/</span>audit.log1<br>相对路径写法<br>cp  audit.log<span class="hljs-regexp">/root/</span>audit.log2<br>目标文件保持源文件名不变写法<br>cp  audit.log    <span class="hljs-regexp">/root/</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121299.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>六、删除文件</p><p>删除文件我们使用rm命令,<strong><em>注意删除命令执行后，会弹出提示，是否删除，我们按Y表示确定删除</em></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm  <span class="hljs-regexp">/root/</span>audit.log<br></code></pre></td></tr></table></figure><p>七、修改文件权限 先查看/root/audit.log1的权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ls  -l  <span class="hljs-regexp">/root/</span>audit.log1<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121361.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>修改/root/audit.log1的权限为400，即root用户可以读取，其它用户无法读写执行</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121461.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>八、修改文件所有者</p><p>先查看文件/root/audit.log1的所有者，为root <imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121574.png"alt="image.png" /></p><p>修改所有者为mail用户 chown mail:mail /root/audit.log1</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201121673.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="实验小结">实验小结：</h3><p>学会Linux的基本文件、文件夹、权限等操作，加深理解</p><h2 id="linux文本编辑实验">Linux文本编辑实验</h2><h3 id="实验目的-1">实验目的：</h3><p>通过实验加深对linux下文本编辑工具vim的使用，重点为理解vim的三种模式</p><h3 id="实验环境-1">实验环境：</h3><p>一台Linux服务器</p><h3 id="实验原理-1">实验原理</h3><p>通过实际操作，加深对Linux操作系统基本操作的理解，vim三种模式的切换如下图</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502330.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h3 id="实验步骤-1">实验步骤</h3><p>首先需要检查系统中是否已经安装了vim,如果未安装，请执行安装命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> vim -y<br></code></pre></td></tr></table></figure><h4 id="一使用vim新建文件">一、使用vim新建文件</h4><p>使用vim 新建名为test.test的文件，命令如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">vim <span class="hljs-keyword">test</span>.<span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502319.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="二在新建文件中输入内容">二、在新建文件中输入内容</h4><p>1、vim打开文件后，默认在命令模式，需要进入输入模式才能输入文件</p><p>使用字母 “i” 进入输入模式</p><p>按下字母i后，发现最下面提示变成INSERT，即输入模式（也叫插入模式）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502587.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>2、输入内容，如 Hello Sangfor 2021！</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502313.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="三保存文件并退出">三、保存文件并退出</h4><p>保存并退出文件，需要在底行模式下执行，而我们当前在输入模式</p><p>从输入模式进入底行模式，需要先返回命令模式，再进入底行模式</p><p>输入模式返回命令模式，按下按键“ESC”（ 键盘最左上角)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502326.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>从命令模式进入底按模式，按下“:” (shitf+字母L右边第一个)</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502340.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>保存并退出指令是wq ,其中w表示保存write，q表示退出quit</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502796.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>保存退出后，会有简单提示</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311201502841.png"alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>实验二、 使用/etc/dnsmasq.conf 文件完成以下操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cp <span class="hljs-regexp">/etc/</span>dnsmasq.conf  <span class="hljs-regexp">/tmp/</span><span class="hljs-number">1</span>.txt     <span class="hljs-regexp">//</span>复制文件，用于实践<br></code></pre></td></tr></table></figure><p>完成以下操作</p><p>为了便于理解，显示行号操作， 底行模式 :set nu回车</p><p>将光标分别下、右、左、上移动6个字符（命令模式 6j 6l 6h 6k ）将光标向下、向上翻两页（命令模式 CTRL+F按两次，CTRL+B按两次）将光标移到第54行（命令模式 54G）将光标移动到行尾，再移动到行首（命令模式 行尾：$即SHIFT+4 行首^即SHIFT+6） 将光标移动到文件最后一行 (命令模式 G) 将光标移动到文件第一行（命令模式 gg ） 搜索全文中dnsmasq字符串，并数一下有多少个 （命令模式/dnsmasq，按n进行下一个查找） 将1到10行中的dnsmasq替换成dns (底行模式:1,10s/dnsmasq/dns/g) 还原刚才的操作 （命令模式： u） 删除第50行（命令模式： 50G dd） 删除37到42行 （命令模式： 37G 6dd）复制48行，并粘贴到50行下面 （48G yy 50G p） 保存文件并退出（先按ESC 再:wq）</p><h3 id="实验小结-1">实验小结：</h3><p>加强对vim的应用与理解</p>]]></content>
    
    
    
    <tags>
      
      <tag>深信服</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 3 运算符</title>
    <link href="/2023/11/08/Java%203%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/11/08/Java%203%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p></blockquote><h2 id="算数运算符">3.1 算数运算符</h2><blockquote><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java程序中使用得非常多。其运算结果是一个数值量。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081107099.png"alt="image-20231108110732994" /><figcaption aria-hidden="true">image-20231108110732994</figcaption></figure><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code>：加（正）、减（负）、乘、除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticOperator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//从数学来看是 2.5, java 中 2</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//java 是 2.5</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">4</span>;    <span class="hljs-comment">//java 中 10 / 4 = 2, 2=&gt;2.0</span><br>System.out.println(d);<span class="hljs-comment">// 是 2.0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>%</code>：取模（求余数），结果和被取模数同号。本质是一个公式:<code>a % b == a - a / b * b;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1</span><br><span class="hljs-comment">// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span><br><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">// -1</span><br>System.out.println(<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>);<span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure></li><li><p><code>++</code> ：自增。</p><ul><li>作为独立的语句使用,<code>++i</code>和<code>i++</code>都完全等价于<code>i = i + 1</code></li><li>作为表达式使用:<code>++i</code> 先自增后赋值；<code>i++</code>先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//++的使用</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>i++;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 11</span><br>++i;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 12</span><br>System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<span class="hljs-comment">//12</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j; <span class="hljs-comment">//等价 j=j+1;k=j;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//9  9</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++; <span class="hljs-comment">// 等价 k=j;j=j+1;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//8 9</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>练习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//i-&gt;1</span><br>i = i++; <span class="hljs-comment">//规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">// 1</span><br><br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>i=++i; <span class="hljs-comment">//规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">//2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i1++;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//10</span><br>i = --i2;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//19</span><br>System.out.println(<span class="hljs-string">&quot;i2=&quot;</span>+i2); <span class="hljs-comment">//19</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符比较运算符">3.2 关系运算符（比较运算符）</h2><blockquote><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code>要么是 <code>false</code>。其关系表达式经常用在 <code>if</code>结构的条件中或循环结构的条件中。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081136572.png"alt="image-20231108113644487" /><figcaption aria-hidden="true">image-20231108113644487</figcaption></figure><h3 id="使用细节">3.2.1 使用细节</h3><ol type="1"><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>ture</code>，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li></ol><h2 id="逻辑运算符">3.3 逻辑运算符</h2><blockquote><p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code> 值。</p></blockquote><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code>同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于<code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则<code>b</code> 不判断。而 <code>&amp;</code> 会完成判断。开发中多用<code>&amp;&amp;</code> ，因为其效率更高。</p></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code>相似，若第一个为 <code>ture</code> ，则 <code>||</code>不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为<code>ture</code>，则结果为 <code>false</code>。反之为<code>ture</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code>不同，结果为 <code>ture</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符">3.4 赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>复合赋值运算符：<code>+=</code> ; <code>-=</code> ;<code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1">3.4.1 使用细节</h3><ol type="1"><li><p>运算顺序从右往左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> a + b + c;<span class="hljs-comment">// 先运行(a + b + c)，再结算int num =</span><br></code></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; b += <span class="hljs-number">3</span>;<span class="hljs-comment">// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br>b++;<span class="hljs-comment">// 同理</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="三元运算符">3.5 三元运算符</h2><blockquote><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code>，运算的结果是表达式1；反之为表达式2。</p><p>口诀------一眼顶真</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-comment">// 解读</span><br><span class="hljs-comment">// 1. a &gt; b 为 false</span><br><span class="hljs-comment">// 2. 返回 b--, 先返回 b 的值,然后再 b-1</span><br><span class="hljs-comment">// 3. 返回的结果是 99</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : b--;<br>System.out.println(<span class="hljs-string">&quot;result=&quot;</span> + result); <span class="hljs-comment">//99</span><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a); <span class="hljs-comment">//10</span><br>System.out.println(<span class="hljs-string">&quot;b=&quot;</span> + b); <span class="hljs-comment">//98</span><br></code></pre></td></tr></table></figure><h3 id="使用细节-2">3.5.1 使用细节</h3><ol type="1"><li><p>表达式1 和 表达式2要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a &gt; b ? (<span class="hljs-type">int</span>)<span class="hljs-number">1.1</span> : (<span class="hljs-type">int</span>)<span class="hljs-number">3.4</span>;<span class="hljs-comment">//可以的</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a &gt; b ? a : b + <span class="hljs-number">3</span>;<span class="hljs-comment">//可以的，满足 int -&gt; double</span><br></code></pre></td></tr></table></figure></li><li><p>三元运算符可以转成 <code>if--else</code></p></li></ol><h2 id="运算符优先级">3.6 运算符优先级</h2><p><a href="https://c.biancheng.net/view/794.html">Java运算符优先级(biancheng.net)</a></p><h2 id="标识符">3.7 标识符</h2><blockquote><p>Java 对各种变量、方法和类等命名时使用的字符序列称为标识符</p><p>凡是自己可以起名字的地方都叫标识符<code>double height = 0.0;</code></p></blockquote><h3 id="命名规则">3.7.1 命名规则</h3><ol type="1"><li>标识符由 26 个大、小写英文字母，0 - 9 阿拉伯数字，_ 或 $符号组成。</li><li><strong>数字不能开头</strong>。错误示范：<code>int 3a = 1;</code></li><li>不能使用关键字和保留字（可以包含）。<ahref="https://www.w3schools.cn/java/java_ref_keywords.asp">Java 关键字(w3schools.cn)</a></li><li>严格区分大小写，长度无限制。</li><li>不能包含空格。</li><li>与多数编程语言不同。Java 可以用任何 Unicode字符（特殊字符除外）作为标识符。但不推荐这么做|</li></ol><h3 id="命名规范专业">3.7.2 命名规范(专业)</h3><ol type="1"><li>包名：多单词组成时所有字母都小写：aaa.bbb.ccc，比如：com.hsp.crm</li><li>类名、接口名：多单词组成时，采用大驼峰法，所有单词的首字母大写：XxxYyyZzz，比如：TankShotGame</li><li>变量名、方法名：多单词组成时，采小驼峰法（驼峰法），第一个单词首字母小写，第二个开始每个单词首字母大写：xxxYyyZzz</li><li>常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ，比如：TAX_RATE</li><li>更详细的规则查看 <ahref="https://developer.aliyun.com/article/709470">Java编码规范</a></li></ol><h2 id="输入与输出">3.8 输入与输出</h2><blockquote><p>在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。<code>Input.java</code>, 需要一个 扫描器(对象), 就是<code>Scanner</code></p></blockquote><p><strong>步骤 ：</strong></p><ol type="1"><li>导入该类的所在包，java.util.*</li><li>创建该类对象（声明变量）</li><li>调用里面的功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner; <span class="hljs-comment">//表示把 java.util 下的 Scanner 类导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Input</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//Scanner 类 表示 简单文本扫描器，在 java.util 包</span><br><span class="hljs-comment">//1. 引入/导入 Scanner 类所在的包</span><br><span class="hljs-comment">//2. 创建 Scanner 对象 , new 创建一个对象</span><br><span class="hljs-comment">// myScanner 就是 Scanner 类的对象</span><br>        <br><span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//3. 接收用户输入，使用相关的方法</span><br>System.out.println(<span class="hljs-string">&quot;请输入名字&quot;</span>);<br>        <br><span class="hljs-comment">//当程序执行到 next 方法时，会等待用户输入~~~ </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> myScanner.next(); <span class="hljs-comment">//接收用户输入字符串</span><br>    <br>System.out.println(<span class="hljs-string">&quot;请输入年龄&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();  <span class="hljs-comment">//接收用户输入 int</span><br>System.out.println(<span class="hljs-string">&quot;请输入薪水&quot;</span>);<br><span class="hljs-type">double</span> <span class="hljs-variable">sal</span> <span class="hljs-operator">=</span> myScanner.nextDouble();  <span class="hljs-comment">//接收用户输入 double</span><br>System.out.println(<span class="hljs-string">&quot;人的信息如下:&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;名字=&quot;</span> + name + <span class="hljs-string">&quot; 年龄=&quot;</span> + age + <span class="hljs-string">&quot; 薪水=&quot;</span> + sal);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="进制">3.9 进制</h2><ul><li>二进制：数字有 0 - 1，满 2 进 1，以 <code>0b</code> 或<code>0B</code> 开头</li><li>十进制</li><li>八进制：0 - 7，满 8 进 1，以 <code>0</code> 开头表示</li><li>十六进制：0 - 9 及 A - F，满 16 进 1，以<code>0x</code> 或<code>0X</code> 开头。此处的 A - F 不分大小写。</li></ul><h3 id="进制的转换">3.9.1 进制的转换</h3><ul><li>其他进制转十进制：略</li><li>十进制转其他进制：将该数不断除以对象进制数，直到商为0为止，将每步得到的余数倒过来。</li><li>二进制与八进制或十六进制互相转换：二进制从低位开始，每 3位一组，转成对应的八进制即可。反之同理。十六进制每 4 位一组</li></ul><h3 id="原码反码补码背">3.9.2 原码、反码、补码（背）</h3><p>对于有符号数而言：</p><ol type="1"><li>二进制的最高位是符号位：0表示正数，1表示负数。(<code>0-&gt;0 1-&gt;-</code>)</li><li>正数的原码、反码、补码都一样。</li><li>负数的原码转反码：原码符号位不变，其他位取反；反码再转原码：反码符号位不变，其他位取反</li><li><strong>负数的补码 = 反码 + 1。负数的反码 = 补码 - 1。</strong></li><li>0 的反码、补码都是 0。</li><li>Java 没有无符号数。换言之，Java 的数都是有符号的。</li><li><strong>| 计算机运算时，都是以补码的方式来运算的。|</strong></li><li><strong>当我们看运算结果时，要看其原码。</strong></li></ol><h2 id="位运算符">3.10 位运算符</h2><ul><li><p><code>&amp;</code> 按位与：两位都为 1，结果为 1，否则为0</p></li><li><p><code>|</code> 按位或：两位有一个为 1，结果为 1，否则为0</p></li><li><p><code>^</code> 按位异或：两位不同，结果为 1，否则为 0</p></li><li><p><code>~</code> 按位取反：把 0 变 1，1 变 0</p><p>示例：</p><ul><li><p><code>2 &amp; 3</code>：</p><blockquote><p><code>int</code>类型是4个字节</p><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>3 的原码：00000000 00000000 00000000 00000011</p><p>3 的补码：00000000 00000000 00000000 00000011</p><p>补码运算结果：00000000 00000000 00000000 00000010</p><p>结果转成原码：00000000 00000000 00000000 00000010</p><p>运算结果：2</p></blockquote></li><li><p><code>~-2</code>：</p><blockquote><p>得到 -2 的原码：10000000 00000000 00000000 00000010</p><p>得到 -2 的反码：11111111 11111111 11111111 11111101</p><p>得到 -2 的补码：11111111 11111111 11111111 11111110</p><p>补码运算结果：00000000 00000000 00000000 00000001</p><p>结果转成原码：00000000 00000000 00000000 00000001</p><p>运算结果：1</p></blockquote></li><li><p><code>~2</code>：</p><blockquote><p>2 的原码：00000000 00000000 00000000 00000010</p><p>2 的补码：00000000 00000000 00000000 00000010</p><p>补码运算：11111111 11111111 11111111 11111101</p><p>结果转成反码：11111111 11111111 11111111 11111100</p><p>反码转成原码：10000000 00000000 00000000 00000011</p><p>运算结果：-3</p></blockquote></li></ul></li><li><p><code>&gt;&gt;</code>算术右移：低位溢出，符号位不变，用符号位补溢出的高位</p></li><li><p><code>&lt;&lt;</code> 算数左移：符号位不变，低位补 0</p></li><li><p><code>&gt;&gt;&gt;</code>逻辑右移（无符号右移）：低位溢出，高位补 0</p></li><li><p>没有<code>&lt;&lt;&lt;</code>符号</p><p>示例：</p><ul><li><p>将数字 1 算术右移 2 位：<code>int a = 1 &gt;&gt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000000</p><p>结果：00000000 00000000 00000000 00000000</p></blockquote></li><li><p>将数字 1 算术左移 2 位：<code>int b = 1 &lt;&lt; 2</code></p><blockquote><p>1 的补码：00000000 00000000 00000000 00000001</p><p>补码结果：00000000 00000000 00000000 00000100</p><p>结果：00000000 00000000 00000000 00000100</p></blockquote></li></ul><p>也就是说，<code>1 &lt;&lt; 2</code> 本质是<code>1 * 2 * 2 = 4</code></p><p>而 <code>1 &gt;&gt; 2</code> 本质是<code>1 / 2 / 2 = 0</code></p></li></ul><blockquote><p>参考：</p><p><ahref="https://www.bilibili.com/video/BV1fh411y7R8/?spm_id_from=333.337.search-card.all.click">【零基础快速学Java】韩顺平 零基础30天学会Java_哔哩哔哩_bilibili</a></p><p><ahref="https://i-melody.github.io/2021/11/23/Java/入门阶段/3%20运算符/">3运算符 ★ Melody 的小纸箱 (i-melody.github.io)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统 2 进程管理</title>
    <link href="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%202%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%202%20%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>B站王道考研视频内容，结合《计算机操作系统（第四版）——汤小丹》课本做的笔记</p><p>王道的有些图做的确实很好，比较容易看懂</p></blockquote><h1 id="进程与线程">2.1 进程与线程</h1><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272241508.png"alt="image-20231127224148425" /><figcaption aria-hidden="true">image-20231127224148425</figcaption></figure><h2 id="进程的概念组成特征组织">2.1.1 进程的概念、组成、特征、组织</h2><h3 id="进程的概念">进程的概念</h3><p>在多道程序环境下，程序的执行属于并发执行，此时它们将<strong>失去其封闭性</strong>，并具有<strong>间断性</strong>，以及其<strong>运行结果不可再现性</strong>的特征。由此，决定了通常的程序是不能参与并发执行的，否则，程序的运行也就失去了意义。为了能使程序并发执行，并且可以对并发执行的程序加以描述和控制，人们引入了“进程”的概念。</p><p>为了使参与并发执行的每个程序(含数据)都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为<strong>进程控制块(ProcessControlBlock，PCB)</strong>。系统利用PCB来描述进程的基本情况和活动过程，进而控制和管理进程。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272245700.png"alt="进程的概念" /><figcaption aria-hidden="true">进程的概念</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271249005.png"alt="进程的概念" /><figcaption aria-hidden="true">进程的概念</figcaption></figure><p>进程和程序的区别和联系：</p><p>区别：</p><ol type="1"><li>进程是动态的;程序是静态的。</li><li>进程有独立性，能并发执行；程序不能并发执行。</li><li>二者无一一对应关系。</li><li>进程异步运行，会相互制约；程序不具备此特征。</li><li>组成不同。进程包含PCB、程序段、数据段。程序包含数据和指令代码。程序是一个包含了所有指令和数据的静态实体。本身除占用磁盘的存储空间外，并不占用系统如CPU、内存等运行资源。进程由程序段、数据段和PCB构成，会占用系统如CPU、内存等运行资源。</li></ol><p>但是，进程与程序又有密切的联系： 进程不能脱离具体程序而虚设，程序规定了相应进程所要完成的动作。</p><h3 id="进程的组成">进程的组成</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271259596.png"alt="进程的组成" /><figcaption aria-hidden="true">进程的组成</figcaption></figure><p><strong>进程控制块PCB的作用</strong></p><ol type="1"><li><p>作为独立运行基本单位的标志</p></li><li><p>能实现间断性运行方式。</p></li><li><p>提供进程管理所需要的信息</p></li><li><p>提供进程调度所需要的信息</p></li><li><p>实现与其它进程的同步与通信</p></li></ol><p><strong>进程控制块（PCB）中的信息</strong></p><p>进程控制块中主要包括下述四个方面的信息。</p><p><strong>1.进程标识符：</strong></p><p>用于唯一地标识一个进程；通常有两种标识符：</p><ol type="1"><li>外部标识符(显示名称)，(2) 内部标识符(PID)</li></ol><p><strong>2.处理机状态：</strong></p><p>处理机的各种寄存器中的内容组成</p><p><strong>3.进程调度信息：</strong></p><p>① 进程状态：进程的当前状态，作为进程调度和对换时的依据；</p><p>②进程优先级：描述进程使用处理机的优先程度的一个整数，优先级高的进程应优先获得处理机；</p><p>③进程调度所需的其它信息：例如，进程已等待CPU的时间总和、进程已执行的时间总和等；</p><p>④事件：是指进程由执行状态变为阻塞状态所等待发生的事件，即阻塞原因。</p><p><strong>4.进程控制信息</strong></p><p>① 程序和数据的地址：进程实体中的程序和数据的内存或外存地(首)址；</p><p>②进程同步和通信机制：如消息队列指针、信号量等，它们可能全部或部分地放在PCB中；</p><p>③资源清单：进程在运行期间所需的全部资源(除CPU以外)；另外还有一张已分配到该进程的资源的清单；</p><p>④ 链接指针：给出本进程(PCB)所在队列中的下一进程的PCB首地址。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271257067.png"alt="进程的组成-PCB" /><figcaption aria-hidden="true">进程的组成-PCB</figcaption></figure><h3 id="进程的特征">进程的特征</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271300169.png"alt="image-20231127130059069" /><figcaption aria-hidden="true">image-20231127130059069</figcaption></figure><h3 id="进程的组织">进程的组织</h3><p>在一个操作系统中，通常可拥有数十个、数百个乃至数千个PCB，为了能对它们加以有效的管理，应该用适当的方式将这些PCB 组织起来。目前常用的组织方式有以下三种。</p><p><strong>(1)线性方式</strong>，即将系统中所有的 PCB都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中。该方式实现简单、开销小，但每次查找时都需要扫描整张表，因此适合进程数目不多的系统。图2-10示出了线性表的PCB组织方式。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272314372.png"alt="进程的组织方式-线性方式" /><figcaption aria-hidden="true">进程的组织方式-线性方式</figcaption></figure><p><strong>(2) 链接方式</strong>，即把具有相同状态进程的 PCB分别通过PCB中的链接字链接成一个队列。这样，可以形成就绪队列、若干个阻塞队列和空白队列等。</p><p>对就绪队列而言，往往按进程的优先级将 PCB从高到低进行排列，将优先级高的进程PCB排在队列的前面。同样也可把处于阻塞状态进程的 PCB根据其阻塞原因的不同，排成多个阻塞队列，如等待I/O操作完成的队列和等待分配内存的队列等。图2-11示出了一种链接队列的组织方式</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272317499.png"alt="进程的组织-链接方式" /><figcaption aria-hidden="true">进程的组织-链接方式</figcaption></figure><p><strong>(3)索引方式</strong>：即系统根据所有进程状态的不同，建立几张索引表，例如，就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录具有相应状态的某个PCB在PCB表中的地址。图2-12示出了索引方式的PCB组织。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272319746.png"alt="进程组织方式-索引方式" /><figcaption aria-hidden="true">进程组织方式-索引方式</figcaption></figure><h2 id="进程的状态及转换">2.1.2 进程的状态及转换</h2><h3 id="进程的状态">进程的状态</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272302615.png"alt="三种基本状态" /><figcaption aria-hidden="true">三种基本状态</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272303686.png"alt="另外两种状态" /><figcaption aria-hidden="true">另外两种状态</figcaption></figure><p>创建状态</p><ul><li>首先：由进程申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；</li><li>然后：为该进程分配运行时所必须的资源；</li><li>最后：把该进程转入就绪状态并插入就绪队列之中。</li></ul><p>如果进程所需的资源不能得到满足，比如无足够的内存使进程无法装入其中，此时创建工作尚未完成，进程不能被调度运行，于是把此时进程所处的状态称为创建状态。</p><p>终止状态</p><ul><li>首先：等待操作系统进行善后处理</li><li>最后：将其PCB清零，并将PCB空间返还操作系统</li></ul><p>当一个进程到达了自然结束点，或是出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入<strong>终止状态</strong>。进入终止态的进程以后不能再执行，但在操作系统中依然保留一个记录，其中保存状态码和一些计时统计数据，供其他进程收集。一旦其他进程完成了对其信息的提取之后，操作系统将删除该进程，即将其PCB清零，将空白PCB返还系统。</p><h3 id="进程状态间的转换">进程状态间的转换</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272310509.png"alt="五状态转换图" /><figcaption aria-hidden="true">五状态转换图</figcaption></figure><h2 id="进程控制">2.1.3 进程控制</h2><h3 id="进程控制概念">进程控制概念</h3><p>进程控制是进程管理中最基本的功能，主要包括创建新进程、终止已完成的进程、将因发生异常情况而无法继续运行的进程置于阻塞状态、负责进程运行中的状态转换等功能。如当一个正在执行的进程因等待某事件而暂时不能继续执行时，将其转变为阻塞状态，而在该进程所期待的事件出现后，又将该进程转换为就绪状态等。进程控制一般是由OS 的内核中的<strong>原语</strong>来实现的。</p><p>简单说：<strong>进程控制就是要实现进程状态转换</strong></p><h3 id="原语实现对进程的控制">原语实现对进程的控制</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272349181.png"alt="原语实现对进程的控制" /><figcaption aria-hidden="true">原语实现对进程的控制</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272349922.png"alt="如何实现原语的“原子性”" /><figcaption aria-hidden="true">如何实现原语的“原子性”</figcaption></figure><p>思考：如果这两个特权指令允许用户程序使用的话，会发生什么情况？</p><p>------流氓程序，必须执行完它，才能执行其他的程序，这种是不被允许的</p><h3 id="进程控制的五种原语">进程控制的五种原语</h3><h4 id="进程的创建原语">进程的创建原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272352438.png"alt="进程的创建原语" /><figcaption aria-hidden="true">进程的创建原语</figcaption></figure><h4 id="进程的终止原语">进程的终止原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272354577.png"alt="进程的终止原语" /><figcaption aria-hidden="true">进程的终止原语</figcaption></figure><h4 id="进程的唤醒和阻塞原语">进程的唤醒和阻塞原语</h4><p>引起进程阻塞和唤醒的事件</p><ol type="1"><li><p>向系统请求共享资源失败。</p></li><li><p>等待某种操作的完成。</p></li><li><p>新数据尚未到达。</p></li><li><p>等待新任务的到达。</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280004416.png"alt="image-20231128000426318" /><figcaption aria-hidden="true">image-20231128000426318</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272358262.png"alt="进程的唤醒和阻塞原语" /><figcaption aria-hidden="true">进程的唤醒和阻塞原语</figcaption></figure><h4 id="进程的切换原语">进程的切换原语</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280001800.png"alt="进程的切换原语" /><figcaption aria-hidden="true">进程的切换原语</figcaption></figure><p>无论哪个进程控制原语，要做的无非三类事情：</p><ol type="1"><li>更新PCB中的信息</li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h2 id="进程通信">2.1.4 进程通信</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280012893.png"alt="为什么进程通信需要操作系统支持？" /><figcaptionaria-hidden="true">为什么进程通信需要操作系统支持？</figcaption></figure><p>进程通信是指进程之间的信息交换。进程的互斥与同步也归为进程通信；互斥与同步称为低级进程通信。</p><p>以信号量机制为例，它们之所以低级的原因在于：</p><p>①<strong>效率低</strong>，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息；</p><p>②<strong>通信对用户不透明</strong>，OS只为进程之间的通信提供了共享存储器。</p><p>在进程之间要传送大量数据时，应当利用OS提供的高级通信工具，这些工具最主要的特点是：</p><ol type="1"><li><p>使用方便：OS隐藏了实现进程通信的具体细节，向用户提供一组用于实现高级通信的命令(原语)；通信过程对用户是透明的，大大减少了通信程序编制上的复杂性。</p></li><li><p>高效地传送大量数据：用户可直接利用高级通信命令(原语)高效地传送大量的数据。</p></li></ol><h3 id="共享存储系统">共享存储系统</h3><p>共享一块大家都可以访问的空间，一次只能有一个进程进行读或写操作</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280014990.png"alt="共享存储" /><figcaption aria-hidden="true">共享存储</figcaption></figure><h3 id="消息传递系统">消息传递系统</h3><p>发送信息的进程将消息头写好，接受信息进程根据消息头读取信息或寻找信封是哪一个</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280019498.png"alt="image-20231128001938441" /><figcaption aria-hidden="true">image-20231128001938441</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280021015.png"alt="消息传递（直接）" /><figcaption aria-hidden="true">消息传递（直接）</figcaption></figure><p>直接通信方式：点名道姓的消息传递</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311280022111.png"alt="消息传递（间接）" /><figcaption aria-hidden="true">消息传递（间接）</figcaption></figure><h3 id="管道通信系统">管道通信系统</h3><p>共享通信方式是写哪都可以，管道通信相当于一个队列（FIFO）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041012576.png"alt="管道通信系统" /><figcaption aria-hidden="true">管道通信系统</figcaption></figure><h2 id="线程概念与多线程模型">2.1.5 线程概念与多线程模型</h2><h3 id="线程概念">1. 线程概念</h3><h4 id="为什么要引入线程">为什么要引入线程？</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041015374.png"alt="为什么要引入线程？" /><figcaption aria-hidden="true">为什么要引入线程？</figcaption></figure><h4 id="什么是线程">什么是线程？</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041016703.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="引入线程带来的变化">引入线程带来的变化</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041018836.png"alt="引入线程带来的变化" /><figcaption aria-hidden="true">引入线程带来的变化</figcaption></figure><h3 id="线程的属性">2. 线程的属性</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041018011.png"alt="线程的属性" /><figcaption aria-hidden="true">线程的属性</figcaption></figure><h3 id="线程的实现方式">3. 线程的实现方式</h3><ul><li>线程的实现分为两类：用户级线程(User-LevelThread,UTL)和内核级线程(Kernel-Level Thread,KTL)。内核级线程又称内核支持的线程。</li><li>内核级线程 KLT (Kernel-Level Thread)又称“内核支持的线程”：内核支持线程 KST (Kernel Supported Threads)</li></ul><p>历史背景：早期的操作系统 (如：早期Unix)只支持进程不支持线程。当时的“线程”是由线程库实现的</p><h4 id="用户级线程">用户级线程</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092137706.png"alt="用户级线程（ULT）" /><figcaption aria-hidden="true">用户级线程（ULT）</figcaption></figure><p>ULT线程方式的<strong>优点</strong>：</p><ol type="1"><li><p>线程切换不需要转换到内核空间，线程管理的系统开销小，效率高</p></li><li><p>调度算法可以是进程专用的</p></li><li><p>ULT线程的实现与OS平台无关，因为对于线程管理的代码是属于用户程序的一部分，所有的应用程序都可以对之进行共享。</p></li></ol><p>ULT线程方式的<strong>主要缺点</strong>：</p><ol type="1"><li>系统调用的阻塞问题</li></ol><p>在基于进程机制的OS中，当线程执行一个系统调用时，不仅该线程被阻塞，该进程内的所有线程会被阻塞。并发度不高。</p><ol start="2" type="1"><li>不能充分利用多处理机</li></ol><p>OS每次分配给一个进程的仅有一个CPU，因此，进程中仅有一个线程能执行，在该线程放弃CPU之前，进程中其它线程只能等待，即多个线程不可在多核处理机上并行运行</p><h4 id="内核级线程">内核级线程</h4><p>在内核空间为每一个内核线程设置了一个TCB，OS内核根据TCB来感知某线程的存在，并对其加以控制和管理</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092142494.png"alt="内核级线程" /><figcaption aria-hidden="true">内核级线程</figcaption></figure><p>KST线程方式的四个主要优点：</p><ol type="1"><li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行；</li><li>如果进程中的某个线程被阻塞，内核可以调度该进程中的其它线程运行，也可以运行其它进程中的线程；</li><li>KLT（KST）线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</li><li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</li></ol><p>内核支持线程的主要缺点是：</p><p>对于用户的线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到核心态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</p><blockquote><p>这里的两个切换，一个开销大，一个开销小，这里解释一下：优点说的是内核级线程之间的切换，缺点说的是用户级线程之间的切换</p></blockquote><h4 id="特殊的组合方式">特殊的组合方式</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092233931.png"alt="上面两种方式结合的组合方式" /><figcaption aria-hidden="true">上面两种方式结合的组合方式</figcaption></figure><h3 id="多线程模型">4. 多线程模型</h3><ul><li>前面我们提到了线程的实现方式，有用户级和内核级。那么这两种模式的交叉组合就会产生几种不一样的组织结构，即不一样的模型。</li></ul><p><strong>一对一模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092236237.png"alt="一对一模型" /><figcaption aria-hidden="true">一对一模型</figcaption></figure><p><strong>多对一模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092237384.png"alt="多对一模型" /><figcaption aria-hidden="true">多对一模型</figcaption></figure><p><strong>多对多模型</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092238578.png"alt="多对多模型" /><figcaption aria-hidden="true">多对多模型</figcaption></figure><h2 id="线程的状态与转换">2.1.6 线程的状态与转换</h2><h3 id="线程的状态与转换-1">线程的状态与转换</h3><p>线程的状态与转换与进程的完全一致</p><ol type="1"><li><p>执行状态（或者叫运行状态）：表示线程已获得处理机而正在运行；</p></li><li><p>就绪状态：指线程已具备了各种执行条件，只须再获得CPU便可立即执行；</p></li><li><p>阻塞状态：指线程在执行中因某事件受阻而处于暂停状态，例如，当一个线程执行从键盘读入数据的系统调用时，该线程就被阻塞</p></li></ol><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092241476.png"alt="线程的状态与转换" /><figcaption aria-hidden="true">线程的状态与转换</figcaption></figure><h3 id="线程控制块tcb">线程控制块TCB</h3><p>如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块ThreadControl Block(TCB)，将所有用于控制和管理线程的信息记录在线程控制块中</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092243843.png"alt="线程控制块TCB" /><figcaption aria-hidden="true">线程控制块TCB</figcaption></figure><h1 id="处理机的调度">2.2 处理机的调度</h1><h2 id="处理机调度的概念及层次">2.2.1 处理机调度的概念及层次</h2><h3 id="调度的基本概念">1. 调度的基本概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092247567.png"alt="调度的基本概念" /><figcaption aria-hidden="true">调度的基本概念</figcaption></figure><h3 id="调度的三个层次">2. 调度的三个层次</h3><h4 id="高级调度作业调度">高级调度（作业调度）</h4><p>作业后备队列：</p><p>作业：一个具体的任务，用户向系统提交一个作业 ≈用户让操作系统启动一个程序（来处理一个具体的任务）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092252526.png"alt="高级调度（作业调度）" /><figcaption aria-hidden="true">高级调度（作业调度）</figcaption></figure><p>高级调度主要用于多道批处理系统中，在分时和实时系统中不设置高级调度。</p><blockquote><p>高级调度简化理解：好几个程序需要启动，到底先启动哪个</p></blockquote><h4 id="低级调度进程调度">低级调度（进程调度）</h4><p>低级调度所调度的对象是进程（或内核级线程）。</p><p>进程调度是最基本的一种调度，在多道批处理、分时和实时二种类型的OS中，都必须配置这级调度。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092256398.png"alt="低级调度（进程调度）" /><figcaption aria-hidden="true">低级调度（进程调度）</figcaption></figure><h4 id="中级调度内存调度">中级调度（内存调度）</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092300921.png"alt="中级调度（内存调度）" /><figcaption aria-hidden="true">中级调度（内存调度）</figcaption></figure><h4 id="进程的七状态模型">进程的七状态模型</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092301899.png"alt="进程的七状态模型" /><figcaption aria-hidden="true">进程的七状态模型</figcaption></figure><h3 id="三层调度的联系和对比">3. 三层调度的联系和对比</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092302116.png"alt="三层调度的联系和对比" /><figcaption aria-hidden="true">三层调度的联系和对比</figcaption></figure><h2 id="进程调度的时机切换与过程方式">2.2.2进程调度的时机、切换与过程、方式</h2><h3 id="进程调度的时机">进程调度的时机</h3><p>（1）什么时候进行进程调度？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312092311354.png"alt="什么时候进行进程调度？" /><figcaption aria-hidden="true">什么时候进行进程调度？</figcaption></figure><p>（2）什么时候不能进行进程调度？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101012847.png"alt="什么时候不能进行进程调度？" /><figcaption aria-hidden="true">什么时候不能进行进程调度？</figcaption></figure><p>（3）OS内核程序临界区与普通临界区的进程调度情况</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101017358.png"alt="OS内核程序临界区与普通临界区的进程调度情况" /><figcaptionaria-hidden="true">OS内核程序临界区与普通临界区的进程调度情况</figcaption></figure><p>内核程序临界区是会上一个🔒，然后独自占用资源，并且其他的进程是无法进去就绪队列的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101018703.png"alt="OS内核程序临界区与普通临界区的进程调度情况" /><figcaptionaria-hidden="true">OS内核程序临界区与普通临界区的进程调度情况</figcaption></figure><p>一些IO设备，如打印机，因为这类的设备处理会很慢很慢，总不可能一直等待打印机工作结束</p><p>一个是临界区，一个是内核临界区，临界区是大范围，内核临界区是小范围</p><h3 id="进程调度的方式">进程调度的方式</h3><p>在进程调度的时机“（1）什么时候进行进程调度？”中，有的系统中，只允许进程主动放弃处理机，而有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><p>这就引出了进程调度的两种方式——非剥夺与剥夺</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101025696.png"alt="进程调度的方式" /><figcaption aria-hidden="true">进程调度的方式</figcaption></figure><h3 id="进程的切换和过程">进程的切换和过程</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101027326.png"alt="进程的切换和过程" /><figcaption aria-hidden="true">进程的切换和过程</figcaption></figure><h2 id="调度程序和闲逛程序">2.2.3 调度程序和闲逛程序</h2><h3 id="调度程序">调度程序</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101034396.png"alt="调度器/调度程序" /><figcaption aria-hidden="true">调度器/调度程序</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101034769.png"alt="image-20231210103451666" /><figcaption aria-hidden="true">image-20231210103451666</figcaption></figure><h3 id="闲逛进程">闲逛进程</h3><p>调度程序永远的备胎，没有其他就绪进程时，运行闲逛进程 (idle)</p><p>闲逛进程的特性：</p><ul><li>优先级最低</li><li>可以是0地址指令，占一个完整的指令周期(指令周期末尾例行检查中断)</li><li>能耗低</li></ul><h2 id="调度算法的评价指标">2.2.4 调度算法的评价指标</h2><h3 id="cpu利用率">1. CPU利用率</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101038132.png"alt="CPU利用率" /><figcaption aria-hidden="true">CPU利用率</figcaption></figure><h3 id="系统吞吐量">2. 系统吞吐量</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101039962.png"alt="系统吞吐量" /><figcaption aria-hidden="true">系统吞吐量</figcaption></figure><h3 id="周转时间">3. 周转时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101041879.png"alt="周转时间-平均周转时间" /><figcaption aria-hidden="true">周转时间-平均周转时间</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101042046.png"alt="带权周转时间" /><figcaption aria-hidden="true">带权周转时间</figcaption></figure><p>带权周转时间其实表示的是进程的周转时间比运行时间大多少倍的这样一个指标</p><h3 id="等待时间">4. 等待时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101049567.png"alt="等待时间" /><figcaption aria-hidden="true">等待时间</figcaption></figure><h3 id="响应时间">5. 响应时间</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101049703.png"alt="响应时间" /><figcaption aria-hidden="true">响应时间</figcaption></figure><h2 id="作业进程调度算法1">2.2.5 作业/进程调度算法1</h2><h3 id="思维导图">0. 思维导图</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101050430.png"alt="调度算法学习思路" /><figcaption aria-hidden="true">调度算法学习思路</figcaption></figure><h3 id="先来先服务--fcfs">1. 先来先服务--FCFS</h3><ul><li>First Come First Serve</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101058223.png"alt="先来先服务--FCFS" /><figcaption aria-hidden="true">先来先服务--FCFS</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101058654.png"alt="先来先服务(FCFS)例题" /><figcaption aria-hidden="true">先来先服务(FCFS)例题</figcaption></figure><h3 id="短作业优先--sjf">2. 短作业优先--SJF</h3><ul><li>Shortest Job First</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101111700.png"alt="短作业优先--SJF" /><figcaption aria-hidden="true">短作业优先--SJF</figcaption></figure><p>非抢占式—SJF：</p><p>其实这里应该叫短进程优先---SPF，但是很多时候题目也不区分这两个了</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101103547.png"alt="非抢占式—SJF例题" /><figcaption aria-hidden="true">非抢占式—SJF例题</figcaption></figure><p>抢占式—SJF（SRTN）：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101107164.png"alt="抢占式—SJF（SRTN）" /><figcaption aria-hidden="true">抢占式—SJF（SRTN）</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101108438.png"alt="抢占式—SJF（SRTN）各种时间计算" /><figcaptionaria-hidden="true">抢占式—SJF（SRTN）各种时间计算</figcaption></figure><p>注意几个细节：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101110507.png"alt="image-20231210111022273" /><figcaption aria-hidden="true">image-20231210111022273</figcaption></figure><h3 id="高响应比优先--hrrn">3. 高响应比优先--HRRN</h3><ul><li>Highest Response Ratio Next</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101114044.png"alt="思考中……" /><figcaption aria-hidden="true">思考中……</figcaption></figure><blockquote><p>byd看一个多小时qing有点小累了🥱🥱🥱，2023.12.10 11:15</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101117977.png"alt="高响应比优先--HRRN" /><figcaption aria-hidden="true">高响应比优先--HRRN</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101116056.png"alt="高响应比优先--HRRN例题" /><figcaption aria-hidden="true">高响应比优先--HRRN例题</figcaption></figure><h3 id="三种算法的对比和总结">4. 三种算法的对比和总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101119679.png"alt="三种算法的对比和总结" /><figcaption aria-hidden="true">三种算法的对比和总结</figcaption></figure><h2 id="作业进程调度算法2">2.2.6 作业/进程调度算法2</h2><h3 id="思维导图-1">0.思维导图</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101120953.png"alt="作业/进程调度算法2" /><figcaption aria-hidden="true">作业/进程调度算法2</figcaption></figure><h3 id="时间片轮转--rr">1. 时间片轮转--RR</h3><ul><li>Round-Robin</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101135481.png"alt="时间片轮转--RR" /><figcaption aria-hidden="true">时间片轮转--RR</figcaption></figure><p>时间片大小为2举例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101124113.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101126838.png"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101128750.png"alt="3" /><figcaption aria-hidden="true">3</figcaption></figure><p>时间片大小为5举例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101130158.png"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><p>可能出现的问题，与FCFS对比</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101133785.png"alt="RR与FCFS对比" /><figcaption aria-hidden="true">RR与FCFS对比</figcaption></figure><p>如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><ul><li>比如：系统中有10个进程在并发执行，如果时间片为1秒，则一个进程被响应可能需要等9秒...也就是说，如果用户在自己进程的时间片外通过键盘发出调试命令，可能需要等待9秒才能被系统响应</li></ul><p>另一方面，进程调度、切换是有时间代价的(保存、恢复运行环境)，因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><p>一般来说，设计时间片时要让切换进程的开销占比不超过1%</p><h3 id="优先级调度算法">2. 优先级调度算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101145451.png"alt="优先级调度算法" /><figcaption aria-hidden="true">优先级调度算法</figcaption></figure><p>用于作业调度的时候，选择一个处于外存后备队列当中的作业，进入内存</p><p>用于进程调度的时候，选择一个在内存的就绪队列当中的进程，为它分配处理机</p><p>非抢占式例子：</p><p>这里的优先数越大，优先级越高<strong>只是本题规定的</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101140170.png"alt="优先级调度算法-非抢占式例子" /><figcaption aria-hidden="true">优先级调度算法-非抢占式例子</figcaption></figure><p>抢占式例子：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101142267.png"alt="优先级调度算法-抢占式例子" /><figcaption aria-hidden="true">优先级调度算法-抢占式例子</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101144369.png"alt="补充一点点喵" /><figcaption aria-hidden="true">补充一点点喵</figcaption></figure><h3 id="多级反馈队列调度算法">3. 多级反馈队列调度算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101150481.png"alt="思考🤔" /><figcaption aria-hidden="true">思考🤔</figcaption></figure><ul><li>Multileveled Feedback Queue</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101217786.png"alt="多级反馈队列调度算法" /><figcaption aria-hidden="true">多级反馈队列调度算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101216309.png"alt="多级反馈队列调度算法例题" /><figcaption aria-hidden="true">多级反馈队列调度算法例题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101214114.gif"alt="多级反馈队列调度算法调度过程" /><figcaption aria-hidden="true">多级反馈队列调度算法调度过程</figcaption></figure><h3 id="三种算法的对比总结">4. 三种算法的对比总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101219993.png"alt="三种算法的对比总结" /><figcaption aria-hidden="true">三种算法的对比总结</figcaption></figure><h3 id="补充多队列调度算法">5. 补充：多队列调度算法</h3><ul><li>Multilevel queue scheduling</li></ul><p>单个就绪队列无法满足用户对进程调度策略的不同要求；将就绪队列分成多个队列，提出多级队列调度算法</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312101222441.png"alt="多队列调度算法" /><figcaption aria-hidden="true">多队列调度算法</figcaption></figure><p>固定优先级：一般不用固定优先级，比如你打字打着打着有个系统进程要运行，那你就不能打字了</p><p>时间片划分，比如100ms，那么在这100ms每个优先级的进程都会被至少响应一次</p><h1 id="进程的同步与互斥">2.3 进程的同步与互斥</h1><h2 id="进程的同步与互斥-1">2.3.1 进程的同步与互斥</h2><h3 id="进程同步">1. 进程同步</h3><p>知识点回顾：进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p><ul><li><strong>同步也称为直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系</strong>。进程间的直接制约关系就是源于它们之间的相互合作。</li><li>进程同步是为了解决进程的异步问题。</li></ul><blockquote><p>一个简单的例子来理解这个概念。 例如，让系统计算1 + 2 *3，假设系统产生两个进程:一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生。</p></blockquote><h3 id="进程互斥">2. 进程互斥</h3><ul><li>互斥，亦称间接制约关系。</li><li><strong>进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</strong></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102041440.png"alt="进程互斥" /><figcaption aria-hidden="true">进程互斥</figcaption></figure><ul><li>临界资源(Critical Resouce)<ul><li>许多硬件资源如打印机、 磁带机等，都属于临界资源</li><li>进程间应采取互斥方式，实现对这类资源的共享。</li><li>软件资源如信号量，共享变量等</li></ul></li><li>临界区(critical section)<ul><li>不论是硬件临界资源还是软件临界资源，多个进程必须互斥地对它进行访问；每个进程中访问临界资源的那段代码称为临界区。</li></ul></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102043787.png"alt="image-20231210204357574" /><figcaption aria-hidden="true">image-20231210204357574</figcaption></figure><p>为了禁止两个进程同时进入<code>临界区</code>，实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><ol type="1"><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</li><li>忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区(保证不会饥饿)</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h2 id="进程互斥的软件实现方法">2.3.2 进程互斥的软件实现方法</h2><blockquote><p>这部分书上其实就一句话：软件方法能解决诸如进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。</p><p>所以期末考试是不会考的，但王道讲了的话说明在408的范围内🧐🧐</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102057658.png"alt="进程互斥的软件实现方法" /><figcaption aria-hidden="true">进程互斥的软件实现方法</figcaption></figure><h3 id="单标志法">1. 单标志法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102107598.png"alt="单标志法" /><figcaption aria-hidden="true">单标志法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102108192.png"alt="单标志法" /><figcaption aria-hidden="true">单标志法</figcaption></figure><h3 id="双标志先检查法">2. 双标志先检查法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102112579.png"alt="双标志先检查法" /><figcaption aria-hidden="true">双标志先检查法</figcaption></figure><p>如果能让 “检查” 和“上锁”一气呵成，那其实这个算法就没啥问题了，下一小节的硬件实现方法就实现了</p><h3 id="双标志后检查法">3. 双标志后检查法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102114531.png"alt="双标志后检查法" /><figcaption aria-hidden="true">双标志后检查法</figcaption></figure><h3 id="peterson算法">4. Peterson算法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102120741.png"alt="Peterson算法" /><figcaption aria-hidden="true">Peterson算法</figcaption></figure><p>Peterson算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待、有限等待三个原则，但是依然未遵循<strong>让权等待</strong>的原则。</p><p>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p><h2 id="进程互斥的硬件实现方法">2.3.3 进程互斥的硬件实现方法</h2><h3 id="中断屏蔽方法">1. 中断屏蔽方法</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312102125013.png"alt="中断屏蔽方法" /><figcaption aria-hidden="true">中断屏蔽方法</figcaption></figure><p>关中断方法的缺点：</p><p>① 滥用关中断权力可能导致严重后果；</p><p>②关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</p><p>③不适用于多CPU系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</p><h3 id="test-and-set指令">2. Test-and-Set指令</h3><p><code>TestAndSet</code> 简称 <code>TS</code> 指令，也有地方称为<code>TestAndSetLock</code> 指令，或 <code>TSL</code> 指令</p><p><code>TSL</code>指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p><p>以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 布尔型共享变量 lock 表示当前临界区是否被加锁</span><br><span class="hljs-comment">// true 表示已经加锁， false 表示未加锁</span><br><span class="hljs-type">bool</span> <span class="hljs-title function_">TestAndSet</span><span class="hljs-params">(<span class="hljs-type">bool</span> *lock)</span><br>&#123;<br>    <span class="hljs-type">bool</span> old;            <br>    old = *lock;          <span class="hljs-comment">// 用于存放lock 原来的值</span><br>    *lock = <span class="hljs-literal">true</span>;         <span class="hljs-comment">// 无论之前是否已经加锁，都将lock值设为true</span><br>    <span class="hljs-keyword">return</span> old;           <span class="hljs-comment">// 返回lock原来的值</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用TSL指令，实现互斥的算法逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> (TestAndSet(&amp;lock));        <span class="hljs-comment">// “上锁”并“检查”</span><br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;                     <span class="hljs-comment">// “解锁”</span><br>剩余区代码段...<br></code></pre></td></tr></table></figure><p>代码说明： 若刚开始 <code>lock</code> 是 <code>false</code>，则<code>TSL</code> 返回的 <code>old</code> 值为<code>false</code>，<code>while</code>循环条件不满足，直接跳过循环，进入临界区。 若刚开始 <code>lock</code> 是<code>true</code>，则执行 <code>TSL</code> 后 <code>old</code>返回的值为 <code>true</code>，<code>while</code>循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。</p><blockquote><p>简而言之：</p><p>假设lock现在为false，代表临界资源A空闲，那么我就可以访问这个资源，同时将lock=true，提醒别的进程，这个临界资源A我正在使用，你先别急，等等，然后用完之后再<code>lock = false;</code>，解锁，让别人能用</p><p>假设lock为true，代表临界资源正在有人使用，所以我必须等待，并且将lock=true，这无所谓，反正已经是true了</p><p><code>lock=true</code>这个语句只是为了让lock为false时可以上锁</p></blockquote><p>相比软件实现方法，<code>TSL</code>指令把“上锁”和“检查”操作用硬件的方式变成了一气呵成的原子操作。</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：不满足“<strong>让权等待</strong>”原则，暂时无法进入临界区的进程会占用CPU并循环执行<code>TSL</code> 指令，从而导致“忙等”。</li></ul><h3 id="swap指令">3. Swap指令</h3><p>有的地方也叫 <code>Exchange</code> 指令，或简称 <code>XCHG</code>指令。 <code>Swap</code>指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。</p><p>以下是用C语言描述的逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// swap原语</span><br><span class="hljs-comment">// swap指令的作用是交换两个变量的值</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Swap</span> <span class="hljs-params">(<span class="hljs-type">bool</span> *a, <span class="hljs-type">bool</span> *b)</span><br>&#123;<br>    <span class="hljs-type">bool</span> temp;<br>    temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>以下是使用Swap指令 实现互斥的算法逻辑，<code>lock</code>表示当前临界区是否被加锁</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// true 表示已经加锁， false 表示未加锁</span><br><span class="hljs-type">bool</span> old = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (old == <span class="hljs-literal">true</span>)&#123;<br>    Swap (&amp;lock, &amp;old);<br>&#125;<br>临界区代码段...<br>lock = <span class="hljs-literal">false</span>;<br>剩余区代码段...<br></code></pre></td></tr></table></figure><p>逻辑上来看 <code>Swap</code> 和 <code>TSL</code>并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在<code>old</code> 变量上），再将上锁标记 <code>lock</code> 设置为<code>true</code>，最后检查 <code>old</code>. 如果 <code>old</code> 为<code>false</code>则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p><blockquote><p>清晰地说：</p><p>①<code>old</code>是每个进程都要进行的一步，都必须将<code>old=true</code></p><p>②因为<code>lock</code>是某一特定临界资源的共享变量，当每一个进程准备访问这个特定的临界资源时，初始化<code>old=true</code>，然后进入<code>while</code>循环进行交换</p><p>③如果当前<code>lock</code>是<code>false</code>，则交换后old=false，则当前进程可以跳出循环进入临界区代码段，同时因为交换，<code>lock=old=true</code>上锁，不让别的进程来打扰，别的进程会因为<code>lock</code>变为<code>true</code>，一直在<code>while</code>循环等待</p><p>④当使用完临界资源，则将<code>lock=false</code>，此时别的进程再交换<code>old</code>和<code>lock</code>就能再判断<code>old=false</code>，就又进入了③步骤，可以跳出循环，使用临界资源。</p></blockquote><p>优缺点跟Test-and-Set指令一样，因为他俩逻辑上是基本一样的东西</p><ul><li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境</li><li>缺点：不满足“<strong>让权等待</strong>”原则，暂时无法进入临界区的进程会占用CPU并循环执行<code>Swap</code>指令，从而导致“忙等”。</li></ul><h3 id="互斥总结">*互斥🔒总结</h3><p>前面的七种方式其实都是🔒，下面对他们统一总结：</p><p>解决临界区最简单的工具就是互斥锁 (mutex lock)。</p><p>一个进程在进入临界区时应获得锁，在退出临界区时释放锁。函数<code>acquire()</code>获得锁，而函数 <code>release()</code>释放锁。</p><p>每个互斥锁有一个布尔变量available，表示锁是否可用。如果锁是可用的，调用<code>acquire()</code>会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">acquire()&#123;<br><span class="hljs-keyword">while</span>(!available)<br>           ;          <span class="hljs-comment">//忙等待              </span><br>available = <span class="hljs-literal">false</span>;  <span class="hljs-comment">//获得锁</span><br>&#125;<br>release()&#123;<br>    available = <span class="hljs-literal">true</span>;  <span class="hljs-comment">//释放锁</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>acquire()</code>或<code>release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p><p>互斥锁的主要缺点是<strong>忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用<code>acquire()</code>。当多个进程共享同一 CPU 时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p><p>需要连续循环忙等的互斥锁，都可称为<strong>自旋锁 (spin lock)</strong>，如TSL指令、swap指令、单标志法</p><p>特性:</p><ul><li>需忙等，进程时间片用完才下处理机，违反“让权等待“</li><li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低，</li><li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li><li>不太适用于单处理机系统，忙等的过程中不可能解锁</li></ul><blockquote><p>怎么感觉上面这部分总结有点不太懂啊，标记一处地点🐕💧</p></blockquote><h2 id="信号量机制">2.3.4 信号量机制</h2><h3 id="前期总结">0. 前期总结</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111525892.png"alt="知识总览" /><figcaption aria-hidden="true">知识总览</figcaption></figure><p>为什么引入信号量机制？</p><ul><li>为了更好的解决进程互斥与同步的问题</li></ul><h3 id="信号量机制-1">1. 信号量机制</h3><p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>（Semaphore）进行操作，从而很方便的实现了进程互斥、进程同步。</p><ul><li>信号量其实就是一个变量，可以用一个信号量（可以是一个整数，也可以是更复杂的记录型变量）<strong>来表示系统中某种资源的数量</strong>，比如：系统中只有一台打印机，就可以设置一个初值为1 的信号量。</li><li>原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</li></ul><p>一对原语：<code>wait(S)</code> 原语和 signal(S)原语，可以把原语理解为我们自己写的函数，函数名分别为 <code>wait</code>和 <code>signal</code>，括号里的信号量 S其实就是函数调用时传入的一个参数。</p><blockquote><p><code>wait</code>、<code>signal</code> 原语常简称为P、V操作（来自荷兰语 proberen 和 verhogen）。</p></blockquote><p>常把<code>wait(S)</code>、<code>signal(S)</code> 两个操作分别写为<code>P(S)</code>、<code>V(S)</code>。</p><h3 id="整型信号量">2. 整型信号量</h3><p>用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。</p><blockquote><p>与普通整数变量的区别：对信号量的操作只有三种，即<code>初始化</code>、<code>P操作</code>、<code>V操作</code>。</p></blockquote><p>eg：某计算机系统中有一台打印机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> S = <span class="hljs-number">1</span>;                <span class="hljs-comment">// 初始型整型信号量s，表示当前系统中可用的打印机资源数</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;         <span class="hljs-comment">// wait 原语，相当于“进入区”</span><br>    <span class="hljs-keyword">while</span> (S &lt;= <span class="hljs-number">0</span>);       <span class="hljs-comment">// 如果资源数不够，就一直循环等待</span><br>    S--;                  <span class="hljs-comment">// 如果资源数够，则占用一个资源</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(<span class="hljs-type">int</span> S)</span>&#123;      <span class="hljs-comment">// signal 原语，相当于“退出区”</span><br>    S++;                <span class="hljs-comment">// 使用完资源后，在退出区释放资源</span><br>&#125;<br></code></pre></td></tr></table></figure><p>进程 P0 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                 <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...       // 临界区，访问资源</span><br>signal(S);                <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>当P0在访问打印机资源的时候，假如说发生了进程切换，有另外的进程，比如进程P1，它也想使用打印机这种资源，所以使用之前先执行<code>wait (S);</code>，但是打印机已经被P0占用了，S是0，就一直循环等待，直到P0进程把打印机资源释放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...      // 临界区，访问资源</span><br>signal(S);               <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>...</p><p>进程 Pn （执行过程跟P1一样）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ...</span><br>wait (S);                <span class="hljs-comment">// 进入区，申请资源</span><br><span class="hljs-comment">// 使用打印机资源...      // 临界区，访问资源</span><br>signal(S);               <span class="hljs-comment">// 退出区，释放资源</span><br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>在任何一个进程开始执行的时候，进入程序内部执行检查操作，检查信号量资源是否被完全占据，如果被占据，就一直忙等待，等有空闲信号量资源的时候，再占据这个信号量。<strong>“检查”和“上锁”一气呵成</strong>，避免了并发、异步导致的问题。（双标志先检查法的改进，用一个原语来实现的）</p><p>存在的问题：不满足“让权等待”原则，会发生“忙等”（<strong>忙等</strong>，busywait，当一个进程正处在某临界区内，任何试图进入其临界区的进程都必须进入代码连续循环，陷入忙等状态，连续测试一个变量直到某个值出现为止）。</p><h3 id="记录型信号量">3. 记录型信号量⭐</h3><p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“<strong>记录型信号量</strong>”，即用记录型数据结构表示的信号量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 记录型信号量的定义 */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;                 <span class="hljs-comment">// 剩余资源数，S.value 的初值表示系统中某种资源的数目。</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span>         <span class="hljs-comment">// 等待队列</span><br>&#125; Semaphore;<br><br><span class="hljs-comment">/* 某进程需要使用资源时，通过wait原语申请 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(Semaphore S)</span> &#123;<br>    S.value--;<br>    <span class="hljs-keyword">if</span> (S.value &lt; <span class="hljs-number">0</span>) &#123;<br>        block (S.L);  <br>        <span class="hljs-comment">//如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（即阻塞队列）中。</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*进程使用完资源后，通过signal 原语释放*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">signal</span> <span class="hljs-params">(Semaphore S)</span> &#123;<br>    s.value++;<br>    <span class="hljs-keyword">if</span> (S.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        wakeup(S.L);<br>        <span class="hljs-comment">//释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>一个例子</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111625591.png"alt="记录型信号量例子" /><figcaption aria-hidden="true">记录型信号量例子</figcaption></figure><blockquote><p>可以去看原视频，更好理解</p></blockquote><p>最初：</p><ol type="1"><li>剩余资源数：2</li><li>等待队列：<code>-&gt;null</code></li></ol><p>P0进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：1，等待队列：<code>-&gt;null</code></li><li>把红色打印机分配给P0</li></ol><p>P1进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：0，<code>S.value=0</code>，资源恰好分配完，等待队列：<code>-&gt;null</code></li><li>把绿色打印机分配给P1</li></ol><p>P2进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：-1，<code>S.value = -1</code>，</li><li>因为<code>S.value &lt; 0</code>，执行<code>block (S.L);</code>，等待队列：<code>-&gt;P2</code></li></ol><p>P3进程申请：</p><ol type="1"><li>执行<code>wait(S)</code>原语，<code>value--</code>，剩余资源数：-2，<code>S.value = -2</code>，</li><li>因为<code>S.value &lt; 0</code>，执行<code>block (S.L);</code>，等待队列：<code>-&gt;P2-&gt;P3</code></li></ol><p>假设P0进程使用完打印机了，</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：-1，<code>S.value = -1</code>，还是小于等于0，说明等待队列当中还是有进程等待</li><li>执行<code>signal(S)</code>原语中的<code>wakeup(S.L);</code>，用于唤醒信号量对应的等待队列当中队头的进程<code>P2</code>，<code>P2</code>由阻塞态变为就绪态，等待队列：<code>-&gt;P3</code></li><li>把红色打印机分配给P2</li></ol><p>假设P2进程使用完打印机了，</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：0，<code>S.value = 0</code>，还是小于等于0，说明等待队列当中还是有进程等待</li><li>执行<code>signal(S)</code>原语中的<code>wakeup(S.L);</code>，用于唤醒信号量对应的等待队列当中队头的进程<code>P3</code>，等待队列：<code>-&gt;null</code></li><li>把红色打印机分配给P3</li></ol><p>如果之后CPU又回到为P1服务，P1也用完了打印机</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：1，<code>S.value = 1</code>，这时大于0了，说明等待队列当中已经没有进程等待</li><li>所以在执行<code>signal(S)</code>原语时，不需要执行<code>wakeup(S.L);</code></li><li>P1继续往下执行，结束</li></ol><p>之后CPU为P3服务，P3也用完了打印机</p><ol type="1"><li>执行<code>signal(S)</code>原语，<code>value++</code>，剩余资源数：2，<code>S.value = 2</code>，这时大于0了，说明等待队列当中已经没有进程等待</li><li>所以在执行<code>signal(S)</code>原语时，不需要执行<code>wakeup(S.L);</code></li><li>P3继续往下执行，结束</li></ol><p>对信号量 <code>S</code> 的一次 <code>P</code>操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value &lt; 0</code>时表示该类资源已分配完毕，因此进程应调用 <code>block</code>原语进行自我阻塞（当前运行的进程从运行态 -&gt;阻塞态），主动放弃处理机，并插入到该类资源的等待队列 S.L 中。</p><p>可见，该机制<strong>遵循了“让权等待”原则，不会出现“忙等”现象</strong>。</p><p>对信号量 S 的一次<code>V</code>操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value++</code>，表示资源数加1，若加1后仍是<code>S.value &lt;= 0</code>，表示依然有进程在等待该类资源，因此应调用<code>wakeup</code>原语唤醒等待队列中的第一个进程（被唤醒进程从阻塞态 -&gt; 就绪态）。</p><blockquote><p>注：若考试中出现 P(S)、V(S)的操作，除非特别说明，否则默认S为记录型信号量</p></blockquote><h2 id="信号量的应用">2.3.5 信号量的应用</h2><h3 id="信号量机制实现进程互斥">1. 信号量机制实现进程互斥</h3><p><strong>实现方法</strong></p><ul><li>分析并发进程的关键活动，<strong>划定临界区</strong>（如：对临界资源打印机的访问就应放在临界区）</li><li>设置互斥信号量 <code>mutex</code>，<strong>初值</strong>为 1</li><li>在进入区 <code>P(mutex)</code> —— 申请资源</li><li>在退出区 <code>V(mutex)</code> —— 释放资源</li></ul><blockquote><p>信号量 <code>mutex</code> 表示“进入临界区的名额”。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*记录型信号量的定义*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">int</span> value;                <span class="hljs-comment">// 剩余资源数</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">process</span> *<span class="hljs-title">L</span>;</span>        <span class="hljs-comment">// 等待队列</span><br>&#125; Semaphore;<br><br><br><span class="hljs-comment">/* 信号量机制实现互斥 */</span><br>Semaphore mutex = <span class="hljs-number">1</span>;   <span class="hljs-comment">// 初始化信号量</span><br><span class="hljs-comment">//要会自己定义记录型信号量，但如果题目中没特别说明,可以把信号量的声明简写成这种形式</span><br><br>P1()&#123;<br>    ...<br>    P(mutex);                <span class="hljs-comment">// 使用临界资源前需要加锁</span><br>    临界区代码段<br>    V(mutex);                <span class="hljs-comment">// 使用临界资源后需要解锁</span><br>    ...<br>&#125;<br><br>P2()&#123;<br>    ...<br>    P(mutex);<br>    临界区代码段<br>    V(mutex);<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>注意： 对不同的临界资源需要设置不同的互斥信号量。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121507626.png"alt="对不同的临界资源需要设置不同的互斥信号量" /><figcaptionaria-hidden="true">对不同的临界资源需要设置不同的互斥信号量</figcaption></figure><p><strong>P、V操作必须成对出现</strong>。缺少<code>P(mutex)</code>就不能保证临界资源的互斥访问。缺少 <code>V(mutex)</code>会导致资源永不被释放，等待进程永不被唤醒。</p><h3 id="信号量机制实现进程同步">2. 信号量机制实现进程同步</h3><p>进程同步：要让<strong>各并发进程按要求有序地推进</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">P1()&#123;<br>    代码 <span class="hljs-number">1</span>;<br>    代码 <span class="hljs-number">2</span>; <br>    代码 <span class="hljs-number">3</span>;<br>&#125;<br>P2()&#123;<br>    代码 <span class="hljs-number">4</span>;<br>    代码 <span class="hljs-number">5</span>; <br>    代码 <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如：P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p><p>若 P2 的“代码4”要基于 P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。这就是<strong>进程同步问题</strong>，让本来异步并发的进程互相配合，有序推进。</p><p>用信号量实现进程同步：</p><ul><li><p>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）；</p></li><li><p>设置同步信号量 S，初始为 0；</p></li><li><p>在“前操作”之后执行 V(S)；</p></li><li><p>在“后操作”之前执行 P(S)；</p><blockquote><p>前V后P</p></blockquote></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 信号量机制实现同步 */</span><br>Semaphore S = <span class="hljs-number">0</span>;<br><br>P1()&#123;<br>    代码 <span class="hljs-number">1</span>;<br>    代码 <span class="hljs-number">2</span>; <br>    V(S);   <br>    代码 <span class="hljs-number">3</span>;<br>&#125;<br><br>P2()&#123;    <span class="hljs-comment">// P2 的执行需要依赖一种信号量资源S，而这种资源只能由P1 释放，因此保证必须 P1 后再 P2</span><br>    P(S);<br>    代码 <span class="hljs-number">4</span>;<br>    代码 <span class="hljs-number">5</span>; <br>    代码 <span class="hljs-number">6</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>若先执行到 <code>V(S)</code> 操作，则 <code>S++</code> 后<code>S = 1</code>。之后当执行到 <code>P(S)</code> 操作时，由于<code>S = 1</code>，表示有可用资源，会执行 <code>S--</code>，S 的值变回0，P2 进程不会执行 <code>block</code> 原语，而是继续往下执行代码4。</li></ul><blockquote><p>执行顺序 1、2、4、5、6。保证代码4在代码2之后执行</p></blockquote><ul><li>若先执行到 <code>P(S)</code> 操作，由于<code>S = 0</code>，<code>S--</code> 后<code>S = -1</code>，表示此时没有可用资源，因此P操作中会执行 block原语，主动请求阻塞。</li><li>之后当处理机交还处理进程P1，执行完代码2，继而执行 <code>V(S)</code>操作，<code>S++</code>，使 S 变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在 V 操作中执行<code>wakeup</code> 原语，唤醒 P2 进程。这样 P2 就可以继续执行 代码4了。</li></ul><blockquote><p>理解：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源。</p></blockquote><h3 id="信号量机制实现前驱关系">3. 信号量机制实现前驱关系</h3><blockquote><p>其实是用信号量机制实现进程同步的升级版，多级同步问题，记住前V后P</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121521211.png"alt="信号量机制实现前驱关系" /><figcaption aria-hidden="true">信号量机制实现前驱关系</figcaption></figure><h2 id="进程同步与互斥经典问题">2.3.6 进程同步与互斥经典问题</h2><h3 id="生产者-消费者问题">1. 生产者-消费者问题</h3><h4 id="问题描述">(1) 问题描述</h4><p>系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。(注：这里的“产品”理解为某种数据)</p><ul><li>生产者、消费者<code>共享</code>一个初始为空、大小为n的缓冲区。</li><li>只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。</li><li>只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。</li><li>缓冲区是临界资源，各进程必须<code>互斥</code>地访问。</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121535185.png"alt="生产者-消费者问题" /><figcaption aria-hidden="true">生产者-消费者问题</figcaption></figure><h4 id="问题分析">(2) 问题分析</h4><blockquote><p>常把<code>wait(S)</code>、<code>signal(S)</code> 两个操作分别写为<code>P(S)</code>、<code>V(S)</code>。</p></blockquote><p>PV操作题目分析步骤：</p><ol type="1"><li><p>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</p><p>生产者和消费者对缓冲区互斥访问是<code>互斥关系</code>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，它们也是<code>同步关系</code>。</p></li><li><p>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</p><p>生产者每次要消耗 (P)一个空闲缓冲区，并生产(V)一个产品。</p><p>消费者每次要消耗 (P) 一个产品，并增加一个空闲缓冲区(V)。</p><p>往缓冲区放入/取走产品需要互斥。</p></li><li><p>设置信号量。并根据题目条件确定信号量初值。（<strong>互斥信号量初值一般为</strong>1，同步信号量的初始值要看对应资源的初始值是多少）</p></li></ol><p>在这样的环境下，设置信号量如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">semaphore mutex = <span class="hljs-number">1</span>;   <span class="hljs-regexp">//</span> 互斥信号量，实现对缓冲区的互斥访问<br><br>semaphore empty = n;   <span class="hljs-regexp">//</span> 同步信号量，表示空闲缓冲区的数量 <br>semaphore full = <span class="hljs-number">0</span>;    <span class="hljs-regexp">//</span> 同步信号量，表示产品的数量，也即非空缓冲区的数量<br><span class="hljs-regexp">//</span>full表示缓冲区有多少产品，empty表示缓冲区有多少空位<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121621055.png"alt="前驱图" /><figcaption aria-hidden="true">前驱图</figcaption></figure><h4 id="代码实现">(3) 代码实现</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121621165.png"alt="代码实现" /><figcaption aria-hidden="true">代码实现</figcaption></figure><h4 id="一些分析">(4) 一些分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121625077.png"alt="实现互斥的P操作一定要在实现同步的P操作之后" /><figcaptionaria-hidden="true">实现互斥的P操作一定要在实现同步的P操作之后</figcaption></figure><blockquote><p>如果是按照（3）中的代码</p><p>当缓冲区内已经放满产品时，则<code>empty=0，full=n</code>，</p><p>生产者执行<code>P(empty)</code>，由于已经没有空闲缓冲区，因此生产者被阻塞</p><p>由于生产者被阻塞，因此切换回消费者进程，消费者进程执行<code>P(full)</code>，消耗一个产品，<code>full = n-1</code>，</p><p>然后接着执行<code>P(mutex);从缓冲区取出一个产品;V(mutex);</code>，然后继续<code>V(empty)</code>，增加一个空闲缓冲区，然后就能回到消费者那里执行了……，完美</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312121626796.png"alt="知识点回顾" /><figcaption aria-hidden="true">知识点回顾</figcaption></figure><h3 id="多生产者-多消费者问题">2. 多生产者-多消费者问题</h3><h4 id="问题描述-1">(1) 问题描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151147746.png"alt="多生产者-多消费者问题" /><figcaption aria-hidden="true">多生产者-多消费者问题</figcaption></figure><p>多意思是多类</p><h4 id="问题分析-1">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151148404.png"alt="多生产者-多消费者问题" /><figcaption aria-hidden="true">多生产者-多消费者问题</figcaption></figure><h4 id="代码实现-1">(3) 代码实现</h4><p><strong>有mutex：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151150962.png"alt="有mutex" /><figcaption aria-hidden="true">有mutex</figcaption></figure><p><strong>无mutex：</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151151343.png"alt="无mutex" /><figcaption aria-hidden="true">无mutex</figcaption></figure><p>结论：即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象</p><p><strong>为什么有mutex和没有mutex一样呢？</strong></p><ul><li>原因在于：本题中的缓冲区大小为1，在任何时刻，apple、 orange、 plate三个同步信号量中最多只有一个是1。因此在任何时刻，最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区</li></ul><p><strong>如果有两个盘子plate</strong></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151153035.png"alt="如果有两个盘子plate" /><figcaption aria-hidden="true">如果有两个盘子plate</figcaption></figure><h4 id="一些总结">(4) 一些总结</h4><p>总结：在生产者-消费者问题中，如果缓冲区大小为1，那么有可能不需要设置互斥信号量就可以实现互斥访问缓冲区的功能。当然，这不是绝对的，要具体问题具体分析。</p><p>建议：在考试中如果来不及仔细分析，可以加上互斥信号量，保证各进程一定会互斥地访问缓冲区。但需要注意的是，实现互斥的P操作一定要在实现同步的P操作之后，否则可能引起“死锁”。</p><blockquote><p>加上互斥信号量就完事了</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151155820.png"alt="总结" /><figcaption aria-hidden="true">总结</figcaption></figure><h3 id="吸烟者问题">3. 吸烟者问题</h3><h4 id="问题描述-2">(1) 问题描述</h4><blockquote><p>可生产多种产品的单生产者——多消费者问题</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151157921.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="问题分析-2">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151310903.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151311504.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="代码实现-2">(3) 代码实现</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151315256.png"alt="吸烟者问题" /><figcaption aria-hidden="true">吸烟者问题</figcaption></figure><h4 id="一些总结-1">(4) 一些总结</h4><p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。</p><p>值得吸取的精华是：“轮流让各个吸烟者吸烟”，必然需要：“轮流的在桌上放上组合一、二、三”，注意体会我们是如何用一个整型变量i 实现这个“轮流”过程的。</p><p>如果题目改为“每次随机地让一个吸烟者吸烟”，我们有应该如何用代码写出这个逻辑呢？<code>random()</code></p><p>若一个生产者要生产多种产品(或者说会引发多种前驱事件)，那么各个V操作应该放在各自对应的“事件”发生之后的位置。</p><h3 id="读者写者问题">4. 读者写者问题</h3><h4 id="问题描述-3">(1) 问题描述</h4><blockquote><p>读进程之间不互斥，写进程和读进程、写进程都互斥</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151319006.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><h4 id="问题分析-3">(2) 问题分析</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151320681.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><h4 id="代码实现-3">(3) 代码实现</h4><p><strong>① 给count加mutex互斥访问</strong></p><ul><li>为什么要加mutex——保证对count变量的互斥访问</li><li>潜在的问题：读进程正在读这个文件，count的值是1，如果有一个写进程到达，由于第一个读进程已经对rw进行了P操作，rw的值变成了0，写进程在进行<code>P(rw)</code>，会被阻塞在这个信号量上面，如果这时再有读进程到达，因为count的值是1，读进程可以跳过P操作，执行下面的代码，如果有源源不断的读进程到达的话，都能直接执行，由于最后一个读进程读完之后才会<strong>解锁</strong>，会导致写进程饿死的现象</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151325300.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><p><strong>② 加一个w实现“读写公平法”</strong></p><p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151335105.png"alt="读者写者问题" /><figcaption aria-hidden="true">读者写者问题</figcaption></figure><blockquote><p>上面的几种情况可以自己分析一下</p></blockquote><h4 id="一些总结-2">(4) 一些总结</h4><p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p><p>其核心思想在于设置了一个计数器 count用来记录当前正在访问共享文件的读进程数。我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p><p>另外，对 count变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现“一气呵成”，自然应该想到用互斥信号量。</p><p>最后，还要认真体会我们是如何解决“写进程饥饿”问题的。</p><p>绝大多数的考研PV操作大题都可以用之前介绍的几种生产者-消费者问题的思想来解决，如果遇到更复杂的问题，可以想想能否用读者写者问题的这几个思想来解决。</p><h3 id="哲学家进餐问题">5. 哲学家进餐问题</h3><h4 id="问题描述-4">(1) 问题描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151338885.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="问题分析-4">(2) 问题分析</h4><p>每个哲学家吃饭前依次拿起左、右两支筷子：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151339523.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="代码实现-4">(3) 代码实现</h4><p>如何防止死锁的发生呢?</p><p>①可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的</p><p>②要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况</p><blockquote><p>思考代码如何实现这两种方案</p></blockquote><p>③ 仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</p><p>假设0先想吃饭，1再想吃，2再想吃：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151343096.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><p>假设0先想吃，4再想吃：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151345367.png"alt="哲学家进餐问题" /><figcaption aria-hidden="true">哲学家进餐问题</figcaption></figure><h4 id="一些总结-3">(4) 一些总结</h4><p>哲学家进餐问题的关键在于解决进程死锁。</p><p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要<strong>同时持有两个临界资源</strong>，因此就有“死锁”问题的隐患。</p><p>如果在考试中遇到了一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</p><p>可以参考哲学家就餐问题解决死锁的三种思路。</p><h2 id="管程">2.3.7 管程</h2><h3 id="why">why</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151444301.png"alt="why" /><figcaption aria-hidden="true">why</figcaption></figure><h3 id="管程的定义及基本特征">管程的定义及基本特征</h3><p>管程是一种特殊的软件模块，有这些部分组成：</p><ol type="1"><li><p>局部于管程的共享数据结构说明</p></li><li><p>对该数据结构进行操作的一组过程</p></li><li><p>对局部于管程的共享数据设置初始值的语句</p></li><li><p>管程有一个名字</p><blockquote><p>跨考Tips：“过程”其实就是“函数”，可以类比于面向对象的思想</p><p>管程当做类class</p><p>共享数据结构当做类里面的变量</p><p>一组过程可以看做是类里面的函数</p></blockquote></li></ol><p>管程的基本特征：</p><ol type="1"><li>局部于管程的数据只能被局部于管程的过程所访问</li><li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ol><h3 id="拓展">拓展</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151554816.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151555932.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151556747.png"alt="管程" /><figcaption aria-hidden="true">管程</figcaption></figure><h1 id="死锁">2.4 死锁</h1><h2 id="死锁的概述">2.4.1 死锁的概述</h2><h3 id="资源竞争问题">1. 资源竞争问题</h3><p>系统中有许多不可被抢占的资源，即临界资源；如打印机、数据文件、队列、信号量等</p><p>需要采用互斥机制访问临界资源</p><p><strong>可重用性资源和消耗性资源</strong></p><ol type="1"><li><p>可重用性资源</p><ul><li><p>只能分配给一个进程使用，不允许多个进程共享</p></li><li><p>必须按以下顺序使用</p><ul><li><p>请求资源：如果请求失败，请求进程将会被阻塞</p></li><li><p>使用资源：进程使用该资源</p></li><li><p>释放资源：当进程使用完后自己释放资源</p></li></ul></li><li><p>系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它</p></li></ul></li></ol><ol start="2" type="1"><li><p>可消耗性资源</p><p>又称临时性资源；由进程动态创建和消耗，性质如下：</p><ul><li>① 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的</li><li>②进程可以不断创造可消耗性资源的单元，将它们放入该资源类的缓冲区中，以增加该资源类的单元数目</li><li>③进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中</li></ul></li></ol><p>​ 最典型可消耗性资源是进程间传递的消息！</p><p><strong>可抢占性资源和不可抢占性资源</strong></p><ol type="1"><li>可抢占性资源：某进程在获得这类资源后，该资源可以再被其它进程或系统抢占</li></ol><ol start="2" type="1"><li>不可抢占性资源：一旦系统把该类资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放</li></ol><h3 id="计算机系统中的死锁">2. 计算机系统中的死锁</h3><p>① 竞争不可抢占性资源引起死锁</p><p>系统中不可抢占性资源数量不足以满足多个进程运行需要，使得进程在运行过程中，会因争夺资源而陷入僵局；如下图所示：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151608885.png"alt="共享文件时的死锁情况" /><figcaption aria-hidden="true">共享文件时的死锁情况</figcaption></figure><p>② 竞争可消耗资源引起死锁</p><p>图3-13示例为三个进程在利用消息通信机制进行通信时(竞争可消耗资源，即消息m)所形成的死锁情况。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151608470.png"alt="进程之间通信时的死锁" /><figcaption aria-hidden="true">进程之间通信时的死锁</figcaption></figure><p>③ 进程推进顺序不当引起死锁</p><p>除了多个进程对资源的竞争会引发死锁外，进程在运行过程中对资源进行申请和释放的顺序是否合法，也是系统中是否会产生死锁的一个重要因素</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151609292.png"alt="进程推进顺序对死锁的影响" /><figcaption aria-hidden="true">进程推进顺序对死锁的影响</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151612111.png"alt="进程推进顺序合法" /><figcaption aria-hidden="true">进程推进顺序合法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151612279.png"alt="进程推进顺序非法" /><figcaption aria-hidden="true">进程推进顺序非法</figcaption></figure><p>上面其实就是说了一个问题：什么时候会发生死锁？</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151617534.png"alt="什么时候会发生死锁？" /><figcaption aria-hidden="true">什么时候会发生死锁？</figcaption></figure><h3 id="死锁的定义">3. 死锁的定义</h3><blockquote><p>婆婆特里面的：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。</p></blockquote><p>在并发环境下，各进程因竞争资源而造成的一种互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象，就是“死锁”，发生死锁后若无外力干涉这些进程都将无法向前推进</p><h3 id="死锁饥饿死循环">4. 死锁、饥饿、死循环</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151616034.png"alt="死锁、饥饿、死循环" /><figcaption aria-hidden="true">死锁、饥饿、死循环</figcaption></figure><h3 id="产生死锁的必要条件">5. 产生死锁的必要条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151617833.png"alt="产生死锁的必要条件" /><figcaption aria-hidden="true">产生死锁的必要条件</figcaption></figure><h3 id="处理死锁的方法">6. 处理死锁的方法</h3><ol type="1"><li>预防死锁。破坏死锁产生的四个必要条件中的一个或几个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁(银行家算法)</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol><h2 id="预防死锁">2.4.2 预防死锁</h2><ul><li>预防死锁的方法是通过破坏产生死锁的四个必要条件中的一个或几个，以避免发生死锁</li><li>互斥条件是非共享设备所必须的特性；不仅不能改变，还应加以保证</li><li>因此，死锁预防主要是破坏产生死锁的后三个条件</li></ul><h3 id="破坏互斥条件">1.破坏互斥条件</h3><blockquote><p>不建议这样做</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151621206.png"alt="破坏互斥条件" /><figcaption aria-hidden="true">破坏互斥条件</figcaption></figure><h3 id="破坏不可剥夺条件">2. 破坏不可剥夺条件</h3><blockquote><p>不可剥夺条件又称 不可抢占条件</p></blockquote><p>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。</p><p>破坏不剥夺条件：</p><p>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。</p><p>方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级(比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用)</p><p>该策略的缺点：</p><ol type="1"><li>实现起来比较复杂。</li><li>释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。</li><li>反复地申请和释放资源会增加系统开销，降低系统吞吐量。</li><li>若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。</li></ol><h3 id="破坏请求和保持条件">3. 破坏请求和保持条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151628930.png"alt="破坏请求和保持条件" /><figcaption aria-hidden="true">破坏请求和保持条件</figcaption></figure><h3 id="破坏循环等待条件">4. 破坏循环等待条件</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151637987.png"alt="破坏循环等待条件" /><figcaption aria-hidden="true">破坏循环等待条件</figcaption></figure><h2 id="避免死锁">2.4.3 避免死锁</h2><ul><li>属于事先预防的策略，但并不是事先采取某种限制措施去破坏产生死锁的必要条件</li><li>是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁</li><li>这种方法所施加的限制条件较弱，可能获得较好的系统性能；目前常用此方法来避免发生死锁</li></ul><h3 id="系统安全状态">1. 系统安全状态</h3><ul><li>把系统的状态分为安全状态和不安全状态</li><li>当系统处于安全状态时，可避免发生死锁；当系统处于不安全状态时，则可能进入到死锁状态</li></ul><p>① 安全状态</p><ul><li>定义：系统能按某种进程推进顺序为每个进程分配所需资源，使进程都能顺利完成。若存在该顺序，则系统处于<strong>安全状态</strong>;否则，处于<strong>不安全状态</strong></li><li>允许进程动态地申请资源，但系统在进行资源分配之前应先计算此次资源分配的安全性</li></ul><p>② 安全状态示例</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151646699.png"alt="安全状态示例" /><figcaption aria-hidden="true">安全状态示例</figcaption></figure><p>P2---P1----P3</p><blockquote><p>总结：</p><p>所谓安全序列，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。当然，安全序列可能有多个。</p><p>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态)</p><p>因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。这也是“银行家算法”的核心思想。</p></blockquote><h3 id="银行家算法">2. 银行家算法</h3><blockquote><p>Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。</p></blockquote><p>银行家算法的实质就是<strong>要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</strong></p><h4 id="例子">例子</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151654236.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151654833.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><h4 id="银行家算法中的数据结构">银行家算法中的数据结构</h4><p>为了实现银行家算法，在系统中必须设置这样四个数据结构：</p><p>1）<strong>Available向量</strong>：系统中可利用的资源数目，长度为m的一维数组</p><p>2）<strong>Max矩阵</strong>：每个进程对每种资源的最大需求，n*m的矩阵</p><p>3）<strong>Allocation矩阵</strong>：每个进程已分配的各类资源的数目，n*m的矩阵</p><p>4）<strong>Need矩阵</strong>：每个进程还需要的各类资源数，<code>Need[i,j] = Max[i,j] - allocation[i, j]</code></p><p>5）<strong>Request</strong>：表示进程此次申请的各种资源数，长度为m的一维数组</p><h4 id="银行家算法的描述">银行家算法的描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151659146.png"alt="初试数据" /><figcaption aria-hidden="true">初试数据</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312151657873.png"alt="银行家算法" /><figcaption aria-hidden="true">银行家算法</figcaption></figure><h4 id="section"></h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628354.png"alt="image-20231107162817252" /><figcaption aria-hidden="true">image-20231107162817252</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628465.png"alt="image-20231107162835370" /><figcaption aria-hidden="true">image-20231107162835370</figcaption></figure><h4 id="银行家算法流程图表示">银行家算法流程图表示</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071626146.png"alt="image-20231107162637053" /><figcaption aria-hidden="true">image-20231107162637053</figcaption></figure><h4 id="银行家算法的程序实现">银行家算法的程序实现</h4><p><strong>数据结构：</strong></p><ol type="1"><li>可用资源向量<code>Available</code>,这是一个一维数组<code>Available[j],j=1,…m</code>，表示第<code>j</code>种资源的可用数量，其中<code>m</code>为资源的种类个数</li><li>最大资源需求矩阵<code>Max</code>,这是一个<code>n*m</code>的二维数组，其中<code>n</code>为进程个数。单元<code>Max[i,j]</code>存储的数值表示第<code>i</code>个进程最多需要多少第<code>j</code>种资源</li><li>分配矩阵<code>Allocation</code>，这是一个<code>n*m</code>的二维数组。单元<code>Allocation[i,j]</code>存储的是已经分配给第<code>i</code>个进程的第<code>j</code>种资源的数量</li><li>需求矩阵<code>Need</code>，这也是一个<code>n*m</code>的矩阵，单元<code>Need[i,j]</code>存储的数值表示进程<code>i</code>还需要多少第<code>j</code>种资源的数量才能完成退出。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>詹姆斯？<br></code></pre></td></tr></table></figure><p>可以看一下b站这个视频，做题是话应该够了：</p><p><ahref="https://www.bilibili.com/video/BV1rJ411p7au/?spm_id_from=333.337.search-card.all.click&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">操作系统-银行家算法_哔哩哔哩_bilibili</a></p><h2 id="死锁的检测和解除">2.4.4 死锁的检测和解除</h2><p>如果在系统中，既不采取死锁预防措施也未配有死锁避免算法，系统很可能会发生死锁；在这种情况下，系统应当提供两个算法：</p><p>① 死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁</p><p>②死锁解除算法：当认定系统中已发生了死锁，利用该算法可将系统从死锁状态中解脱出来</p><h3 id="死锁的检测">1. 死锁的检测</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152135794.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程...</p><p>如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁(相当于能找到一个安全序列)</p><p>如果最终不能消除所有边，那么此时就是发生了死锁，最终还连着边的那些进程就是处于死锁状态的进程</p><ul><li>举个例子，可以消除所有边，即无死锁发生</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152140347.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><ul><li>举个例子，不可消除所有边，即产生死锁</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152141978.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152142522.png"alt="死锁的检测" /><figcaption aria-hidden="true">死锁的检测</figcaption></figure><h3 id="死锁的解除">2. 死锁的解除</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312152143990.png"alt="死锁的解除" /><figcaption aria-hidden="true">死锁的解除</figcaption></figure><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/weixin_43914604/article/details/104415990">《王道操作系统》学习笔记总目录+思维导图_王道操作系统思维导图-CSDN博客</a></p><p><ahref="https://www.zhihu.com/tardis/zm/art/384678500?source_id=1005">详解操作系统之银行家算法（附流程图）(zhihu.com)</a></p><p><ahref="https://www.bilibili.com/video/BV1YE411D7nH?p=13&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">2.1_2_进程的状态与转换、进程的组织_哔哩哔哩_bilibili</a></p><p><a href="https://zhuanlan.zhihu.com/p/585216267">【OS 操作系统】047 |进程同步与互斥 - 知乎 (zhihu.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学导论</title>
    <link href="/2023/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="密码学导论">密码学导论</h1><h2 id="密码学的发展概况">密码学的发展概况</h2><p>密码学是一门古老、年轻且深奥的学科。</p><p>密码学经历了从古典密码学到现代密码学的演变。</p><p>密码学是研究信息系统安全保密的科学。它包括密码编码学和密码分析学。</p><p>1949年前密码技术是一门技术性很强的艺术，而不是一门科学。</p><p>1949年shannon “保密系统的通信理论”，密码学成为科学。</p><p><strong>1976年Diffie和Hellman“密码学的新方向”，密码学的一场革命，标志着公钥密码学的出现</strong></p><p>1977年美国国家标准局公布DES，并公开算法，揭开神秘面纱。</p><p>密码分析者通常可以在下述情况下进行攻击：</p><p>（1）唯密文攻击：密码分析者仅知道一些密文。</p><p>（2）已知明文攻击：密码分析者知道一些明文和相应的密文。（随便给的一些明文和密文）</p><p>（3）选择明文攻击：密码分析者可以选择一些明文，并得到相应的密文。（有加密机）</p><p>（4）选择密文攻击：密码分析者可以选择一些密文，并得到相应的明文。（有解密机）</p><p>唯密文攻击的强度最弱，攻击强度依此增加。</p><blockquote><p>公钥加密中选择明文攻击是自动发生的，因为是公钥加密，🐕</p></blockquote><p>无条件安全的（不可破译的）：一次一密方案（一次一密乱码本），不可破译的</p><p>计算上安全的：流密码、分组密码、公钥密码，给你无限的资源你是可以破译的，这样我们也是可以接受的</p><p>密码算法只要满足以下两条准则之一就行：</p><p><strong>（1） 破译密文的代价超过被加密信息的价值。</strong></p><p><strong>（2 ) 破译密文所花的时间超过信息的有用期。</strong></p><p>满足以上两个准则的密码算法在实际中是可用的。</p><p>多表代换密码</p><h1 id="分组密码">分组密码</h1><h2 id="分组密码-1">分组密码</h2><h3 id="概念">概念</h3><p>若明文流被分割成等长串，各串用相同的加密算法和相同的密钥进行加密，就是分组密码。</p><p>即当：</p><ol type="1"><li><p>明文和密文是固定长度为 <spanclass="math inline">\(\mathrm{n}\)</span> 的比特串 <spanclass="math inline">\(m=m_1 m_2 m_3 \cdots m_n\)</span>, <spanclass="math inline">\(c=c_1 c_2 c_3 \cdots c_n\)</span></p></li><li><p>加密密钥和解密密钥相等，是固定长度为 <spanclass="math inline">\(r\)</span> 的比特串 <spanclass="math inline">\(k=k_1 k_2 k_3 \cdots k_r\)</span></p></li><li><p>加密算法为 <spanclass="math inline">\(c=\operatorname{Enc}_K(m)\)</span></p></li><li><p>解密算法为 <spanclass="math inline">\(m=\operatorname{Dec}_k(c)=\operatorname{Dec}_K\left(\operatorname{Enc}_k(m)\right)\)</span>.</p></li></ol><p>则称这样的加解密算法为分组密码</p><h3 id="构造原则">构造原则</h3><p>分组密码的构造都应遵循下列几个原则：</p><ul><li><p>要有足够大分组长度（保证足够大的明文空间，避免给攻击者提供太多的明文统计特征信息）</p></li><li><p>密钥空间要尽可能大（防止穷举密钥）</p></li><li><p>保证足够强的密码算法复杂度以加强分组密码算法自身的安全性，</p><p>方法如下：</p><ul><li><p>先将一个明文分组划分为若干子组分别进行处理，然后合并起来再做一些适当的变换，以增大密码算法强度。采取这样的措施也便于密码算法的实际分析和评测</p></li><li><p>采用乘积密码的思想。通过两种或两种以上简单密码的逐次应用，构成强度比其中任何一个更强的加密结果。有效克服单一密码变换的弱点</p></li></ul></li><li><p>软件实现尽量采用子块和简单运算，采用加法、乘法、异或和移位等指令，易于标准处理器完成运算</p></li><li><p>加解密硬件结构最好一致，这样便于应用超大规模集成芯片实现。以简化系统整体结构的复杂性。</p></li></ul><h2 id="对称密码">对称密码</h2><p>对称密钥算法(Symmetric-keyalgorithm)，又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。</p><p>对称加密的特点是，在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。</p><p>对称加密的优点是速度快，缺点是需要共享密钥，安全性不足。</p><blockquote><p>​在没有非对称密码之前，我们所有的密码方案都属于对称密码，如今我们一般特指对称密码中的块密码指代对称密码，我们在RSA中了解了对称密码的缺点，并且了解了非对称密码的优点，那么为什么还需要使用对称密码呢？实际上对称密码还拥有非对称密码不可比拟的一个优点则是：<strong>快</strong>。</p><p>​实际上，可能会考虑非对称密码密钥过长，算法较复杂，需要分块设计填充算法等等，这些都不是最重要的缺点，最主要的便是非对称密码和对称密码比起来在同等性能下实在是太慢了。甚至部分小功耗设备性能不足以支持运行一些非对称密码。所以对称密码依然广泛运用于我们的现实生活中，大部分的对称加密算法都是基于<code>ARX</code>操作，即加法<code>Add</code>，移位<code>Rotate</code>，异或<code>Xor</code>，在速度上相对于非对称密码复杂的幂、指数和函数运算来说天生有着绝对的优势。</p></blockquote><p>对称加密算法可分为两大类型:</p><ul><li><code>分组加密</code>：先将明文切分成一个个固定大小的块，再对每个块进行加密，这种方式被称为分组加密或块加密，有的资料称呼为"分组密码"或"块密码"。</li><li><code>流加密</code>：将密钥扩展到与密文等长后，用扩展后的密钥与明文按比特位做异或运算</li></ul><p>相比分组加密，流加密具有速度快，消耗少的优点，在网络通信的某些特定场景比较有优势。然而流加密的发展落后于分组加密，其安全性、可扩展性、使用灵活性上，目前认为还是比不上分组加密的，同时某些分组加密算法可以兼具流加密的部分特点。因此对称加密的主流仍然是分组加密。</p><p>常见的流加密算法如<code>RC4</code>、<code>ChaCha20</code>等等，它们的安全强度主要取决于扩展后密钥的随机性。</p><p>流加密不是本章的学习重点，这里只简单了解一下，接下来开始学习分组加密，后文提到对称加密时，一般都是特指分组加密。</p><h2 id="des">DES</h2><ul><li><p>DES是一种典型的块加密，即将明文分成一块一块的数据，分别进行加密再进行拼接得到密文。</p><p>在DES中，具有如下特点</p><ol type="1"><li><p>输入<code>64</code>位。</p></li><li><p>输出<code>64</code>位。</p></li><li><p>密钥<code>64</code>位，使用<code>64</code>位密钥中的<code>56</code>位，剩余的<code>8</code>位要么丢弃，要么作为奇偶校验位。</p></li><li><p>采用<code>Feistel</code>迭代结构：</p><ol type="1"><li>明文经过 16 轮迭代得到密文。</li><li>密文经过类似的 16 轮迭代得到明文。</li></ol></li></ol></li><li><p>其实Feistel是用来构建块加密算法的对称结构，但是从CTF的实际角度来说，我们并不从Feistel开始介绍而是直接介绍DES，有关Feistel迭代结构的详细介绍可以参考</p><p><code>https://zhuanlan.zhihu.com/p/381026295</code></p><p>在这里我们只需要了解Feistel是一种轮次迭代方式即可。</p></li></ul><h1 id="公钥密码学">公钥密码学</h1><h2 id="公钥密码体制的模型">公钥密码体制的模型</h2><ul><li>公钥密码体制在加密和解密时使用不同的密钥，这样通信双方无须预先交换密钥就可以建立保密通信。克服了对称密码体制中通信双方必须使用一个安全信道预先约定密钥的缺点</li><li>在公钥密码体制中，每个用户保存一对密钥，即公钥PK和私钥SK，PK是公开信息，不需要保密。虽然公钥密码体制的私钥SK和公钥PK是成对出现的，但给定公钥，要确定出私钥是计算上不可行的。持有公钥的任何人都可以加密明文产生密文，只有持有私钥的人才能够解密</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272226233.png"alt="image-20231127222619147" /><figcaption aria-hidden="true">image-20231127222619147</figcaption></figure><h2 id="公钥密码体制的基本原理">公钥密码体制的基本原理</h2><p>用抽象的观点来看，公钥密码体制就是一种陷门单向函数</p><ul><li><p><strong>单向函数</strong>是满足下列条件的函数：</p><p>它是定义域到值域的一个映射，同时还要满足下列条件：计算函数值是容易的，而从函数值计算原像是不可行的.</p></li><li><p><strong>陷门单向函数</strong>是这样的单向函数，存在一个附加信息，当不知道该附加信息时，从函数值求原像是困难的，但当知道该附加信息时，从函数值求原像就变得容易了。即陷门单向函数在附加信息未知时是单向函数，而当附加信息已知时，就不再是单向函数了。通常把附加信息称为陷门信息。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311272227209.png"alt="image-20231127222741135" /><figcaption aria-hidden="true">image-20231127222741135</figcaption></figure><p>公钥密码体制就是基于这一原理而设计的，利用一个陷门单向函数，将它作为公开密钥，而将陷门信息作为秘密密钥.。其安全强度取决于它所依据的问题的计算复杂度</p><h2 id="公钥密码体制的要求">公钥密码体制的要求</h2><ul><li>产生一对密钥在计算上是可行的</li><li>已知公钥和明文，产生密文是容易的</li><li>接收方利用私钥来解密密文在计算上是可行的</li><li>对于攻击者，利用公钥来推断私钥在计算上是不可行的</li><li>已知公钥和密文，在不知道私钥的情况下，恢复明文在计算上是不可行的</li></ul><h2 id="数论基础知识">数论基础知识</h2><p><a href="https://oi-wiki.org/math/number-theory/basic/">数论基础 - OIWiki (oi-wiki.org)</a></p><h3 id="群的相关概念">群的相关概念</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041837387.png"alt="群的概念" /><figcaption aria-hidden="true">群的概念</figcaption></figure><p>对乘法，单位元是1，但是不是所有的整数都有逆元（或者说除了1和-1都没有=</p><p>逆元：对任意a，存在b，使得a * b=b * a=e，这里的b是逆元，e是单位元</p><p>群的阶：<spanclass="math inline">\(ord(G)=群中元素的个数\)</span></p><p>群元素的阶：<span class="math inline">\(ord(g)\)</span></p><ul><li>群元素g做群的操作 i 次</li><li>最小的正整数 i 满足，<spanclass="math inline">\(g^i=1\)</span>（单位元）</li></ul><p><span class="math inline">\(g^{ord(G)} =1(单位元)\)</span>，证明如下：</p><p><span class="math display">\[\begin{align}∵ord(g) \ &amp;|\ ord(G)\\g^{ord(g)} &amp;= 1\\∴ord(G) &amp;= k*ord(g)\\∴g^{ord(G)} &amp;= 1\end{align}\]</span></p><p>对$Z_n* $ ，{ a|gcd(a,N)=1 } *mod N，元素的个数为欧拉函数：φ(N)</p><p>当N为素数，{0,1,2,,,,,p-1} *mod p</p><p>例如p等于7时，$Z_n* <spanclass="math inline">\(为\)</span>{1,2,3,4,5,6}$，单位元：1</p><p>元素1-6的阶为：1，3，6，6（×）3（√），6，2</p><p>元素1的阶：<span class="math inline">\(1*1=1\)</span>，再mod 7 =1，所以元素1的阶为1</p><p>元素2的阶：<span class="math inline">\(2 * 2 * 2 = 8\)</span>，再mod7 =1，所以元素2的阶为3，写作：<spanclass="math inline">\(ord（2）=3\)</span></p><p>元素3的阶：<span class="math inline">\(3 * 3 * 3 * 3 * 3 * 3 =729\)</span>，再mod 7 = 1，所以元素3的阶为6</p><p>元素4的阶：<span class="math inline">\(4 * 4 * 4=64\)</span>，再mod 7= 1，所以元素4的阶为3</p><p>……</p><p>逆元（1-6的）：1，4，5，2，3，6</p><p>1的逆元：1 * 1 = 1，再mod 7 = 1，所以元素1的逆元为1</p><p>2的逆元：2 * 4 = 8，再mod 7 = 1，所以元素2的逆元为4</p><p>3的逆元：3 * 5 = 15，再mod 7 = 1，所以元素3的逆元为5</p><p>4的逆元：4 * 2 = 8，再mod 7 = 1，所以元素4的逆元为2</p><p>……</p><h2 id="rsa公钥密码体制">RSA公钥密码体制</h2><p>加密过程：</p><ul><li>选两个大质数p和q，且 <span class="math inline">\(p!=q\)</span>，计算<span class="math inline">\(N=p*q\)</span>，N就算出来了</li><li>然后计算N的欧拉函数 <spanclass="math inline">\(φ(N)=(p-1)(q-1)\)</span></li><li>然后你自己选个e， <spanclass="math inline">\(1&lt;e&lt;φ(N)\)</span>，且与φ(N)互质，<ul><li>为什么e与φ(N)互素：要存在d，互素才存在这样一个d</li></ul></li><li>由e和φ(N)互质，<spanclass="math inline">\((e,φ(N))=1\)</span>，再由辗转相除法，则一定有<spanclass="math inline">\(ed - φ(N)k = 1\)</span></li><li>那么由e就可以算出d，<span class="math inline">\(ed ≡ 1\quadmod(φ(N))\)</span><ul><li>pk（公钥）：N，e</li><li>sk（私钥）：d</li></ul></li></ul><p>加解密：</p><p><span class="math display">\[\begin{align}Enc（pk，m∈Z_N^*）:c = m^e\ mod \ N\\Dec（sk，c）： m = c^d\ mod\ N\end{align}\]</span></p><h3 id="正确性证明">正确性证明</h3><p><span class="math display">\[\begin{align}&amp;即验证 c^d modN 是否等于 m\\&amp;∵ed ≡ 1\quad mod(φ(N))\\&amp;∴ed = kφ(N) + 1\\&amp;即验证m^{ed} mod N最后是等于m的\\&amp;m^{kφ(N) + 1} \quad mod \quad N \\&amp;m^{kφ(N)}*m \quad mod \quad N\\&amp;即求:m^{φ(N)}≡1modN\\&amp;∵m∈Z_N^*\\&amp;g^{ord(G)} = 1(单位元)\\&amp;∴m^{φ(N)}≡1modN&amp;\end{align}\]</span></p><p>对于</p><p><span class="math display">\[\begin{align}&amp;m∈Z_N（放大m的范围了）\\&amp;m \notin Z_N^*\\&amp;∵ N =p*q\\&amp;∴gcd(m,N)=p或q\\&amp;这里的情况N直接分解出来了\\&amp;若gcd(m,N)=p,m&lt;N,N=p*q\\&amp;得m=kp,1≤k&lt;q\\&amp;gcd(m,q)= 1\\&amp;相当于m∈Z_q^*，则m^{φ(q)}=1modq\\&amp;m^{q-1}=1modq\\&amp;ed = k^{&#39;}φ(N)+1=k^{&#39;}(p-1)(q-1)+1\\&amp;m^{k^{&#39;}(p-1)(q-1)} =1modq\\&amp;m^{k^{&#39;}φ(N)} =1modq\\&amp;即m^{k^{&#39;}φ(N)} =rq+1\\&amp;我们这里还是要求m^{ed}modN最后等于m\\&amp;m^{k^{&#39;}φ(N)}*m \quad mod N\\&amp;=(rq+1)m \quad modN\\&amp;=(rqm+m)\quad mod N\\&amp;=(rq*kp+m)\quad mod N\\&amp;=(rkN+m)\quad mod N\\&amp;=m\end{align}\]</span></p><p>RSA问题，给定N，e，<spanclass="math inline">\(y∈Z_N^*\)</span>，求x，满足<spanclass="math inline">\(x^e=y\ mod\ N\)</span></p><blockquote><p>一个密文对应一个明文，所以jzlaoshi不把RSA叫做一个加密方案，而是一个单向陷门置换</p></blockquote><h3 id="rsa公钥密码体制的安全性">RSA公钥密码体制的安全性</h3><p>RSA是建立在大整数分解的困难性之上的</p><p>大整数分解攻击：一旦分解出p和q，就可以得到n的欧拉数φ(N)，再利用欧几里德扩展算法求出RSA的私钥d.</p><p>因此，应当采用足够大的大整数n(至少应取1024位，最好为2048位)。此外，对素数p和q的选取应满足以下要求：</p><ul><li>p和q的长度应该相差不大</li><li>(p - 1)和(q - 1)都应该包含大的素因子</li><li>gcd(p - 1,q -1)应该尽可能小</li><li>d &lt; n，且<spanclass="math inline">\(d&lt;n^{0.294}\)</span>，特别是当<spanclass="math inline">\(d&lt;n^{1/4}\)</span>时，已经有办法攻破RSA</li></ul><h2 id="elgamal公钥密码体制">ElGamal公钥密码体制</h2><blockquote><p><strong>ElGamal</strong>加密算法是一个基于Diffie-Hellman密钥交换的非对称加密算法，</p></blockquote><p>离散对数问题： <span class="math display">\[G，p，g，，，h∈G，求x∈Z_p，使得h = g^x\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311131908490.png"alt="image-20231113190856360" /><figcaption aria-hidden="true">image-20231113190856360</figcaption></figure><blockquote><p>加密算法的第一行写错了，m ∈ G</p></blockquote><h2 id="公钥密码体制的安全模型">公钥密码体制的安全模型</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311202114001.png"alt="image-20231120211350752" /><figcaption aria-hidden="true">image-20231120211350752</figcaption></figure><blockquote><p>OW-CCA 比 OW-CPA安全性高</p><p>IND-CCA 比 IND-CPA安全性高</p><p>IND-CCA 比 OW-CCA高</p><p>也就是说 CCA安全一定是CPA安全，但CPA安全不一定是CCA安全，</p></blockquote><h3 id="ind-cpa">IND-CPA</h3><p>示意图：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311202118705.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>IND-CPA所表示的含义为，在敌手能<strong>自行选择明文，并查询对应密文</strong>这一模型中，我们的加密算法是否还能实现密文不可区分。在这一Game中，敌手可以查询任意一条明文消息对应的密文，这需要我们开放自己算法的加密功能给敌手</p><p>IND-CPA这一Game的步骤如下： <imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311211004293.png"alt="image-20231121100449131" /></p><p>这里的Pr是计算某一事件的概率</p><p>可以看出，IND-CPA实际上是想表达“<strong>如果密文足够随机的话，密文是不会泄露任何关于明文信息</strong>”这一深层含义</p><p>任意一个公钥加密方案，如果加密算法是一个确定的算法，它永远不可能达到IND-CPA安全。如：RSA就达不到，一个明文对应一个密文</p><h3 id="ind-cca">IND-CCA</h3><p>ElGamal不是IND-CCA安全</p><h1 id="数字签名">数字签名</h1><h2 id="概述">概述</h2><ul><li><p>在传统商务活动中，为了保证交易的安全与真实，一份书面合同或公文要由当事人或其负责人签字、盖章，以便让交易双方识别是谁签的合同，保证签字或盖章的人认可合同的内容，在法律上才能承认这份合同是有效的。</p></li><li><p>而在电子商务的虚拟世界中，合同或文件是以电子文件的形式表现和传递的。在电子文件上，传统的手写签名和盖章是无法进行的，这就必须依靠技术手段来替代。</p></li><li><p>数字签名就是能起到手写签名或者盖章同等作用的电子技术手段。</p></li><li><p>数字签名已成为计算机网络不可缺少的一项安全技术措施是实现认证的重要工具。数字签名在商业、金融、军事等领域，特别是在电子贸易、电子支票、电子购物、电子政务及知识产权保护等方面的应用，有力地显示了数字签名的重要性。</p></li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271854832.png"alt="image-20231127185410719" /><figcaption aria-hidden="true">image-20231127185410719</figcaption></figure><h3 id="数字签名的特征">数字签名的特征</h3><ul><li>收方能够确认或证实发方的签名，但不能伪造</li><li>发方发出签名的消息给收方后，就不能再否认他所签发的消息。</li><li>收方对已收到的签名消息不能否认。</li><li>第三者可以确认收发双方之间的消息传送，但不能伪造这一过程。</li></ul><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271842022.png"alt="image-20231127184246792" /><figcaption aria-hidden="true">image-20231127184246792</figcaption></figure><h2 id="rsa签名方案">RSA签名方案</h2><p><span class="math display">\[\begin{align}&amp;m_1*σ_1 = m_1^d \mod N\\&amp;m_2*σ_2 = m_2^d \mod N\\&amp;m =m_1*m_2，σ =σ_1*σ_2\\&amp;两个相乘 m*σ = (m_1m_2)^d \mod N\\&amp;也就是说我知道两个就能构造第三个，（其实知道一个就可以了\\&amp;所以是不安全的\\&amp;可以利用一个安全的Hash函数 H 来产生消息摘要H(m);\\&amp;H(m_1,m_2)≠H(m_1)*H(m_2)\\\end{align}\]</span></p><p>所以直接拿来做签名是不安全</p><p>要改一改：利用一个安全的Hash函数 H来产生消息摘要H(m)，哈希函数是一个单向函数</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271900288.png"alt="RSA签名方案" /><figcaption aria-hidden="true">RSA签名方案</figcaption></figure><p>安全性：</p><ol type="1"><li>签名时使用了Hash函数可以防止利用同态的伪造攻击，有很好的抗攻击性。</li><li>RSA签名方案存在签名可重用的问题，同一消息在不同时刻签名不应是相同的。</li></ol><h2 id="elgamal签名方案">ElGamal签名方案</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271940031.png"alt="ElGamal签名方案" /><figcaption aria-hidden="true">ElGamal签名方案</figcaption></figure><p><strong>签名算法中：</strong></p><p>g是<spanclass="math inline">\(Z_p^*\)</span>的生成元，但是实际上中很难取到，所以一般设置<spanclass="math inline">\(p-1=rq\)</span>，所以<spanclass="math inline">\(Z_p^*\)</span>中存在一个q阶的子群，随便在<spanclass="math inline">\(Z_p^*\)</span>中选一个h，作<spanclass="math inline">\(h^r\)</span>，则<spanclass="math inline">\(g=h^r\)</span>一定是生成元 （对吗？😥😥</p><p><span class="math inline">\(gcd(k,p-1)\)</span>，才能保证<spanclass="math inline">\(k \mod p-1\)</span>有逆元，才能算出来s</p><p>定义：生成元的阶就是群的阶，这里就是<spanclass="math inline">\(p-1\)</span>，所以<spanclass="math inline">\(0&lt;k&lt;p-1\)</span>，k只能在这个范围，<spanclass="math inline">\(p-1\)</span>就是最大的了</p><p>这里的群的阶最大就是<span class="math inline">\(p-1\)</span></p><h2 id="schnorr签名方案">Schnorr签名方案</h2><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311271959541.png"alt="image-20231127195957438" /><figcaption aria-hidden="true">image-20231127195957438</figcaption></figure><p>签名验证算法中可以给<spanclass="math inline">\(σ=(e,s)\)</span>，也可以给<spanclass="math inline">\((R,s)\)</span>，大部分都选前者</p><p>原因：计算开销是一样的，不管给谁R，e，s都是要算的，所以看通信的消耗size，R是群中的元素，表示群元素至少要<spanclass="math inline">\(log_2p\)</span>位，e是mod之后的，所以e的位数要小一点</p><p>公布<span class="math inline">\((e,s)\)</span>作为签名：</p><p>计算<span class="math inline">\(R&#39;=g^s*y^e\)</span></p><p>验证 <span class="math inline">\(e\ 等于or不等于\H(m,R&#39;)\)</span></p><p>这里假设 <span class="math inline">\(s=r-ex\)</span>是对滴，那么<spanclass="math inline">\(g^s=g^{r-ex}=g^r*(g^x)^{-e}=g^r*y^{-e}=R*y^{-e}\)</span></p><p>公布<span class="math inline">\((R,s)\)</span>作为签名：</p><p>计算<span class="math inline">\(e=H(m,R)\)</span></p><p>验证 <span class="math inline">\(g^s =or≠ R*y^{-e}\)</span></p><p><spanclass="math inline">\(g^s=g^{r-ex}=g^r*(g^x)^{-e}=g^r*y^{-e}=R*y^{-e}\)</span></p><h2 id="数字签名标准">数字签名标准</h2><blockquote><p>更习惯于叫它DSA</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312041913546.png"alt="image-20231204191305426" /><figcaption aria-hidden="true">image-20231204191305426</figcaption></figure><p>DSA这里<span class="math inline">\(g\)</span>的阶是<spanclass="math inline">\(q\)</span>，因为<spanclass="math inline">\(q\)</span>是素数，所以k的逆元一定存在，所以这里的k&lt;p就行了，跟上面比少了一个<spanclass="math inline">\(gcd(k,p-1)\)</span>的条件</p><p>ElGamal签名方案g的阶是p-1</p><p>跟ElGamal签名方案的构造本质上是一样的，不过不再作用在<spanclass="math inline">\(Z_p^*\)</span>，而是它的一个子群中</p><p><span class="math display">\[ElGamal签名方案：r=g^k\ mod\ p，s=k^{-1}(H(m)+xr)\ mod\p-1，0&lt;k&lt;p-1\\数字签名标准(DSA):r=g^k\ mod\ p，s=k^{-1}(H(m)+xr)\ mod\ q，0&lt;k&lt;q\]</span> <span class="math inline">\(Z_p^* ，*\modp，ElGamal签名方案种，g是这个群的生成元\)</span></p><p><strong>DSS算法的详细解释（简单易懂版）</strong></p><p><strong>（1）DSS算法的主要参数：</strong></p><ol type="1"><li><p>全局公开密钥分量：</p><ul><li>素数p, <span class="math inline">\(2 ^ {511} &lt; p &lt; 2 ^{512}\)</span>；</li><li>q是(p-1)的一个素因子, <span class="math inline">\(2^{159} &lt; q&lt; 2^{160}\)</span>；</li><li><span class="math inline">\(g=h ^ {[(p-1)/q]} mod p\)</span>,其中h是一整数，<span class="math inline">\(1&lt;h&lt;(p-1)\)</span></li></ul></li><li><p>私钥：</p><p>私钥x是随机或伪随机整数, 其中<spanclass="math inline">\(0&lt;x&lt;q\)</span>；</p></li><li><p>公钥：</p><p><span class="math inline">\(y=g ^ x mod p\)</span>，<spanclass="math inline">\(（p，q，g，y）\)</span>为公钥；</p></li><li><p>用户的随机选择数：</p><p>k为随机或伪随机整数, 其中<spanclass="math inline">\(0&lt;k&lt;q\)</span></p></li></ol><p><strong>（2）DSS的签名过程：</strong></p><p><span class="math inline">\(r=(g ^ k \mod p) \modq\)</span>，这里又mod q，再做了一次压缩，这是跟ElGamal最大的差别</p><p><span class="math inline">\(s=[k ^ {-1} (H(M)-xr)] \modq\)</span></p><p>形成了对信息M的数字签名(r,s)，数字签名和信息M一同发送给接收方。接收方接收到信息M’和数字签名(r’,s’)后，对数字签名的验证过程如下：</p><p><span class="math inline">\(w=(s’) ^ {-1} \mod q\)</span></p><p><span class="math inline">\(u1=[H(M’)w] \mod q,\)</span></p><p><span class="math inline">\(u2=( r’) w \mod q\)</span></p><p><span class="math inline">\(v=[(g ^ {u1} y ^ {u2}) \mod p] \modq\)</span></p><p>如果 <span class="math inline">\(v=r’\)</span>，则说明信息确实来自发送方。</p><p><strong>lai：</strong></p><p><span class="math inline">\(k=s^{-1}(H(m)+xr)\mod q\)</span></p><p>g的阶是q</p><p><spanclass="math inline">\(g^k=g^{s^{-1}(H(m)+xr)}=g^{s^{-1}H(m)+s^{-1}xr}=g^{s^{-1}H(m)}*y^{s^{-1}r}\mod p \mod q\)</span></p><p>看<span class="math inline">\(g^{s^{-1}H(m)}*y^{s^{-1}r} \mod p \modq\)</span>是否等于r</p><blockquote><p>从群的角度来看，其实ElGamal和DSA是一样的，但是在计算r的时候又modq，如果不mod q的话，其实两个方案就是一样的</p></blockquote><h2 id="签名的安全模型">签名的安全模型</h2><h3 id="euf-cma">EUF-CMA</h3><blockquote><p>或EU-CMA，选择消息攻击下的存在性不可伪造：Existential Unforgeabilityunder Chosen Messagge Attack</p></blockquote><p>这一模型中的CMA指Chosen MessageAttack，即选择消息攻击，本质上与CPA其实是一样的，只不过在数字签名等算法中，用消息一词要比明文更加贴切。CMA和CPA都是形容敌手能自由地向算法提交输入并获得的相应输出这一能力。</p><p><strong>意思就是：你可以要任何消息的签名，但是你不能造出一个一样的签名</strong></p><p>EUF则是指存在性不可伪造，即 ExistentialUnForgeability，指的是对于消息认证、数字签名等算法而言，当敌手通过查询获得了q 个签名后， 他无法再获得第 q+1个签名。这一Game的示意图如下所示：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111857649.png"alt="EUF-CMA示意图" /><figcaption aria-hidden="true">EUF-CMA示意图</figcaption></figure><p>可以看到，其基本形式依然和前文的模型保持相似，在查询阶段，敌手 <spanclass="math inline">\(\mathcal{A}\)</span> 可不断与一实现了签名Oracle的<span class="math inline">\(\mathcal{C}\)</span> 交互，来获得所提交消息<span class="math inline">\(m\)</span> 的签名 <spanclass="math inline">\(\sigma\)</span> 。在进行 <spanclass="math inline">\(q\)</span> 次交互后，敌手将输出一对 <spanclass="math inline">\(\left(m^*, \sigma^*\right)\)</span>。这一Game的主要步骤为: 1. Game中拥有一具有多项式资源的敌手 <spanclass="math inline">\(\mathcal{A}\)</span>和一个能自由调用签名算法oracle <span class="math inline">\(E\)</span>的挑战者 <span class="math inline">\(\mathcal{C}\)</span> 。 2. <spanclass="math inline">\(\mathcal{C}\)</span> 随机选取 <spanclass="math inline">\(sk\stackrel{\$}{\leftarrow}\{0,1\}^n\)</span>，作为签名算法的私钥 3. <span class="math inline">\(\mathcal{A}\)</span>向 <span class="math inline">\(\mathcal{C}\)</span> 提交消息 <spanclass="math inline">\(m, \mathcal{C}\)</span> 得到 <spanclass="math inline">\(m\)</span> 对应的签名 <spanclass="math inline">\(\sigma\)</span> 4. 重复步骤 <spanclass="math inline">\(3 q\)</span> 次 (即敌手查询 <spanclass="math inline">\(q\)</span> 次不同消息的签名) 5. <spanclass="math inline">\(\mathcal{A}\)</span> 输出一对 <spanclass="math inline">\(\left(m^*, \sigma^*\right)\)</span>; 6. <spanclass="math inline">\(\mathcal{C}\)</span> 对 <spanclass="math inline">\(\sigma^*\)</span> 进行验证，并返回验证结果；</p><p>若最后敌手输出的 <span class="math inline">\(m^*\)</span>未曾被查询过，且 <span class="math inline">\(\sigma^*\)</span>能通过验证，就可认为敌手挑战成功。这一结果即为“签名的伪造”，此处敌手的优势可写为: <span class="math display">\[\operatorname{Adv}_S^{\text {EUF-CMA}}(\mathcal{A})=\operatorname{Pr}\left[\mathcal{A} \text { forges}\left(m^*, \sigma^*\right)\right]\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111906302.png"alt="EUF-CMA游戏描述" /><figcaption aria-hidden="true">EUF-CMA游戏描述</figcaption></figure><p><ahref="https://crypto.stackexchange.com/questions/44188/what-do-the-signature-security-abbreviations-like-euf-cma-mean">terminology- What do the signature security abbreviations like EUF-CMA mean? -Cryptography Stack Exchange</a></p><h3 id="suf-cma">SUF-CMA</h3><blockquote><p>或SU-CMA，选择消息攻击下的强不可伪造性：Strong Unforgeability underChosen Messagge Attack</p></blockquote><p>在EUF-CMA中，E表示的是Existential，而此处的SUF的S则表示Strong，即强不可伪造性，这一Game的基本模型如下图所示。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202312111858862.png"alt="SUF-CMA示意图" /><figcaption aria-hidden="true">SUF-CMA示意图</figcaption></figure><p>与EUF-CMA相比，SUF-CMA唯一的不同之处在于敌手最终输出伪造的签名对<span class="math inline">\((m^∗,σ^∗)\)</span>时，不仅要求 <spanclass="math inline">\(m^∗\)</span>是未曾查询过的，也要求签名<spanclass="math inline">\(σ^∗\)</span>是未曾出现过的。</p><p>因此，EUF-CMA这一Game中的敌手只需要寻找到 m 关于 σ的一个<strong>碰撞</strong>即可，而在SUF-CMA中，敌手的任务并不是要找碰撞，而是要从根本上伪造出一个签名消息对。</p><blockquote><p>总结一下：</p><p>这里的签名的安全模型规定的这些东西，对数字签名本身的功能来讲，功能不大，因为相当于你伪造了一个我的章发出去，可是我已经用我的章发出去了，你伪造一个跟我一样的章发出去，对我没影响，我消息发出去了（只是当成一个签名）</p><p>但是用数字签名方案构造其他东西的时候，会有用，也就是说可以把数字签名方案当成一个部件，去搭建更🐂🖊的功能</p></blockquote><ul><li>一个证明题</li></ul><p>以下两种证明的表述是一样的：</p><p>证明：如果一个数字签名方案，它的签名算法是一个确定性的算法，那么这个方案对EUF-CMA和SUF-CMA的安全性是一样的</p><p>证明：如果一个数字签名方案，它的签名算法是一个确定性的算法，它是EUF-CMA安全的，那么这个方案也是SUF-CMA的</p><p>我们讲的签名方案中，只有RSA是确定性的算法</p><p>因为<spanclass="math inline">\(SUF-CMA⟹EUF-CMA\)</span>是肯定成立的</p><p>上面的证明就是要证明：</p><p>如果一个签名方案其签名算法是确定性的算法，那么<spanclass="math inline">\(EUF-CMA⟹SUF-CMA\)</span></p><p>设存在<span class="math inline">\(SUF-CMA\)</span>敌手，构造一个<spanclass="math inline">\(EUF-CMA\)</span></p><p><span class="math display">\[\begin{align}&amp;有(m_1,σ_1),(m_2,σ_2),(m_3,σ_3),……,(m_q,σ_q)\\&amp;敌手已经找到了(m^*,σ^*),已经通过了验证，\\&amp;那么(m^*,σ^*)≠\{(m_1,σ_1),(m_2,σ_2),(m_3,σ_3),……,(m_q,σ_q)\}\\&amp;由签名方案其签名算法是确定性的算法，得m^*≠\{m_1,m_2,m_3,……,m_q\}\\&amp;其实这就结束了，这就相当于构造出了一个EUF-CMA\\&amp;\\\end{align}\]</span></p><blockquote><p>参考：</p><p><ahref="https://www.cnblogs.com/max1z/p/16841472.html">现代密码学常用符号总结- Max1z - 博客园 (cnblogs.com)</a></p><p><ahref="https://www.cnblogs.com/max1z/p/15992505.html#IND-CCA2">密码学之安全模型总结- Max1z - 博客园 (cnblogs.com)</a></p><p><a href="https://www.ruanx.net/diffie-hellman/">Diffie-Hellman密钥交换和 Elgamal 加密算法 (ruanx.net)</a></p><p><ahref="https://zhuanlan.zhihu.com/p/599518034">一文搞懂Diffie-Hellman密钥交换协议- 知乎 (zhihu.com)</a></p><p><ahref="https://gejiangxia.github.io/2020/04/30/ELGamal加密方案不是CCA安全/">(<em>´∇｀</em>)被你发现啦~ ELGamal加密方案不是CCA安全 | Hexo(gejiangxia.github.io)</a></p><p><ahref="https://www.cnblogs.com/WittPeng/p/8978737.html">《现代密码学》 -WittPeng - 博客园 (cnblogs.com)</a></p><p>下面是一个隐藏的公式： <span class="math display">\[\begin{align}&amp;1\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\\end{align}\]</span></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 1_绪论</title>
    <link href="/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>凭借一句话获得图灵奖的Pascal语言之父——NicklausWirth，让他获得图灵奖的这句话就是他提出的著名公式： <spanclass="math display">\[程序 = 数据结构 + 算法\]</span></p><h2 id="基本概念和术语">基本概念和术语</h2><p>知识结构图： 数据 ——&gt; 数据元素 ——&gt; 数据项 ——&gt; 数据对象</p><p>数据：是对客观事物的符号表示</p><p>数据元素(dataelement)：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。一个数据元素往往由若干数据项组成。</p><p>数据项(DataItem)：是组成数据元素的、有独立含义的、不可分割的最小单位</p><p>数据对象(data object)：是性质相同的数据元素的集合</p><p>数据结构(DataStructure)：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带”结构＂的数据元素的集合，“结构”就是指数据元素之间存在的关系。</p><p><strong>逻辑结构和物理结构</strong></p><p>逻辑结构：数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是数据元素；二是关系。</p><p>四类基本逻辑结构</p><ul><li>集合</li><li>松散结构线性结构：一对一的关系</li><li>树形结构：一对多关系</li><li>图状结构：多对多关系</li></ul><p>物理结构/存储结构</p><p>物理结构：数据的逻辑结构在计算机中(内存)的存储形式。</p><p>分为顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><p><strong>数据类型</strong></p><p>数据类型是一个值的集合和定义在值集上的一组操作的总称。</p><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式、C语言中函数的参数、返回值，明确说明它们所属的数据类型。</p><p>C语言中：提供int,char,float,double等基本数据类型；数组、结构、共用体、枚举等构造数据类型；还有指针、空（void)类型，用户也可用typedef自己定义数据类型。而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>在C语言中，数据类型可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型姿型数据组成的数组。</li></ul><h2 id="抽象数据类型adt">抽象数据类型(ADT)</h2><p>是指一个数据模型以及定义在该模型上的一组操作。和数据类型实质上是一个概念</p><p>形式化定义: (D, S, P)</p><ul><li>D是数据对象</li><li>S是D上的关系集</li><li>P是对D的基本操作</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">定义格式<br>      ADT 抽象数据类型名 &#123;<br>             数据对象: <span class="hljs-tag">&lt;<span class="hljs-name">数据对象的定义</span>&gt;</span><br>             数据关系: <span class="hljs-tag">&lt;<span class="hljs-name">数据关系的定义</span>&gt;</span><br>             基本操作: <span class="hljs-tag">&lt;<span class="hljs-name">基本操作的定义</span>&gt;</span><br>      &#125; ADT 抽象数据类型  <br><br></code></pre></td></tr></table></figure><p>对图形进行一个缩放n倍<code>scale(G(被操作的图形),n)</code>对图形进行缩放，它当然也会返回一个图形<code>G'=scale(G,n)</code>返回值要赋值给G写成<code>scale（&amp;G,n）</code>引用参数以"&amp;"打头，除可提供输入值外，还将返回操作结果。</p><h2 id="算法和算法分析">算法和算法分析</h2><h3 id="算法">算法</h3><p>算法定义：解决问题的方法和步骤。在计算机中表现为指令的有限序列。其中每条指令表示一个或多个操作。</p><p>算法的描述</p><p>自然语言；流程图【NS图、框图】；伪代码(<strong>类C语言</strong>)；程序设计(C、Java...)</p><p><strong>程序与算法</strong></p><ul><li>程序=数据结构+算法</li><li>数据结构通过算法来实现操作</li><li>算法根据数据结构设计程序</li></ul><p><strong>算法的特性(确定、有穷、可行、输入、输出)</strong></p><ol type="1"><li>有穷性：算法在执行有限步骤之后，自动结束而不会出现无限循环，并且每一个步骤都在可接受的时间范围内完成。当然这里的有穷并不是纯数学意义的，而是在实际应用中合理的、可以接受的“边界”。</li><li>确定性：算法的每一个步骤都有确定的含义，不会出现二义性(不会有歧义)。</li><li>可行性：算法中的所有操作都可以通过已经实现的基本操作运算执行有限次来实现。</li><li>输入：一个算法有零个或多个输入。当用函数描述算法时，输入往往是通过形参表示的，在它们被调用时，从主调函数获得输入值。</li><li>输出：一个算法有一个或多个输出，它们是算法进行信息加工后得到的结果，无输出的算法没有任何意义。当用函数描述算法时，输出多用返回值或引用类型的形参表示。</li></ol><p><strong>算法的设计要求</strong></p><p>好的算法应该具有正确性、可读性、健壮性、时间效率高和存储量低的特征。</p><ol type="1"><li><p>正确性(Correctness)：能正确的反映问题的需求，能得到正确的答案。</p><p>分以下四个层次：</p><ul><li><p>算法程序没有语法错误；</p></li><li><p>算法程序对n组输入产生正确的结果；</p></li><li><p>算法程序对典型、苛刻、有刁难性的几组输入可以产生正确的结果；</p></li><li><p>算法程序对所有输入产生正确的结果；</p></li></ul><p>但我们不可能逐一的验证所有的输入，因此算法的正确性在大多数情况下都不可能用程序证明，而是用数学方法证明。所以一般情况下我们把层次3作为算法是否正确的标准。</p></li><li><p>可读性(Readability)：算法，首先应便于人们理解和相互交流，其次才是机器可执行性。可读性强的算法有助于人们对算法的理解，而难懂的算法易于隐藏错误，且难于调试和修改。</p></li><li><p>健壮性(Robustness)：当输入的数据非法时，好的算法能适当地做出正确反应或进行相应处理，而不会产生一些莫名其妙的输出结果。【健壮性又名鲁棒性即使用棒子粗鲁地对待他也能做出正确反应或进行相应处理】</p></li><li><p>(高效性)时间效率高和存储量低</p></li></ol><h3 id="算法分析">算法分析</h3><p>算法分析的目的是看算法实际是否可行，并在同一问题存在多个算法时可进行性能上的比较，以便从中挑选出比较优的算法。</p><p>(时间效率)运行时间的长短、(空间效率)占用内存空间的大小是衡量算法好坏的重要因素。</p><p>衡量算法时间效率的方法主要有两类：事后统计法和事前分析估算法。</p><blockquote><p>事后统计法需要先将算法实现，然后测算其时间和空间开销。这种方法的缺陷很显然，</p><p>一是必须把算法转换成可执行的程序，</p><p>二是时空开销的测算结果依赖于计算机的软硬件等环境因素，这容易掩盖算法本身的优劣。</p><p>三是算法的测试数据设计困难，并且程序的运行时间往往还与测试数据的规模有很大关系，效率高的算法在小的测试数据面前往往得不到体现。比如10个数字的排序，不管用什么算法，差异几乎是零。而如果有一百万个随机数字排序，那不同算法的差异就非常大了。那么我们为了比较算法，到底用多少数据来测试，这是很难判断的问题。</p><p>所以我们通常采用事前分析估算法。</p></blockquote><p>一个算法的执行时间大致上等于其所有语句执行时间的总和，而语句的执行时间则为该条语句的重复执行次数和执行一次所需时间的乘积。</p><p>一条语句的重复执行次数称作语句频度(FrequencyCount)。</p><p>语句的执行要由源程序经编译程序翻译成目标代码，目标代码经装配再执行，因此语句执行一次实际所需的具体时间是与机器的软、硬件环境（如机器速度、编译程序质量等）密切相关的。</p><p>设每条语句执行一次所需的时间均是单位时间，则一个算法的执行时间可用该算法中所有语句频度之和来度量。所谓的算法分析并非精确统计算法实际执行所需时间，而是针对算法中<strong>语句的执行次数</strong>做出估计，从中得到算法执行时间的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span> ; i &lt; n ; i++)     <span class="hljs-comment">//&lt;- 从 0 到 n，执行 n+1 次</span><br>&#123;<br>    a++;                         <span class="hljs-comment">//&lt;- 从 0 到 n-1，执行 n 次</span><br>&#125;<br><span class="hljs-comment">/*可以看到，这段程序中仅有 2 行代码，其中：</span><br><span class="hljs-comment">for 循环从 i 的值为 0 一直逐增至 n（注意，循环退出的时候 i 值为 n），因此 for 循环语句执行了 n+1 次；</span><br><span class="hljs-comment">而循环内部仅有一条语句，a++ 从 i 的值为 0 就开始执行，i 的值每增 1 该语句就执行一次，一直到 i 的值为 n-1，因此，a++ 语句一共执行了 n 次。</span><br><span class="hljs-comment">因此，整段代码中所有语句共执行了 (n+1)+n 次，即 2n+1 次。数据结构中，每条语句的执行次数，又被称为该语句的频度。整段代码的总执行次数，即整段代码的频度。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="渐进时间复杂度">渐进时间复杂度</h3><p>对于稍微复杂一些的算法，计算出算法中所有语句的频度通常是比较困难的。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。</p><p>这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171703344.png"alt="image-20231117170354264" /><figcaption aria-hidden="true">image-20231117170354264</figcaption></figure><p>分析算法时间复杂度的基本方法</p><ol type="1"><li><p>找出语句频度最大的那条语句作为基本语句；</p></li><li><p>计算基本语句的频度，得到问题规模n的某一个函数；</p></li><li><p>取其数量级用O表示</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//例子</span><br>i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(i&lt;=n)<br>    i = i*<span class="hljs-number">2</span>;<br><br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(log_2n)\)</span></p><h3 id="最好最坏和平均时间复杂度">最好、最坏和平均时间复杂度</h3><p>最坏时间复杂度是指在最坏情况下算法的的复杂度；</p><p>最好时间复杂度是指在最好情况下算法的的复杂度；</p><p>平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</p><p>通常考虑最坏和平均，但有时平均比较难计算，所以只考虑<strong>最坏时间复杂度</strong>，最坏情况运行时间是一种保证，那就是运行时间不会再坏了。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311171718909.png"alt="image-20231117171824861" /><figcaption aria-hidden="true">image-20231117171824861</figcaption></figure><h3 id="算法的空间复杂度">算法的空间复杂度</h3><p>和时间复杂度类似，一个算法的空间复杂度，也常用大 O 记法表示。</p><p>要知道每一个算法所编写的程序，运行过程中都需要占用大小不等的存储空间，例如：</p><ul><li>程序代码本身所占用的存储空间；</li><li>程序中如果需要输入输出数据，也会占用一定的存储空间；</li><li>程序在运行过程中，可能还需要临时申请更多的存储空间。</li></ul><p>首先，程序自身所占用的存储空间取决于其包含的代码量，如果要压缩这部分存储空间，就要求我们在实现功能的同时，尽可能编写足够短的代码。</p><p>程序运行过程中输入输出的数据，往往由要解决的问题而定，即便所用算法不同，程序输入输出所占用的存储空间也是相近的。</p><p>事实上，对算法的空间复杂度影响最大的，往往是程序运行过程中所申请的临时存储空间。不同的算法所编写出的程序，其运行时申请的临时存储空间通常会有较大不同。</p><p>如果程序所占用的存储空间和输入值无关，则该程序的空间复杂度就为O(1)；反之，如果有关，则需要进一步判断它们之间的关系：</p><ul><li>如果随着输入值 n的增大，程序申请的临时空间成线性增长，则程序的空间复杂度用 O(n)表示;</li><li>如果随着输入值 n 的增大，程序申请的临时空间成 n2关系增长，则程序的空间复杂度用 O(n2) 表示；</li><li>如果随着输入值 n 的增大，程序申请的临时空间成 n3关系增长，则程序的空间复杂度用 O(n3) 表示；</li><li>等等。</li></ul><blockquote><p>在多数场景中，一个好的算法往往更注重的是时间复杂度的比较，而空间复杂度只要在一个合理的范围内就可以。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-递归和分治策略</title>
    <link href="/2023/11/02/%E7%AE%97%E6%B3%95%203-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <url>/2023/11/02/%E7%AE%97%E6%B3%95%203-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="递归">递归</h1><h2 id="递归的概述">递归的概述</h2><h3 id="递归的定义">递归的定义</h3><p>递归(Recursion)，又译为递回，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。</p><blockquote><p>Recursion从词源上分析只是"re- (again)" + "curs- (come, happen)"也就是重复发生，再次重现的意思, 中文翻译“递归”表达了两个意思：递＋归。</p></blockquote><p>递归(Recursion)基本思想：把规模大的问题转化为规模小的相似的子问题来解决。在函数实现时，因为解决大问题的方法和解决小问题的方法往往是同一个方法，所以就产生了函数直接或间接调用它自身的情况。这个解决问题的函数必须有明显的结束条件，这样就不会产生无限递归的情况。</p><p>应用场景：树、阶乘、Fibonacci数列、Hanoi塔问题</p><p>递归的性能问题：栈的分配和函数调用代价需要在具体工程实践中考虑。</p><blockquote><p>递归的总体思想：</p><ul><li>将求解的较大规模的问题分割成k个更小规模的子问题。</li><li>对这k个子问题分别求解。如果子问题的规模仍然不够小，则再划分为k个子问题，如此递归的进行下去，直到问题规模足够小，很容易求出其解为止。</li><li>将求出的小规模的问题的解合并为一个更大规模的问题的解自底向上逐步求出原来问题的解。</li></ul></blockquote><p>分治法的设计思想：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，再各个击破，分而治之</p><p>直接或间接地调用自身的算法称为递归算法（直接递归间接递归）。用函数自身给出定义的函数称为递归函数。</p><ul><li>边界条件与递归方程是递归函数的二个要素</li><li>递归函数只有具备这两个要素，才能在有限次计算后得出结果。</li></ul><p>由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。</p><p>分治与递归像一对挛生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h3 id="递归递推迭代">递归、递推、迭代</h3><p><strong>递归形式</strong>的斐波那契数列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//伪代码</span><br><span class="hljs-type">int</span> f[maxn] = <span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br><span class="hljs-keyword">if</span>(f[n]) <span class="hljs-keyword">return</span> f[n];<br><span class="hljs-keyword">return</span> f[n] = fib(n<span class="hljs-number">-1</span>) + fib(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推形式</strong>的斐波那契数列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//伪代码</span><br><span class="hljs-type">int</span> f[maxn] = <span class="hljs-number">0</span>;<br>f[<span class="hljs-number">0</span>] = f[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>; i&lt;=n; ++i)&#123;<br>f[i] = f[i<span class="hljs-number">-1</span>] + f[i<span class="hljs-number">-2</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>递推Inductive</strong>：一步步往后，从左往右。即有来无回。</p><p><strong>递归Recursive</strong>：从最后面一步步往前嵌套，再从最前面一步步往后套。递归=递推+回归。即有来有回。</p><p><strong>迭代Iteration</strong>：循环执行，每次把前面计算出的值套下一步。迭代是逐渐逼近，用新值覆盖旧值。</p><p>注意：递归次数太多可能会爆栈。</p><h2 id="分治法的常用例子">分治法的常用例子</h2><h3 id="二分查找">二分查找</h3><h4 id="概述">1. 概述</h4><p>二分查找（Binary Search）算法，也叫折半查找算法</p><p>算法前件：待查找序列有序</p><p>基本思想：先将待查元素与中间元素比，若比中间元素大，则在序列的后一半继续查找；若比中间元素小，则在序列的前一半继续查找。</p><p>二分查找与顺序查找对比图：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311021339520.gif"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="复杂度分析">2.复杂度分析</h4><p><strong>时间复杂度</strong></p><p>我们假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。</p><blockquote><p>被查找区间的大小变化：n、n/2、n/4、n/8 ... n/2^k</p></blockquote><p>假设总共查找了 k 次，则剩余 <spanclass="math inline">\(n/2^k\)</span>个元素。最坏的情况是查找到最后一个元素，则有等式：<spanclass="math inline">\(n/2^k = 1\)</span>，即 <spanclass="math inline">\(2^k=n\)</span>，得：<span class="math inline">\(k= log_2n\)</span></p><p>忽略常数，则二分查找的时间复杂度为<code>O(log n)</code></p><p><strong>空间复杂度</strong></p><p>空间复杂度是很简单的，根据上面的流程可以得知，在整个二分搜索的过程中，只需要额外存储三个变量：最大值，最小值 和 中点，因此，空间复杂度是常量 <code>O(1)</code></p><h4 id="python实现">3. Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分查找的递归与分治策略实现（python）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">arr, target, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &lt;= right:<br>        mid = left + (right - left) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间位置</span><br><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid  <span class="hljs-comment"># 找到目标元素，返回索引</span><br>        <span class="hljs-keyword">elif</span> arr[mid] &lt; target:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, mid + <span class="hljs-number">1</span>, right)  <span class="hljs-comment"># 在右半部分递归查找</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, left, mid - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 在左半部分递归查找</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 目标元素不在数组中，返回-1</span><br><br><span class="hljs-comment"># 输入数组</span><br>input_string = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个升序数组（以逗号分隔）: &quot;</span>)<br>arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, input_string.split(<span class="hljs-string">&#x27;,&#x27;</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已创建好一个升序数组：&quot;</span>,arr)<br><br><span class="hljs-comment"># 输入要查找的数字</span><br>target = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要查找的数字: &quot;</span>))<br><br>result = binary_search(arr, target, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> result != -<span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 在索引 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 不在数组中&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="应用场景及局限性">4. 应用场景及局限性</h4><ul><li><p>二分查找依赖顺序表结构，如数组；</p><blockquote><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p></blockquote></li><li><p>二分查找针对的是有序数据，如果无序，则要先排序；</p></li><li><p>数据量太小不适合二分查找；</p><blockquote><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。</p><p>只有数据量比较大的时候，二分查找的优势才会比较明显。不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p></blockquote></li><li><p>数据量太大也不适合二分查找。</p><blockquote><p>最后，数据量太大也不适合二分查找。</p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB大小的内存空间，那照样无法申请一个 1GB大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p></blockquote></li></ul><h4 id="二分查找算法的改进">5. 二分查找算法的改进</h4><p><ahref="https://c.biancheng.net/algorithm/interpolation-search.html">插值查找算法(biancheng.net)</a></p><p><ahref="https://www.cnblogs.com/MinPage/p/14192152.html">二分查找及其优化- 箐茗 - 博客园 (cnblogs.com)</a></p><p><ahref="https://blog.csdn.net/weixin_42145502/article/details/99676008">斐波那契查找原理深入_斐波那契法原理-CSDN博客</a></p><p><ahref="https://blog.csdn.net/qq_40660998/article/details/134033754">查找算法-斐波那契查找法（FibonacciSearch）-CSDN博客</a></p><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/Abysscarry/article/details/87388195?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-87388195-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">二分查找算法及其变种详解-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_42001592/article/details/128963283?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128963283-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">算法笔记：二分查找_二分查找的时间复杂度-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 2_变量</title>
    <link href="/2023/11/01/Java%202%20%E5%8F%98%E9%87%8F/"/>
    <url>/2023/11/01/Java%202%20%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>变量：变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><p>示例：<code>int a = 1</code> 类型 int 名称 a 值 1</p></blockquote><p>变量相当于内存中的一个数据存储空间的表示</p><h2 id="变量使用注意事项">2.1 变量使用注意事项</h2><ol type="1"><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如<code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型<code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据/值可以在同一类型范围内变化。</li><li>变量的三个基本要素： 变量名 + 值 + 数据类型</li></ol><h2 id="程序中-的使用">2.2 程序中 <code>+</code> 的使用</h2><ol type="1"><li><p>当左右两边都是数值型，做加法运算</p></li><li><p>当左右两边任意一方为字符串，做拼接运算</p></li><li><p>运算顺序是从左到右的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span>);<span class="hljs-comment">// 输出 2hello89</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="java-数据类型">2.3 Java 数据类型</h2><h3 id="基本数据类型记住">基本数据类型（记住！）</h3><ul><li><strong>数值型</strong><ul><li>整数类型，存放整数：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h3 id="引用数据类型复合数据类型">引用数据类型（复合数据类型）</h3><ul><li><p><strong>类</strong>：class</p></li><li><p><strong>接口</strong>：interface</p></li><li><p><strong>数组</strong>：<code>[]</code></p></li></ul><p><strong>字符串类型String实际上是一个”类“</strong></p><h2 id="整数类型">2.4 整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 <spanclass="math inline">\(-2^{15} ～ 2^{15} -1\)</span>（-32768~32767）</li><li><code>int</code> 占用 4 字节，范围 <spanclass="math inline">\(-2^{31} ～ 2^{31} - 1\)</span></li><li><code>long</code> 占用 8 字节，范围 <spanclass="math inline">\(-2^{63} ～ 2^{63} - 1\)</span></li></ul><p><strong>使用细节：</strong></p><ol type="1"><li>Java 各整数类型有固定的范围和字符长度，不受具体OS（操作系统）影响，以保证 Java 程序的可移植性。</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code>型常量须后加<code>‘l’</code>或<code>‘L’</code></li><li>java程序中变量常声明为<code>int</code>型，除非不足以表示大数，才用<code>long</code></li></ol><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用“大数”（后面会讲）</p><h2 id="浮点类型">2.5 浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约-3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约-1.798E308 ~ 1.798E308</li></ul><p>浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 + 尾数位</p><p>因此，尾数部分可能丢失，造成精度损失。所以，小数都是近似值</p><h3 id="使用细节">2.5.1 使用细节</h3><ol type="1"><li><p>与整数类型相似，Java浮点类型有固定的范围和字符长度，不受具体OS（操作系统）影响。</p></li><li><p>Java 默认浮点型常量为 <code>double</code> ，要声明<code>float</code> 型常量必须后加 <code>'f'</code> 或<code>'F'</code></p></li><li><p>浮点型常量有两种表示形式</p><ul><li>十进制数形式：<code>5.12</code>、<code>315.4F</code>、<code>.512</code></li><li>科学计数法：<code>5.12e2</code> 即[5.12 ×10的二次方]、<code>5.12E-2</code> 即[5.12 / 10的二次方]</li></ul></li><li><p>通常情况下，应该使用 <code>double</code>类型，因为它比<code>float</code>型更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相等判断时，要小心。（因为<strong>小数都是近似值</strong>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//num1 = 2.7</span><br><span class="hljs-comment">//num2 = 8.1 / 3</span><br><span class="hljs-keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="hljs-number">0.000001</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;差值非常小，到我的规定精度，认为相等&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="java-api文档">2.6 Java API文档</h2><p>API（Application Programming Interface，应用程序编程接口）是 Java提供的基本编程接口（java提供的类还有相关的方法）。中文在线文档https://www.matools.com/api/java8</p><h2 id="字符类型">2.7 字符类型</h2><blockquote><p>可以表示单个字符，字符类型是char，两个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\t&#x27;</span>;   <span class="hljs-comment">//输出一个制表位</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;字&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-number">97</span>;    <span class="hljs-comment">//输出一个a</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1">2.7.1 使用细节</h3><ol type="1"><li><p>字符常量用<strong>单引号</strong>括起</p></li><li><p>字符允许使用转义符</p></li><li><p><code>char</code> 的本质是一个整数，默认输出时，输出的是 unicode码对应的字符。</p><p>要输出字符常量对应的整数，用 <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>System.out.println((<span class="hljs-type">int</span>)c1);   <span class="hljs-comment">//输出97</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">// 相当于 char c1 = &#x27;b&#x27;</span><br>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(<span class="hljs-type">int</span>(c1));    <span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(c1);        <span class="hljs-comment">// 这个代码输出 b</span><br>System.out.println(<span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 a1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符本质与编码表">2.7.2 字符本质与编码表</h3><ol type="1"><li><p>字符型 存储到计算机中，需要将字符对应的码值(整数)找出来，比如’a’</p><p>存储：’a’ ==&gt; 码值 97 ==&gt; 二进制(110 0001) ==&gt; 存储</p><p>读取：二进制(110 0001) ==&gt; 97 ==&gt; ’a’ ==&gt; 显示</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte（字节），共有 128个字符。缺点：不能表示所有的字符</p><p>Unicode 编码表，占用 2byte（2的16次方，最多65536个字符），字母汉字都占用 2byte，将世界上所有的符号都纳入其中，这样可能浪费空间（字母多汉字少时）。0- 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode实现方式。</p><p>GBK 编码表，可以表示汉字，而且范围广，字母占用 1 byte，汉字占用 2byte。</p><p>GB2312 编码表，可以表示汉字，用的少（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li></ol><h2 id="布尔类型">2.8 布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或<code>false</code> ，没有<code>null</code>。适用于逻辑运算，通常用于程序流程控制</p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li><p>不可以用 0 或 非0 的整数替代 <code>false</code> 或<code>ture</code> 。这点和 C语言 不同。</p></li><li><p>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型转换">2.9 基本数据类型转换</h2><h3 id="自动类型转换">2.9.1 自动类型转换</h3><blockquote><p>自动类型转换：Java在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><p>数据类型按精度（容量）大小排序为（<strong>背！</strong>）</p><p>左边精度小，右边精度大</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">char</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br><span class="hljs-function"><span class="hljs-title">byte</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">short</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br></code></pre></td></tr></table></figure><p>例子：<code>int a = 'c'</code> 或者 <code>double b = 80</code></p></blockquote><h4 id="转换细节">2.9.1.1 转换细节</h4><ol type="1"><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//错误</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//正确</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1F</span>; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。），反之进行自动类型转换。</p></li><li><p><code>byte</code> ，<code>short</code>和 <code>char</code>三者不会相互自动转换，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确，当把具体数赋给 byte 时，先判断该数是否在byte范围内，如果是就可以。</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>; <span class="hljs-comment">//错误 </span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> n2; <span class="hljs-comment">//错误，如果是变量赋值，判断类型</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> b1; <span class="hljs-comment">//错误，不会自动转换</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>三者不会相互自动转换，但可以计算。计算时首先转化为<code>int</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b2 + s1;  <span class="hljs-comment">//正确</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> b2 + b3;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p><code>boolean</code> 类型不参与自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> pass; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。❤</p></li></ol><h3 id="强制类型转换">2.9.2 强制类型转换</h3><blockquote><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符<code>( )</code>，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p></blockquote><h4 id="使用细节-2">2.9.2.1 使用细节</h4><ol type="1"><li><p>当进行数据从大到小转换时，就要用强制转换。</p></li><li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code>提升优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>; <span class="hljs-comment">//编译错误：double -&gt;int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>);<span class="hljs-comment">// 编译正确：(int)44.0 -&gt; 44</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 可以保留 <code>int</code>的常量值，但不能保存其变量值。此时需要强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">//错误</span><br><span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)a ;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>在进行运算时，当作 <code>int</code> 处理。</p></li></ol><h4 id="练习">2.9.2.2 练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>; <span class="hljs-comment">//ok,12在short的范围内</span><br>s = s - <span class="hljs-number">9</span>;   <span class="hljs-comment">//错误，int -&gt; short</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//ok</span><br>b = b + <span class="hljs-number">11</span>; <span class="hljs-comment">//错误，int -&gt; byte</span><br>b = (<span class="hljs-type">byte</span>)(b + <span class="hljs-number">11</span>); <span class="hljs-comment">//ok</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">.314F</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c + i + d; <span class="hljs-comment">//ok,float -&gt; double，自动转换</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;<span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s + b; <span class="hljs-comment">//错误，int -&gt; short </span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和-string-的转换">2.9.3 基本数据类型和<code>String</code> 的转换</h3><ul><li><p>基本类型转 <code>String</code>：基本数据类型加上<code>" "</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1F</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;函&#x27;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> f1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str2</span> <span class="hljs-operator">=</span> c1 + <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-comment">//char转String</span><br>System.out.println(s1 + <span class="hljs-string">&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用<code>parseXX</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br><span class="hljs-type">double</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Double.parseDouble(s);<br><span class="hljs-type">float</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Float.parseFloat(s);<br></code></pre></td></tr></table></figure><p>特别的，把 <code>String</code> 转换为 <code>char</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到 s 字符串中的第一个字符。</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用细节-3">2.9.3.1 使用细节</h4><ol type="1"><li>将 <code>String</code>转成基本数据类型时，要保证其能转换为有效数据。比如：不能把<code>"Hello"</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出，程序会中止。（问题会在异常处理章节中处理）👓</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学</title>
    <link href="/2023/11/01/%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/11/01/%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>$$</p><p>定理3 如果有<span class="math inline">\(limf(x) = A\)</span>，<spanclass="math inline">\(limg(x) = B\)</span> ,那么</p><ul><li><span class="math inline">\(lim[f(x) ± g(x)] = limf(x) + limg(x) =A±B\)</span></li><li><span class="math inline">\(lim[f(x) * g(x)] = limf(x) * limg(x) = A* B\)</span></li><li>若又有<span class="math inline">\(B != 0\)</span>,则<ul><li><span class="math inline">\(limf(x)/g(x) = limf(x)/limg(x) =A/B\)</span></li></ul></li></ul><ol type="1"><li>数列单调有界，得出<spanclass="math inline">\(limx_n=limx_{n+1}=A\)</span>;</li><li>由定理：若<span class="math inline">\(limx_n\)</span>不为零，则<spanclass="math inline">\(lim(x_{n+1}/x_n)=limx_{n+1}/limx_n=A/A=1。\)</span>,而题中为1/2，∴<spanclass="math inline">\(limx_n=0\)</span></li></ol><p><strong>那么当n趋于无穷大时，设数列<spanclass="math inline">\(x_n\)</span>极限为a，那么<spanclass="math inline">\(x_{n+1}\)</span>的极限也为a吗，如何证明？</strong></p><p>①正常思考，当n等于任意合理值时<spanclass="math inline">\(x_n=a\)</span>一定成立。既然已经假定数列有极限，那么当n趋近无穷大时，<spanclass="math inline">\(x_{n+1}-x_n→0\)</span>，它们有相同的极限。</p><p>②证明: <imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311072152624.png"alt="image-20231107215208567" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S13能夺冠吗？</title>
    <link href="/2023/10/31/S13/"/>
    <url>/2023/10/31/S13/</url>
    
    <content type="html"><![CDATA[<p>S13，LPL能夺冠吗？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NewStarCTF 2023 week2</title>
    <link href="/2023/10/27/NewStarCTF%202023%20week2/"/>
    <url>/2023/10/27/NewStarCTF%202023%20week2/</url>
    
    <content type="html"><![CDATA[<h2 id="滴啤">滴啤</h2><h3 id="main">main</h3><blockquote><p>不分解也能求</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_prime</span>(<span class="hljs-params">number</span>):<br>    p = getPrime(number//<span class="hljs-number">2</span>)<br>    q = getPrime(number//<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> p,q<br><br>m = bytes_to_long(flag.encode())<br>p,q = gen_prime(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(p*q)<br>e = <span class="hljs-number">65537</span><br>d = gmpy2.invert(e,(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(d%(p-<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(m,e,p*q))<br><span class="hljs-comment"># 93172788492926438327710592564562854206438712390394636149385608321800134934361353794206624031396988124455847768883785503795521389178814791213054124361007887496351504099772757164211666778414800698976335767027868761735533195880182982358937211282541379697714874313863354097646233575265223978310932841461535936931</span><br><span class="hljs-comment"># 307467153394842898333761625034462907680907310539113349710634557900919735848784017007186630645110812431448648273172817619775466967145608769260573615221635</span><br><span class="hljs-comment"># 52777705692327501332528487168340175436832109866218597778822262268417075157567880409483079452903528883040715097136293765188858187142103081639134055997552543213589467751037524482578093572244313928030341356359989531451789166815462417484822009937089058352982739611755717666799278271494933382716633553199739292089</span><br><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p><strong>考点</strong>：已知dp分解n</p><p>什么玩意,求助xenny呜呜呜😭</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 1_概述</title>
    <link href="/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="java-历史">1.1 Java 历史</h2><ul><li><p>目前 Java 版权属于甲骨文公司。</p></li><li><p>长期支持的版本只有 Java8 与Java11。这两个版本也是最多使用的版本。</p></li><li><p>Java SE：标准版</p><p>Java EE：企业版（重要）</p><p>Java ME：小型版（少）</p></li></ul><h2 id="java-重要特点">1.2 Java 重要特点</h2><ol type="1"><li><p>Java 语言是<strong>面向对象的（oop）</strong></p><p>简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。</p></li><li><p>Java语言是<strong>健壮的</strong>。其强类型机制、异常处理、垃圾自动收集是健壮性的保证。</p><p>Java强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p></li><li><p>Java 语言是<strong>跨平台性</strong>的：一个编译好的<code>.class</code>文件可以在多个不同系统（windows、Linux等）下直接运行。</p></li><li><p>Java 语言是<strong>解释型</strong>的：Java解释器能在任何移植了解释器的机器上直接执行 Java 字节码。</p><p>解释性语言：javascript，PHP，java等</p><p>编译性语言：c， c++等</p><p>区别是：</p><ul><li>解释性语言，编译后的代码，不能直接被机器执行，需要解释器来执行</li><li>编译性语言，编译后的代码，可以直接被机器执行</li></ul></li></ol><h2 id="java的开发工具">1.3 Java的开发工具</h2><ul><li>javac：Java 编译器。将 Java 程序编译成字节码</li><li>java：Java 解释器。执行已经转换为字节码的文件</li><li>jdb：Java 调试器。调试 Java 程序</li><li>javap：反编译。将类文件还原回方法和变量</li><li>javadoc：文档生成器。创建 HTML 文件</li></ul><h2 id="java-运行基础">1.4 Java 运行基础</h2><p>JVM：Java Virtual Machine（Java虚拟机）</p><ul><li>JVM 是–跨平台性的基础。被包含在 JDK 中。</li><li>不同平台有各自对应的不同 JVM</li><li>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”</li></ul><p>JDK ：全称：Java Development Kit（Java 开发工具包）</p><ul><li>JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</li><li>给开发人员使用的，包括了 JRE</li></ul><p>JRE：Java Runtime Enviroment（Java 运行环境）</p><ul><li>JRE = JVM + Java SE 标准类库（Java 的核心类库）</li><li>如果想要运行一个开发好的 Java 程序，计算机中只需要安装JRE即可</li></ul><h2 id="java快速入门">1.5 Java快速入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java第一个程序</span><br><br><span class="hljs-comment">//1. public class Hello 表示Hello是一个类，是一个public公有的类</span><br><span class="hljs-comment">//2. Hello&#123;&#125;表示一个类的开始和结束</span><br><span class="hljs-comment">//3. public static void main(String[] args)表示一个主方法</span><br><span class="hljs-comment">//4. main()&#123;&#125;表示方法的开始和结束</span><br><span class="hljs-comment">//5. System.out.println(&quot;hello,world~&quot;)表示输出hello,world~</span><br><span class="hljs-comment">//6. ;表示语句结束</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br><br><span class="hljs-comment">//main方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我的 hello,world~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="java-执行流程分析">1.6 Java 执行流程分析</h2><blockquote><p><code>.Java</code> 文件（源文件） — javac（编译）—<code>.class</code> 文件（字节码文件） — java（运行）— 结果</p></blockquote><h3 id="编译">1.5.1 编译</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>源文件名.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure><ul><li>通过编译器将 Java 源文件编译成 JVM可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。</li><li>在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。</li><li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的<code>.class</code> 文件，该文件称为字节码文件，也是可执行的 Java程序。</li></ul><h3 id="运行">1.5.2 运行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">java 程序名 <span class="hljs-selector-attr">[参数列表]</span><br></code></pre></td></tr></table></figure><ul><li>有了可执行的 Java 程序（例如Hello.class字节码文件）</li><li>通过运行工具<code>Java.exe</code> 对字节码文件进行执行，本质是将<code>.class</code> 文件装载到 JVM 机执行</li></ul><p><strong>注意，修改后的 .Java 源文件需要重新编译</strong></p><h2 id="java-开发细节">1.7 Java 开发细节</h2><p><strong>在控制台按 Tab 可以实现代码补齐。</strong></p><ol type="1"><li><p>源文件以 <code>.java</code>为扩展名，源文件的基本组成部分是类（class）</p></li><li><p>Java 应用程序的执行入口是 <code>main()</code>方法。其有固定的<strong>书写格式：</strong></p><p><code>public static void main(string[]args)&#123;…&#125;</code></p></li><li><p>Java 语言<strong>严格区分大小写</strong>。</p></li><li><p>Java 方法由一条条语句构成，<strong>每个语句都以 <code>;</code>结束</strong>。</p></li><li><p><strong>大括号 <code>&#123;</code> <code>&#125;</code>是成对出现的</strong>，缺一不可。习惯先写 <code>&#123;&#125;</code>再写代码</p></li><li><p>一个源文件中<strong>最多只有一个 public类</strong>，其余类不限。</p></li><li><p><strong>如果文件中包含 public类，则文件名必须按该类命名。</strong></p></li><li><p>也可以把 main 方法写在非 public 类中，然后运行指定非 public类，这样入口方法是非 public 类的主方法。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,world~&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//一个源文件中最多只有一个 public 类，其余类不限。</span><br><span class="hljs-comment">//Dog 是一个类</span><br><span class="hljs-comment">// 编译后，每一个类，都会生成一个.class</span><br><span class="hljs-comment">//这里就会生成三个.class文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">//也可以把 main 方法写在非 public 类中，然后运行指定非 public 类，这样入口方法是非 public 类的主方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小狗&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小老虎&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011227499.png"alt="image-20231101122753469" /><figcaption aria-hidden="true">image-20231101122753469</figcaption></figure><h2 id="java-转义字符">1.8 Java 转义字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示转义字符的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeChar2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//     \t：一个制表位，实现对齐的功能</span><br>System.out.println(<span class="hljs-string">&quot;北京\t上海\t广州&quot;</span>);<br><br><span class="hljs-comment">//     \n：换行符</span><br>System.out.println(<span class="hljs-string">&quot;北京\n上海\n广州&quot;</span>);<br><br><span class="hljs-comment">//     \\：一个\</span><br>System.out.println(<span class="hljs-string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>);<br><br><span class="hljs-comment">//       \&#x27;：  一个&#x27;</span><br><span class="hljs-comment">//       \&quot;：  一个&quot;</span><br><span class="hljs-comment">//       \r：  一个回车</span><br>System.out.println(<span class="hljs-string">&quot;一起学习java\r我们&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011508043.png"alt="image-20231101150805984" /><figcaption aria-hidden="true">image-20231101150805984</figcaption></figure><h2 id="代码规范">1.9 代码规范</h2><ol type="1"><li><p>类、方法的注释要以 Javadoc 的方式来写</p></li><li><p>非 Javadoc的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等。</p></li><li><p>不要用 <code>a</code><code>b</code>，这种名称命名变量，尽量写得清楚<code>int age = 10;</code></p><p>另外，<strong>Java 源代码使用的是 Unicode码，因此汉语也能作为标识符</strong>。但不推荐使用汉语做标识符。</p></li><li><p>使用 tab 键操作，使代码右移。使用 shift+tab键，使代码左移。</p></li><li><p>运算符两边各加入空格。注意排版规范。</p></li><li><p>源文件使用 UTF-8 编码。</p></li><li><p>代码行宽度不要超过 80 个字符。超过时通过换行保持简洁。</p></li><li><p>代码编写<strong>次行风格</strong>及<strong>行尾风格</strong></p><blockquote><p>次行风格：换行输入<code>&#123;</code> <code>&#125;</code>，使其总在行头，√</p><p>行尾风格：在一行的末尾输入 <code>&#123;</code>，换行输入<code>&#125;</code></p></blockquote></li><li><p>一段代码完成一个小功能，尽量不要混合。这样更加灵活。</p></li></ol><h2 id="dos了解">1.10 DOS（了解）</h2><blockquote><p>DOS：Disk Operating System（磁盘操作系统）</p></blockquote><h3 id="dos-的基本原理">DOS 的基本原理</h3><blockquote><p>在 cmd（控制台）输入指令 — DOS系统 接受指令 — 解析指令 — 执行指令</p></blockquote><ul><li><p>相对路径和绝对路径（举例从 JDK8访问到 JDK8）</p><blockquote><p>相对路径：从当前目录开始定位，形成的路径 <code>..\jre\bin</code></p><p>返回上一级：<code>..\</code></p><p>绝对路径：从顶级目录开始定位，形成的路径<code>d:\Program\JDK8\jre\bin</code></p></blockquote></li></ul><h3 id="常用的-dos-命令">常用的 DOS 命令</h3><blockquote><p>查看帮助：<code>help</code> 或 <code>help cd</code> 等</p><p>查看目录内容：<code>dir</code> 查看当前目录 或<code>dir d:\Program\JDK8\bin</code> 查看指定目录</p><p>切换到其他盘：<code>cd /D d:</code> 从 C盘 切换至 D盘 （changedirectory）</p><p>切换到当前盘的其他目录：<code>cd d:\Program\JDK8\jre\bin</code></p><p>返回上级目录：<code>cd ..</code></p><p>切换至根目录：<code>cd \</code></p><p>查看子集目录：<code>tree</code> 当前目录 或<code>tree d:/Program</code> 指定目录</p><p>清屏：<code>cls</code></p><p>退出：<code>exit</code></p><p>创建目录：<code>md 目录名</code> 如：<code>md tom100</code></p><p>删除目录：<code>rd 目录名</code></p><p>:traffic_light:</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习</title>
    <link href="/2023/10/18/Java%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/18/Java%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;&quot;</span>);  <span class="hljs-comment">//换一行</span><br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>); <span class="hljs-comment">//换两行</span><br></code></pre></td></tr></table></figure><p>因为<code>System.out.println()</code>中的<code>ln</code>就已经换行一次了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入字符的代码</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入一个字符：&quot;</span>);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> myScanner.next().charAt(<span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;字符为： &quot;</span> + c1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入整数型数据</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入年龄: &quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> myScanner.nextInt();<br>        System.out.println(<span class="hljs-string">&quot;输入为：&quot;</span> + age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//从键盘输入字符串</span><br><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-comment">//导入</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">myScanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        System.out.println(<span class="hljs-string">&quot;请输入名字: &quot;</span>);<br>        name = myScanner.next();<br>        System.out.println(<span class="hljs-string">&quot;输入的名字为：&quot;</span> + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>记事本乱码解决方案：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1697599757237.png"alt="1697599757237" /><figcaption aria-hidden="true">1697599757237</figcaption></figure><h3 id="类的封装">类的封装</h3><p>定义：类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>如何实现封装：在定义一个类时，将类中的属性私有化，即<strong>使用private关键字来修饰，私有属性只能在它所在类中被访问</strong>，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p><h3 id="类的继承">类的继承</h3><p>定义：在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法</p><h3 id="多态">多态</h3><p>定义：在Java中，多态是指不同类的对象在调用同一个方法时所呈现出的多种不同行为。</p><p>说明：通常来说，在一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一个方法所呈现出的多种不同形态。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构实验</title>
    <link href="/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="哈夫曼编码">哈夫曼编码</h2><p><ahref="https://blog.csdn.net/qq_35852228/article/details/111192722?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=哈夫曼编码c&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-111192722.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">数据结构：霍夫曼（哈夫曼）编码（C语言）_数据结构求huffman编码-CSDN博客</a></p><p>今天刚学到（10.17）：</p><p>D.对给定的输入数值集合所生成的哈夫曼树深度是确定的 （×）</p><p>解释：当两个结点的和与另外两结点的值相同时，组合顺序不同生产的哈夫曼树深度不同，比如权分别为：1，1，2，2，</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NewStarCTF 2023 week1</title>
    <link href="/2023/10/02/NewStarCTF%202023%20week1/"/>
    <url>/2023/10/02/NewStarCTF%202023%20week1/</url>
    
    <content type="html"><![CDATA[<p>NewStarCTF 2023 week1 Crypto方向的一些题</p><h2 id="vigenère">Vigenère</h2><p>维吉尼亚密码解密</p><p>打开txt后就一段字符：</p><p>pqcq{qc_m1kt4_njn_5slp0b_lkyacx_gcdy1ud4_g3nv5x0}</p><p>前四个应该是对应flag，直接找就欧克了</p><p>下表<strong>上面一行是明文，左边一列是密钥</strong></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695730908860.png"alt="1695730908860" /><figcaption aria-hidden="true">1695730908860</figcaption></figure><p>这段字符害的我好苦，太傻了我，都找到key是kfck了，怎么就不能想到是key的长度是3呢</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695729736638.png"alt="1695729736638" /><figcaption aria-hidden="true">1695729736638</figcaption></figure><p>但是好像有什么更厉害的遍历网站/代码，可是我没找到😥（</p><h2 id="babyxor">babyxor</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> *<br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append(f ^ key)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><span class="hljs-comment"># e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p>看了知道是异或</p><p><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></p><p>将f转换成对应的ASCII码，与0xe9进行异或就可以获得key</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695732585874.png"alt="1695732585874" /><figcaption aria-hidden="true">1695732585874</figcaption></figure><p>得到key是143</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii         <span class="hljs-comment"># 该模块包含了十六进制编码和解码的函数。</span><br>cipher = <span class="hljs-string">&quot;e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2&quot;</span><br>c = binascii.unhexlify(cipher)  <span class="hljs-comment"># 将十六进制字符串 cipher 解码为字节序列并将结果存储在变量 c 中</span><br>                                <span class="hljs-comment"># binascii.unhexlify() 函数用于将十六进制字符串转换为二进制数据。</span><br><br>key = <span class="hljs-number">143</span><br><br>result = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:<br>    result += <span class="hljs-built_in">chr</span>(i^key)    <span class="hljs-comment"># chr() 函数用于将一个整数转换为对应的字符。</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h2 id="affine">Affine</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag, key<br><br>modulus = <span class="hljs-number">256</span><br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append((key[<span class="hljs-number">0</span>]*f + key[<span class="hljs-number">1</span>]) % modulus)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><br><span class="hljs-comment"># dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064</span><br><br><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><p>仿射密码</p><p>exp是照着一个师傅的代码copy的</p><p><ahref="https://blog.csdn.net/qq_38798840/article/details/127206181?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Newstarctf&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-127206181.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">NewStarCTF公开赛week2密码学题目wp_ctf密码学题目_想要变强的47的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><br>a = <span class="hljs-string">&quot;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&quot;</span><br><br><span class="hljs-comment"># 使用 bytes.fromhex() 方法将十六进制字符串转换为字节数据</span><br>byte_data = <span class="hljs-built_in">bytes</span>.fromhex(a)<br><br><span class="hljs-comment"># 打印字节数据</span><br><span class="hljs-built_in">print</span>(byte_data)<br><br><br><span class="hljs-comment"># f1=ord(&#x27;\xb1&#x27;)</span><br><span class="hljs-comment"># #f2=ord(&#x27;\x83&#x27;) #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br><span class="hljs-comment"># f3=ord(&#x27;\x82&#x27;)</span><br><span class="hljs-comment"># f4=ord(&#x27;T&#x27;)  #ord(&#x27;T&#x27;)=84，是g对应的密文</span><br><br>f1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xdd&#x27;</span>)<br><span class="hljs-comment">#f2=ord(&#x27;C&#x27;)   #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br>f3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\x88&#x27;</span>)<br>f4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xee&#x27;</span>) <br><br><br>m1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-comment">#m2=ord(&#x27;l&#x27;)</span><br>m3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>m4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;g&#x27;</span>)  <span class="hljs-comment">#ord(&#x27;g&#x27;)=103，可以验证a=17,b=23时满足(103*a+b)%256 = 238 = ord(&#x27;\xee&#x27;)</span><br><br>a=(f3-f1)*gmpy2.invert(m3-m1,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span> <span class="hljs-comment">#可以用&#x27;f&#x27;和&#x27;a&#x27;求解出a</span><br><span class="hljs-built_in">print</span>(a)   <span class="hljs-comment">#a=17</span><br>b=(f1-a*m1)%<span class="hljs-number">256</span><br><span class="hljs-built_in">print</span>(b)   <span class="hljs-comment">#b=23</span><br><br><span class="hljs-comment"># c=&quot;\xb1\x83\x82T\x10\x80\xc9O\x84\xc9&lt;\x0f\xf2\x82\x9a\xc9\x9b8&#x27;\x9b&lt;\xdb\x9b\x9b\x82\xc8\xe0V&quot;</span><br><br>c=<span class="hljs-string">&quot;\xddC\x88\xeeB\x8b\xdd\xddXe\xccf\xaaX\x87\xff\xcc\xa9f\x10\x9cf\xed\xcc\xa9 fz\x881 d&quot;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> cc <span class="hljs-keyword">in</span> c:<br>    m=(<span class="hljs-built_in">ord</span>(cc)-b)*gmpy2.invert(a,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span><br>    flag+=<span class="hljs-built_in">chr</span>(m)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是dd、C、88、ee这样组合呢？</p><p>我的想法是你可以看原来的十六进制的数据 a ="dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064"</p><p>因为一个字节由8个二进制位组成，表示成十六进制就是2个十六进制位组成，那么就是两个一组表示一个字节</p><p>也就是dd、43、88、ee，即下面的dd、C、88、ee，写的时候要写成''，</p></blockquote><blockquote><p><code>f1 = ord('\xdd')</code>这行代码的作用是将十六进制表示的字节序列 <code>'\xdd'</code>转换为对应的整数值，并将结果赋值给变量 <code>f1</code>。</p><ol type="1"><li><code>\xdd</code>: 这是一个字符串字面量，其中 <code>\x</code>是表示后面两个字符是十六进制值的转义序列，<code>dd</code>是两个十六进制数字，表示一个字节的十六进制值。在这里，<code>\xdd</code>表示一个字节，其十六进制值为 <code>0xdd</code>。</li><li><code>ord()</code>: 这是一个内置函数，用于获取给定字符的 Unicode码点（整数值）。在这里，<code>ord('\xdd')</code> 将返回<code>221</code>，因为十六进制 <code>0xdd</code> 对应的十进制值是<code>221</code>。</li><li><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></li></ol><p>所以，<code>f1</code> 最终的值将是 <code>221</code>，因为它表示了字符<code>'\xdd'</code> 对应的 Unicode 码点。</p></blockquote><h2 id="babyaes">babyaes</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> data + <span class="hljs-string">b&quot;&quot;</span>.join([<span class="hljs-string">b&#x27;\x00&#x27;</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(data))])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    flag_ = pad(flag)<br>    key = os.urandom(<span class="hljs-number">16</span>) * <span class="hljs-number">2</span><br>    iv = os.urandom(<span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(bytes_to_long(key) ^ bytes_to_long(iv) ^ <span class="hljs-number">1</span>)<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    enc_flag = aes.encrypt(flag_)<br>    <span class="hljs-built_in">print</span>(enc_flag)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><span class="hljs-comment"># 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>官方说法：</p><p>解密 flag 我们需要获取到 key 和 iv 的值，由条件：</p><p>key=os.urandom(16)*2</p><p>iv=os.urandom(16)</p><p>可知：key是32bytes,256bits ；iv是16bytes ,128bits</p><p>key^iv ，那么只有 iv 与 key 的低128位相异或，所以 key的高128位是固定不变的。所以 xor 的高128bits,就是 key的高128bits,进而可以得到 key 的所有值256bits。</p><p>之后 key 的低128bits，与 xor 的低128bits 相异或，所得结果就是 iv的值了</p><p>得到 key , iv 后就可以直接用aes.decrypt()来解密了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是我的exp，没成功，（后来发现是做出来了😡</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br> <br><br>out = <span class="hljs-number">3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># 转换成为字节类型</span><br>out =long_to_bytes(out)<br><br>flag_encrypted = <span class="hljs-string">b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br> <br><span class="hljs-comment">#高十六位是key的高十六位 并且key是按照16位进行重复 所以得到高16位就能得到整个key</span><br>key = out[:<span class="hljs-number">16</span>]*<span class="hljs-number">2</span><br><br><br><span class="hljs-comment"># 把key的低十六位与out的低十六位做异或就能得到向量iv</span><br>iv = bytes_to_long(key[<span class="hljs-number">16</span>:]) ^ bytes_to_long(out[<span class="hljs-number">16</span>:])<br><br><span class="hljs-comment">#重新转换成为字节</span><br>iv = long_to_bytes(iv)<br><span class="hljs-comment">#创建aes解密器 需要秘钥key 解密模式 还有解密向量iv</span><br>aes = AES.new(key,AES.MODE_CBC,iv)<br><span class="hljs-comment">#使用解密器解密</span><br>flag = aes.decrypt(flag_encrypted)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment"># b&#x27;firsT_cry_Aes\x00\x00\x01&#x27;</span><br><span class="hljs-comment"># 然后flag&#123;firsT_cry_Aes&#125;，测！</span><br></code></pre></td></tr></table></figure><h2 id="babyrsa">babyrsa</h2><blockquote><p>提示：很容易分解的n</p></blockquote><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_prime</span>(<span class="hljs-params">n</span>):<br>    res = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>        res *= getPrime(n)<br><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = gen_prime(<span class="hljs-number">32</span>)<br>    e = <span class="hljs-number">65537</span><br>    m = bytes_to_long(flag)<br>    c = <span class="hljs-built_in">pow</span>(m,e,n)<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-comment"># 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br><span class="hljs-comment"># 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><blockquote><p>跟MoeCTF 2023 factor_signin 一题一样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br>n = <span class="hljs-number">17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br>c = <span class="hljs-number">14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P10 = 3831680819</span><br><span class="hljs-string">P10 = 2338725373</span><br><span class="hljs-string">P10 = 2370292207</span><br><span class="hljs-string">P10 = 2706073949</span><br><span class="hljs-string">P10 = 2970591037</span><br><span class="hljs-string">P10 = 2923072267</span><br><span class="hljs-string">P10 = 3654864131</span><br><span class="hljs-string">P10 = 2463878387</span><br><span class="hljs-string">P10 = 3939901243</span><br><span class="hljs-string">P10 = 2804303069</span><br><span class="hljs-string">P10 = 3207148519</span><br><span class="hljs-string">P10 = 4093178561</span><br><span class="hljs-string">P10 = 2217990919</span><br><span class="hljs-string">P10 = 2794985117</span><br><span class="hljs-string">P10 = 4278428893&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-comment"># b&#x27;flag&#123;us4_s1ge_t0_cal_phI&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="small-d">small d</h2><h3 id="main-4">main</h3><blockquote><p>提示: Michael J. Wiener 觉得很赞</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br>d = getPrime(<span class="hljs-number">32</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>n = p*q<br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(e)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br><span class="hljs-comment"># e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br><span class="hljs-comment"># n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><blockquote><p>[RSA2]4(Wiener)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny师傅的库</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>c = <span class="hljs-number">6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br>e = <span class="hljs-number">8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br>n = <span class="hljs-number">19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MoeCTF 2023</title>
    <link href="/2023/09/24/MoeCTF%202023/"/>
    <url>/2023/09/24/MoeCTF%202023/</url>
    
    <content type="html"><![CDATA[<p>（仅有部分题目</p><h2 id="crypto-入门指北">Crypto 入门指北</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag <span class="hljs-comment"># 这个secret不是一个库，flag是你要自己求出来的，所以不要问为什么找不到这个库了（</span><br><br>p,q = getPrime(<span class="hljs-number">512</span>), getPrime(<span class="hljs-number">512</span>) <span class="hljs-comment"># 随机生成了两个质数</span><br>e = <span class="hljs-number">65537</span> <span class="hljs-comment"># 这是什么？</span><br>n = p*q<br>m = <span class="hljs-built_in">int</span>.from_bytes(flag.encode(),<span class="hljs-string">&quot;big&quot;</span>) <span class="hljs-comment"># 把flag编码成bytes，再转换成一个长整数</span><br>c = <span class="hljs-built_in">pow</span>(m,e,n) <span class="hljs-comment"># RSA加密！</span><br><br><span class="hljs-built_in">print</span>(p)<br><span class="hljs-built_in">print</span>(q)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># p = 0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br><span class="hljs-comment"># q = 0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br><span class="hljs-comment"># c = 0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br></code></pre></td></tr></table></figure><blockquote><p><code>m = int.from_bytes(flag.encode(),"big")</code></p><p>这行代码的作用是将字符串 <code>flag</code> 转换成一个大整数<code>m</code>。具体解释如下：</p><ul><li><code>flag</code>:这是一个字符串，通常包含需要进行加密或其他操作的敏感信息，例如密码或标志。</li><li><code>flag.encode()</code>: 这是将字符串 <code>flag</code>转换为字节序列的操作。在计算机中，所有的数据最终都会以字节的形式表示。<code>encode()</code>方法将字符串编码为字节，使用默认的编码方式（通常是UTF-8）。</li><li><code>"big"</code>:这是一个参数，它告诉Python将字节序列视为一个大端（big-endian）的整数。在大端表示法中，高位字节在前，低位字节在后。这是一种常见的表示整数的方式。</li><li><code>int.from_bytes(...)</code>:这是一个方法，用于将字节序列转换为整数。它接受两个参数，第一个参数是要转换的字节序列，第二个参数是表示字节序列顺序的字符串，这里是<code>"big"</code>。它会将字节序列按照指定的顺序解释为一个整数。</li></ul><p>因此，<code>m</code> 将包含了从字符串 <code>flag</code>转换而来的整数表示。在加密算法中，通常会将明文消息转换成整数形式，以便进行数学运算，例如RSA加密中的指数运算。</p></blockquote><blockquote><p><code>c = pow(m,e,n)</code></p><p>这行代码实现了RSA（Rivest–Shamir–Adleman）加密的核心操作。具体解释如下：</p><ul><li><code>m</code>:这是明文消息的整数表示。在RSA加密中，明文消息通常首先被编码成一个整数，这个整数在加密过程中被处理。</li><li><code>e</code>:这是RSA加密算法中的公钥指数。它是一个正整数，通常是65537。公钥指数是用于加密消息的指数。</li><li><code>n</code>:这是RSA加密算法中的模数（或称为模ulus）。它是两个大素数 p 和 q的乘积。模数在RSA加密和解密过程中都会用到。</li><li><strong><code>pow(m, e, n)</code>: 这是Python中的一个函数，用于计算m 的 e 次方除以 n的余数</strong>。也就是说，它执行的是模指数运算。在RSA加密中，这等效于对明文消息m 进行加密操作。</li></ul><p>最终，<code>c</code>将包含加密后的密文，它是整数形式的，可以通过RSA私钥进行解密，从而还原为原始的明文消息<code>m</code>。RSA是一种非对称加密算法，公钥用于加密，私钥用于解密，这使得只有拥有私钥的人才能够解密密文。</p></blockquote><p><strong><em>哦~~，这里就是说flag是不知道的，就是让我们求一下flag</em></strong></p><h3 id="exp">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><br>p = <span class="hljs-number">0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br>q = <span class="hljs-number">0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br>c = <span class="hljs-number">0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br>e = <span class="hljs-number">65537</span><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>) <span class="hljs-comment"># 你知道什么是 欧拉函数吗 [1]</span><br>d = <span class="hljs-built_in">pow</span>(e, -<span class="hljs-number">1</span>, phi) <span class="hljs-comment"># 什么是乘法逆元？ [2]</span><br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>相当于我们知道了p，q，c，e，然后求m，那就求出 n 和 d 即可</p><p>所以关键的就是求d</p><blockquote><p><code>d = pow(e, -1, phi)</code></p><p>这行代码计算了私钥 <code>d</code>，它是公钥指数 <code>e</code> 在模<code>phi</code> 下的乘法逆元。</p><p>因为 e 和 d之间一定满足：<code>(e * d) % phi(n) = 1</code>，即<code>e*d ≡ 1(mod φ(N))</code></p><p>这行代码其实跟之前 <em>[SWPUCTF 2021 新生赛]ez_rsa</em>解密代码中<code>d = gmpy2.invert(e, phi)</code>是一个意思</p></blockquote><ul class="task-list"><li><label><input type="checkbox" />由$ e*d ≡ 1(mod φ(N)) $可以得出 $e^{-1} ≡ d(mod φ(N)) $ 吗？</label></li></ul><p>答案是可以的，经过简单的运算即可得到</p><p>知识：<ahref="%5B乘法逆元%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/inverse/#定义)">乘法逆元</a>、<ahref="%5B欧拉函数%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/euler/)">欧拉函数</a>等</p><hr /><h2 id="baby_e">baby_e</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime,bytes_to_long<br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>e = <span class="hljs-number">7</span><br>n = p*q<br>m = bytes_to_long(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read().strip())<br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c = &quot;</span>,c)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n = &quot;</span>,n)<br><br><span class="hljs-comment"># c =  147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br><span class="hljs-comment"># n =  553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br>c = <span class="hljs-number">147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br>n = <span class="hljs-number">553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br>e = <span class="hljs-number">7</span>       <span class="hljs-comment"># 但是我们不知道p和q啊，这怎么求啊</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">7</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><span class="hljs-comment"># print(a)</span><br><br></code></pre></td></tr></table></figure><p>思路（very very very 感谢峰哥（<del>其实是学弟，惭愧</del>））：</p><p>小公钥指数攻击：</p><ul><li>因为 e 很小，n 很大</li><li>所以明文 m 乘了 e 次方也没到 n ，n 根本没用到</li><li>所以 c直接开7次根就是明文了，这里要用<code>gmpy2.iroot(c, 7)</code>，而不能<code>pow(c,1/7)</code>，后者算不动</li><li>找时间去看：<ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></li></ul><hr /><h2 id="bad_e">bad_E</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment"># 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br><span class="hljs-built_in">print</span>(q) <span class="hljs-comment"># 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>m = bytes_to_long(flag.encode())<br>c = <span class="hljs-built_in">pow</span>(m,e,p*q)<br><span class="hljs-built_in">print</span>(c) <span class="hljs-comment"># 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>参考下面的博客：</p><p><ahref="https://blog.csdn.net/qq_57235775/article/details/132575196?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=e和phi不互素&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-132575196.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">e与phi不互素的情况_余切66的博客-CSDN博客</a></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694699685619.png"alt="1694699685619" /><figcaption aria-hidden="true">1694699685619</figcaption></figure><p>e和phi不互素，本题是gcd(e,q-1)=1，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br>q = <span class="hljs-number">11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br>c = <span class="hljs-number">63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(gcd(e,q-<span class="hljs-number">1</span>))<br><br><br>phi = q-<span class="hljs-number">1</span><br>d = gmpy2.invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,q)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factor_signin">factor_signin</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip()<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(flag) == <span class="hljs-number">72</span><br><br>m1 = <span class="hljs-built_in">int</span>.from_bytes(flag[:<span class="hljs-number">36</span>],<span class="hljs-string">&quot;big&quot;</span>)<br>m2 = <span class="hljs-built_in">int</span>.from_bytes(flag[<span class="hljs-number">36</span>:],<span class="hljs-string">&quot;big&quot;</span>)<br><br>e = <span class="hljs-number">65537</span><br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>n1 = p*q<br>c1 = <span class="hljs-built_in">pow</span>(m1,e,n1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c1 = &quot;</span>,c1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n1 = &quot;</span>,n1)<br><br>primes = [getPrime(<span class="hljs-number">64</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]<br>n2 = prod(primes)<br>c2 = <span class="hljs-built_in">pow</span>(m2,e,n2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c2 = &quot;</span>,c2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n2 = &quot;</span>,n2)<br><br><span class="hljs-comment"># c1 =  10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br><span class="hljs-comment"># n1 =  343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br><span class="hljs-comment"># c2 =  4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br><span class="hljs-comment"># n2 =  8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><p>前半部分：直接分解n1</p><p>后半部分：n2是多个素数的乘积，求欧拉函数，我教过你吧😋<del>（但是这个脚本我还真第一次见</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br><br>c1 =  <span class="hljs-number">10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br>n1 =  <span class="hljs-number">343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br>c2 =  <span class="hljs-number">4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br>n2 =  <span class="hljs-number">8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br><br>p1 = <span class="hljs-number">18055722101348711626577381571859114850735298658417345663254295930584841136416234624852520581982069555948490061840244710773146585295336094872892685938420880462305333393436098181186277450475949236132458958671804132443554885896037342335902958516394876382378829317303693655605215373555988755516058130500801822723195474873517960624159417903134580987202400855946137101429970119186394052011747475879598126195607938106163892658285305921071673588966184054026228745012993740035399652049777986535759039077634555909031397541116025395236871778797949216479130412500655359057128438928721459688727543057760739527720641179290282309741</span><br>q1 = <span class="hljs-number">19024691283015651666032297670418553586155390575928421823630922553034857624430114628839720683172187406577114034710093054198921843669645736474448836706112221787749688565566635453151716934583685087745112614898780150391513798368931496744574075511968933800467288441832780919514199410584786925010518564670786685241724643282580795568609339268652910564215887176803735675069372979560024792322029911970574914829712553975379661212645059271137916107885326625543090473004683836665262304916304580076748336858662108554591235698235221618061328251985929904075811056422186525179189846420226944944513865790999242309352900287977666792901</span><br><br>phi = (p1-<span class="hljs-number">1</span>)*(q1-<span class="hljs-number">1</span>)<br>d = invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c1,d,n1)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P20 = 14745811312384518031</span><br><span class="hljs-string">P20 = 18345408081492711641</span><br><span class="hljs-string">P20 = 14678737767649343977</span><br><span class="hljs-string">P20 = 14619040595108594017</span><br><span class="hljs-string">P19 = 9949603102225364603</span><br><span class="hljs-string">P20 = 12034779627328165471</span><br><span class="hljs-string">P20 = 10596280721192026229</span><br><span class="hljs-string">P20 = 15211380502610462057</span><br><span class="hljs-string">P20 = 14813953870710226847</span><br><span class="hljs-string">P20 = 13062839684118954553</span><br><span class="hljs-string">P20 = 15332916111580607077</span><br><span class="hljs-string">P20 = 16870346804576162551</span><br><span class="hljs-string">P20 = 11092420583960163379</span><br><span class="hljs-string">P20 = 14397830993057803133</span><br><span class="hljs-string">P20 = 16123604149048919099</span><br><span class="hljs-string">P20 = 13645878578452317313</span><br><span class="hljs-string">P20 = 17093292308638969889</span><br><span class="hljs-string">P20 = 17289161209347211817</span><br><span class="hljs-string">P20 = 15175734709842430433</span><br><span class="hljs-string">P20 = 15751974537676958401</span><br><span class="hljs-string">P20 = 10864078180916418691</span><br><span class="hljs-string">P20 = 17673334943789572513</span><br><span class="hljs-string">P20 = 18390046459144888243</span><br><span class="hljs-string">P20 = 12404642343676224637</span><br><span class="hljs-string">P20 = 18106525049998616747</span><br><span class="hljs-string">P20 = 11853704782834170959</span><br><span class="hljs-string">P20 = 17543713628803023199</span><br><span class="hljs-string">P20 = 10049235158029375571</span><br><span class="hljs-string">P20 = 12448177342966243757</span><br><span class="hljs-string">P20 = 17265001711647542137</span><br><span class="hljs-string">P20 = 10547615587767500213</span><br><span class="hljs-string">P20 = 16408421615173973083&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m2 = <span class="hljs-built_in">pow</span>(c2,d,n2)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m2))<br><span class="hljs-comment"># b&#x27;moectf&#123;fACtord6_And_YAfu_Are_6oth_good_utils_to_fACtorize_num6ers_ff90S&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="feistel">feistel</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><span class="hljs-built_in">round</span> = <span class="hljs-number">2</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./secret&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>).read().strip()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">m, key</span>):<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">4</span>)<br>    m = m ^ (m &lt;&lt; <span class="hljs-number">5</span>)<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">8</span>)<br>    m ^= key<br>    m = (m * <span class="hljs-number">1145</span> + <span class="hljs-number">14</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * <span class="hljs-number">1919</span> + <span class="hljs-number">810</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * key) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    <span class="hljs-keyword">return</span> m<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params">m, key, <span class="hljs-built_in">round</span></span>):<br>    key = bytes_to_long(key)<br>    left = bytes_to_long(m[:<span class="hljs-number">8</span>])<br>    right = bytes_to_long(m[<span class="hljs-number">8</span>:])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">round</span>):<br>        left, right = right, f(right, key) ^ left<br>    left, right = right, left<br>    <span class="hljs-keyword">return</span> long_to_bytes(left).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>) + long_to_bytes(right).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding</span>(<span class="hljs-params">m</span>):<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    pad = <span class="hljs-number">16</span> - mlen % <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> m + pad * <span class="hljs-built_in">bytes</span>([pad])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecb_enc</span>(<span class="hljs-params">m, key</span>):<br>    m = padding(m)<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    c = <span class="hljs-string">b&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mlen // <span class="hljs-number">16</span>):<br>        c += enc(m[i * <span class="hljs-number">16</span> : i * <span class="hljs-number">16</span> + <span class="hljs-number">16</span>], key, <span class="hljs-built_in">round</span>)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-built_in">print</span>(ecb_enc(flag, <span class="hljs-string">b&quot;wulidego&quot;</span>))<br><br><span class="hljs-comment"># b&#x27;\x0b\xa7\xc6J\xf6\x80T\xc6\xfbq\xaa\xd8\xcc\x95\xad[\x1e\&#x27;W5\xce\x92Y\xd3\xa0\x1fL\xe8\xe1&quot;^\xad&#x27;</span><br><br></code></pre></td></tr></table></figure><h2 id="nn">n&amp;n</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip().encode()<br><br>m = bytes_to_long(flag)<br>n = p * q<br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br>c1 = <span class="hljs-built_in">pow</span>(m,e1,n)<br>c2 = <span class="hljs-built_in">pow</span>(m,e2,n)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-built_in">print</span>(c2)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># 5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br><span class="hljs-comment"># 4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br><span class="hljs-comment"># 13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><p>共模攻击，用的脚本</p><p><u>这里十六进制的e1竟然不用转换</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> gmpy2<br> <br>c1 = <span class="hljs-number">5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br>c2 = <span class="hljs-number">4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br><span class="hljs-comment"># e1 = int(str(e1), 16) </span><br><br><br>n = <span class="hljs-number">13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br><br><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">RSA_ComModAtk</span>(<span class="hljs-params">e1, e2, c1, c2, n</span>):<br>    e1, e2, c1, c2, n = <span class="hljs-built_in">int</span>(e1), <span class="hljs-built_in">int</span>(e2), <span class="hljs-built_in">int</span>(c1), <span class="hljs-built_in">int</span>(c2), <span class="hljs-built_in">int</span>(n)<br>    <span class="hljs-keyword">if</span> gmpy2.gcd(e1,e2) ==<span class="hljs-number">1</span>:<br>        s = gmpy2.gcdext(e1, e2)  <span class="hljs-comment"># 扩展欧几里得算法-辗转相除法使得  x*e1+y*e2=1,求出t和z</span><br>        x = s[<span class="hljs-number">1</span>]<br>        y = s[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>            x = - x  <span class="hljs-comment"># 变指数为正值</span><br>            c1 = gmpy2.invert(c1, n)  <span class="hljs-comment"># 求c1的逆元</span><br>        <span class="hljs-keyword">if</span> y &lt; <span class="hljs-number">0</span>:<br>            y = -y  <span class="hljs-comment"># 变指数为正值</span><br>            c2 = gmpy2.invert(c2, n)  <span class="hljs-comment"># 求c2的逆元</span><br>        m = (<span class="hljs-built_in">pow</span>(c1, x, n) * <span class="hljs-built_in">pow</span>(c2, y, n)) % n  <span class="hljs-comment"># (c1^x*c2^y)%n=m^e1x*me2y%n=m^(e1x+e2y)%n=m%n=m</span><br>        <span class="hljs-keyword">return</span> m<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> bytes_to_long(<span class="hljs-string">b&#x27;e1 and e2 are not relatively prime&#x27;</span>) <span class="hljs-comment"># e1和e2不互质</span><br>    <br><br>m = RSA_ComModAtk(e1, e2, c1, c2, n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factorize_me">factorize_me!</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> nextprime<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choices<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>primes = [getPrime(<span class="hljs-number">512</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(primes) = &#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(p - <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes) = &#125;</span>&quot;</span>)<br><br>primes2 = [nextprime(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> choices(primes, k=<span class="hljs-number">3</span>)]<br>n = prod(primes2)<br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">int</span>.from_bytes(flag, <span class="hljs-string">&#x27;big&#x27;</span>), e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836866602305788131186220057989320357344904731322223310531945208433910803617954798258382169132907508787682006064930747033681966462568715421005454243255297306718356766130469885581576362173340673516476386201173298433892314145854649884922769732583885904512624543994675379894718657682146178638074984373206937523380103438050549181568015985546172618830480078894445808092527561363650503540062128543705172678754195578429520889784813733491180748361345720247750720179608752244490362713103319685024237941527268458213442611663415417005556439749055222361212059968254748751273361732365487788593341859760309778894350385339764442343374673786357175846291309425081492959910254127778240522152676060766139057453197528944251599979227271074508795482632471242983094008619339488744362509349734218480932255216087706001484182136783834973304870508270118505737767002256270427907341952256516206663258530300791364944105025764611810001781971638030661367630116818647252727909489405550104641122269772492252464714694507693447974171377200402508765841829763548525530878309985480248379655169722567051495205792089930014228403456098065971372039443284193603395249634283366194562380309469628114581468645669390610963076340643757972439104287127375438663839421605531570285615180251</span><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836492373364350673588273863828369502073826782362255108313852264064760467561392054178047091483873483255491431451728274259516789065331176728192953741805933100379191778599394515981288225535175013258094287912195847642598436035132783919453991516358280321085873745330313812205910011387125778714795906023110368957596998222544234082487264006696812862179916726781327290284827659294751262185328816323311831349296593013038823107653943652771448719760448938995150646738377177532550757319539185878535087009904848382493668686831331474113789651777885239747000076063679062106375348803749466079052774597412239427050432901553466002731972993029311850718200685157193170716432600165476733200831046297530470544781309612128231925681374239849452623513538498417735984094919756374577623486416462101457492789215144166273775249387638107644634704270216130852885082174564648445147377239033930079759024399532146184753110240154062693457622208373371290126810856885343328090305620627668495081760346853701632815149478447405718664667978825807101325764916405446176183238866136433205933785973568759281210319422288153910340542098573782006262190181726245838857185687242960093445000287347616796984610291664809895901301187179157382169999966124177588884152267266994164841066291200</span><br><span class="hljs-comment"># n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441</span><br><span class="hljs-comment"># e = 65537</span><br><span class="hljs-comment"># c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br></code></pre></td></tr></table></figure><h3 id="exp-5">exp</h3><p><strong>[RSA1]P7</strong>，直接分解n运算即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br><br>p = <span class="hljs-number">6991223361118904775931217829045348785013077549030883418924453538830605687999480005714979700653172534877541317997174968789510984315425270755055110913347349</span><br>q = <span class="hljs-number">9987009117206906203158749743824168660291275882852229158070368815160479543708376165641735042845357978292384303332559592302507789120810447986634662721490849</span><br>r = <span class="hljs-number">12876877424944854147075816504195994138450356002779004886384584287813869165469217718717854027672044903401715370348223932937626725119320180795716270261309141</span><br><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment"># 不知道上面给那两个大数是干啥的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数学习</title>
    <link href="/2023/09/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>byd这个用markdown写着太麻烦了😡</p></blockquote><h2 id="lec01_方程组的几何解释">Lec01_方程组的几何解释</h2><p>线性代数的基本问题就是解n元一次方程组。</p><p>例如：二元一次方程组</p><p><span class="math display">\[\left\{ \begin{matrix}2x+y=0   \\-x+2y=3\end{matrix}\right.\]</span></p><p>写成矩阵形式就是：</p><p><span class="math display">\[\begin{bmatrix}2&amp;-1  \\-1&amp;2  \\\end{bmatrix}\begin{bmatrix}x \\y\end{bmatrix}=\begin{bmatrix}0 \\ 34\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(A = \begin{bmatrix}  2&amp;-1\\  -1&amp;2 \\ \end{bmatrix}\)</span>被称为系数矩阵</p><p>未知数向量通常记为 <span class="math inline">\(X = \begin{bmatrix}x\\ y \end{bmatrix}\)</span></p><p>而等号右侧的向量记为<strong>b</strong>。线性方程组简记为<strong>Ax=b</strong>。</p><h3 id="行图像">行图像</h3><p>就是按行来画，跟我们之前的思维很像</p><p>行图像遵从解析几何的描述，每个方程在平面上的图像为一条直线。找到符合方程的两个数组，就可以确定出x-y平面上的两个点，</p><p>连接两点可以画出该方程所代表的直线。两直线交点即为方程组的解x=1,y=2。</p><h3 id="列图像">列图像</h3><p>在列图像中，我们将系数矩阵写成列向量的形式，则求解原方程变为寻找列向量的线性组合来构成向量<strong>b</strong>。</p><p><span class="math inline">\(x\begin{bmatrix}  2 \\  -1 \\\end{bmatrix}+y\begin{bmatrix}  -1 \\  -2 \\\end{bmatrix}=\begin{bmatrix}  0 \\  3 \\ \end{bmatrix}\)</span></p><p>向量线性组合是贯穿本课程的重要概念。对于给定的向量<strong>c</strong>和<strong>d</strong>以及标量<em>x</em>和<em>y</em>，我们将x<strong>c</strong>+y<strong>d</strong>称之为<strong>c</strong>和<strong>d</strong>的一个线性组合。</p><p>几何上讲，如下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230923165849317.png"alt="image-20230923165849317" /><figcaption aria-hidden="true">image-20230923165849317</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构学习</title>
    <link href="/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-线性表">第二章 线性表</h2><h3 id="section">2.5</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">L</span><span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">; P=L;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br>P-&gt;next<span class="hljs-operator">=</span>NULL<span class="hljs-comment">;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">;i&gt;=1;i--) Ins_LinkList(L,i+1,i*2);</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=3;i++) Del_LinkList(L,i);</span><br></code></pre></td></tr></table></figure><p><code>L=(LinkList)malloc(sizeof(LNode));</code></p><p>这行代码是C或C++中用于动态分配内存并创建一个链表（或链表的头节点）的代码。</p><p>这行代码作用的详细解释：</p><ol type="1"><li><code>malloc</code> 函数：<code>malloc</code>是C和C++中用于动态分配内存的函数。它的作用是在堆（heap）中分配一块指定大小的内存，并返回一个指向该内存块的指针。在这里，<code>malloc(sizeof(LNode))</code>分配了一块大小为 <code>sizeof(LNode)</code> 字节的内存。</li><li><code>sizeof(LNode)</code>：<code>sizeof</code>是一个运算符，用于获取数据类型或结构体的大小（以字节为单位）。<code>LNode</code>是链表节点的数据结构（或类型），因此 <code>sizeof(LNode)</code> 返回<code>LNode</code> 结构体的大小。</li><li><code>(LinkList)</code>强制类型转换：在C和C++中，<code>malloc</code> 返回一个 <code>void</code>指针，需要将其转换为所需的数据类型，这里是 <code>LinkList</code>类型。这样做是为了让指针指向正确的数据类型，以便后续操作。</li><li><code>L</code>：这是链表的头指针，它被分配了一块内存，并指向了链表的头节点。</li></ol><p>总结起来，这行代码的作用是创建一个链表，并将链表的头指针<code>L</code> 指向一个新分配的内存块，该内存块大小为<code>sizeof(LNode)</code> 字节，用来存储链表的头节点。</p><p>这是创建链表的起始步骤，通常会跟随其他操作来构建链表的节点和连接。在使用完链表后，需要记得使用<code>free</code>函数来释放分配的内存，以避免内存泄漏。例如：<code>free(L)</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个循环，它用于在链表中创建四个节点，并为每个节点赋值。解释如下：</p><ol type="1"><li><code>for(i=1;i&lt;=4;i++)</code>：这是一个循环，它会执行四次，<code>i</code>从1开始，每次递增1，直到 <code>i</code> 的值为4。</li><li><code>P-&gt;next=(LinkList)malloc(sizeof(LNode));</code>：这行代码分配了一个新的内存块，用于存储下一个节点，并将当前节点的<code>next</code>指针指向这个新节点。这意味着创建了一个新节点，并将其链接到链表中。</li><li><code>P=P-&gt;next;</code>：将指针 <code>P</code>移动到下一个节点。现在 <code>P</code>指向了新创建的节点，以便为它赋值。</li><li><code>P-&gt;data=i*2-1;</code>：为当前节点的 <code>data</code>成员赋值。这里应该是<code>P-&gt;data = i*2 - 1;</code>，将当前节点的数据设为 <code>i</code>乘以 2 减去 1 的结果。</li></ol><p>所以，这个循环会创建四个新的节点，并在每个节点的 <code>data</code>成员中存储一个奇数值（1、3、5、7）。</p><p>然后最后两行语句-----</p><ul><li><code>Ins_LinkList(L,i+1,i*2);</code>：调用了一个名为<code>Ins_LinkList</code> 的函数，将元素 <code>i*2</code> 插入到链表的第<code>i+1</code> 个位置。</li><li><code>Del_LinkList(L,i);</code>：调用了一个名为<code>Del_LinkList</code> 的函数，删除链表中的第 <code>i</code>个元素(<strong>这里是不算头节点的,因为头节点没有被赋予元素?????</strong>)。</li></ul><h3 id="section-1">2.6</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><code>while(P-&gt;next!=NULL) P=P-&gt;next;</code></label></li></ul><p>这行代码是一个 <code>while</code> 循环，其目的是在链表中移动指针<code>P</code> 直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。</p><p>解释如下：</p><ol type="1"><li><code>P-&gt;next != NULL</code>：这是一个条件表达式，它检查当前节点<code>P</code> 的下一个节点是否不等于<code>NULL</code>。条件表达式的结果是一个布尔值，如果当前节点的下一个节点不是<code>NULL</code>，则条件为真，继续执行循环体。</li><li><strong><code>P = P-&gt;next;</code>：如果条件为真，就执行这行代码。这行代码将指针<code>P</code> 移动到下一个节点，即将 <code>P</code>更新为当前节点的下一个节点，以便继续检查下一个节点是否为链表的末尾。(终于理解😭)</strong></li></ol><p>循环将一直执行，直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。一旦链表末尾被找到，条件表达式为假，循环终止。这段代码通常用于遍历整个链表，直到到达链表的末尾节点。</p><p>总之，这段代码的目的是在链表中移动指针 <code>P</code>直到达到链表的末尾节点。</p><p>已知 L 是带表头结点的非空单链表，和已知 L是无表头结点的单链表，有什么区别</p><h3 id="section-2">2.7</h3><p><strong>带表头结点</strong>和<strong>无表头结点</strong>的单链表在数据结构中有一些重要区别：</p><ol type="1"><li><strong>存在与否：</strong><ul><li><strong>带表头结点的单链表：</strong>这种链表在头部有一个额外的结点，通常称为表头结点或者哨兵结点。这个结点不存储实际的数据，它的主要目的是使链表操作更容易实现，因为它可以避免对空链表的特殊处理。带表头结点的链表通常在操作上更加统一，因为头结点始终存在，即使链表为空。</li><li><strong>无表头结点的单链表：</strong>这种链表不包含表头结点，直接从第一个存储数据的结点开始。这意味着如果链表为空，那么链表头部就是一个空指针，需要特殊处理。</li></ul></li><li><strong>索引/遍历起始点：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，链表的第一个数据结点从头结点的下一个结点开始，索引为1。</li><li><strong>无表头结点的单链表：</strong>在没有头结点的情况下，链表的第一个数据结点通常是链表的头部，索引为0。</li></ul></li><li><strong>空链表处理：</strong><ul><li><strong>带表头结点的单链表：</strong>即使链表为空，头结点始终存在，因此对于空链表的处理与非空链表一样，不需要额外的特殊情况处理。</li><li><strong>无表头结点的单链表：</strong>如果链表为空，头部就是一个空指针，需要特殊处理，否则在访问链表时可能会引发错误。</li></ul></li><li><strong>操作实现的复杂性：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，通常可以更容易地实现插入和删除操作，因为不需要特殊情况处理头部节点。</li><li><strong>无表头结点的单链表：</strong>操作实现可能稍微复杂一些，因为需要处理头部节点的特殊情况。</li></ul></li></ol><p>在实际应用中，选择使用带表头结点还是无表头结点的单链表取决于具体的需求和设计。带表头结点的链表通常在实现上更加统一和方便，而无表头结点的链表可能更节省一些内存空间。</p><p><strong>首元结点&amp;尾元结点</strong></p><p>判断:在带头结点的循环单链表中，尾元结点的next指针指向链表的首元结点。</p><blockquote><p>false</p><p>尾元结点的next值指向链表的头节点，而不是首元结点。</p><p>首元结点指的是链表中存储第一个数据元素的结点。头节点是在首元结点之前设置的一个结点。</p></blockquote><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230919200445761.png"alt="image-20230919200445761" /><figcaption aria-hidden="true">image-20230919200445761</figcaption></figure><p>这里的D是尾元结点</p><p><strong>【头结点】【头指针】【首元结点】</strong></p><p>头结点（不一定有），存在为了方便操作，头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度），对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。</p><p>首元结点：实际记录数据的第一个节点；</p><p>头指针：指向第一个物理节点地址的指针，就是定义的链表名，这个头指针的意义在于，在访问链表时，总要知道链表存储在什么位置（从何处开始访问），由于链表的特性（next指针），知道了头指针，那么整个链表的元素都能够被访问，也就是说头指针是必须存在的。</p><h3 id="section-3">2.9</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 分析一下下面这段代码<br>Status A(LinkedList L) &#123; <span class="hljs-regexp">//</span>L 是无表头结点的单链表<br><span class="hljs-keyword">if</span>(L &amp;&amp; L-&gt;<span class="hljs-keyword">next</span>) &#123;<br>    Q=L; L=L-&gt;<span class="hljs-keyword">next</span>; P=L;<br>    <span class="hljs-keyword">while</span>(P-&gt;<span class="hljs-keyword">next</span>) P=P-&gt;<span class="hljs-keyword">next</span>;<br>    P-&gt;<span class="hljs-keyword">next</span>=Q; Q-&gt;<span class="hljs-keyword">next</span>=NULL;<br>&#125;<br>return OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个函数<code>Status A(LinkedList L)</code>，其目的是将无表头结点的单链表<code>L</code> 中的首元素移到链表的末尾。以下是代码的逐行解释：</p><ol type="1"><li><code>if (L &amp;&amp; L-&gt;next)</code>：这是一个条件语句，确保链表<code>L</code>不为空且至少包含两个元素。如果链表为空或只包含一个元素，那么没有必要执行首元素移到末尾的操作。</li><li><code>Q = L;</code>：创建一个指向链表头结点的指针<code>Q</code>，用于暂时保存链表的首元素。</li><li><code>L = L-&gt;next;</code>：将链表头指针 <code>L</code>移动到链表的下一个元素，即跳过了原始的首元素。</li><li><code>P = L;</code>：创建一个指向链表头结点的新指针<code>P</code>，用于遍历链表并找到末尾元素。</li><li><code>while (P-&gt;next) P=P-&gt;next</code>：进入一个循环，该循环将<code>P</code> 移动到链表的最后一个元素，即当 <code>P</code>的下一个元素不为空时继续执行。</li><li><code>P-&gt;next = Q;</code>：将末尾元素的 <code>next</code>指针指向原始首元素 <code>Q</code>，这样就将首元素移到了链表的末尾。</li><li><code>Q-&gt;next = NULL;</code>：将原始首元素 <code>Q</code> 的<code>next</code> 指针设置为<code>NULL</code>，以确保它成为新链表的末尾元素。</li><li><code>return OK;</code>：函数返回 OK，表示操作成功完成。</li></ol><p>总之，这段代码的作用是将无表头结点的单链表 <code>L</code>中的首元素移到链表的末尾。如果链表为空或只包含一个元素，则不执行任何操作。否则，它将通过重新连接指针来实现首元素的移动。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//分析一下下面这段代码</span><br>void <span class="hljs-constructor">BB(LNode <span class="hljs-operator">*</span><span class="hljs-params">s</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span> &#123;<br>    <span class="hljs-comment">// 声明指针 p，并将其初始化为 s</span><br>    p = s;<br>    <span class="hljs-comment">// 当 p 指向的结点的下一个结点不等于 q 时，执行循环</span><br>    <span class="hljs-keyword">while</span> (p-&gt;next != q) &#123;<br>        <span class="hljs-comment">// 将 p 移动到下一个结点</span><br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 将 q 结点的 next 指针指向 s，形成闭环</span><br>    p-&gt;next = s;<br>&#125;<br>void <span class="hljs-constructor">AA(LNode <span class="hljs-operator">*</span><span class="hljs-params">pa</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">pb</span>)</span> &#123;<br>    <span class="hljs-comment">// 调用 BB 函数，将结点 pa 到 pb 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pa</span>, <span class="hljs-params">pb</span>)</span>;<br>    <span class="hljs-comment">// 再次调用 BB 函数，将结点 pb 到 pa 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pb</span>, <span class="hljs-params">pa</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="section-4">2.11</h3><ul class="task-list"><li><label><input type="checkbox" />2.11 设顺序表 va中的数据元素递增有序。试写一算法，将 x插入到顺序表的适当位置上，以保持该表的有序性。</label></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Status InsertOrderList(SqList &amp;va,ElemType x)<br>&#123;<br>//在非递减的顺序表 va 中插入元素 x 并使其仍成为顺序表的算法<br>int i;<br><span class="hljs-keyword">if</span>(va.<span class="hljs-built_in">length</span>==va.listsize)<span class="hljs-built_in">return</span>(OVERFLOW);<br><br><span class="hljs-keyword">for</span>(i=va.<span class="hljs-built_in">length</span>;i&gt;<span class="hljs-number">0</span>,x&lt;va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];i--)<br>va.<span class="hljs-built_in">elem</span>[i]=va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];<br><br>va.<span class="hljs-built_in">elem</span>[i]=x;<br>va.<span class="hljs-built_in">length</span>++;<br><span class="hljs-built_in">return</span> OK;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Status InsertOrderList(SqList &amp;va,ElemType x)</code></p><p>这行代码是一个函数的声明，具体解释如下：</p><ul><li><code>Status</code>：这是函数的返回类型。在C/C++中，函数通常会返回一个值，表示函数的执行结果或状态。在这里，函数返回类型是<code>Status</code>，这意味着该函数会返回一个表示操作状态的值。</li><li><code>InsertOrderList</code>：这是函数的名称。函数名用于标识和调用函数。在这个情境下，函数名是<code>InsertOrderList</code>，它表示这个函数的目的是将一个元素插入到一个顺序表中。</li><li><code>(SqList &amp;va, ElemType x)</code>：这是函数的参数列表。它指定了函数接受的输入参数。具体解释如下：<ul><li><code>SqList &amp;va</code>：这是第一个参数，它是一个引用（<code>&amp;</code>符号表示引用）。这意味着函数将接受一个名为 <code>va</code>的参数，这个参数是一个 <code>SqList</code>类型的顺序表。通过引用传递，函数可以直接修改传递给它的顺序表，而不需要复制整个数据结构，这可以提高性能并节省内存。</li><li><code>ElemType x</code>：这是第二个参数，它是一个名为 <code>x</code>的参数，表示要插入到顺序表中的元素。<code>ElemType</code>可能是一个在代码的其他地方定义的数据类型，用于表示元素的类型。</li></ul></li></ul><p>综上，这行代码的含义是声明一个名为 <code>InsertOrderList</code>的函数，该函数接受一个顺序表 <code>va</code> 和一个元素 <code>x</code>作为参数，并且会返回一个 <code>Status</code>类型的值，用于表示函数执行的状态或结果。</p><p><code>for (i = va.length; i &gt; 0 &amp;&amp; x &lt; va.elem[i - 1]; i--)    va.elem[i] = va.elem[i - 1];</code></p><ul><li><p>这是一个 <code>for</code>循环，从顺序表的最后一个元素开始向前遍历，同时检查元素 <code>x</code>是否小于当前位置的元素。循环条件包括两部分：<code>i &gt; 0</code>表示循环要继续直到遍历到顺序表的第一个元素；<code>x &lt; va.elem[i - 1]</code>表示只要元素 <code>x</code>小于当前位置的元素，就继续循环。这个循环的目的是找到插入位置。</p></li><li><p>在循环中，将当前位置的元素向后移动，以为新元素 <code>x</code>腾出位置。这是为了为新元素 <code>x</code>让路，为其找到适当的插入位置。</p></li></ul><h3 id="section-5">2.15</h3><ul class="task-list"><li><label><input type="checkbox" />2.15 已知指针 ha 和 hb分别指向两个单链表的头结点，并且已知两个链表的长度分别为 m 和n。试写一算法将这两个链表连接在一起，假设指针 hc指向连接后的链表的头结点，并要求算法以尽可能短的时间完成连接运算。</label></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">void MergeList_L(LinkList &amp;ha,LinkList &amp;hb,LinkList &amp;hc) <br>&#123; <br>    LinkList pa,pb; <br>    pa=ha; <br>    pb=hb; <br>    <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>&amp;&amp;pb-&gt;</span>next)&#123; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>=pb-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-title">if</span>(!pa-&gt;</span>next)&#123;          <span class="hljs-comment">//pa到头了</span><br>        hc=hb; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pb-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pb=pb-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=ha-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-keyword">else</span>&#123; <br>        hc=ha; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pa=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=hb-&gt;</span>next; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="section-6">2.16</h3><p>已知指针 la 和 lb分别指向两个无头结点单链表中的首元结点。写一个算法实现:</p><ul class="task-list"><li><label><input type="checkbox" />从表 la 中删除自第 i 个元素起共 len个元素后，将它们插入到表 lb 中第 i 个元素之前。</label></li></ul><h3 id="section-7">2.22</h3><ul class="task-list"><li><label><input type="checkbox"checked="" />试写一算法，对单链表实现就地逆置。</label></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span><br>    ElemType data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span> <br>&#125; Lnode, *LinkList;<br><br><span class="hljs-comment">//Lnode，将 struct Lnode 重命名为 Lnode，这允许我们在代码中使用 Lnode 来声明结构体类型的变量。？？</span><br><span class="hljs-comment">//LinkList，将 struct Lnode* 重命名为 LinkList，这样我们可以使用 LinkList 来声明指向链表节点的指针变量。</span><br><br>Status <span class="hljs-title function_">ListOppose_L</span><span class="hljs-params">(LinkList &amp;L)</span> <br>&#123; <br>    LinkList p,q;   <span class="hljs-comment">//两个辅助指针</span><br>    p=L;       <span class="hljs-comment">//将 p 指针指向链表头节点。</span><br>    p=p-&gt;next;  <span class="hljs-comment">// 将 p 移动到链表的第一个真实节点，即跳过头节点。</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 将头节点的 next 指针置空，即将逆置后的链表末尾节点的 next 指针指向空。</span><br>    <span class="hljs-keyword">while</span>(p)&#123; <br>        q=p;         <br>        p=p-&gt;next;   <span class="hljs-comment">//这两行就是把 q 指向 p，然后将 p 向后移动到下一个节点：</span><br>        q-&gt;next=L-&gt;next;  <br>        L-&gt;next=q;   <span class="hljs-comment">//这两行就是进行插入，即：将 q 所指的节点插入到现在的表 L 的头结点和首元结点中间：</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> OK; <br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><ahref="https://blog.csdn.net/qq_41109668/article/details/104636252?ops_request_misc=%7B%22request%5Fid%22%3A%22169519655816800227422429%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519655816800227422429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104636252-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=试写一算法，对单链表实现就地逆置。&amp;spm=1018.2226.3001.4187">试写一算法，对单链表进行逆置试写一算法,实现单链表的就地逆置(要求在原链表上进行)_白薇.的博客-CSDN博客</a></p><p>大佬！！！这篇博客解释的非常清楚</p><h2 id="第三章">第三章</h2><h3 id="section-8">3.19</h3><p>括号匹配</p><h2 id="第六章-树">第六章 树</h2><h3 id="section-9">6.24</h3><p>树转换成二叉树：</p><ol type="1"><li>加线，所有兄弟结点之间连接一条线；</li><li>去线，对树中的每个结点，只保留它与第一个孩子结点的连线，删除与其他孩子结点之间的连线；</li><li>层次调整，以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）；</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698111444872.png"alt="1698111444872" /><figcaption aria-hidden="true">1698111444872</figcaption></figure><p>二叉树转换成树：</p><ol type="1"><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。（即先将父节点与其所有非第一个孩子结点的结点相连）</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。例子如下：</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079388509.png"alt="1698079388509" /><figcaption aria-hidden="true">1698079388509</figcaption></figure><p>森林转换成二叉树：</p><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p><ol type="1"><li>把每一棵树转换为二叉树</li><li>第一棵二叉树不动，第二棵树开始，以此把后一棵二叉树的根结点作为前一棵树的根结点的右子树连接起来</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698112427431.png"alt="1698112427431" /><figcaption aria-hidden="true">1698112427431</figcaption></figure><p>二叉树转换成森林：</p><ul><li>看二叉树的根结点是否有右孩子，有右结点是森林，无右结点是树。（根据孩子兄弟表示法，一棵树的根结点转换为二叉树，其二叉树的根结点无右孩子）</li><li>若是森林：<ul><li>依次把与右孩子结点的连线删除，得到分离的二叉树</li><li>把分离后的每棵二叉树转换为树；</li><li>整理第（2）步得到的树，使之规范，这样得到森林。例子如下：</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079139900.png"alt="1698079139900" /><figcaption aria-hidden="true">1698079139900</figcaption></figure></li></ul></li><li>若是树：<ul><li>参照二叉树转换成树</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-动态规划</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95%204-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95%204-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="多段图最短路径问题">多段图最短路径问题</h2><h3 id="动态规划法">动态规划法</h3><p><strong>动态规划法</strong>将待求解问题分解成若干个相互重叠的子问题，每个子问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系(<em>称为动态规划函数</em>)中，将子问题的解求解一次并填入表中，当需要再次求解此子问题时，可以通过查表获得该子问题的解，从而避免了大量重复计算。具体的动态规划法多种多样，但都具有相同的填表形式。一般来说，动态规划法的求解过程由以下三个阶段组成：</p><ol type="1"><li><strong>划分子问题</strong>：将原问题分解为若干个子问题，每个子问题对应一个决策阶段，并且子问题之间具有重叠关系。</li><li><strong>确定动态规划函数</strong>：根据子问题之间的重叠关系找到子问题满足的递推关系式即动态规划函数，这是动态规划法的关键。</li><li><strong>填写表格</strong>：设计表格，以自底向上的方式计算各个子问题的解并填表，实现动态规划过程。</li></ol><p>上述动态规划过程可以求得问题的最优值即目标函数的极值，如果要求出具体的最优解，通常在动态规划过程中记录必要的信息，再根据最优决策序列构造最优解。</p><h3 id="多段图最短路径问题-1">多段图最短路径问题</h3><p>设图 <span class="math inline">\(G =（V,E）\)</span>是一个带权有向图，如果把顶点集合 V 划分成 k 个互不相交的子集 <spanclass="math inline">\(V_i（2≤k≤n,1≤i≤k）\)</span>，使得 E 中的任何一条边&lt;u,v&gt;，必有 <span class="math inline">\(u∈V_i, v∈V_{i + m}(i&lt;k,1&lt;i+m≤k)\)</span>,则称图 G 为多段图，称 s∈V1 为源点，t∈Vk为终点。</p><p>多段图的最短路径问题为从源点到终点的最小代价路径，如下动图所示：</p><blockquote><p>多段图是一个有向的无环图。求解从起始点到终止点的最短路径的长度，首先看一下这个问题是否具有最优子结构的性质。对于每一点来说，从v0到它的最短路径有两种可能，分别是从v0直接到该点或者是从最短的前驱节点开始到该节点。从这里可以看出有递归的性质，所以使用回溯的方法也是可以解决的。即从终点开始，依次向前找到最短的路径。由于递归本身所用的时间较长，并且在回溯的过程中存在重复的工作，所以使用动态规划更好。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082106575.gif"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h3 id="最优子结构证明">最优子结构证明</h3><p>适合采用动态规划方法的最优化问题中的两要素：</p><p>✓ <strong>最优子结构</strong></p><p>✓ <strong>重叠子问题</strong></p><p><strong>一、 最优子结构</strong></p><ul><li><p>如果问题的最优解是由其子问题的最优解来构造的，则称该问题具有最优子结构</p></li><li><p>在动态规划中，我们利用子问题的最优解来构造问题的一个最优解，因此必须确保在我们所考虑的子问题范围中，包含了用于一个最优解的那些子问题</p></li></ul><p><strong>二、重叠子问题</strong></p><ul><li>适用于动态规划求解的最优化问题的第二个要素是子问题的空间要小，使用来解原问题的递归算法可反复解同样的子问题，而不总在产生新的子问题。</li><li>不同的子问题数是输入规模的一个多项式。</li><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，该性质称为子问题的重叠性质</li></ul><p>设s，s，s1，s2，……，sp，t是s到t的一条最短路径，且s到s1的路径已经求出，则问题转为s1到t的最短路径，因此s1，s2，……，sp，t构成一条最短路径，如果不是，则设s1，r1，r2，……，rp，t是一条从s1到t的最短路径，则s，s1，r1，r2，……，rp，t是一条从s到t的最短路径且比s，s1，s2，……，sp，t短，因此矛盾，所以多段图的最短路径问题满足最优性原理。</p><h3 id="问题分析">问题分析</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091126212.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091125642.png"alt="image-20231109112545467" /><figcaption aria-hidden="true">image-20231109112545467</figcaption></figure><h3 id="程序实现">程序实现</h3><p><code>c</code></p><p><code>arc[N] [N]</code>：图的邻接矩阵 <code>cost[N]</code>：一维数组存储到每个顶点的最小开销。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147421.png"alt="image-20231109114707374" /><figcaption aria-hidden="true">image-20231109114707374</figcaption></figure><p><code>path[N]</code>：用来保存每个顶点的前驱顶点，注意这个前驱结点是最短路径上的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147374.png"alt="image-20231109114720321" /><figcaption aria-hidden="true">image-20231109114720321</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 999999</span><br><br><span class="hljs-type">int</span> arc[N][N];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> vnum, arcnum;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入顶点的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;vnum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arcnum);<br>    <br>     <span class="hljs-comment">// 把arc初始化为一个vmun*vnum的矩阵，</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= vnum; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= vnum; j++) &#123;<br>            arc[i][j] = MAX;<br>        &#125;<br>        arc[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 顶点到自身的距离为0</span><br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的两个顶点和权值: \n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; arcnum; k++) &#123;<br>        <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;i, &amp;j, &amp;weight);<br>        arc[i][j] = weight;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> vnum;<br>&#125;<br><br><span class="hljs-comment">//返回最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BackPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-comment">//cost[N]是一个一维数组表，用来存储源点到每个顶点的最小开销</span><br>    <span class="hljs-comment">//path[N]保存每个结点的前驱</span><br>    <span class="hljs-type">int</span> cost[N], path[N];<br><br>    <span class="hljs-comment">//cost[i]初始化为长度为n的一维数组，值为arc[1][i]，即为源点到每个顶点的距离</span><br>    <span class="hljs-comment">//path[i]，用来保存每个顶点的前驱顶点，先都初始化为1，后面不更新的话就是1-&gt;n，注意这个前驱结点是最短路径上的</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cost[i] = arc[<span class="hljs-number">1</span>][i];<br>        path[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//for i=2,因为第一行已经赋值给cost[i]了，所以只需要遍历n-1行即可</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 检查是否存在一条从源点1经过顶点 i 到达顶点 j 的路径，其开销小于当前的 cost[j]，小于的话就更新cost[j]</span><br>            <span class="hljs-keyword">if</span> (cost[i] + arc[i][j] &lt; cost[j]) &#123;<br>                cost[j] = arc[i][j] + cost[i];<br>                path[j] = i;   <span class="hljs-comment">// 更新路径上的前一个顶点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从顶点1到顶点%d的最小开销为：%d，路径为：&quot;</span>, i, cost[i]);<br>        j = i;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &lt;- &quot;</span>, j);  <span class="hljs-comment">// 输出路径</span><br>            j = path[j];  <span class="hljs-comment">// 回溯路径上的前一个顶点</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> vnum = CreateGraph();<br>    BackPath(vnum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>c++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++的代码的coppy，没学过c++，主要看思路，</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXV 11</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;    <span class="hljs-comment">//图的定义</span><br>    <span class="hljs-type">int</span> edges[MAXV][MAXV];    <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> n;    <span class="hljs-comment">//顶点数</span><br>&#125; MGraph;<br><br>MGraph topography;    <span class="hljs-comment">//保存城市关系的邻接矩阵 </span><br><span class="hljs-type">int</span> path[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到该顶点的最短路径对应的前驱 </span><br><span class="hljs-type">int</span> min_cost[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到每个顶点的最短路径长 </span><br><br><span class="hljs-function">MGraph <span class="hljs-title">CreateMGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>    <span class="hljs-comment">//建图 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// MGraph topography;</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> point1, point2;<br><span class="hljs-type">int</span> value;<br><br><span class="hljs-comment">//初始化边为不存在 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br>topography.edges[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入边数：&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>cin &gt;&gt; point1 &gt;&gt; point2 &gt;&gt; value;<br>topography.edges[point1][point2] = value;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n建立的邻接矩阵为：&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,topography.edges[i][j]);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>topography.n = num;<br><span class="hljs-keyword">return</span> topography;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> cities_num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//城市数量 </span><br><span class="hljs-type">int</span> a_cost;    <span class="hljs-comment">//当前路径的开销</span><br><span class="hljs-type">int</span> pre;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;城市数量为：&quot;</span>; <br>cin &gt;&gt; cities_num;<br><span class="hljs-comment">//建图</span><br>topography = <span class="hljs-built_in">CreateMGraph</span>(cities_num);<br>        <span class="hljs-comment">//初始化路径开销</span><br>min_cost[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= topography.n; i++) &#123;<br>min_cost[i] = <span class="hljs-number">99999</span>;<br>&#125;<br><span class="hljs-comment">//依次计算到达所有点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cities_num; i++)&#123;<br><span class="hljs-comment">//遍历之前的所有点，计算到达该点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br><span class="hljs-keyword">if</span>(topography.edges[j][i] != <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//若路径存在 </span><br>a_cost =  min_cost[j] + topography.edges[j][i];<br><span class="hljs-keyword">if</span>(a_cost &lt; min_cost[i])&#123;    <span class="hljs-comment">//更新最短路径长 </span><br>min_cost[i] = a_cost;<br>path[i] = j;    <span class="hljs-comment">//记录前驱顶点 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出到所有顶点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cities_num; i++)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;到顶点&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的最小开销为：&quot;</span> &lt;&lt; min_cost[i] &lt;&lt; <span class="hljs-string">&quot;，路径：&quot;</span> &lt;&lt; i;<br>pre = i;<br><span class="hljs-keyword">while</span>(path[pre])&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;-&quot;</span> &lt;&lt; path[pre];<br>pre = path[pre];<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试样例">测试样例</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082352054.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><h4 id="输入数据">输入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span><br><span class="hljs-number">18</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span><br><span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">7</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="输出数据">输出数据</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091132283.png"alt="image-20231109113255170" /><figcaption aria-hidden="true">image-20231109113255170</figcaption></figure><h3 id="算法分析">算法分析</h3><p>算法的时间复杂度主要由两部分组成：</p><p>第一部分是依次计算从源点到各个顶点的最短路径长度，由两层嵌套的循环组成，外层循环执行n-1次，内层循环对所有入边进行计算，并且在所有循环中，每条入边只计算一次。假定图的边数为m，则时间性能是 O(m)。</p><p>第二部分是输出最短路径经过的顶点，设多段图划分为 k 段，其时间性能是O(k)。</p><p>综上所述，<strong>时间复杂度为 O(m+k)</strong>。</p><blockquote><p>参考:</p><p><ahref="https://www.cnblogs.com/linfangnan/p/14059868.html#3295747898">动态规划法解多段图最短路径问题- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><ahref="https://developer.aliyun.com/article/1047074">【动态规划】多段图最短路径（动图演示）-阿里云开发者社区(aliyun.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-排序</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://blog.csdn.net/weixin_43586713/article/details/119820797?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=快速排序&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-119820797.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">快速排序(详细讲解)-CSDN博客</a></p><p><ahref="https://blog.csdn.net/justidle/article/details/104203958?ops_request_misc=%7B%22request%5Fid%22%3A%22169518266216800185894255%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169518266216800185894255&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104203958-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=归并排序&amp;spm=1018.2226.3001.4187">排序——归并排序（Mergesort)-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习记录</title>
    <link href="/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-数据类型">C 数据类型</h2><p><em>C 中的类型可分为以下几种：</em></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100932882.png"alt="image-20231110092838613" /><figcaption aria-hidden="true">image-20231110092838613</figcaption></figure><h3 id="整数类型">整数类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100937438.png"alt="image-20231110093736344" /><figcaption aria-hidden="true">image-20231110093736344</figcaption></figure><blockquote><p><em>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</em></p></blockquote><h3 id="浮点类型">浮点类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100938962.png"alt="image-20231110093854912" /><figcaption aria-hidden="true">image-20231110093854912</figcaption></figure><h3 id="void类型">void类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100939141.png"alt="image-20231110093933055" /><figcaption aria-hidden="true">image-20231110093933055</figcaption></figure><h2 id="c-变量">C 变量</h2><p>基本类型：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100940065.png"alt="image-20231110094029970" /><figcaption aria-hidden="true">image-20231110094029970</figcaption></figure><p>1.注意，赋值表达式有返回值，等于等号右边的值</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>y <span class="hljs-operator">=</span> (<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>//变量 y 的值就是赋值表达式（ <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span> ）的返回值 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>2.头文件 stdbool.h 定义了另一个类型别名 bool ，并且定义了 true 代表 1、 false 代表 0 。只要加载 这个头文件，就可以使用这几个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//加载头文件 stdbool.h 以后，就可以使用 bool 定义布尔值类型，以及 false 和 true 表示真伪。</span><br></code></pre></td></tr></table></figure><h2 id="c-数组">C 数组</h2><h3 id="数组的地址">数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p;<br>p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);   <span class="hljs-comment">//11</span><br><br><span class="hljs-comment">//&amp;a[0] 就是数组 a 的首个成员 11 的内存地址，也是整个数组的起始地址。反过来，从这个地址（ *p ），可以获得首个成员的值 11</span><br><br></code></pre></td></tr></table></figure><p>由于数组的起始地址是常用操作， <code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（ <code>array[0]</code>）的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span>* p = a;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>&amp;a[0]</code> 和数组名 <code>a</code>是等价的。</p><p>这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p><p>函数接受数组作为参数，函数原型可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-comment">// 写法二</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span>;<br><br></code></pre></td></tr></table></figure><p>上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号<code>[]</code> 与指针符号 <code>*</code> 是可以互换的。下一个例子是通过数组指针对成员求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 假定数组有 10 个成员</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    total += arr[i];<br> &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-comment">//示例中，传入函数的是一个指针 arr （也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。</span><br></code></pre></td></tr></table></figure><p><code>*</code> 和 <code>&amp;</code> 运算符也可以用于多维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 取出 a[0][0] 的值</span><br>*(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 等同于</span><br>**a<br></code></pre></td></tr></table></figure><p>上面示例中，由于 <code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员 <code>a[0][0]</code> 。所以，<code>*(a[0])</code> 取 出的是 <code>a[0][0]</code> 的值。至于<code>**a</code> ，就是对 <code>a</code> 进行两次 <code>*</code>运算，第一次取出的是 <code>a[0]</code> ，第二次取出的是<code>a[0][0]</code> 。同理，二维数组的 <code>&amp;a[0][0]</code> 等同于<code>*a</code> 。</p><blockquote><p>不能将一个数组名赋值给另外一个数组名。</p></blockquote><h3 id="数组指针的加减法">数组指针的加减法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *(a + i));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，通过指针的移动遍历数组， <code>a + i</code>的每轮循环每次都会指向下一个成员的地址， <code>*(a +  i)</code>取出该地址的值，等同于 <code>a[i]</code> 。对于数组的第一个成员，<code>*(a + 0)</code> （即 <code>*a</code> ）等同于 <code>a[0]</code>。</p><p>由于数组名与指针是等价的，所以下面的等式总是成立。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[b]</span> == *(<span class="hljs-selector-tag">a</span> + b)<br></code></pre></td></tr></table></figure><p>上面代码给出了数组成员的两种访问方式，一种是使用方括号<code>a[b]</code> ，另一种是使用指针 <code>*(a + b)</code> 。</p><p>如果指针变量 <code>p</code> 指向数组的一个成员，那么 <code>p++</code>就相当于指向下一个成员，这种方法常用来遍历数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">999</span>&#125;;<br><span class="hljs-type">int</span>* p = a;<br><span class="hljs-keyword">while</span> (*p != <span class="hljs-number">999</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<br>  p++;<br>&#125;<br><span class="hljs-comment">//示例中，通过 p++ 让变量 p 指向下一个成员。</span><br><span class="hljs-comment">//注意，数组名指向的地址是不能变的，所以例中，不能直接对 a 进行自增，即 a++ 的写法是错的，必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增</span><br></code></pre></td></tr></table></figure><p>同一个数组的两个成员的指针相减时，返回它们之间的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>* q = &amp;a[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p - q); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q - p); <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><h2 id="c-流程控制">C 流程控制</h2><p>break 命令只能跳出循环体和 switch 结构，不能跳出 if 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无效</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//示例中， break 语句是无效的，因为它不能跳出外层的 if 结构。</span><br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><h3 id="main">main()</h3><p>C 语言规定， <code>main()</code>是程序的入口函数，即所有的程序一定要包含一个 <code>main()</code>函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。</p><h3 id="函数指针">函数指针</h3><p>对于任意函数，都有五种调用函数的写法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br>print(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法二</span><br>(*print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法三</span><br>(&amp;print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法四</span><br>(*print_ptr)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法五</span><br>print_ptr(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//为了简洁易读，一般情况下，函数名前面都不加 * 和 &amp; 。</span><br></code></pre></td></tr></table></figure><h2 id="struct-结构">struct 结构</h2><p>C语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p><p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p><ul><li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li><li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li></ul><p>为了解决这些问题，C 语言提供了 <code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C语言没有其他语言的对象（object）和类（class）的概念，<code>struct</code>结构很大程度上提供了对象和类的功能。</p><p>下面是 struct 自定义数据类型的一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> &#123;</span><br>  <span class="hljs-type">int</span> numerator;<br>  <span class="hljs-type">int</span> denominator;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面示例定义了一个分数的数据类型 struct fraction ，包含两个属性numerator 和 denominator 。</p><p>注意，作为一个自定义的数据类型，它的类型名要包括 struct关键字，比如上例是 struct fraction ，单独的 fraction没有任何意义，另外， struct 语句结尾的分号不能省略</p><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> <span class="hljs-title">f1</span>;</span><br>f1.numerator = <span class="hljs-number">22</span>;<br>f1.denominator = <span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//这里先声明了一个 struct fraction 类型的变量 f1 ，这时编译器就会为 f1 分配内存，接着就可以为 f1 的不同属性赋值。struct 结构的属性通过点（ . ）来表示，比如 numerator 属性要写成 f1.numerator 。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">float</span> price;<br>  <span class="hljs-type">int</span> speed;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;<span class="hljs-string">&quot;Saturn SL/2&quot;</span>, <span class="hljs-number">16000.99</span>, <span class="hljs-number">175</span>&#125;<br><span class="hljs-comment">//大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;.speed=<span class="hljs-number">172</span>, .name=<span class="hljs-string">&quot;Saturn SL/2&quot;</span>&#125;;<br>saturn.speed = <span class="hljs-number">168</span>;<br></code></pre></td></tr></table></figure><p><code>struct</code>的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cell_phone</span> &#123;</span><br>  <span class="hljs-type">int</span> cell_no;<br>  <span class="hljs-type">float</span> minutes_of_charge;<br>&#125; phone;<br>phone p = &#123;<span class="hljs-number">5551234</span>, <span class="hljs-number">5</span>&#125;<br><br></code></pre></td></tr></table></figure><p>指针变量也可以指向 struct 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;* b1;<br><span class="hljs-comment">// 或者写成两个语句</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span>* <span class="hljs-title">b1</span>;</span><br><span class="hljs-comment">//变量 b1 是一个指针，指向的数据是 struct book 类型的实例。</span><br></code></pre></td></tr></table></figure><h3 id="struct-指针">struct 指针</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">char</span>* species;<br>  <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle t)</span> &#123;<br>  t.age = t.age + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> <span class="hljs-title">myTurtle</span> =</span> &#123;<span class="hljs-string">&quot;MyTurtle&quot;</span>, <span class="hljs-string">&quot;sea turtle&quot;</span>, <span class="hljs-number">99</span>&#125;;<br>  happy(myTurtle);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="hljs-comment">// 输出 99</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，函数 <code>happy()</code> 传入的是一个<code>struct</code> 变量 <code>myTurtle</code>，函数内部有一个自增操作。但是，执行完 <code>happy()</code>以后，函数外部的 <code>age</code>属性值根本没变。原因就是函数内部得到的是 <code>struct</code>变量的副本， 改变副本影响不到函数外部的原始数据</p><p>通常，希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将<code>struct</code> 变量的指针传入函数，通过指针来修改<code>struct</code> 属性，就可以影响到函数外部。</p><p><code>struct</code> 指针传入函数的写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>&#125;<br>happy(&amp;myTurtle);<br><span class="hljs-comment">//这里 t 是 struct 结构的指针，调用函数时传入的是指针</span><br><span class="hljs-comment">//struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成 &amp;myTurtle 。</span><br></code></pre></td></tr></table></figure><p>函数内部也必须使用 <code>(*t).age</code> 的写法，从指针拿到<code>struct</code> 结构本身：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br> (*t).age = (*t).age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>(*t).age</code> 不能写成 <code>*t.age</code>，因为点运算符 <code>.</code> 的优先级高于 <code>*</code> 。<code>*t.age</code> 这种写法会将 <code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p><p>现在，重新编译执行上面的整个示例， <code>happy()</code> 内部对<code>struct</code> 结构的操作，就会反映到函数外部。</p><p><code>(*t).age</code> 这样的写法很麻烦。C语言就引入了一个<strong>新的箭头运算符</strong><code>-&gt;</code>，可以从<code>struct</code> 指针上直接 获取属性，大大增强了代码的可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>  t-&gt;age = t-&gt;age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，对于 <code>struct</code> 变量名，使用点运算符<code>.</code>获取属性；对于 <code>struct</code> 变量指针，使用箭头运算符<code>-&gt;</code> 获取属性。</p><p>以变量 <code>myStruct</code> 为例，假设 <code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ptr == &amp;myStruct</span><br>myStruct.prop == (*ptr).prop == ptr-&gt;prop<br></code></pre></td></tr></table></figure><h2 id="指针">指针</h2><h3 id="简介">简介</h3><p>指针是什么？首先，它是一个值，这个值代表一个内存地址，因此指针相当于指向某个内存地址的路标。</p><p>字符 <code>*</code>表示指针，通常跟在类型关键字的后面，表示指针指向的是什么类型的值。比如，<code>char*</code> 表示一 个指向字符的指针， <code>float*</code>表示一个指向 <code>float</code> 类型的值的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* intPtr;<br><span class="hljs-comment">//上面示例声明了一个变量 intPtr ，它是一个指针，指向的内存地址存放的是一个整数。</span><br></code></pre></td></tr></table></figure><p>星号 *可以放在变量名与类型关键字之间的任何地方，下面的写法都是有效的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>   *intPtr;<br><span class="hljs-type">int</span> * intPtr;<br><span class="hljs-type">int</span>*  intPtr;<br></code></pre></td></tr></table></figure><p>&amp; 运算符与 * 运算符互为逆运算，下面的表达式总是成立。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">if</span> (i == *(&amp;i)) <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><h3 id="指针变量的初始化">指针变量的初始化</h3><p>声明指针变量之后，编译器会为指针变量本身分配一个内存空间，但是这个内存空间里面的值是随机的，也就是说，指针变量指向的值是随机的。这时一定不能去读写指针变量指向的地址，因为那个地址是随机地址，很可能会导致严重后果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int* p<span class="hljs-comment">;</span><br>*p <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">; // 错误</span><br></code></pre></td></tr></table></figure><p>上面的代码是错的，因为 p指向的那个地址是随机的，向这个随机地址里面写入 1 ，会导致意想不到的结果。正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">int</span>* p<span class="hljs-comment">;</span><br><span class="hljs-keyword">int</span> i<span class="hljs-comment">;</span><br>p = &amp;i<span class="hljs-comment">;</span><br><span class="hljs-symbol">*p</span> = <span class="hljs-number">13</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>上面示例中， p 是指针变量，声明这个变量后， p会指向一个随机的内存地址。这时要将它指向一个已经分配好的内存地址，上例就是再声明一个整数变量 i ，编译器会为 i分配内存地址，然后让 p 指向 i 的内存地址（ <code>p = &amp;i;</code>）。完成初始化之后，就可以对 p 指向的内存地址进行赋值了（<code>*p = 13;</code> ）。</p><h2 id="typedef-命令">typedef 命令</h2><p><code>typedef</code> 命令用来为某个类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> type name;<br><span class="hljs-comment">//上面代码中， type 代表类型名，name 代表别名。</span><br></code></pre></td></tr></table></figure><p>比如下面的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INTEGER;<br>INTEGER a, b;<br>a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p><code>INTEGER a, b;</code>等效于<code>int a, b;</code>。</p><p><code>typedef</code> 可以一次指定多个别名</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">typedef</span> <span class="hljs-built_in">int</span> antelope, bagel, mushroom;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 可以为指针起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span>* intptr;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>intptr x = &amp;a;<br><span class="hljs-comment">//上面示例中， intptr 是 int* 的别名。不过，使用的时候要小心，这样不容易看出来，变量 x 是一个指针类型。</span><br></code></pre></td></tr></table></figure><p><code>typedef</code> 为<strong>结构体</strong>类型定义别名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">stu</span>&#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-type">char</span> sex;<br>&#125; STU;<br></code></pre></td></tr></table></figure><p>STU 是 struct stu 的别名，可以用 STU 定义结构体变量：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">STU</span> body1,body2;<br></code></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">stu</span> body1, body2;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 也可以用来为数组类型起别名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> five_ints[<span class="hljs-number">5</span>];<br>five_ints x = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br></code></pre></td></tr></table></figure><p><code>typedef</code> 为函数起别名的写法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">signed</span> <span class="hljs-title function_">char</span> <span class="hljs-params">(*fp)</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br><span class="hljs-comment">//上面示例中，类型别名 fp 是一个指针，代表函数 signed char (*)(void) 。</span><br></code></pre></td></tr></table></figure><h3 id="主要好处">主要好处</h3><p>（1）更好的代码可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span>* STRING;<br>STRING name;<br><span class="hljs-comment">//上面示例为字符指针起别名为 STRING ，以后使用 STRING 声明变量时，就可以轻易辨别该变量是字符串。</span><br></code></pre></td></tr></table></figure><p>（2）为 struct、union、enum等命令定义的复杂数据结构创建别名，从而便于引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treenode</span>* <span class="hljs-title">Tree</span>;</span><br><span class="hljs-comment">//上面示例中， Tree 为 struct treenode* 的别名。</span><br></code></pre></td></tr></table></figure><p><code>typedef</code> 也可以与 <code>struct</code>定义数据类型的命令写在一起</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">animal</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">int</span> leg_count, speed;<br>&#125; animal;<br><span class="hljs-comment">//上面示例中，自定义数据类型时，同时使用 typedef 命令，为 struct animal 起了一个别名 animal 。</span><br></code></pre></td></tr></table></figure><p>这种情况下，C 语言允许省略 struct 命令后面的类型名。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>  <span class="hljs-type">char</span> *name;<br>  <span class="hljs-type">int</span> leg_count, speed;<br>&#125; animal;<br><span class="hljs-comment">//上面示例相当于为一个匿名的数据类型起了别名 animal 。</span><br></code></pre></td></tr></table></figure><p>（3）typedef 方便以后为变量改类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">float</span> app_float;<br>app_float f1, f2, f3;<br></code></pre></td></tr></table></figure><p>上面示例中，变量 f1 、 f2 、 f3 的类型都是 <code>float</code>。如果以后需要为它们改类型，只需要修改 <code>typedef</code>语句即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">double</span> app_float;<br></code></pre></td></tr></table></figure><p>上面命令将变量 f1 、 f2 、 f3 的类型都改为 <code>long double</code>。</p><h2 id="typedef-和-define-的区别">typedef 和 #define 的区别</h2><p>typedef 在表现上有时候类似于#define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。</p><ol type="1"><li>可以使用其他类型说明符对宏类型名进行扩展，但对 typedef所定义的类型名却不能这样做。如下所示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERGE int</span><br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//没问题</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INTERGE;<br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//错误，不能在 INTERGE 前面添加 unsigned</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在连续定义几个变量的时候，typedef能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTR_INT int *</span><br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>经过宏替换以后，第二行变为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span> *<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int类型。</p><p>相反，在下面的代码中：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p><h2 id="其他">其他</h2><p>如果在<code>int</code>型变量的声明中为变量赋应该实数值的初始值（如3.14或5.7等）会怎么样？</p><ul><li>会直接舍去小数部分，只保留整数部分</li></ul><p>单目运算符&amp;（取值运算符）</p><ul><li>&amp;a，取得a的地址（生产指向a的指针）</li></ul><p>单目运算符*（指针运算符）</p><ul><li>*a，a指向的对象</li></ul><p>赋值表达式的左操作数不可以是数组名。</p><p><code>p</code>指向<code>x</code>时，<code>*p</code>是<code>x</code>的别名</p><p>指针<code>p</code>指向数组中的元素<code>e</code>时</p><ul><li><code>p + i</code>为指向元素<code>e</code>后第<code>i</code>个元素的指针</li><li><code>p - i</code>为指向元素<code>e</code>前第<code>i</code>个元素的指针</li><li>指向元素<code>e</code>后第<code>i</code>个元素的<code>*(p + i)</code>，可以写为<code>p[i]</code></li><li>指向元素<code>e</code>前第<code>i</code>个元素的<code>*(p - i)</code>，可以写为<code>p[-i]</code></li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142303857.png"alt="image-20230917142303857" /><figcaption aria-hidden="true">image-20230917142303857</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142327597.png"alt="image-20230917142327597" /><figcaption aria-hidden="true">image-20230917142327597</figcaption></figure><p><code>c</code>语言编译阶段出现如下的问题：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgc00e0930273a652d2e9d0d0b218eb41.png"alt="c00e0930273a652d2e9d0d0b218eb41" /><figcaptionaria-hidden="true">c00e0930273a652d2e9d0d0b218eb41</figcaption></figure><p>可以检查一下是不是有正在运行的端口没关闭！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（二）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>2023.09.14-</p><p>2023.10.27,重拾,感觉还是要跟着兴趣走吧😥😭😭😭😭😭😭😭</p><p>2023.11.14 😢</p><h2 id="rsa21小明文攻击">[RSA2]1(小明文攻击)</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">5120</span>)<br>q = getPrime(<span class="hljs-number">5120</span>)<br><br>n = p*q<br>e = <span class="hljs-number">97</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br><span class="hljs-string">e = 97</span><br><span class="hljs-string">c = 79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>小明文攻击</strong></label></li></ul><p><strong>加密指数指的是e，e一般取65535，但当e很小时，可直接解密</strong></p><p>这里<strong>$ m^{e} &lt; c$</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br>e = <span class="hljs-number">97</span><br>c = <span class="hljs-number">79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">97</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><br></code></pre></td></tr></table></figure><p>也能用 <strong>[RSA2]P2</strong>的方法，可以得到k是等于0的，也验证了$ m^{e}= c$,也就是在取模的过程中没有丢失任何信息，我们可以直接开方从而获得m</p><h2 id="rsa22低加密指数攻击">[RSA2]2(低加密指数攻击)</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = <span class="hljs-number">3</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br><span class="hljs-string">e = 3</span><br><span class="hljs-string">c = 90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>低加密指数攻击</strong></label></li></ul><p>yafu和<ahref="http://factordb.com/">factordb.com</a>都没分解成功，<strong>这里的n也不大，怎么就没成功呢🙄</strong></p><p>那只能看看原理了</p><p>直接使用上题的方式开方并不行，则说明$ m^{e}&gt; c$，不能直接开方。</p><p>我们考虑原理： <span class="math display">\[c \equiv m^{e} (mod\quad n)\]</span> 消去取模，有： <span class="math display">\[m^{e} = c + k\cdot n\]</span> 因为本题中加密指数e很小，我们可以考虑<spanclass="math inline">\(m^{e}\)</span>的值并不是特别大，则我们可以通过遍历<code>k</code>的方式将取模后丢失的信息找回来，</p><p>遍历到何时停止呢？当<span class="math inline">\(c + k\cdotn\)</span>是一个完全e次方数时，则说明我们得到了正确的答案，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>n = <span class="hljs-number">111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br>e = <span class="hljs-number">3</span><br>c = <span class="hljs-number">90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>    cc = c + k*n<br>    res = iroot(cc, e)<br>    <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]:             <span class="hljs-comment">#如果第二个参数返回的是true，则m等于第一个参数</span><br>        m = res[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;k:&#x27;</span>,k)                <span class="hljs-comment"># k=11</span><br></code></pre></td></tr></table></figure><h2 id="rsa23rabin">[RSA2]3(Rabin)</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br><span class="hljs-keyword">assert</span> p%<span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q%<span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br>n = p*q<br>e = <span class="hljs-number">2</span><br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br><span class="hljs-string">q = 91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br><span class="hljs-string">e = 2</span><br><span class="hljs-string">c = 5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><ul class="task-list"><li><label><input type="checkbox" checked="" /><strong>RSA衍生算法——Rabin算法</strong></label></li></ul><blockquote><p><ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/#rsa-rabin">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></p><p>Rabin 算法的特征在于 <span class="math inline">\(e=2\)</span>。</p></blockquote><p>和上题一样，本题e非常小，有<spanclass="math inline">\(e=2\)</span>，但我们会发现c不是一个完全平方数，则说明不能用低加密指数攻击的方法解决。</p><p>同时我们也发现本题e和phi不互素，他们都是偶数，所以我们也得不到RSA的私钥。实际上，除了RSA算法外，还有很多的非对称加密方案，例如在本题中实际上使用了Rabin算法进行加密，只是它类似于RSA，故在CTF中我们将其划分到RSA攻击范畴中，在后续学习中我们还会遇到很对实际并不是RSA但类似RSA的加密算法。</p><p><strong>1.加密</strong></p><ol type="1"><li>取两个大素数p，q，满足<span class="math inline">\(p≡q≡3\ mod\4\)</span>，即这两个素数形式为4k+3，计算<spanclass="math inline">\(n=pq\)</span></li><li><span class="math inline">\(C=m^2\ mod\ n\)</span></li><li>n作公钥，p，q作私钥</li></ol><p><strong>2.解密</strong></p><p>求m，<span class="math inline">\(m^2≡c(mod\ n)\)</span></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Xenny的轮子</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br>q = <span class="hljs-number">91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br>e = <span class="hljs-number">2</span><br>c = <span class="hljs-number">5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rabin_attack</span>(<span class="hljs-params">c, n, p, q</span>):<br>    c1 = powmod(c, (p+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, p)<br>    c2 = powmod(c, (q+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, q)<br>    cp1 = p - c1<br>    cp2 = q - c2<br><br>    t1 = invert(p, q)<br>    t2 = invert(q, p)<br><br>    m1 = (q*c1*t2 + p*c2*t1) % n<br>    m2 = (q*c1*t2 + p*cp2*t1) % n<br>    m3 = (q*cp1*t2 + p*c2*t1) % n<br>    m4 = (q*cp1*t2 + p*cp2*t1) % n<br><br>    <span class="hljs-keyword">return</span> m1, m2, m3, m4<br><br>ms = rabin_attack(c, p*q, p, q)<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ms:<br>    <span class="hljs-built_in">print</span>(long_to_bytes(m))    <span class="hljs-comment"># 四个只有一个是</span><br></code></pre></td></tr></table></figure><h2 id="rsa24wiener">[RSA2]4(Wiener)</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>d = getPrime(<span class="hljs-number">128</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br><span class="hljs-string">e = 3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br><span class="hljs-string">c = 1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp1">exp1</h3><ul class="task-list"><li><label><inputtype="checkbox" /><strong>Wiener攻击</strong></label></li></ul><p><strong>已知（e，n，c），求m。d很小且e很大，可知是低解密指数攻击（Wiener攻击）。</strong></p><p><strong>这里相当于是反过来了，先生成了d，再由d去求e</strong>，当我们发现<strong>e很大或者说很接近n</strong>时，便可以考虑使用连分数展开的方式，遍历每一个系数，测试是否是解题中需要用到的关键因子，</p><p><ahref="https://blog.csdn.net/XiongSiqi_blog/article/details/130515028">RSA--维纳攻击--代码和题目分析_维纳攻击脚本_Emmaaaaaaaaaa的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny的轮子</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br> <br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure><h3 id="exp2">exp2</h3><ul class="task-list"><li><label><input type="checkbox" />用原理写的，还没理解</label></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinuedFraction</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        self.numberlist = []  <span class="hljs-comment"># number in continued fraction</span><br>        self.fractionlist = []  <span class="hljs-comment"># the near fraction list</span><br>        self.GenerateNumberList(numerator, denumerator)<br>        self.GenerateFractionList()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateNumberList</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        <span class="hljs-keyword">while</span> numerator != <span class="hljs-number">1</span>:<br>            quotient = numerator // denumerator<br>            remainder = numerator % denumerator<br>            self.numberlist.append(quotient)<br>            numerator = denumerator<br>            denumerator = remainder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateFractionList</span>(<span class="hljs-params">self</span>):<br>        self.fractionlist.append([self.numberlist[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(self.numberlist)):<br>            numerator = self.numberlist[i]<br>            denumerator = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                temp = numerator<br>                numerator = denumerator + numerator * self.numberlist[i - j - <span class="hljs-number">1</span>]<br>                denumerator = temp<br>            self.fractionlist.append([numerator, denumerator])<br><br><br>a = ContinuedFraction(e, n)<br><span class="hljs-keyword">for</span> k, d <span class="hljs-keyword">in</span> a.fractionlist:<br>    m = powmod(c, d, n)<br>    flag = long_to_bytes(m)<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="rsa25低加密指数广播攻击">[RSA2]5(低加密指数广播攻击)</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br>flag = os.getenv(<span class="hljs-string">&#x27;FLAG&#x27;</span>)<br>m = bytes_to_long(flag.encode())<br>e = <span class="hljs-number">127</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>():<br>    p = getPrime(<span class="hljs-number">512</span>)<br>    q = getPrime(<span class="hljs-number">512</span>)<br>    n = p*q<br>    c = <span class="hljs-built_in">pow</span>(m, e, n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c: <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        opt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input&gt; &#x27;</span>))<br>        <span class="hljs-keyword">if</span> opt == <span class="hljs-number">1</span>:<br>            enc()<br><br>main()<br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><p>1、低加密指数</p><p>​所谓<strong>低加密指数</strong>，指的是RSA加密过程中使用的参数e的值很小，这样往往会产生安全隐患，导致低加密指数攻击的发生。</p><p>2、广播、</p><p>​所谓<strong>广播</strong>，就是发送方将一份明文进行多份加密，但是每份使用不同的密钥，即密钥中的模数n不同，但是指数e相同且很小，因此我们只要得到多份密文和对应的模数n就可以利用中国剩余定理进行解密。</p><p>3、低加密指数广播攻击</p><p> 实现<strong>低加密指数广播攻击</strong>需要满足以下三个条件：</p><p>（1）加密指数e非常小。</p><p>（2）同一份明文使用不同的模数n，相同的加密指数e进行多次加密。</p><p>（3）攻击者可以得到每一份加密后的密文和对应的模数n、加密指数e。</p><hr /><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310271642498.png"alt="image-20231027164245430" /><figcaption aria-hidden="true">image-20231027164245430</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Xenny师傅wp，还在学，主要这个是交互的</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crt</span>(<span class="hljs-params">n_list, c_list</span>):  <span class="hljs-comment">#中国剩余定理（CRT）</span><br>    n = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> n_list:<br>        n *= i<br>    N = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> n_list:<br>        N.append(n // i)  <span class="hljs-comment">#计算每个模数对应的 N 值，即将总乘积除以当前模数。</span><br>    t = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n_list)):<br>        t.append(invert(N[i], n_list[i]))   <span class="hljs-comment">#使用invert函数计算每个模数对应的模反元素，并将其添加到列表 t 中。</span><br><br>    summary = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(n_list)):<br>        <span class="hljs-comment">#使用CRT的公式计算解密结果，遍历每个模数，将其密文与相应的权重相乘，然后取模，最后累加到 summary 中。</span><br>        summary = (summary + c_list[i] * t[i] * N[i]) % n<br>    <span class="hljs-keyword">return</span> summary<br><br><br>io = remote(<span class="hljs-string">&#x27;node4.anna.nssctf.cn&#x27;</span>, <span class="hljs-number">28522</span>)<br>e = <span class="hljs-number">127</span><br>n_list = []<br>c_list = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">127</span>):<br>    io.sendlineafter(<span class="hljs-string">b&#x27;input&gt; &#x27;</span>, <span class="hljs-string">b&#x27;1&#x27;</span>)  <span class="hljs-comment"># 等待收到input&gt; 后发送1</span><br>    n = <span class="hljs-built_in">int</span>(io.recvline().decode()[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 接收一行数据 即 n: xxxx</span><br>    c = <span class="hljs-built_in">int</span>(io.recvline().decode()[<span class="hljs-number">2</span>:])  <span class="hljs-comment"># 接收一行数据 即 c: xxxx</span><br>    n_list.append(n)<br>    c_list.append(c)<br><br>M = crt(n_list, c_list)<br>m = iroot(M, e)[<span class="hljs-number">0</span>]<br>flag = long_to_bytes(m)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><blockquote><p>你是真的难啊，我的哥埃，配置b WSL 2环境给我折腾废了</p><p>其实就是你安装好之后直接去 pycharm里面操作就可以了，有没有的包就安装，安装不成就换源</p><p>比如我安的时候第一次就失败了，然后换源解决：<code>pip install -i https://pypi.doubanio.com/simple/ pycryptodome</code></p><p>注意：</p><p>在 Linux（如你当前的 Bash 终端）中，路径分隔符是斜杠 <code>/</code>而不是反斜杠 <code>\</code>。如果你想切换到<code>D:\code\python\python3.8\Xenny_RSA2\[RSA2]P5</code>目录，你需要使用正斜杠，并且可能需要对特殊字符进行转义。</p><p>尝试使用以下命令：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/mnt/</span>d<span class="hljs-regexp">/code/</span>python<span class="hljs-regexp">/python3.8/</span>Xenny_RSA2/[RSA2]P5<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311142341052.png"alt="image-20231114234103995" /><figcaption aria-hidden="true">image-20231114234103995</figcaption></figure></blockquote><h2 id="rsa26p-1光滑">[RSA2]6(p-1光滑)</h2><h3 id="main-5">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMyPrime</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p.bit_length() &lt;= nbits:<br>            p *= choice(sieve_base)<br>        <br>        <span class="hljs-keyword">if</span> isPrime(p+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span><br><br>p = getMyPrime(<span class="hljs-number">256</span>)<br>q = getMyPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><blockquote><p>光滑数 (Smooth number)：指可以分解为小素数乘积的正整数</p><p>当p是N的因数，并且p−1是光滑数，可以考虑使用<code>Pollard's p-1</code>算法来分解N</p></blockquote><p>这篇文章讲的挺清晰的：</p><p><ahref="https://blog.csdn.net/qq_42667481/article/details/106729900">【大数分解】Pollard‘sp-1 method_大数分解程序-CSDN博客</a></p><p>其实就是计算<spanclass="math inline">\(gcd(a^{B!}-1,n)\)</span>是否存在，并且结果不为1也不为n，那么存在的那个值就是p</p><p>然后对于<spanclass="math inline">\(a^{B!}\)</span>，我们选取a=2，然后B!我们也从2开始累乘，</p><p>这里结合模的性质：<span class="math inline">\(a^{(x+1) !}\equiv\left(a^{x !} \bmod n\right)^{x+1} \quad(\bmodn)\)</span>，就能写出代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618</span><br><br>a = <span class="hljs-number">2</span><br>m = <span class="hljs-number">2</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    a = powmod(a, m, n)<br>    p = gcd(a-<span class="hljs-number">1</span>, n)<br>    <span class="hljs-keyword">if</span> p != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> p != n:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;p=&quot;</span>,p)<br>        <span class="hljs-keyword">break</span><br>    m += <span class="hljs-number">1</span><br><br>q = n // p<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;q=&quot;</span>,q)<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa27p1光滑">[RSA2]7(p+1光滑)</h2><h3 id="main-6">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMyPrime</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p.bit_length() &lt;= nbits:<br>            p *= choice(sieve_base)<br><br>        <span class="hljs-keyword">if</span> isPrime(p - <span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> p - <span class="hljs-number">1</span><br><br><br>p = getMyPrime(<span class="hljs-number">256</span>)<br>q = getMyPrime(<span class="hljs-number">256</span>)<br><br>n = p * q<br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-5">exp</h3><blockquote><p>当p是N的因数，并且p+1是光滑数，可以考虑使用<code>Williams's p+1</code>算法来分解N</p></blockquote><p>不行，这玩意的原理有些过于复杂了，咱就先略过，当个脚本小子先，有时间再回来看吧😢</p><p><a href="https://www.nssctf.cn/note/set/6">文章列表 | NSSCTF</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># from sage.all_cmdline import *</span><br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> williams_pp1<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> invert, powmod<br><br><span class="hljs-comment"># p+1光滑</span><br>n = <span class="hljs-number">63398538193562720708999492397588489035970399414238113344990243900620729661046648078623873637152448697806039260616826648343172207246183989202073562200879290937</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">26971181342240802276810747395669930355754928952080329914687241779532014305320191048439959934699795162709365987652696472998140484810728817991804469778237933925</span><br><br>p, q = williams_pp1.attack(n, <span class="hljs-number">55</span>)<br>phi = (p - <span class="hljs-number">1</span>) * (q - <span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br>flag = long_to_bytes(m)<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><p>这个代码在WSL 2Ubuntu运行成功了，但在windows运行错误，不知道为什么</p><h2 id="rsa28共模攻击">[RSA2]8(共模攻击)</h2><h3 id="main-7">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e1 = getPrime(<span class="hljs-number">16</span>)<br>e2 = getPrime(<span class="hljs-number">16</span>)<br><br>m = bytes_to_long(flag)<br><br>c1 = <span class="hljs-built_in">pow</span>(m, e1, n)<br>c2 = <span class="hljs-built_in">pow</span>(m, e2, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e1 = <span class="hljs-subst">&#123;e1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e2 = <span class="hljs-subst">&#123;e2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571</span><br><span class="hljs-string">e1 = 38317</span><br><span class="hljs-string">e2 = 63409</span><br><span class="hljs-string">c1 = 42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622</span><br><span class="hljs-string">c2 = 50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-6">exp</h3><p><strong>已知（n，e1，e2，c1，c2），求m。</strong></p><blockquote><p>当两个用户使用相同的模数N、不同的私钥时，加密同一明文消息时即存在共模攻击。</p><p>本题使用两组公钥对同一消息进行加密，经过观察我们可以发现这两种公钥的n是同一个n，也就是说模数相同，那么此时我们便可以使用共模攻击进行解密。</p></blockquote><p><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151558469.png" /></p><p>扩展欧几里得算法（在<code>gmpy2</code>中的<code>gcdext</code>）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151605501.png"alt="image-20231115160526421" /><figcaption aria-hidden="true">image-20231115160526421</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">120294155186626082670474649118722298040433501930335450479777638508444129059776534554344361441717048531505985491664356283524886091709370969857047470362547600390987665105196367975719516115980157839088766927450099353377496192206005171597109864609567336679138620134544004766539483664270351472198486955623315909571</span><br>e1 = <span class="hljs-number">38317</span><br>e2 = <span class="hljs-number">63409</span><br>c1 = <span class="hljs-number">42703138696187395030337205860503270214353151588149506110731264952595193757235229215067638858431493587093612397165407221394174690263691095324298012134779703041752810028935711214038835584823385108771901216441784673199846041109074467177891680923593206326788523158180637665813642688824593788192044139055552031622</span><br>c2 = <span class="hljs-number">50460092786111470408945316270086812807230253234809303694007902628924057713984397041141665125615735752600114964852157684904429928771531639899496987905067366415806771003121954852465731110629459725994454904159277228514337278105207721011579794604761255522391446534458815389983562890631994726687526070228315925638</span><br><br><span class="hljs-built_in">print</span>(gcd(e1,e2))  <span class="hljs-comment"># 1</span><br>_,r,s = gcdext(e1,e2)       <span class="hljs-comment"># 扩展欧几里得算法求出r,s的值，满足e1*r + e2*s = 1</span><br>m = <span class="hljs-built_in">pow</span>(c1,r,n) * <span class="hljs-built_in">pow</span>(c2,s,n) % n   <span class="hljs-comment">#这个算式最后的结果就是m</span><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa29dpdq泄漏攻击">[RSA2]9(dp&amp;dq泄漏攻击)</h2><h3 id="main-8">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = getPrime(<span class="hljs-number">128</span>)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br>dq = d % (q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dq = <span class="hljs-subst">&#123;dq&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 13070310882303377463944295715444821218324151935347454554272870042925400761984585838979931730897626589859098834802923539617244712852188293321626061072925723</span><br><span class="hljs-string">q = 10411551818233737389114520103233235272671271111546186997024935593000298916988792710521511848414549553426943998093077337023514210631662189798921671306236009</span><br><span class="hljs-string">c = 62492280219693914005334023569480350249964827909276875032578276064973191654731196407886841145547165693859745313398152742796887457192397932684370631253099255490064673499746314452067588181106154875239985334051909867580794242253066085627399488604907196244465911471895118443199543361883148941963668551684228132814</span><br><span class="hljs-string">dp = 11568639544706374912496682299967972464196129347160700749666263275305083977187758414725188926013198988871173614336707804756059951725809300386252339177953017</span><br><span class="hljs-string">dq = 3455040841431633020487528316853620383411361966784138992524801280785753201070735373348570840039176552952269927122259706586236960440300255065994052962742469</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-7">exp</h3><p><strong>已知（p，q，c，dp，dq，e），求m。</strong></p><p>时刻记住：</p><p><span class="math display">\[\begin{align}Enc（pk，m∈Z_N^*）:c = m^e\ mod \ N\\Dec（sk，c）： m = c^d\ mod\ N\end{align}\]</span> 这里不知道e，那我们看它要怎么求</p><p>已知：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151626021.png"alt="image-20231115162626957" /><figcaption aria-hidden="true">image-20231115162626957</figcaption></figure><p>解密：</p><p><span class="math inline">\(m \equiv c^d(\bmod n) \equiv c^d(\bmod p* q)=k * p * q+c^d\)</span></p><p>分别模p和模q，得到：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311151628906.png"alt="image-20231115162805814" /><figcaption aria-hidden="true">image-20231115162805814</figcaption></figure><blockquote><p>公式中的k1就是表示一个整数，不要多想，因为k1*p之后再modp就没了，只能说整个式子的推导很巧妙~</p></blockquote><p>到这里，m就已经解出来了，这是其中的一种方法，其实非常的简单：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">13070310882303377463944295715444821218324151935347454554272870042925400761984585838979931730897626589859098834802923539617244712852188293321626061072925723</span><br>q = <span class="hljs-number">10411551818233737389114520103233235272671271111546186997024935593000298916988792710521511848414549553426943998093077337023514210631662189798921671306236009</span><br>c = <span class="hljs-number">62492280219693914005334023569480350249964827909276875032578276064973191654731196407886841145547165693859745313398152742796887457192397932684370631253099255490064673499746314452067588181106154875239985334051909867580794242253066085627399488604907196244465911471895118443199543361883148941963668551684228132814</span><br>dp = <span class="hljs-number">11568639544706374912496682299967972464196129347160700749666263275305083977187758414725188926013198988871173614336707804756059951725809300386252339177953017</span><br>dq = <span class="hljs-number">3455040841431633020487528316853620383411361966784138992524801280785753201070735373348570840039176552952269927122259706586236960440300255065994052962742469</span><br><br>mp = gmpy2.powmod(c, dp, p)<br>mq = gmpy2.powmod(c, dq, q)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(mp))<br><span class="hljs-built_in">print</span>(long_to_bytes(mq)) <span class="hljs-comment">#两个值一样</span><br></code></pre></td></tr></table></figure><h2 id="rsa210dp泄漏攻击">[RSA2]10(dp泄漏攻击)</h2><h3 id="main-9">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">100</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br><span class="hljs-string">c = 70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br><span class="hljs-string">dp = 3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-8">exp</h3><p><strong>已知（n，c，dp，e），求m。</strong></p><p>本题我们又有e了，但是却失去了了一个dq，怎么解决呢？不知道，上网搜一下吧i😭</p><p><span class="math display">\[\begin{align}&amp;∵dp≡d\mod(p-1)，∴e*dp≡e*d\mod(p-1)，∴e*dp=k_1(p-1)+e*d\\&amp;又∵ed≡1\mod(p-1)(q-1)，∴ed=k_2(p-1)(q-1)+1\\&amp;第二行代入第一行：\\&amp;e*dp=k_1(p-1)+k_2(p-1)(q-1)+1\\&amp;=(p-1)(k_1+k_2(q-1))+1\\&amp;∵dp&lt;p-1\\&amp;∴e＞(k_1+k_2(q-1))\\&amp;即(k_1+k_2(q-1))∈(1,e)\\&amp;令x=k_1+k_2(q-1)，用x遍历(1,e)即可求出p\\&amp;然后q=n//q\\\end{align}\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> libnum<br><br>n = <span class="hljs-number">79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br>c = <span class="hljs-number">70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br>dp = <span class="hljs-number">3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,e):<br>    <span class="hljs-keyword">if</span> e * dp % x ==<span class="hljs-number">1</span>:<br>        p = (e*dp - <span class="hljs-number">1</span>) // x + <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> n % p == <span class="hljs-number">0</span>:<br>            q = n // p<br>            d = invert(e, (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>))<br>            m = powmod(c,d,n)<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(m))<br><br><span class="hljs-built_in">print</span>(libnum.n2s(<span class="hljs-built_in">int</span>(m)))<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311291147798.png"alt="image-20231129114702659" /><figcaption aria-hidden="true">image-20231129114702659</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#或者直接用xenny师傅的库</span><br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> dpleak<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><br>e = <span class="hljs-number">65537</span><br>n = <span class="hljs-number">79201858340517902370077926747686673001645933420450220163567700296597652438275339093680329918615445030212417351430952656177171126427547284822789947152085534939195866096891005587613262293569611913019639653984932469691636338705418303482885987114085769045348074530172292982433373154900841135911548332400167290083</span><br>c = <span class="hljs-number">70109332985937768446301118795636999352761371683181615470371772202170324747707233792154935611826981798791499937601162039878070094663516868746240133223110650205575807753345252087103328657073552992431511929172241702073381723302143955977662087561904058172777520360991685289300855900793806183473523998422682944404</span><br>dp = <span class="hljs-number">3098334089252415941833934532457314870210700261428241562420857845879512952043729097866485406309479489101668423603305497982177150304625615059119312238777275</span><br><br>m = dpleak.attack(dp,c,e=e,n=n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="rsa211e很大的dp泄露攻击">[RSA2]11(e很大的dp泄露攻击)</h2><h3 id="main-10">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">80</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = getPrime(<span class="hljs-number">128</span>)<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><br>dp = d % (p-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;dp = <span class="hljs-subst">&#123;dp&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br><span class="hljs-string">e = 305691242207901867366357529364270390903</span><br><span class="hljs-string">c = 26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br><span class="hljs-string">dp = 2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-9">exp</h3><p>上一题中最后我们发现未知数k是一个小于<em>e</em>的数，所以我们采用了遍历[1,<em>e</em>)的方式来进行爆破，但这种方法不总是可行，例如在本题中<em>e</em>是128为的素数，显然我们不能去爆破它了。</p><p>本题可以看作10的升级版，比赛中其实会有很多的升级版本，这里可以分析一下条件</p><p>在RSA中，我们不仅有P10中e*dp的关系，还有其他我们可以利用的条件，由欧拉降幂有</p><p><span class="math inline">\(a^{e*dp}≡a^{e*dp \mod (p-1)}≡a\modp\)</span></p><p>则：<span class="math inline">\(a^{e*dp}-a≡0\mod p\)</span>，即$a^{e<em>dp} - a = k</em>p$</p><p>所以<spanclass="math inline">\((a^{e*dp}-a)|p\)</span>，显然我们已经攻破了本题，接下来我们需要求解<spanclass="math inline">\((a^{e*dp}-a)\)</span>和n的最大公因数即可。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311291345449.png"alt="image-20231129134524369" /><figcaption aria-hidden="true">image-20231129134524369</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#其实是这种类型题的通解</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>n = <span class="hljs-number">108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br>e = <span class="hljs-number">305691242207901867366357529364270390903</span><br>c = <span class="hljs-number">26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br>dp = <span class="hljs-number">2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><br>a = getPrime(<span class="hljs-number">64</span>)<br>pp = <span class="hljs-built_in">pow</span>(a, e*dp, n) - a<br><br>p = GCD(n, pp)<br>q = n // p<br>d = inverse(e, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>或者：</p><p><strong>⭐一招鲜吃遍天？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> dpleak<br><br>n = <span class="hljs-number">108280026722298796068968170303156759745471686664814404724171434502249429011870583595808692893118419248225924869164875379709992190884930717654004006466664403479467573176438601715156464950045121937338569942817256182277141174728470067308962244296992229214749863655518517510026063088263849891990324547823192559069</span><br>e = <span class="hljs-number">305691242207901867366357529364270390903</span><br>c = <span class="hljs-number">26537258289122728220745496185201994733321402056894636636642710319261241111675937946139938310952968353253866895253865273981912174303818938005932883052177988834834575591342856235464380238486868448329727891268391728758132913642966389278296932186703733187105516710825918064228397602264185334108934765627411913661</span><br>dp = <span class="hljs-number">2656631506624565349527023729530989647164022271235521672257622068579788839123502046687139927161669209201953909023994372208117081512139181611949631467292513</span><br><br>m = dpleak.attack(dp,c,e=e,n=n)<br>flag = long_to_bytes( m )<br><span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="rsa212d泄露攻击">[RSA2]12(d泄露攻击)</h2><h3 id="main-11">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br><span class="hljs-keyword">assert</span> p &lt; q<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;d = <span class="hljs-subst">&#123;d&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;flag is NSSCTF&#123;md5(p)&#125;&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103</span><br><span class="hljs-string">d = 15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353</span><br><span class="hljs-string">flag is NSSCTF&#123;md5(p)&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-10">exp</h3><p>简化为（先知道结果，证明过程先略略😎）：</p><p>本题我们的目标不再是求解明文，而是考虑当私钥已经泄露的情况，能否利用公私钥来进行因数分解。</p><p>首先有一个定理 <span class="math display">\[r \equiv s(\bmod \phi(n)) \Leftrightarrow a^r \equiv a^s(\bmod n)\\也就是说我们可以将模n的同余幂式转换成其指数部分模ϕ(n)下的同余式。\\其中ϕ(n) = φ(n)/g，g=gcd(p-1,q-1)\]</span> 所以有：<span class="math inline">\(e * d \equiv 1(\bmod\phi(n)) \Rightarrow a^{e * d} \equiv a(\bmod n)\)</span></p><p>我们令 <span class="math inline">\(e * d-1=2^s * t\)</span></p><p>使得 <span class="math inline">\(t\)</span> 是一个奇数，这样我们遍历<span class="math inline">\([1, s]\)</span>，假设能够找到满足下列关系式的式子 <span class="math inline">\(a^{2^i *t} \equiv 1(\bmod n)\)</span> 且 <span class="math inline">\(a^{2^{i-1}* t} \not \equiv \pm 1(\bmod n)\)</span></p><p>就会有 <span class="math inline">\(\operatorname{gcd}\left(a^{2^{i-1}* t}-1, n\right)=p\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5<br><br>n = <span class="hljs-number">113917408220469425995764932761465306974540330325378601642830241920567032775895088098706711486764203845425248022960733155994427766750033219106642310531864450654102562104771892268897793145789045570107312401570269581223945259704851104645493075550316424129401227653740942495625720165869565257394427181127734628103</span><br>d = <span class="hljs-number">15762135247924329080208071933121250646888501386858311483546464344350547831176536290630826247188272280853810047335214127264865205744683174860903496832368687060941437002920094364116706593296591581117381565805322046922482804679245558495134876677733584718947309975077159564300049936769192724856722338627154192353</span><br>e = <span class="hljs-number">65537</span><br><br>t = e * d - <span class="hljs-number">1</span><br>s = <span class="hljs-number">0</span><br><br><span class="hljs-keyword">while</span>(t % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>):<br>    t = t // <span class="hljs-number">2</span><br>    s += <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 此时 e * d - 1 = ( 2^s ) * t</span><br>p = <span class="hljs-number">2</span><br>q = <span class="hljs-number">2</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>,s):<br>    c1 = powmod(<span class="hljs-number">2</span>,powmod(<span class="hljs-number">2</span>,i,n) * t , n )<br>    c2 = powmod(<span class="hljs-number">2</span>,powmod(<span class="hljs-number">2</span>,(i-<span class="hljs-number">1</span>),n) * t, n )<br>    <span class="hljs-keyword">if</span>(c2 != <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c2 != n-<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> c1 == <span class="hljs-number">1</span> ):<br>        p = gcd(c2 - <span class="hljs-number">1</span>,n)<br>        q = n // p<br>        <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> p &gt; q:<br>    p, q = q, p  <span class="hljs-comment">#交换</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(p).encode()).hexdigest()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NSSCTF&#123;&quot;</span>+flag+<span class="hljs-string">&quot;&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>参考： <ahref="https://blog.csdn.net/m0_74345946/article/details/131192056?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%5BRSA1%5DP4&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-131192056.nonecase&amp;spm=1018.2226.3001.4187">Crypto--RSA系列_iroot函数_yolocth的博客-CSDN博客</a></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p><p><a href="https://shimo.im/docs/Dy5ekHJhKo0ap5v3/read">NewStarCTF 2023Week2 官方WriteUp (shimo.im)</a></p><p><a href="https://www.ruanx.net/rsa-solutions/">CTF RSA题解集(ruanx.net)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（一）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不知道为啥就对密码学感兴趣了，上学期学了半天pwn没搞懂，或许就不适合学pwn吧😭</p><p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>在探姬的建议下，还是买了这套课程，开干！</p><h2 id="rsa1p1">[RSA1]P1</h2><h3 id="main.py">main.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br><span class="hljs-string">q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py">decrypt.py</h3><p><strong>已知p,q,e,c,可直接求出d,然后求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br>q = <span class="hljs-number">8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <span class="hljs-comment"># b&#x27;NSSCTF&#123;now!you_know_rsa&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>关于类型的转换，pepper师傅这里说的很好，我就直接copy了</p><p>本题需要理解明文和密文的类型及其类型转换函数。<strong>long类型为一串数字</strong>，<strong>bytes是字符</strong>。</p><p>在下列示例中，message表示bytes类型明文，m表示long类型明文，c表示long类型密文。</p><p>在rsa.py函数中：</p><ol type="1"><li><p>输入 message 明文为 bytes 类型,加密 c=pow(m,e,n) 中明文 m 为 long类型，输出密文 c 是 long 类型。</p><p>message 到 m 需要通过 bytes_to_long(message) 方法进行转换</p></li><li><p>解密 m= pow(c, d, n) 中 m 为 long 类型，c 为 long 类型。</p><p>打印输出的明文 message 需要 bytes 类型，通过 long_to_bytes(m)方法进行转换</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">m = bytes_to_long(message) <span class="hljs-built_in">bytes</span>转long<br>message = long_to_bytes(m) long转<span class="hljs-built_in">bytes</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p2">[RSA1]P2</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-1">decrypt.py</h3><p><strong>已知n,e,c,分解n，得到p,q</strong></p><p>本题意思是只知道了n，而p和q都不知道，那么我们就要把n这个大整数分解，用到网站<ahref="http://factordb.com/">factordb.com</a></p><p>得到分解的两个数p和q，即可写出decrypt.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><br>p = <span class="hljs-number">70538125404512947763739093348083497980212021962975762144416432920656660487657</span><br>q = <span class="hljs-number">104660876276442216612517835199819767034152013287345576481899196023866133215633</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p3">[RSA1]P3</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">128</span>)<br>q = getPrime(<span class="hljs-number">128</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53690629441472827148854210396580805205350972614395425306316047967905824330731</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 22130296334673852790451396673112575082637108306697684532954477845025885087040</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-2">decrypt.py</h3><p><strong>已知n,e,c,yafu分解n，得到p,q</strong></p><p>虽然它说是要让用yafu，命令为：<code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><p><ahref="https://wiki.mrskye.cn/Crypto/yafu安装及使用/">yafu安装及使用 -SkYe Wiki (mrskye.cn)</a></p><p>但我寻思这个数比上面的数还小，直接<ahref="http://factordb.com/">factordb.com</a>不就行辣😋</p><p>求出p和q后，解密函数跟<strong>[RSA1]P2</strong>一样</p><hr /><h2 id="rsa1p4">[RSA1]P4</h2><h3 id="main_py-2">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-3">decrypt.py</h3><p><strong>已知n,e,c，且p,q相差不大（特例款）。</strong></p><p>直接copy了xenny师傅的wp，😰😢</p><ul><li>本题的关键是<code>q = gmpy2.next_prime(p)</code>，相当于q是p的下一个素数</li><li>然后这里采用了一个<spanclass="math inline">\(\sqrt{n}\)</span>，因为<spanclass="math inline">\(n = p*q\)</span>，考虑n的算术平方根为$sn = <spanclass="math inline">\(，同时 sn也是p和q的几何平均值。所以有\)</span>p&lt;sn&lt;q$</li><li>又有p，q是相邻的素数，p的下一个素数为q，同理也有sn的下一个素数也应该是q，</li><li>然后由q求出p即可</li></ul><p>这里附上一篇文章：<ahref="https://www.freebuf.com/articles/database/290623.html">浅析RSA因子大小相近时分解因子攻击方法- FreeBuf网络安全行业门户</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br><br>n = <span class="hljs-number">115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><br>sn = isqrt(n)      <span class="hljs-comment">#或者sn = gmpy2.iroot(n,2)</span><br>q = next_prime(sn)<br>p = n // q<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p5">[RSA1]P5</h2><h3 id="main_py-3">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt1.py">decrypt1.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>直接yafu分解：</p><p>但是不能用[RSA1]P4里面的方法，因为根号n的下一个素数不一定是q哦😡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>P = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815375891425102591939094029941691738405035324548070063226677838530633694428729829</span><br>q = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815305905822146210878434959851438079877557401145694064756239882458467901042367473</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>文章 - <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><h3 id="decrypt2.py">decrypt2.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>费马分解： <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><p>看懂了，只有一个问题：为什么从a从根号n开始加</p><ul><li>因为b要从0，a等于根号n时b才等于0😋</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br><br>n = <span class="hljs-number">148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fermat_attack</span>(<span class="hljs-params">n</span>):<br>    a = isqrt(n)<br>    b2 = a*a - n<br>    b = isqrt(n)    <span class="hljs-comment">#这里只是对b进行一个初始化，b=1，2，3，，，等于几应该都行</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> b*b != b2:          <br>        a = a + <span class="hljs-number">1</span><br>        b2 = a*a - n<br>        b = isqrt(b2)<br>        count += <span class="hljs-number">1</span><br>    p = a+b<br>    q = a-b<br>    <span class="hljs-keyword">assert</span> n == p * q<br>    <span class="hljs-keyword">return</span> p, q<br><br><br>p, q = fermat_attack(n)<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br><br>msg = <span class="hljs-built_in">pow</span>(c, d, n)<br>message = long_to_bytes(msg)<br><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p6">[RSA1]P6</h2><h3 id="main_py-4">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p1 = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>p2 = getPrime(<span class="hljs-number">512</span>)<br><br>n1 = p1*q<br>n2 = p2*q<br><br>e = <span class="hljs-number">65537</span><br><br>m = bytes_to_long(flag)<br>c1 = <span class="hljs-built_in">pow</span>(m, e, n1)<br>c2 = <span class="hljs-built_in">pow</span>(m, e, n2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n1 = <span class="hljs-subst">&#123;n1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n2 = <span class="hljs-subst">&#123;n2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br><span class="hljs-string">n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br><span class="hljs-string">c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-4">decrypt.py</h3><p><strong>已知（e,n1,c1,n2,c1），求m</strong></p><p><strong>两组数中e相同，n,c不同，n1和n2的最大公因数即为p,之后就能求出q、d,继而求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n1 = <span class="hljs-number">143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br>n2 = <span class="hljs-number">138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br>e = <span class="hljs-number">65537</span><br>c1 = <span class="hljs-number">54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br>c2 = <span class="hljs-number">122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><br><span class="hljs-comment"># p1 = getPrime(512)</span><br><span class="hljs-comment"># q = getPrime(512)</span><br><span class="hljs-comment"># p2 = getPrime(512)            byd你写解代码的时候加上这一段干什么</span><br><br><span class="hljs-comment"># n1 = p1*q</span><br><span class="hljs-comment"># n2 = p2*q</span><br><br>q = gcd(n1,n2)        <span class="hljs-comment"># 最关键的一句，看出q是n1和n2的最大公因数，然后求出q，后面就常规</span><br><span class="hljs-comment"># print(q)</span><br>p1 = n1 // q<br><br>phi = (q-<span class="hljs-number">1</span>)*(p1-<span class="hljs-number">1</span>)<br>d1 = invert(e, phi) <br><br>m1 = <span class="hljs-built_in">pow</span>(c1, d1, n1)<br><br><br><span class="hljs-comment"># m1=hex(m1).replace(&#x27;0x&#x27;,&#x27;&#x27;)</span><br><span class="hljs-comment"># flag = bytes.fromhex(m1)</span><br><span class="hljs-comment"># print(flag)</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m1))<br><span class="hljs-comment"># 但是有个小问题啊，为什么n1和n2解出来是一样的捏🤒</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p7">[RSA1]P7</h2><h3 id="main_py-5">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">170</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>r = getPrime(<span class="hljs-number">512</span>)<br>n = p*q*r<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br><span class="hljs-string">q = 8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br><span class="hljs-string">r = 12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-5">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（特例款）</strong></p><p>相当于多了一个参数r，还是一样，加上r就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br>q = <span class="hljs-number">8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br>r = <span class="hljs-number">12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;3th_number!&#125;11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&#x27;</span><br><span class="hljs-comment"># 不过至于本题为何要添加上大量的字符1作为填充内容，这个问题待到P9时我们便会知晓。</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p8">[RSA1]P8</h2><h3 id="main_py-6">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">100</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = (p**<span class="hljs-number">3</span>) * q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br><span class="hljs-string">q = 67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-6">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（经典款）</strong></p><p>byd欧拉公式都不知道是吧：</p><p>对于： <span class="math display">\[n = p_{1}^{k_{1}}p_{2}^{k_{2}}p_{3}^{k_{3}}\cdots p_{r}^{k_{r}}\]</span></p><p>欧拉函数等于：</p><p><span class="math display">\[\varphi (n) = \prod_{i=1}^{r} p_{i}^{k_{i}-1}(p_{i}-1)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br>q = <span class="hljs-number">67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><br>n = p * p * p * q<br>phi = (p**<span class="hljs-number">2</span>)*(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p9">[RSA1]P9</h2><h3 id="main_py-7">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = <span class="hljs-number">2</span>*getPrime(<span class="hljs-number">100</span>)*e+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> isPrime(r):<br>        <span class="hljs-keyword">break</span><br><br>n = p*q*r<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br><span class="hljs-string">q = 9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br><span class="hljs-string">r = 102909133680612532601801231903654039</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-7">decrypt.py</h3><p><strong>已知（e，p，q，r)，且m已知很短</strong></p><p>总结：</p><p>满足以下情况时，可以不使用题中给的n=pqr计算公式，自己重新计算n，再进一步计算公私钥：</p><ol type="1"><li>明文m比较简短<ul><li>flag = b’NSSCTF{ <span class="math inline">\(\cdots\cdots\)</span>}’+ b’1’ * 100 不行</li><li>flag = b’NSSCTF{ <span class="math inline">\(\cdots \cdots\)</span>}’ 可以</li></ul></li><li>分析发现使用给定的n无法计算d，原因可能是d = inverse(e,phi)中e、phi不互素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br><br>p = <span class="hljs-number">7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br>q = <span class="hljs-number">9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br>r = <span class="hljs-number">102909133680612532601801231903654039</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><br>n = p * q    <span class="hljs-comment"># 相当于直接把r给忽略掉了，但原理还没懂，xenny师傅的wp有点没看懂</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>Xenny师傅的wp：<ahref="https://www.nssctf.cn/problem/sheet/7142">Crypto系列——RSA（一） |NSSCTF</a></p><hr /><h2 id="rsa1p10">[RSA1]P10</h2><h3 id="main_py-8">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span>*<span class="hljs-number">2</span><br><br>n = p*q<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br><span class="hljs-string">q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br><span class="hljs-string">e = 131074</span><br><span class="hljs-string">c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-8">decrypt.py</h3><p><strong>已知(e，p，q，c），但是e和phi不互素</strong></p><p>因为p−1或q−1都是偶数，e也是偶数，他们显然不互素。</p><p><strong>关键の公式</strong>： <span class="math display">\[c\equiv m^{e}\equiv (m^{2})^{65537}  (mod \quad n)\]</span> 把 <spanclass="math inline">\(m^{2}\)</span>看成一个整体即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br>q = <span class="hljs-number">9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><br><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c, d, p*q)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(isqrt(m)))<br><br><br><span class="hljs-comment"># 后面这部分也能写出下面这样：</span><br><br><br>n = p * q    <br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><span class="hljs-comment"># print(gcd(e, phi))</span><br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br>a,b = gmpy2.iroot(m,<span class="hljs-number">2</span>) <br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))   <br></code></pre></td></tr></table></figure><p>2023.09.10-2023.09.14</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto学习总结</title>
    <link href="/2023/09/12/Crypto%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/12/Crypto%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="rsa">RSA</h2><p><code>from Crypto.Util.number import *</code><code>from gmpy2 import *</code></p><ul><li>导入两个经典的模块</li></ul><p><code>d = inverse(e, phi)</code></p><p><code>d = invert(e, phi)</code></p><ul><li><code>inverse</code>函数，<code>invert</code>函数，函数有两个参数<code>(a,p)</code>，作用便是求解<code>a</code>在模<code>p</code>意义下的乘法逆元，</li><li>这里我们便是求解<code>e</code>在模<code>phi</code>下面的乘法逆元，结果为<code>d</code></li><li>即满足$ e* d ≡ 1(modφ(n)) $</li><li>即满足$ (d * e) % phi = 1 $，%的意思是取余</li><li>这个语句使用的是 <code>Crypto.Util.number</code> 模块中的<code>inverse()</code> 函数</li></ul><p><code>d = gmpy2.invert(e, phi)</code></p><ul><li>该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得$ (d * e) %phi = 1 $</li><li>也即是<code>d * e ≡ 1 (mod phi)</code></li><li>这个语句使用的是外部库 <code>gmpy2</code> 的 <code>invert()</code>函数来计算乘法逆元，<del>gmpy2和Crypto中的数学函数相比：二者速度不是一个量级。</del></li></ul><p><code>d = pow(e,-1,phi)</code></p><ul><li>当传递三个参数时，<code>pow(x, y, z)</code> 用于计算 <code>x</code>的 <code>y</code> 次幂模 <code>z</code> 的结果。在这里，<code>e</code>是底数，<code>-1</code> 是指数，<code>phi</code>是模数。通过将指数设置为 <code>-1</code>，<code>pow(e, -1, phi)</code>计算了 <code>e</code> 的模 <code>phi</code> 的乘法逆元。</li><li>这个语句使用的是内置函数 <code>pow()</code>来执行指数运算和模计算。</li></ul><p><code>a = powmod(a, m, n)</code></p><ul><li><code>powmod(a, m, n)</code>与<code>pow(a, m, n)</code>效果一样</li></ul><p><code>gmpy2.iroot(x, n)</code></p><ul><li>其中，<code>x</code> 是待计算根号的整数，<code>n</code>是根号类型的整数值。<code>irrot（c,e）</code>表示 对c开e次根号，</li><li>如果 <code>x</code>的根号为整数，函数将返回一个<strong>元组（tuple）</strong>，返回值为<code>(mpz(2), False)</code>，第一个参数表示返回的结果，<code>mpz</code>为<code>gmpy2</code>包中对整数的封装类，看作一个整数即可；第二个参数代表这个数是否能被完全开e次方，true表示能。</li><li>例如10开3次方并不是一个整数，但<code>gmpy2</code>只会返回取整后的整数值，故通过第二项我们能够知道是否为完全k次方数。</li><li>例如<code>iroot(9, 2)</code>返回<code>(mpz(3), True)</code>代表9是一个完全平方数。</li><li>如果想获得根号的整数值，可以通过访问元组的第一个元素来实现，例如：<ul><li><code>m1 = gmpy2.iroot(m, 2)[0]</code></li><li><code>print(long_to_bytes(m[0]))</code></li></ul></li><li>也能直接赋值的时候就赋给两个变量，这里a就是取平方根后的整数值<ul><li><code>a, b = gmpy2.iroot(m,2)</code></li></ul></li></ul><p><code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><ul><li>分解1.txt中的整数</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 已知p,q,e之后，常规操作：</span><br><br>phi = (p-1)*(q-1)<br>d = invert(e, phi)<br>m = powmod(c, d, n)<br>print(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="快速解密">快速解密</h2><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><p><ahref="https://blog.csdn.net/Dome_/article/details/120689591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120689591-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">全自动解密解码神器— Ciphey</a></p><p><ahref="https://blog.csdn.net/ntrybw/article/details/131516319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-131516319-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">Windows安装ciphey编码工具，编码工具战神，cry简单题绝对克星！</a></p><hr /><hr /><p>第一个RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694707420490.png"alt="1694707420490" /><figcaption aria-hidden="true">1694707420490</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915000454756.png"alt="image-20230915000454756" /><figcaption aria-hidden="true">image-20230915000454756</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001215482.png"alt="image-20230915001215482" /><figcaption aria-hidden="true">image-20230915001215482</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001234755.png"alt="image-20230915001234755" /><figcaption aria-hidden="true">image-20230915001234755</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><blockquote><p>数学公式里面的空格</p><p>% 意思是打出一个%符号</p><p>% 单独输入这个可以把后面的都注释掉</p><p>写数学公式换行：</p><p><span class="math inline">\(p=q\)</span>，$ p=q$，后面这个就显示错误，不能有空格</p><p>行的中间也不能有空行</p><p>[<ahref="https://blog.csdn.net/bendanban/article/details/77336206">CSDN_Markdown]数学公式对齐_markdown 数学公式对齐-CSDN博客</a></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311062156645.png"alt="image-20231106215632596" /><figcaption aria-hidden="true">image-20231106215632596</figcaption></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF-Crypto（1~15）</title>
    <link href="/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/"/>
    <url>/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>有两个有各种加解密的网站</p><p><a href="http://www.hiencode.com/">在线工具</a></p><p><a href="https://ctf.bugku.com/tools">Bugku CTF</a></p><h2 id="鹤城杯-2021easy_crypto">[鹤城杯 2021]easy_crypto</h2><p>解压后文件内容是社会主义核心价值观，查了一下竟然有<strong>核心价值观编码</strong>，有点逆天，那就直接用工具解码即可。</p><p>下面贴上两个网站</p><p><ahref="http://www.hiencode.com/cvencode.html">核心价值观编码-加解密1</a></p><p><ahref="https://ctf.bugku.com/tool/cvecode">核心价值观编码-加解密2</a></p><hr /><h2 id="强网拟态-2021拟态签到题">[强网拟态 2021]拟态签到题</h2><p>打开txt文件，发现看不懂，这什么东西？</p><p><a href="https://freeimage.host/i/J95ihaR"><imgsrc="https://iili.io/J95ihaR.md.png" alt="2309061" /></a></p><p>GPT一下</p><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><p>GPT倒是一眼看出来了，base64编码，直接解码即可，仍然上面的两个网站任意一个即可</p><hr /><h2 id="swpuctf-2021-新生赛crypto8">[SWPUCTF 2021 新生赛]crypto8</h2><p>打开txt后又是一段乱码：73E-30U1&amp;&gt;V-H965S95]I&lt;U]P;W=E&lt;GT`</p><p>根据题目上面的标签提示，推测是UUencode加密</p><p>用工具解密即可</p><p>NSSCTF{cheese_is_power}</p><blockquote><p><strong>有个小问题哈，这些编码的具体实现方式我们不用具体了解吗难道🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔，直接用工具就行了吗？</strong></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛crypto7">[SWPUCTF 2021 新生赛]crypto7</h2><p>打开txt，原文如下</p><p><code>69f7906323b4f7d1e4e972acf4abfbfc,得到的结果用NSSCTF&#123;&#125;包裹。</code></p><p>根据标签，发现是MD5加密</p><p>直接解密即可，<a href="https://www.cmd5.com/">MD5解密</a></p><p>NSSCTF{md5yyds}</p><hr /><h2 id="swpuctf-2021-新生赛crypto6">[SWPUCTF 2021 新生赛]crypto6</h2><p>打开txt，原文如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">var=<span class="hljs-string">&quot;************************************&quot;</span><br>flag=<span class="hljs-string">&#x27;NSSCTF&#123;&#x27;</span> + base64<span class="hljs-selector-class">.b16encode</span>(base64<span class="hljs-selector-class">.b32encode</span>(base64<span class="hljs-selector-class">.b64encode</span>(<span class="hljs-selector-tag">var</span><span class="hljs-selector-class">.encode</span>()))) + <span class="hljs-string">&#x27;&#125;&#x27;</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flag)</span></span><br><br>小明不小心泄露了源码，输出结果为：<span class="hljs-number">4</span>A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D，你能还原出var的正确结果吗？<br></code></pre></td></tr></table></figure><ul><li>可以看出加密是先base64，再base32，再base16</li><li>所以解密我们就先反过来即可，16 → 32 → 64，用上面的解密网站</li><li>得到5e110989-dc43-1bd3-00b4-9009206158fe</li><li>所以flag为NSSCTF{5e110989-dc43-1bd3-00b4-9009206158fe}</li></ul><hr /><h2 id="swpuctf-2021-新生赛ez_caesar">[SWPUCTF 2021新生赛]ez_caesar</h2><p>打开后是一个.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">caesar</span>(<span class="hljs-params">plaintext</span>):<br>    str_list = <span class="hljs-built_in">list</span>(plaintext)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(plaintext):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> str_list[i].isalpha():<br>            str_list[i] = str_list[i]<br>        <span class="hljs-keyword">else</span>:<br>            a = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-keyword">if</span> str_list[i].isupper() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;a&quot;</span><br>            str_list[i] = <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(str_list[i]) - <span class="hljs-built_in">ord</span>(a) + <span class="hljs-number">5</span>) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a) <span class="hljs-keyword">or</span> <span class="hljs-number">5</span>)<br>        i = i + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(str_list)<br><br>flag = <span class="hljs-string">&quot;*************************&quot;</span><br><span class="hljs-built_in">str</span> = caesar(flag)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment">#str=&quot;U1hYSFlLe2R0em1mYWpwc3RiaGZqeGZ3fQ==&quot;</span><br></code></pre></td></tr></table></figure><p>这，有点看不懂，GPT一下吧，下面是GPT的解释 &gt;这段代码首先导入了base64模块，然后定义了一个名为caesar的函数，该函数接受一个明文字符串作为输入，并返回加密后的字符串。在函数内部，首先将明文字符串转换为字符列表str_list，然后使用while循环遍历明文字符串的每个字符。在每次循环中，首先检查当前字符是否为字母。如果不是字母，则将字符保持不变。如果是字母，则根据字母的大小写确定字母表的起始位置（大写字母从'A'开始，小写字母从'a'开始），然后使用凯撒密码的规则对字母进行替换。替换的规则是将字母的Unicode码减去起始位置的Unicode码，再加上一个固定的位移量5，然后对26取模，最后再加上起始位置的Unicode码或者5。这样可以确保替换后的字符仍然是一个字母。循环结束后，将字符列表转换回字符串，并将加密后的字符串打印出来。最后一行的注释掉的代码是一个经过base64编码的字符串，你可以在需要时将其解码。</p><p>那我就懂了，嘻嘻</p><ul><li>凯撒密码（Caesar cipher），原来就是凯撒密码</li><li>最后一行注释掉的是base64编码后的结果</li><li>那我们就先base64解码，再凯撒解码应该就行</li><li>注意凯撒解码还需要一个偏移量，这里的偏移量就是5</li><li>最后得到 NSSCTF{youhaveknowcaesar}</li></ul><hr /><h2 id="swpuctf-2021-新生赛crypto10">[SWPUCTF 2021 新生赛]crypto10</h2><p>txt中的内容为：<code>AFFPGS&#123;pbatenghyngvbaf!!!&#125;,建议直接秒了</code></p><p>观察标签可以看出是个什么ROT加密，直接搜工具解密即可</p><p>NSSCTF{congratulations!!!}</p><hr /><h2 id="鹤城杯-2021a_crypto">[鹤城杯 2021]A_CRYPTO</h2><p>逆天文本：4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</p><p>从此知道了<strong>ciphey</strong>的存在，准备配置啊啊啊啊</p><p><ahref="https://blog.csdn.net/Dome_/article/details/120689591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120689591-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">全自动解密解码神器— Ciphey</a></p><p><ahref="https://blog.csdn.net/ntrybw/article/details/131516319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-131516319-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">Windows安装ciphey编码工具，编码工具战神，cry简单题绝对克星！</a></p><p>不知道为啥，就安装成功了，但是只能在windows下的cmd中使用，等会还要在kali里面再下一个<strong>ciphey</strong></p><p>解密命令为：</p><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><figure><img src="https://iili.io/J9lb0js.png" alt="202309071.png" /><figcaption aria-hidden="true">202309071.png</figcaption></figure><p>所以flag为："NSSCTF{W0w_y0u_c4n_rea11y_enc0d1ng!}"</p><blockquote><p>0 0 0 下面的东西可以忽略，byd配环境配了将近一上午都没在kali里面配好，不是python版本问题就是什么PATH路径问题，到最后也没解决，草！这里由于百度网盘下载的太慢，一顿搜索后发现了其他的方法，怎么没早点发现啊😭<ahref="https://greasyfork.org/zh-CN/scripts/463707-%E5%B0%B1%E6%98%AF%E5%8A%A0%E9%80%9F-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%97%A0%E9%99%90%E9%80%9F%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E8%BD%BD">不多说好吧，要是有有缘人看到算是你赚了🤭</a>下面就是kali中ciphey的配置 <ahref="http://old.kali.org/virtual-images/kali-2021.2/">http://old.kali.org/virtual-images/kali-2021.2/</a><a href="https://kali.download/">https://kali.download/</a></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛pigpig">[SWPUCTF 2021 新生赛]pigpig</h2><p>根据提示是一个什么猪圈密码</p><p><a href="http://www.hiencode.com/pigpen.html">在线解密即可</a></p><p>NSSCTF{whenthepigwanttoeat}</p><p>什么时候🐖想吃？🐷</p><hr /><h2 id="swpuctf-2021-新生赛ez_rsa">[SWPUCTF 2021 新生赛]ez_rsa</h2><p>打开txt内容如下，搜了一下确实是最最基础的RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233108248.png"alt="image-20230908233108248" /><figcaption aria-hidden="true">image-20230908233108248</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908235228225.png"alt="image-20230908235228225" /><figcaption aria-hidden="true">image-20230908235228225</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233527952.png"alt="image-20230908233527952" /><figcaption aria-hidden="true">image-20230908233527952</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908234751944.png"alt="image-20230908234751944" /><figcaption aria-hidden="true">image-20230908234751944</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><hr /><h2 id="bjdctf-2020base">[BJDCTF 2020]base??</h2><p>打开后是这串东西</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909003141021.png"alt="image-20230909003141021" /><figcaption aria-hidden="true">image-20230909003141021</figcaption></figure><p>直接赛博厨子解决了😂，相当于换表操作，查了一下，写python代码还有点复杂🤔，等会再看一下（</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909005020849.png"alt="image-20230909005020849" /><figcaption aria-hidden="true">image-20230909005020849</figcaption></figure><hr /><h2 id="swpuctf-2021-新生赛traditional">[SWPUCTF 2021新生赛]traditional</h2><p>打开后是个什么东西，不懂，明天再看吧，byd已经1点力，还没刷牙😭</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909010611371.png"alt="image-20230909010611371" /><figcaption aria-hidden="true">image-20230909010611371</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>NSSCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解1²+2²+3²+……+n²</title>
    <link href="/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/"/>
    <url>/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="一种简单的方法">一种简单的方法</h2><p>在做数据结构第一章的习题时遇见这个问题，感觉很有意思，就写了下来</p><p>这种方法把1²+2²+3²+……+n²写成三个式子，相加除以3得到结果，如下：</p><p>1</p><p>2 2</p><p>3 3 3</p><p>...........................</p><p>n n .................n n ①</p><hr /><p>n</p><p>..............n</p><p>3 ...................n</p><p>2 3 ...... ...........n</p><p>1 2 3....................n ②</p><hr /><p>n</p><p>n .........</p><p>n .................. 3</p><p>n ..........................3 2</p><p>n ..................................3 2 1 ③</p><p>这三个式子都表示1²+2²+3²+……+n²，把他们相加</p><p>①+②+③得</p><p>2n+1</p><p>2n+1 2n+1</p><p>....................................</p><p>2n+1 2n+1 2n+1...........................2n+1 2n+1 2n+1 ①+②+③</p><p>3 ∑n² = n(n+1)(2n+1)/2</p><p>故 1²+2²+······+n² = n（n+1）（2n+1）/6</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种软件安装，环境配置</title>
    <link href="/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="在vscode中配置python开发环境">在VScode中配置Python开发环境</h2><p><ahref="https://blog.csdn.net/weixin_43737995/article/details/125690015?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169362300616800182129289%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169362300616800182129289&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125690015-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=vscode%20python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&amp;spm=1018.2226.3001.4187">在VScode中配置Python开发环境</a></p><h2 id="git安装">Git安装</h2><p><ahref="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169205886716800188579548%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169205886716800188579548&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-115693833-null-null.142%5Ev92%5EchatgptT0_1&amp;utm_term=git%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">Git详细安装教程</a></p><h2 id="java安装">JAVA安装</h2><p><ahref="https://blog.csdn.net/qq_48988285/article/details/125593715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169396267216800182147901%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169396267216800182147901&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125593715-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=java%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">超详细Java安装教程，小白速来！！！</a></p><h2 id="dev-c安装">Dev C++安装</h2><p><ahref="https://blog.csdn.net/m0_54158068/article/details/124080083?ops_request_misc=%7B%22request%5Fid%22%3A%22169519422116800213087590%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519422116800213087590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124080083-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=devc%2B%2B&amp;spm=1018.2226.3001.4187">DevC++软件下载及安装教程（详细、具体）_devc++下载_等日出看彩虹的博客-CSDN博客</a></p><h2 id="pycharm安装">Pycharm安装</h2><p><ahref="https://blog.csdn.net/m0_46374969/article/details/131292897?ops_request_misc=%7B%22request%5Fid%22%3A%22169819294316800213022638%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169819294316800213022638&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-131292897-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=pycharm安装教程&amp;spm=1018.2226.3001.4187">PyCharm安装教程(图文结合，超详细，小白安装必看)_王同学要努力的博客-CSDN博客</a></p><h2 id="vscode配置c语言环境">vscode配置C语言环境</h2><p><ahref="https://www.bilibili.com/video/BV1Hj411F7eW/?spm_id_from=333.999.0.0&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">啰啰嗦嗦地手把手教你vscode 配置_哔哩哔哩_bilibili</a></p><h2 id="wsl-2安装">WSL 2安装</h2><p><ahref="https://blog.csdn.net/weixin_51245887/article/details/124393376?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=wsl2&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124393376.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">WSL2 的安装过程（以及介绍）_wsl2-CSDN博客</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo建站过程</title>
    <link href="/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>记录hexo搭建网站过程中遇到的各种问题</p><p>想搭建一个类似博客的师傅也能跟着下面的记录，99%能搭建一个你自己的博客</p></blockquote><p>b站yyds！！！</p><p><ahref="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=445ce756d899a4cef51cfb6b148ba121">hexo加GitHub搭建网站教程</a></p><p>评论区的搭建感谢大佬的博客<ahref="https://ltyzzzxxx.github.io/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/">周三不Coding</a></p><blockquote><p>图床的搭建暂时感谢<ahref="https://blog.csdn.net/Godlichangwu/article/details/127331738?ops_request_misc=%7B%22request%5Fid%22%3A%22169417712716800197059093%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169417712716800197059093&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127331738-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=Github仓库%20%2B%20Picgo%20&amp;spm=1018.2226.3001.4187">搭建免费图床——github+picGo+jsdelivr_github图床token获取_chunis的博客-CSDN博客</a>（bye~~~）</p></blockquote><p>图床的搭建感谢<ahref="https://zhuanlan.zhihu.com/p/653227146">Typora+PicGo+阿里云OSS搭建博客图床- 知乎 (zhihu.com)</a></p><p>网站统计量的设置：<ahref="https://blog.csdn.net/qq_48759664/article/details/119460188?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%20fluid访客量&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-119460188.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">Hexo-fluid主题设置统计博客阅读量_给fluid主题设置统计数量_codeacg的博客-CSDN博客</a>（注意还要配置一下RESTAPI 服务器地址）</p><p>这个是加上网站的运行时间：<ahref="https://blog.csdn.net/qq_36852780/article/details/120943120?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo主题fluid怎么在下面加上运行时间&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120943120.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">HexoFluid主题 细节优化_hexo fluid美化-CSDN博客</a></p><p>数学公式的显示问题参考：<ahref="https://blog.csdn.net/qq_52466006/article/details/126924064?ops_request_misc=%7B%22request%5Fid%22%3A%22169745488716800192255314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169745488716800192255314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126924064-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=博客数学公式显示错误&amp;spm=1018.2226.3001.4187">Hexo显示Latex公式最新解决方案_hexo公式-CSDN博客</a></p><p>在最下面显示了一个地图，来统计一下看谁访问了笨鼠的博客（因为最近阿里云总是给我发信息说我欠费，我就怀疑是外网流入欠的费，每次0.01元，002元，虽然不多，但是总感觉不舒服），不过这里我是修改的<code>D:\blog\myblog\themes\fluid\layout\_partials\footer.ejs</code>，在它最下面添加了：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;script <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;clustrmaps&quot;</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">&quot;//clustrmaps.com/map_v2.js?d=BHu02doWTfACgsoaKUKdCvghL0B4M-WZR956AK7Bn-I&amp;cl=ffffff&amp;w=600&quot;</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p><ahref="https://cloud.tencent.com/developer/article/1585686">如何统计 Hexo网站的访问地区和IP-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>🏓🏓🏓</p><hr /><hr /><p><strong>下面是遇到的一些问题</strong></p><h2 id="数学公式问题">数学公式问题</h2><p>记得打公式的时候”$$“，</p><p>这里前面的 "$"，以及后面的，记得跟公式的正文紧密挨着，不要留空格，如：</p><p><span class="math inline">\(X = \begin{bmatrix} x\\ y\end{bmatrix}\)</span>，就能显示成功</p><p>而：</p>$ X =<span class="math display">\[\begin{bmatrix}x\\ y\end{bmatrix}\]</span><p>$，就直接显示失败</p><h2 id="错误1hexo-d-总是报错">错误1：<code>hexo d</code> 总是报错</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>Spawn failed<br>这错误烦死人，一直报<br></code></pre></td></tr></table></figure><h3 id="解决方案">解决方案</h3><ul><li>重新配置一下SSH，把下面的<strong>write</strong>那个选项给它勾上！！！！！！！！！！！！</li><li>不知道为啥，下面竟然还有个选项，不勾上的话就是readonly，然后就会一直报那个错误😡😡</li></ul><h2id="错误2bash-hexo-command-not-found">错误2：<code>bash: hexo: command not found</code></h2><h3 id="解决方案-1">解决方案</h3><p>将<code>D:\blog\myblog\node_modules\.bin</code>,添加到Path中</p><h2 id="错误3">错误3</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">ssh: Could not resolve hostname github.com: Name or service not known<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/d<br>ocs/troubleshooting.html<br><span class="hljs-keyword">Error: </span>Spawn failed<br>    at ChildProcess.&lt;anonymous&gt; (D:\blog\myblog\node_modules\hexo-util\lib\spawn<br>.js:51:21)<br>    at ChildProcess.emit (node:events:514:28)<br>    at cp.emit (D:\blog\myblog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal/child_process:291:12)<br>    <br></code></pre></td></tr></table></figure><p>不知道为什么会报这个错误，可能是我总是翻墙的问题吧，不太懂，草，一会一个错误md😡</p><h3 id="解决方案-2">解决方案</h3><p><ahref="https://blog.csdn.net/li_001/article/details/70245006?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169400980416800225586698%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169400980416800225586698&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-70245006-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ssh%3A%20Could%20not%20resolve%20hostname%20github.com%3A%20Name%20or%20service%20not%20known%20fatal%3A%20Could%20not%20read%20from%20remote%20repository.&amp;spm=1018.2226.3001.4187">CSDN解决方案</a></p><p>方案一亲测有效，CSDNyyds！😭</p><h2 id="typora-卡顿">Typora 卡顿</h2><p>Typora在写超过大概八九千字的时候就有明显的卡顿，只有在写代码的模式下才不卡，导致非常难受，在网上搜到的一篇文章能稍微缓解一点这个问题</p><h3 id="解决方案-3">解决方案</h3><p><ahref="https://blog.csdn.net/Mao_Jonah/article/details/120533879">win10上Typora卡顿的问题及其解决方案_typora卡顿解决方法-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/14/hello-world/"/>
    <url>/2023/08/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客</title>
    <link href="/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>title: Crypto系列——RSA（二） date: 2023-09-14 21:57:30 tags:[CTF,Crypto,RSA] categories: CTF-Crypto math: true excerpt:《从0开始的密码学世界生活2》😋 updated: 2023-10-03 22:20:49</p><h3 id="pwn1">pwn1</h3><h3 id="pwn2">pwn2</h3><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><figure><img src="https://freeimage.host/i/J9YVHSj" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="https://iili.io/J9YVHSj.md.png" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="http://static.runoob.com/images/runoob-logo.png"title="RUNOOB" alt="RUNOOB 图标" /><figcaption aria-hidden="true">RUNOOB 图标</figcaption></figure><p><sub>撒旦哈市风口浪尖</sub></p><p>测试一下，看能不能直接传图片</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210230931.png"alt="image-20230908210230931" /><figcaption aria-hidden="true">image-20230908210230931</figcaption></figure><p>看来 jsDelivr CDN确实被墙了，那只能试一下阿里云了，测</p><p>哦？？这过了几分钟（2023.09.08 21:07），怎么又行了：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210813336.png"alt="image-20230908210813336" /><figcaption aria-hidden="true">image-20230908210813336</figcaption></figure><p>行吧，那先用着</p><h3 id="section">2023.10.27</h3><p>b jsDelivrCDN总是出错，换成了阿里云OSS，花了我九块大米，试一下能不能上传成功（目前还行，果然“<strong>免费的才是最贵的</strong>”吗？😥）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310270011249.png"alt="image-20231027001155106" /><figcaption aria-hidden="true">image-20231027001155106</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言实验</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="loop双层循环">loop双层循环</h2><hr /><p><a href="https://freeimage.host/i/H655pWu"><imgsrc="https://iili.io/H655pWu.md.png" alt="H655pWu.md.png" /></a></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">10</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">     b:</span> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">cx</span><br>    <br>        <span class="hljs-keyword">loop</span> b<br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span>    <br>        <span class="hljs-keyword">loop</span> s  <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><ul><li>两层循环解决</li></ul><hr /><h2 id="实验4-bx和loop的使用">实验4 [bx]和loop的使用</h2><hr /><p>1.编程，向内存0:200-0:23F依次传送数据0-63（3FH)。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;八条指令的</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>],<span class="hljs-built_in">bx</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;九条指令的，书上现在还规定指令数</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">bl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">loop</span> s<br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验5-编写调试具有多个段的程序">实验5编写、调试具有多个段的程序</h2><hr /><p>1.程序如下，编写code段中的代码，将a段和b段中的数据依次相加，将结果保存到c段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">   </span><br><span class="hljs-symbol">s:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">16</span>+<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">mov</span> [<span class="hljs-number">32</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">dl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>   <span class="hljs-keyword">loop</span> s<br>   <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>2.程序如下，编写code段代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code <br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br><br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,b<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> [<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验6-实践课程中的程序">实验6 实践课程中的程序</h2><hr /><p>将下面的程序补充完整，实现将 datasg 段中的每个单词的前 4个字母改为大写字母。【要求：仅能修改 codesg segment 的代码】</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>codesg ends<br>end start<br><br><br><br>修改后的代码：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows        &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify       &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stacksg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,datasg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s0:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s1:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>]<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><br>            <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><br><br>            <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">loop</span> s1<br><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> s0 <br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验7-寻址方式在结构化数据访问中的应用">实验7寻址方式在结构化数据访问中的应用</h2><hr /><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg<br><br>data <span class="hljs-meta">segment</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1975&#x27;</span>,<span class="hljs-string">&#x27;1976&#x27;</span>,<span class="hljs-string">&#x27;1977&#x27;</span>,<span class="hljs-string">&#x27;1978&#x27;</span>,<span class="hljs-string">&#x27;1979&#x27;</span>,<span class="hljs-string">&#x27;1980&#x27;</span>,<span class="hljs-string">&#x27;1981&#x27;</span>,<span class="hljs-string">&#x27;1982&#x27;</span>,<span class="hljs-string">&#x27;1983&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1984&#x27;</span>,<span class="hljs-string">&#x27;1985&#x27;</span>,<span class="hljs-string">&#x27;1986&#x27;</span>,<span class="hljs-string">&#x27;1987&#x27;</span>,<span class="hljs-string">&#x27;1988&#x27;</span>,<span class="hljs-string">&#x27;1989&#x27;</span>,<span class="hljs-string">&#x27;1990&#x27;</span>,<span class="hljs-string">&#x27;1991&#x27;</span>,<span class="hljs-string">&#x27;1992&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1993&#x27;</span>,<span class="hljs-string">&#x27;1994&#x27;</span>,<span class="hljs-string">&#x27;1995&#x27;</span><br>        <span class="hljs-comment">;以上是表示21年的21个字符串</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">16</span>,<span class="hljs-number">22</span>,<span class="hljs-number">382</span>,<span class="hljs-number">1356</span>,<span class="hljs-number">2390</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">16000</span>,<span class="hljs-number">24486</span>,<span class="hljs-number">50065</span>,<span class="hljs-number">97479</span>,<span class="hljs-number">140417</span>,<span class="hljs-number">197514</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">345980</span>,<span class="hljs-number">590827</span>,<span class="hljs-number">803530</span>,<span class="hljs-number">1183000</span>,<span class="hljs-number">1843000</span>,<span class="hljs-number">2759000</span>,<span class="hljs-number">3753000</span>,<span class="hljs-number">4649000</span>,<span class="hljs-number">5937000</span><br>        <span class="hljs-comment">;以上是表示21年公司总收的21个dword型数据</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">28</span>,<span class="hljs-number">38</span>,<span class="hljs-number">130</span>,<span class="hljs-number">220</span>,<span class="hljs-number">476</span>,<span class="hljs-number">778</span>,<span class="hljs-number">1001</span>,<span class="hljs-number">1442</span>,<span class="hljs-number">2258</span>,<span class="hljs-number">2793</span>,<span class="hljs-number">4037</span>,<span class="hljs-number">5635</span>,<span class="hljs-number">8226</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">11542</span>,<span class="hljs-number">14430</span>,<span class="hljs-number">15257</span>,<span class="hljs-number">17800</span><br>        <span class="hljs-comment">;以上是表示21年公司雇员人数的21个word型数据</span><br>data ends<br><br><br>table <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">21</span> dup (<span class="hljs-string">&#x27;year summ ne ?? &#x27;</span>)<br>table ends<br><br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,table<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>       <span class="hljs-comment">;初始化年份和收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;初始化雇员数和人均收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">21</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的低16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>] <span class="hljs-comment">;加54h是因为21*4=84=54h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的高16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">2h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>+<span class="hljs-number">0a8h</span>]      <span class="hljs-comment">;雇员数，占两个字节，加0a8h是因为84*2=168=a8h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>],<span class="hljs-built_in">ax</span>          <br><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>]<br><span class="hljs-keyword">div</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>]   <span class="hljs-comment">;除法算人均收入</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0dh</span>],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br><span class="hljs-keyword">loop</span> s<br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验9-根据材料编程">实验9 根据材料编程</h2><hr /><p>1.将你的姓名和学号在屏幕上中间显示出来。字符属性要求如下： 学号尾号为1，3，5，7，9 的为黑底绿色；学号尾号为 0，2，4，6，8 的为黑底红色。</p><ul><li><p>BL（闪烁） R G B（背景） I （高亮） R G B （前景）</p></li><li><p>80x25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:</p><ul><li>内存地址空间中，B8000H~BFFFFH 共32KB的空间，为80X25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。</li><li>在 80x25 彩色字符模式下，显示器可以显示 25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪、高亮等合信息)。</li><li>这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。</li><li>80x25模式下，一屏的内容在显示缓冲区中共占4000个字节。</li><li>显示缓冲区分为 8页，每页4KB(4000B)，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</li></ul></li><li><p>在一页显示缓冲区中:</p><ul><li>偏移000~09F对应显示器上的第1行(80个字符占160个字节);</li><li>偏移0A0~13F对应显示器上的第2行;</li><li>偏移140~1DF对应显示器上的第3行;</li><li>依此类推，可知，偏移FOO~F9F 对应显示器上的第25 行。</li></ul></li><li><p>在一行中，<strong>一个字符占两个字节的存储空间(一个字)，低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节</strong>。即在一行中:</p><ul><li>00~01单元对应显示器上的第 1列:</li><li>02~03单元对应显示器上的第2列</li><li>04~05单元对应显示器上的第3 列</li><li>依此类推，可知，9E~9F 单元对应显示器上的第 80 列</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ID: 2021100001, Name: Lu Shuaichao&#x27;</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>                <span class="hljs-comment">;es 控制打印到屏幕上</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">070eh</span>    <br><br><span class="hljs-comment">;bp 控制打印在屏幕上具体的位置。显示器中间的位置为第 12 行（一共25行嘛），对应的偏移为06e0h（11*160）。</span><br><span class="hljs-comment">;要打印的内容共 34 个字符，每个字符占两字节，每行占 160个字节，所以要从与行首位置偏移为 46（002eh）的位置写入，这个位置刚好为中间的位置。</span><br><span class="hljs-comment">;06e0h + 002eh 最终可得出应从偏移为 070eh 的位置开始写入。</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">00000100b</span>          <span class="hljs-comment">;dl 寄存器存放颜色属性</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">34</span>                <span class="hljs-comment">;一次打印循环次数</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s2:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">dl</span>          <span class="hljs-comment">;每次向显存中写入一个字符（两个字节）</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>                   <span class="hljs-comment">;下一个字符</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">loop</span> s2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s0:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验10-编写子程序">实验10 编写子程序</h2><hr /><p>1.显示字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-number">0</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>           <span class="hljs-comment">;指定行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>           <span class="hljs-comment">;指定列号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>   <span class="hljs-comment">;指定颜色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> show_str<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">show_str:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;设置es为显示区段地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>       <span class="hljs-comment">;每行80个字符，一共占160个字节</span><br><span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span>             <span class="hljs-comment">;设置字符显示在哪行</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>          <span class="hljs-comment">;加两次是因为一个字符占两个字节，</span><br> <span class="hljs-comment">;比如屏幕上的一个字母a，它就占两个字节，一个字节是ascii码，一个字节是属性</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;bx是显示区的偏移地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>         <span class="hljs-comment">;颜色属性存入al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">a:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]     <span class="hljs-comment">;ds:[si]是当前指向的字符</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jcxz</span> ok           <span class="hljs-comment">;读到0就退出循环</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span>     <span class="hljs-comment">;第一个是字母</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;第二个是属性</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">jmp</span> short a<br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ok:</span> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">ret</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><p>2.数值显示（加上判断溢出后的代码没看懂）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stack<br>data <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">10</span> dup(<span class="hljs-number">0</span>)<br>data ends<br> <br>stack <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">dw</span> <span class="hljs-number">16</span> dup(<span class="hljs-number">0</span>)    <span class="hljs-comment">;32字节</span><br>stack ends<br> <br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,data    <span class="hljs-comment">;设置ds段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,stack    <span class="hljs-comment">;设置栈顶</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">20H</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">12666</span>     <span class="hljs-comment">;要显示的数据</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>         <span class="hljs-comment">;ds:si指向字符串首地址</span><br>    <span class="hljs-keyword">call</span> dtoc        <span class="hljs-comment">;将数据转为十进制字符</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;在屏幕第几行开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>    <span class="hljs-comment">;在屏幕第几列开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;显示的字符的颜色</span><br>    <span class="hljs-keyword">call</span> show_str<br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00H</span>    <span class="hljs-comment">;程序返回</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21H</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">dtoc:</span>    <span class="hljs-comment">;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si</span><br>            <span class="hljs-comment">;参数：ax 指定的word数据 </span><br>            <span class="hljs-comment">;返回：ds:si指向data段字符串首地址</span><br>    <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;    ;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><span class="hljs-comment">;</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">000aH</span>    <span class="hljs-comment">;bl = 除数，bh = 一共除了几次</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;即将进行除法，dx是高16位，低16位在ax中</span><br><span class="hljs-symbol">pushyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">bl</span>    <span class="hljs-comment">;cx = 除数</span><br>    <span class="hljs-keyword">call</span> divdw    <span class="hljs-comment">;调用不会溢出的除法函数，结果的商的高16位，在dx中，</span><br>                    <span class="hljs-comment">;低16位在ax中，余数在cx中，余数一定&lt;10</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;cx=余数，这个余数在显示的时候要倒序显示，因此先压入栈</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-number">bh</span>         <span class="hljs-comment">;记录将余数压入栈的次数</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">ax</span>      <span class="hljs-comment">;cx = ax = 结果的商的低16位</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>      <span class="hljs-comment">;dx是结果的商的高16位，ax和dx一定都是非负数</span><br>    <span class="hljs-keyword">jcxz</span> popyushu        <span class="hljs-comment">;若cx=0，则说明除法计算已经完毕，跳转下一步执行</span><br>    <span class="hljs-keyword">jmp</span> short pushyushu<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">popyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">bh</span>    <span class="hljs-comment">;ch=0，所以cx = 将余数压入栈的次数，也就是接下来的循环次数</span><br><span class="hljs-symbol">s1:</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">;            ;从栈中pop出一个余数</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">30H</span>         <span class="hljs-comment">;从数字转为对应的数字字符</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span>     <span class="hljs-comment">;用al就够了</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">loop</span> s1<br>    <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span>    <span class="hljs-comment">;子程序结束，将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;</span><br>    <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">divdw:</span>      <span class="hljs-comment">;功能：计算word型被除数与byte型除数的除法</span><br>            <span class="hljs-comment">;参数：  ax=被除数低16位，dx=被除数高16位，cx = 除数</span><br>            <span class="hljs-comment">;返回：  ax=商的低16位，dx=商的高16位，cx = 余数</span><br> <br>    <span class="hljs-comment">;计算公式： X/N = int( H/N ) * 65536 + [rem( H/N) * 65536 + L]/N  </span><br>    <span class="hljs-comment">;其中X为被除数，N为除数，H为被除数的高16位，L为被除数的低16位，</span><br>    <span class="hljs-comment">;int()表示结果的商，rem()表示结果的余数。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>      <span class="hljs-comment">;bx是额外用到的寄存器，要压入栈</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx=L</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>    <span class="hljs-comment">;ax=H</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>     <span class="hljs-comment">;dx=0</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，</span><br>                    <span class="hljs-comment">;因此计算结果就是，高16位=int(H/N)，低16位为0000H。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的低16位，即0000H，压入栈</span><br> <br>                    <span class="hljs-comment">;接下来要计算 rem(H/N)*65536 ，同理可得，</span><br>                    <span class="hljs-comment">;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，</span><br>                    <span class="hljs-comment">;低16位为 0000H。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>     <span class="hljs-comment">;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要将两项求和。  左边项的高、低16位都在栈中，</span><br>                    <span class="hljs-comment">;其中高16位就是最终结果的高16位，低16位是0000H。</span><br>                    <span class="hljs-comment">;右边项的商为16位，在ax中，也就是最终结果的低16位，</span><br>                    <span class="hljs-comment">;余数在dx中，也就是最终结果的余数。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>     <span class="hljs-comment">;cx = 最终结果的余数</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>        <span class="hljs-comment">;cx = int(H/N)*65536结果的低16位，即0000H。</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;bx = int(H/N)*65536结果的高16位，即最终结果的高16位</span><br> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>    <span class="hljs-comment">;还原bx的值</span><br> <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">show_str:</span><br>                <span class="hljs-comment">;功能：将data段中首地址为ds:si的字符，以指定颜色显示在屏幕指定位置</span><br>                <span class="hljs-comment">;参数：dh 行号， dl 列号 ，cl 颜色</span><br>                <span class="hljs-comment">;返回：无</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span>    <span class="hljs-comment">;设置es为显示区段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>    <span class="hljs-comment">;设置首字符显示的地址</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx是显示区的偏移地址</span><br>        <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>    <span class="hljs-comment">;用al存储属性字节</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">    s:</span>                <span class="hljs-comment">;循环读取字符并显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>    <span class="hljs-keyword">jcxz</span> ok            <span class="hljs-comment">;若读到0，就退出循环</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">jmp</span> short s<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    ok:</span>        <span class="hljs-comment">;将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br>    <br>    <span class="hljs-keyword">ret</span>    <span class="hljs-comment">;返回</span><br> <br> <br>code ends<br>end start<br> <br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验12-编写0号中断的处理程序">实验12 编写0号中断的处理程序</h2><hr /><p>1.编写 0 号中断的处理程序并将其安装在 0:200处，使得在除法溢出发生时，屏幕中间自动显示字符串“divideoverflow!”,然后返回到DOS。安装完中断处理程序后，编写针对该中断处理程序的测试程序，并运行测试程序，检查是否正确触发中断处理程序。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset do0                <span class="hljs-comment">;设置ds:si指向源地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>                      <span class="hljs-comment">;设置es:di指向目的地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset do0end-offset do0  <span class="hljs-comment">;cx为传输长度</span><br><span class="hljs-keyword">cld</span>                              <span class="hljs-comment">;传输方向为正</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将do0的代码送入0:200处</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">200h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">2</span>],<span class="hljs-number">0h</span>     <span class="hljs-comment">;设置中断向量</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   do0:</span><span class="hljs-keyword">jmp</span> short do0start       <span class="hljs-comment">;EB10 占两个字节，所以下面是202h，不是200h</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&quot;divide overflow!&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> do0start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>      <span class="hljs-comment">;设置ds:si指向字符串</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">12</span>*<span class="hljs-number">160</span>+<span class="hljs-number">33</span>*<span class="hljs-number">2</span>    <span class="hljs-comment">;设置es:di指向显存空间的中间位置</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">16</span>             <span class="hljs-comment">;cx为字符串长度</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-number">2H</span>  <br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">do0end:</span><span class="hljs-keyword">nop</span><br><br>   <br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">1h</span><br><span class="hljs-keyword">div</span> <span class="hljs-number">bh</span><br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验13-编写0号中断的处理程序">实验13 编写0号中断的处理程序</h2><hr /><p>编写并安装 int 7ch 中断例程，功能为以“年/月/日时:分:秒”的格式，在屏幕中间显示当前的日期、时间。中断例程安装在 0:200处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset a           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset aend-offset a      <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                               <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>  <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   a:</span>   <span class="hljs-keyword">jmp</span> short astart<br>   <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;9/8/7 4:2:0&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">astart:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>     <span class="hljs-comment">;ds:si指向数据段</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">160</span>*<span class="hljs-number">12</span>+<span class="hljs-number">30</span>*<span class="hljs-number">2</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>              <span class="hljs-comment">;es:di指向显示缓冲区</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   s:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span><br>    <span class="hljs-keyword">jb</span> no      <br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">57</span><br>    <span class="hljs-keyword">ja</span> no  <span class="hljs-comment">;ASCII码值小于48或大于57则转移至no,即不是数字就直接显示</span><br><br>    <span class="hljs-keyword">call</span> yes          <span class="hljs-comment">;是数字就转移到yes处执行</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">loop</span> s<br><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>  <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   no:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">far</span> <span class="hljs-built_in">ptr</span> s    <span class="hljs-comment">;段间转移至s处</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   yes:</span> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span> <span class="hljs-comment">;字符转换为整数</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">shr</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">00001111b</span><br><br>        <span class="hljs-keyword">add</span> <span class="hljs-number">ah</span>,<span class="hljs-number">30h</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">30h</span><br><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-number">ah</span>     <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>+<span class="hljs-number">2</span>],<span class="hljs-built_in">al</span>     <br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      aend:</span> <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">7ch</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><span class="hljs-comment">;问题：刚开始没注意到 db 中，即数据段中的数字是 ascii 码。</span><br><span class="hljs-comment">;解决办法：sub cl,48 ;将字符转换为整数</span><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验15-安装新的-int9-中断例程">实验15 安装新的 int9中断例程</h2><hr /><p>安装一个新的 int 9 中断例程，功能：在 DOS下，按下“A”键后，如果松开，则显示满屏幕的“A”（字符显示属性为蓝底高亮红色），其他键照常处理。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-comment">;(有点8懂)</span><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>stack <span class="hljs-meta">segment</span><br>  <span class="hljs-built_in">db</span> <span class="hljs-number">128</span> dup (<span class="hljs-number">0</span>)<br>stack ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">128</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int9<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int9end-offset int9     <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                   <span class="hljs-comment">;设置传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">200h</span>]<br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">202h</span>]             <span class="hljs-comment">;将原int 9中断例程的入口地址保存在0:200单元处</span><br><br>        <span class="hljs-keyword">cli</span>                            <span class="hljs-comment">;设置IF=0，不响应可屏蔽中断</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>],<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>      <span class="hljs-comment">;将新的int 9中断例程安装在0:204处</span><br>        <span class="hljs-keyword">sti</span>                            <span class="hljs-comment">;设置IF=1，响应可屏蔽中断</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">60h</span>                     <span class="hljs-comment">;从端口60h读出键盘的输入</span><br><br>        <span class="hljs-keyword">pushf</span><br>        <span class="hljs-keyword">call</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-number">200h</span>]      <span class="hljs-comment">;调用BIOS的int 9中断例程</span><br><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">9eh</span><br>        <span class="hljs-keyword">jne</span> int9ret<br>    <br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-string">&#x27;A&#x27;</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1ch</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">ah</span> <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9ret:</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">iret</span>  <span class="hljs-comment">;前面没call就险先写iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9end:</span><span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验16-编写包含多个功能子程序的中断例程">实验16编写包含多个功能子程序的中断例程</h2><hr /><ul><li>安装一个新的 int 7ch 中断例程，为显示输出提供如下功能子程序。<ul><li>（1）清屏；</li><li>（2）设置前景色；</li><li>（3）设置背景色；</li><li>（4）向上滚动一行。</li></ul></li><li>入口参数说明如下：<ul><li>（1） 用 ah 寄存器传递功能号：0 表示清屏；1 表示设置前景色；2表示设置背景色；3 表示向上滚动一行；</li><li>（2） 对于 1、2 号功能，用 al 传递颜色值，(al)∈{0,1,2,3,4,5,6,7}。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int7c           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int7cend-offset int7c            <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                            <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                                      <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>    <br>        <span class="hljs-keyword">cli</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br>        <span class="hljs-keyword">sti</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">int7c:</span>  <span class="hljs-keyword">jmp</span> short setscreen<br><br><span class="hljs-comment">; 这里要注意，在安装程序中的sub1是一串数据，在中断例程安装在0:200h中时 如果仍然按照第十六章那样设置，是无法成功调用子程序的，</span><br><span class="hljs-comment">; 因为主程序运行完毕以后,主程序所占的内存可能会被其他内容覆盖，所以我们要把子程序安装在中断例程之后的内存中</span><br><span class="hljs-comment">; 当然这样会存在一个问题，如果中断例程并没有安装在0:200处，则table中的值也要相应改动</span><br><span class="hljs-comment">; 至于为什么子程序中的sub1s,sub2s以及loop指令还能正常工作，是因为这是基于位移的跳转</span><br><span class="hljs-comment">; 即在主程序中，相应的loop/jmp指令已经编译为回退/前进xx字节的指令，因此不会受位置移动的影响</span><br><br>  table<span class="hljs-built_in">dw</span> sub1-int7c+<span class="hljs-number">200h</span>,sub2-int7c+<span class="hljs-number">200h</span>,sub3-int7c+<span class="hljs-number">200h</span>,sub4-int7c+<span class="hljs-number">200h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> setscreen:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>  <br>  <span class="hljs-keyword">cmp</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span><span class="hljs-comment">; 判断功能号是否大于3</span><br>  <span class="hljs-keyword">ja</span> sret<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-number">ah</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">; 根据ah提供的功能号找到对应子程序在table中的偏移</span><br>  <br>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>  <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>  <span class="hljs-keyword">call</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>+<span class="hljs-number">2</span>]<span class="hljs-comment">; 调用</span><br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  sret:</span>   <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>  <span class="hljs-keyword">iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub1:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                 <span class="hljs-comment">;1号子程序,清屏</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub1s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub1s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub2:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>              <span class="hljs-comment">;2号子程序,设置前景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub2s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">11111000b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub2s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub3:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                <span class="hljs-comment">;3号子程序,设置背景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>            <span class="hljs-keyword">shl</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub3s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">10001111b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub3s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub4:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>            <span class="hljs-comment">;4号子程序,向上滚动一行</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">cld</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">24</span><br><span class="hljs-symbol">    sub4s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> sub4s<br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">80</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    sub4s1:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-number">160</span>*<span class="hljs-number">24</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub4s1<br>            <br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int7cend:</span>  <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言检测点</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-基础知识">第一章 基础知识</h2><h3 id="检测点-1.1">检测点 1.1</h3><p><a href="https://freeimage.host/i/HrT21vs"><imgsrc="https://iili.io/HrT21vs.md.png" alt="HrT21vs.md.png" /></a></p><p>（1）<strong>13</strong></p><ul><li>寻址能力：一个CPU有N根地址线，则这个CPU的地址总线的宽度为N，最多可以寻找2的N次方个内存单元。</li><li>地址总线的宽度决定了CPU 的寻址能力。</li><li>\( 2^{N} = 8KB = 8*1024B = 2^{13}B \)，N为地址总线宽度，N=13</li></ul><p>（2）<strong>1024，0，1023</strong> -一个存储单元占一个字节（即1B），故1KB的存储器有1024个存储单元，存储单元编号从0~1023。</p><p>（3）<strong>8192，1024</strong> - 1千字节（KB）= 1024字节（B） -1字节（Byte）= 8比特（bit）</p><p>（4）<strong>\( 2^{30}， 2^{20}， 2^{10}\)</strong></p><p>（5）<strong>64KB，1MB，16MB，4GB</strong> -8080CPU地址总线宽度为16，寻址能力为\(2^{16} = 2^6KB = 64KB\) -其余同理</p><p>（6）<strong>1，1，2，2，4</strong> -8根数据总线一次可传送一个8位二进制数据（即一个字节）</p><p>（7）<strong>512，256</strong> - 8086CPU数据总线16根，一次可读2个字节,1024/2=512</p><p>（8）<strong>二进制</strong></p><h2 id="第二章-寄存器">第二章 寄存器</h2><h3 id="检测点-2.1">检测点 2.1</h3><p><a href="https://freeimage.host/i/H4naDZb"><imgsrc="https://iili.io/H4naDZb.md.png" alt="H4naDZb.md.png" /></a></p><ol type="1"><li><p>有点简单，注意溢出即可，如：C5H+93H=158H，而al只有8位，所以al=58H，从而AX=0058H</p></li><li><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mov</span> ax,<span class="hljs-number">2</span>     ;<span class="hljs-number">2</span>的<span class="hljs-number">1</span>次方 = <span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">2</span>次方 = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">3</span>次方 = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> = <span class="hljs-number">8</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">4</span>次方 = <span class="hljs-number">8</span> + <span class="hljs-number">8</span> = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="检测点-2.2">检测点 2.2</h3><p><a href="https://freeimage.host/i/H4pjm0v"><imgsrc="https://iili.io/H4pjm0v.md.png"alt="H4pjm0v.md.png" /></a></p></li></ol><p>（1）<strong>00010H到1000FH</strong> - 基础地址（段地址*16）+偏移地址 = 物理地址 -偏移地址16位，变化范围为0~FFFFH，仅用偏移地址最多可寻址64KB -给定段地址为0001H，寻址范围为（0001H×16）+0到（0001H×16）+FFFFH，即寻址范围为0010H到1000FH</p><p>（2）<strong>最小为 1001H ，最大为 2000H</strong></p><ul><li>段地址<em>16+偏移地址=物理地址，即SA</em>16+EA=20000H；偏移地址16位，变化范围为0~FFFFH；</li><li>当偏移地址取最大值FFFFH时，段地址最小，SA=(20000H-FFFFH)/16=1001H（<strong>取上界</strong>）</li><li>当偏移地址取最小值0H时，段地址最大，SA=(20000H-0H)/16=2000H。</li></ul><p>思考：当段地址给定为小于1001H或大于2000H时，CPU无论怎么变化偏移地址都无法寻到20000H单元。</p><h3 id="检测点-2.3">检测点 2.3</h3><p><a href="https://freeimage.host/i/H4pvW0u"><imgsrc="https://iili.io/H4pvW0u.md.png" alt="H4pvW0u.md.png" /></a></p><ul><li><p>一共修改了4次。</p></li><li><p>读取 mov ax,bx 指令后，第一次修改IP</p></li><li><p>读取 sub ax,ax 指令后，第二次修改IP</p></li><li><p>读取 jmp ax 指令后，第三次修改IP</p></li><li><p>执行 jmp ax 指令时，第四次修改IP，最后IP=ax=0</p><p><strong>略了，有时间再补，最近期末复习时间太紧了</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言知识点复习</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://freeimage.host/i/H4BEW1R"><imgsrc="https://iili.io/H4BEW1R.md.jpg" alt="H4BEW1R.md.jpg" /></a></p><h2 id="tips">tips</h2><ul><li><p><strong>使用debug××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。</strong></p></li><li><p>inc bx 等价于add bx,1</p></li><li><p>XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusiveor。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XORAX, AX 可以将 AX 寄存器中的值清零。</p></li><li><p>在汇编源程序中，数据不能以字母开头</p></li><li><p>遇到loop指令时，使用P命令来执行。Debug就会自动重复执行循环中的指令，直到(cx)=0为止</p></li><li><p>DOSBOX中，int 21 后面要用 p 指令来结束。</p></li><li><p>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p><ul><li><strong>“dw”</strong>的含义是定义字型数据。dw即“define word”。</li><li>在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节</li></ul></li><li><p>db 字节型，dd双字型</p></li><li><p>通过<strong>DS=0B2D</strong>，可以知道程序从<strong>0B3D:0000</strong>开始存放</p></li><li><p>NOT 实现按位取反，例如(AL)=00010010B，则 NOT AL使得（AL）=11101101B。XOR 为异或运算。</p></li><li><p><strong>var dd 252 dup(10)</strong></p><ul><li>var dd 252 dup(10) 是一种伪指令，用于在汇编语言中定义一个名为 var的变量，并初始化它为重复出现的值。</li><li>根据这个伪指令的语法，252 是要重复的次数，dup(10) 表示要重复的值为10。因此，该指令的作用是将值为 10 的双字型数据重复 252次，然后存储到名为 var 的变量中。</li></ul></li><li><p>VAR3 DB 'HOW ARE YOU?','$'，，，VAR3 = 13 字节 (12 + 1)</p></li><li><p>VAR2 DW 5DUP(?),0，，，，，VAR2 = 12 字节 (5 * 2 + 2)</p></li><li><p>段地址（SA）Segment Address 和 偏移地址（EA）EffectiveAddress</p></li><li><p>要用八位二进制表示 -9 的补码，可以按照以下步骤进行计算：</p><ul><li>将 -9 的<strong>绝对值</strong>转换为二进制。9 的二进制表示为00001001。</li><li>获取 9 的反码。即将二进制数的每一位取反，得到 11110110。</li><li>将反码加 1 得到补码。在这种情况下，11110110 + 1 = 11110111。</li><li>因此，-9 在八位二进制补码表示中为 11110111。十六进制为F7</li></ul></li><li><p>dec bx ;dec指令和inc指令的功能相反，dec bx 进行操作为：(bx) =(bx) - 1</p></li><li><p><strong>mul是乘法指令</strong>，使用 mul 做乘法的时候：</p><ul><li>相乘的两个数：要么都是8位，要么都是16位。<ul><li>8 位：一个默认放在 AL中 ，另一个放在8位寄存器或内存字节单元中；</li><li>16 位： 一个默认放在AX中，另一个放在16 位寄存器或内存字单元中。</li></ul></li><li>结果<ul><li>8位：AX中；</li><li>16位：DX（高位）和AX（低位）中。</li></ul></li><li>格式如下：<ul><li>mul reg</li><li>mul 内存单元</li></ul></li><li>比如：mul byte ptr ds:[0]<ul><li>含义为： (ax)=(al) * ((ds) * 16+0)</li></ul></li><li>mul word ptr [bx+si+8]<ul><li>含义为：</li><li>(ax)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的低16位；</li><li>(dx)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的高16位；</li></ul></li></ul></li><li><p>小写字母的ASCII码范围61H-7AH</p></li><li><p>一般情况下：从<strong>0000:0200至0000:02FF</strong>的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用</p></li><li><p>(IP) = 5，说明 ss:sp = 5，</p></li></ul><h2 id="第1章-基础知识">第1章 基础知识</h2><hr /><h3 id="基础概念">基础概念</h3><ol type="1"><li><p>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</p></li><li><p>汇编语言的主体是汇编指令。</p></li><li><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。汇编指令是机器指令的助记符。</p></li><li><p>汇编语言由以下3类指令组成：</p><ol type="1"><li>汇编指令：机器码的助记符，有对应的机器码。</li><li>伪指令：由编译器执行，没有对应的机器码，计算机并不执行。</li><li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</li></ol></li><li><p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p><ol type="1"><li>存储单元的地址（地址信息）；</li><li>器件的选择，读或写命令（控制信息）；</li><li>读或写的数据（数据信息）。</li></ol></li><li><p>CPU是通过<strong>地址总线</strong>来指定存储器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</p></li><li><p>CPU与内存或其它器件之间的数据传送是通过<strong>数据总线</strong>来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。</p></li><li><p>8088CPU数据总线宽度为8，<strong>8086CPU</strong>数据总线宽度为16。</p></li><li><p><strong>控制总线</strong>：有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p></li></ol><ul class="task-list"><li><label><input type="checkbox"checked="" />前面所讲的内存读或写命令是由几根控制线综合发出的：其中有一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出<strong>低电平</strong>表示将要读取数据；</label></li></ul><ol start="10" type="1"><li><p>b：bit，B：Byte</p></li><li><p>1B = 8b，1KB = 1024B，1MB = 1024KB，1GB = 1024MB</p></li><li><p>将各类存储器看作一个逻辑存储器：所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p></li><li><p>8086PC机的内存地址空间分配：<ahref="https://freeimage.host/cn"><img src="https://iili.io/H4BhK0b.png"alt="H4BhK0b.png" /></a></p></li><li><p>图 1.9 告诉我们，从地址 0 ~ 9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000~ BFFFF的内存单元中写数据，就是向显存中写入数据,这些数据会被显示卡输出到显示器上；我们向地址CO00O ~ FFFFF的内存单元中写入数据的操作是<em>无效的</em>，因为这等于改写只读存储器中的内容。</p></li><li><p>内存地址空间：最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的<em>内存地址空间</em>。😭</p></li></ol><h2 id="第2章-寄存器">第2章 寄存器</h2><hr /><h3 id="基础概念-1">基础概念</h3><ol type="1"><li><p>8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&gt;AX：accumulator register，累加器寄存器 &gt; &gt;BX： baseregister，基数寄存器 &gt; &gt;CX： count register，计数寄存器 &gt;&gt;DX：data register，通用数据寄存器 &gt; &gt;SI：sourceindex，源变址寄存器 &gt; &gt;DI：destination index，目的变址寄存器 &gt;&gt;SP：stack pointer，堆栈指针寄存器 &gt; &gt;BP：basepointer，基址指针寄存器，指示堆栈段中一个数据区的基址位置，通常与SS配对&gt; &gt;IP：instruction pointer，码段地址指针寄存器 &gt; &gt;CS：codesegment，代码段寄存器 &gt; &gt;SS：stacksegment，堆栈段~，存放当前堆栈段的段地址，一般和SP连用 &gt; &gt;DS：datasegment，数据段~，存放当前数据段的段地址 &gt; &gt;ES：extrasegment，附加段~ &gt; &gt;PSW：program state word，标志~</p></li><li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p></li><li><p>AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。</p></li><li><p>一个16位寄存器所能存储的数据的最大值为多少？<br />答案：2^16-1=65535。</p></li><li><p>汇编指令不区分大小写。</p></li><li><p>8086有20位地址总线，可传送20位地址，寻址能力为1M。</p></li><li><p>地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位。</p></li><li><p>“段地址×16+偏移地址=物理地址”的本质含义是： CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p></li><li><p>有两点需要注意：段地址✖16 必然是 16的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16位地址的寻址能力为 64KB，所以<em>一个段的长度最大为 64KB</em>。</p></li><li><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p></li><li><p>8086PC工作过程的简要描述</p><ol type="1"><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</li><li>IP = IP + 所读取指令的长度，从而指向下一条指令；</li><li>执行指令。 转到步骤 （1），重复这个过程。</li></ol></li><li><p><strong>mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。</strong></p></li></ol><h2 id="第3章-寄存器内存访问">第3章 寄存器（内存访问）</h2><hr /><h3 id="基础概念-2">基础概念</h3><ol type="1"><li>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）</li></ol><ul><li>mov ds,1000H 是非法的。</li><li>数据 → 一般的寄存器 → 段寄存器</li></ul><ol start="2" type="1"><li><p><strong>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。</strong></p></li><li><p>合法格式：</p></li></ol><ul><li>mov 寄存器，寄存器/内存单元/段寄存器/立即数</li><li>mov 内存单元，寄存器/段寄存器/立即数</li><li>mov 段寄存器，寄存器/内存单元 ~注意：</li><li>mov指令中的目的操作数不能是立即数、IP和CS寄存器；</li><li>mov指令中不允许在两个存储单元之间直接传送数据；</li><li>mov指令中不允许在两个段寄存器之间直接传送数据；</li><li>mov指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）。</li></ul><ol start="4" type="1"><li>栈：</li></ol><ul><li><p>8086CPU提供了栈操作机制，方案如下：在SS，SP中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，他们根据SS:SP指示的地址，按照栈的方式访问内存单元。</p></li><li><p><strong>push指令的执行步骤</strong>：</p><ol type="1"><li>SP=SP-2；</li><li>向SS:SP指向的字单元中送入数据。</li></ol></li><li><p><strong>pop指令的执行步骤</strong>：</p><ol type="1"><li>从SS:SP指向的字单元中读取数据；</li><li>SP=SP+2。</li></ol></li><li><p>任意时刻，SS:SP指向栈顶元素。</p></li><li><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p></li><li><p>用栈来暂存以后需要恢复的寄存器的内容时 ，寄存器出栈的顺序要和入栈的顺序相反。</p></li><li><p>push、pop实质上是一种内存传送指令，注意它们的灵活应用。</p></li></ul><ol start="5" type="1"><li><p>一个栈段的容量最大为64KB。</p></li><li><p>如果我们将10000H~1FFFFH这段空间当作栈段，初始状态是空的，此时，SS=1000H，SP=？、、、答案：0，（SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H，SP=0。）</p></li><li><p><strong>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。</strong></p><ul><li>我们可以用一个段存放数据，将它定义为“数据段”</li><li>我们可以用一个段存放代码，将它定义为“代码段”</li><li>我们可以用一个段当作栈，将它定义为“栈段”</li></ul><p>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：</p><ul><li>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li><li>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li><li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP中，这样CPU在需要进行栈操作的时候，比如执行 push、pop指令等，就将我们定义的栈段当作栈空间来用。</li><li>可见，不管我们如何安排 ，CPU 将内存中的某段内存当作代码，是因为CS:IP指向了那里；CPU将某段内存当作栈 ，是因为 SS:SP指向了那里。</li></ul></li></ol><h2 id="第4章-第一个程序">第4章 第一个程序</h2><hr /><h3 id="基础概念-3">基础概念</h3><ol type="1"><li><p>DOS系统中.EXE文件中的程序的加载过程： <ahref="https://freeimage.host/i/H6suidv"><imgsrc="https://iili.io/H6suidv.md.png"alt="H6suidv.md.png" /></a></p></li><li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0 ，则<strong>程序所在的内存区的地址为：ds:0</strong>；这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。 从256字节处向后的空间存放的是程序。</p></li><li><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0。因为PSP占256（100H）字节，所以<strong>程序的物理地址</strong>是：<em>SA×16+0+256=SA×16+16×16=（SA+16）×16+0</em>可用段地址和偏移地址表示为：<strong>SA+10:0</strong>。</p><ul><li>如：DS=129E，则PSP的的地址为129E:0，程序的地址为12AE:0。</li></ul></li><li><p>一个源程序从写出到执行的过程：<strong>编写、编译、连接、执行</strong>（使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。）</p></li><li><p>说明<strong>伪指令和汇编指令的区别</strong>：汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，是由编译器来执行的。</p></li><li><p>说明汇编语言程序中<strong>标号的作用</strong>：汇编源程序中一个标号指代了一个地址，比如codesg在segment的前面，作一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p></li></ol><h2 id="第5章-bx和loop指令">第5章 [bx]和loop指令</h2><hr /><h3 id="基础概念-4">基础概念</h3><ol type="1"><li><p>描述性符号“()”，例如：对于push ax的功能，我们可以这样来描述：</p><ul><li>(sp) = (sp)-2</li><li>((ss) * 16＋(sp))=(ax)</li></ul></li><li><p>(2000:0)、((ds):1000H)等是错误的用法</p></li><li><p>(ax)、(ds)、(al)、(2000H)、((ds) *16+(bx))等是正确的用法</p></li><li><p>指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作：</p><ol type="1"><li>(cx)=(cx)-1；</li><li>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li></ol></li><li><p>ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间</p></li><li><p><strong>我们在Debug中写过类似的指令：<code>mov ax,[0]</code>表示将ds:0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>处理。</strong></p></li><li><p>为防止上述情况发生，在源程序中，可采用两种方法访问2000:0单元：</p></li></ol><ul><li><p>方法一： <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br></code></pre></td></tr></table></figure></p></li><li><p>方法二： <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]                 一般用第二种方法<br></code></pre></td></tr></table></figure></p></li></ul><ol start="8" type="1"><li><p>DOS方式下，一般情况， 0:200 ~ 0:2FF空间中没有系统或其他程序的数据或代码；以后，我们需要直接向一段内存中写入内容时，就使用0:200~ 0:2FF这段空间。</p></li><li><p>利用栈对CX寄存器内容进行保护push和恢复pop可以实现多重loop循环。如：</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, m<br><span class="hljs-symbol">s1:</span>          <span class="hljs-comment">;循环体1</span><br> <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,n<br><span class="hljs-symbol">s2:</span>          <span class="hljs-comment">;循环体2</span><br> <span class="hljs-keyword">loop</span> s2<br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">loop</span> s1<br></code></pre></td></tr></table></figure><h3 id="程序">程序</h3><ol type="1"><li>将内存ffff:0~ffff:b段单元中的数据拷贝到 0:200~0:20b单元中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offffh<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;al作为中转寄存器</span><br><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">loop</span> s<br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编写程序片断，利用 loop 指令，实现斐波那契数列前 9 个数字1、1、2、3、5、8、13、21、34 的求和，并将求和结果保存到内存字单元 0:200中</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;ax中的值依次为1、1、2、3、5、8、13、21、34      </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;来存最后的计算结果</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">9</span>    <span class="hljs-comment">;循环次数</span><br><span class="hljs-symbol"> s:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">ax</span><br><br> <span class="hljs-keyword">loop</span> s<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">200h</span>],<span class="hljs-built_in">dx</span><br> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br> <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><h2 id="第6章-包含多个段的程序">第6章 包含多个段的程序</h2><hr /><h3 id="基础概念-5">基础概念</h3><ol type="1"><li><p>我们在源程序中用伪指令 “assumecs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连。这样做了之后，CPU是否就会将cs指向ode，ds 指向 data，ss指向stack，从而按照我们的意图来处理这些段呢？</p></li><li><p>当然也不是，要知道 assume是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。我们不必深究assume的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。</p></li><li><p>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。</p></li><li><p>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p></li></ol><h2 id="第7章-更灵活的定位内存地址的的方法">第7章更灵活的定位内存地址的的方法</h2><hr /><h3 id="基础概念-6">基础概念</h3><ol type="1"><li><p>（1）and 指令：逻辑与指令，按位进行与运算。（2）or指令：逻辑或指令，按位进行或运算。</p></li><li><p>在ASCII编码方案中，用61H 表示“a”，62H表示“b”。用41H表示“A”，42H表示“B”。</p></li><li><p>就ASCII码的二进制形式来看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。大写字母ASCII码的第5位（位数从0开始计算）为0，小写字母的第5位为1。</p></li><li><p>or al,00100000b;将al中的ASCII码的第5位置为1，变为小写字母</p></li><li><p>and al,11011111b ;将al中的ASCII码的第5位置为0，变为大写字母</p><ul><li><strong>and byte ptr[si],11011111b</strong>，等到了后面就是这样了</li></ul></li><li><p>指令<strong>movax,[bx+200]也可以写成如下格式（常用）</strong>：</p><ul><li>mov ax,[200+bx]</li><li><strong>mov ax,200[bx]</strong></li><li>mov ax,[bx].200</li></ul></li><li><p>SI(source index register)和DI(destination indexregister)是8086CPU中和bx功能相近的寄存器，<strong>SI和DI不能够分成两个8位寄存器来使用</strong>。</p></li><li><p>指令mov ax,[bx+si]的数学化的描述为：(ax)=( (ds) * 16+(bx)+(si))。 该指令也可以写成如下格式（常用）：mov ax,[bx][si]</p></li><li><p>指令mov ax,[bx+si+200]，该指令也可以写成如下格式（常用）：</p><ul><li>mov ax,[bx+200+si]</li><li>mov ax,[200+bx+si]</li><li>mov ax,200[bx][si]</li><li>mov ax,[bx].200[si]</li><li>mov ax,[bx][si].200</li></ul></li></ol><h2 id="第8章-数据处理的两个基本问题">第8章 数据处理的两个基本问题</h2><hr /><h3 id="基础概念-7">基础概念</h3><ol type="1"><li><p>我们将使用reg来表示一个寄存器，用sreg表示一个段寄存器。reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；sreg的集合包括：ds、ss、cs、es。</p></li><li><p>在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]”中来进行内存单元的寻址。</p></li><li><p>在“[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p></li><li><p><strong>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</strong>。</p></li><li><p>mov ax,1 对应机器码：B80100；mov ax,076a的机器码？B86A07</p></li><li><p>在没有寄存器名存在的情况下，用操作符<strong>Xptr</strong>指明内存单元的长度，X在汇编指令中可以为word或byte。</p></li><li><p>push指令只进行字操作</p></li><li><p>div是除法指令，使用div作除法的时候：</p><ul><li>除数：8位或16位，在寄存器或内存单元中</li><li>被除数：（默认）放在AX 或 DX（高16位）和AX（低16位）中</li><li>结果：如果除数为8位，商：AL，余数：AH；<strong>如果除数为16位，商：AX，余数：DX</strong>；</li></ul></li><li><p>div指令格式： div reg div 内存单元</p></li><li><p>div byte ptr ds:[0]</p><ul><li>含义为：(al)=(ax)/((ds) * 16+0)的商；</li><li>(ah)=(ax)/((ds) * 16+0)的余数</li></ul></li><li><p>div word ptr [bx+si+8]</p><ul><li>含义为：(ax)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的商；</li><li>(dx)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的余数</li></ul></li><li><p>dd 1，数据为00000001H，占2个字；</p></li><li><p><strong>dup</strong>是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。 它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p><ul><li>db 3 dup (0) 定义了3个字节，它们的值都是0，相当于 db 0,0,0</li><li>db 3 dup(0,1,2)定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于 db0,1,2,0,1,2,0,1,2</li><li>db 3 dup(‘abc’,’ABC’)定义了18个字节，它们是‘abcABCabcABCabcABC’，相当于db‘abcABCabcABCabcABC’</li></ul></li></ol><h2 id="第9章-转移指令的原理">第9章 转移指令的原理</h2><hr /><h3 id="基础概念-8">基础概念</h3><ol type="1"><li><p>jmp指令要给出两种信息： 转移的目的地址，转移的距离（段间转移jmp far、段内短转移jmp short，段内近转移jmpnear）</p></li><li><p><strong>jmp short 标号</strong>（转到标号处执行指令）这种格式的jmp 指令实现的是<strong>段内短转移，它对IP的修改范围为-128~127</strong>，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p></li><li><p>在“jmp short标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。这个位移，是编译器根据汇编指令中的“标号”计算出来的。</p></li><li><p>实际上，指令“jmp short 标号”的功能为(IP)=(IP)+8位位移。</p><ul><li><strong>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址</strong>；</li><li>short指明此处的位移为8位位移；</li><li>8位位移的范围为-128~127，用补码表示。</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li><p><strong>jmp near ptr</strong>标号它实现的时<strong>段内近转移</strong>。<strong>IP修改范围为：-32768~32767</strong>。</p></li><li><p>指令 <strong>jmp far ptr</strong> 标号实现的是<strong>段间转移，又称为远转移</strong>。farptr指明了指令用标号的段地址和偏移地址修改CS和IP。IP修改范围：随意。</p></li><li><p>jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址</p></li><li><p>转移地址在内存中的jmp指令有两种格式：</p><ul><li>jmp word ptr 内存单元地址（段内转移）<ul><li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li></ul></li><li>jmp dword ptr 内存单元地址（段间转移）<ul><li>功能：从内存单元地址处开始存放着两个字，<strong>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</strong>。</li><li>(CS)=(内存单元地址+2)</li><li>(IP)=(内存单元地址)</li><li>内存单元地址可用寻址方式的任一格式给出。</li></ul></li></ul></li><li><p>jcxz指令（jump if cx equalszero）为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。<strong>指令格式：jcxz标号 （如果(cx)=0，则转移到标号处执行。）</strong></p></li><li><p>jcxz 标号 指令操作：</p><ul><li>当(cx)=0时，(IP)=(IP)+8位位移）<ul><li><strong>8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；</strong></li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li>当(cx)不为0时，什么也不做（程序向下执行）。</li></ul></li><li><p>loop指令为循环指令，<strong>所有的循环指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。指令格式：loop标号</p></li></ol><h2 id="第10章-call和ret指令">第10章 CALL和RET指令</h2><hr /><h3 id="基础概念-9">基础概念</h3><ol type="1"><li><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p><ul><li>CPU执行ret指令时，相当于进行：pop IP</li></ul></li><li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p><ul><li>CPU执行retf指令时，相当于进行：<ul><li>pop IP（<strong>注意！这是违法的，只是效果</strong>）</li><li>pop CS</li></ul></li></ul></li><li><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的 IP 或 CS 和 IP 压入栈中；</li><li>转移。</li></ul></li><li><p>CPU 执行指令“call 标号”时，相当于进行：</p><ul><li>push IP</li><li>jmp near ptr 标号</li></ul></li><li><p>call s在指令缓冲器时，IP已经改变了，指向了下一条指令，suoooooo以，<strong>call指令指向时将下一条指令的IP入栈</strong>。</p></li><li><p>CPU 执行指令 “call far ptr 标号”时，相当于进行：</p><ul><li>push CS</li><li>push IP</li><li>jmp far ptr 标号</li></ul></li><li><p>CPU执行call 16位reg时，相当于进行：</p><ul><li>push IP</li><li>jmp 16位寄存器</li></ul></li><li><p>call word ptr 内存单元地址， 汇编语法解释：</p><ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li><li><p>call dword ptr 内存单元地址， 汇编语法解释：</p><ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li></ol><h2 id="第11章-标志寄存器">第11章 标志寄存器</h2><hr /><h3 id="基础概念-10">基础概念</h3><ol type="1"><li><p>flag的第6位是<strong>ZF（zeroflag），零标志位</strong>。它记录相关指令执行后，其结果是否为0</p><ul><li>结果为0 ，ZF = 1</li><li>结果不为0，ZF = 0</li></ul></li><li><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：<strong>add、sub、mul、div、inc、or、and</strong>等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p></li><li><p>flag的第2位是<strong>PF，奇偶标志位</strong>。它记录指令执行后，结果的所有<strong>二进制位（低8位）中</strong>1的个数：</p><ul><li>为偶数，PF = 1；</li><li>为奇数，PF = 0。</li></ul></li><li><p>flag的第7位是<strong>SF，符号标志位</strong>。它记录指令执行后，其结果是否为负</p><ul><li>结果为负，SF = 1；</li><li>结果为正，SF = 0。</li><li>与有符号数的符号位规定一致</li><li>SF 标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。</li><li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li><li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li></ul></li><li><p>比如指令subal,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。</p></li><li><p>flag的第0位是<strong>CF，进位标志位。</strong></p><ul><li>一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</li><li>比如：<ul><li>mov al,98H</li><li>add al,al ;</li><li>执行后： (al)=30H，CF=1，CF记录了最高有效位向更高位的进位值</li></ul></li></ul></li><li><p>flag的第11位是<strong>OF，溢出标志位。</strong></p><ul><li>一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</li><li>如果发生溢出，OF=1，</li><li>如果没有，OF=0。</li><li><strong>CF是对无符号数运算有意义的标志位；而OF是对有符号数运算有意义的标志位。</strong></li></ul></li><li><p>对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用 OF 位来记录是否产生了溢出。当然，还要用SF位来记录结果的符号。</p><ul><li>对于无符号数运算，98+99没有进位，CF=0；</li><li>对于有符号数运算，98+99发生溢出，OF=1。</li></ul></li><li><p><strong>adc是带进位加法指令，它利用了CF位上记录的进位值。</strong></p><ul><li>格式： adc 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1+操作对象2+CF</li><li>比如：adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF</li></ul></li><li><p>下面的指令和add ax , bx具有相同的结果：add al,bl ，adcah,bh，看来CPU提供 adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p></li><li><p><strong>sbb是带借位减法指令，它利用了CF位上记录的借位值。</strong></p><ul><li>格式：sbb 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1–操作对象2–CF</li><li>比如：sbb ax,bx,实现功能： (ax) = (ax) – (bx) – CF</li></ul></li><li><p><strong>cmp指令</strong></p><ul><li>格式：cmp 操作对象1,操作对象2</li><li>功能：计算操作对象1–操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</li></ul></li><li><p>比如：cmpax,ax做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：</p><ul><li>ZF=1，</li><li>PF=1，0是偶数</li><li>SF=0，</li><li>CF=0，</li><li>OF=0。</li><li>根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</li></ul></li><li><p>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</p></li><li><p>虽然 je的逻辑含义是“相等则转移”，但它进行的操作是，ZF=1时则转移。“相等则转移”这种逻辑含义，是通过和cmp 指令配合使用来体现的，因为是cmp指令为“ZF=1”赋予了“两数相等”的含义。虽然我们分别讨论了cmp指令和与其比较结果相关的有条件转移指令，但是它们经常在一起配合使用。所以我们在联合应用它们的时候，不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测。我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。<strong>意思就是说je可以直接用，je就是等于则转移</strong></p></li><li><p><strong>jb 含义是低于则转移，ja含义是高于则转移。</strong></p></li><li><p><strong>jna 含义是不高于则转移，即小于等于则转移；jnb含义是不低于则转移，即大于等于则转移。</strong></p></li></ol><p><a href="https://freeimage.host/i/HPSgh7e"><imgsrc="https://iili.io/HPSgh7e.md.png" alt="HPSgh7e.md.png" /></a></p><ol start="18" type="1"><li><p>flag的第10位是<strong>DF，方向标志位。</strong></p><ul><li>在串处理指令中，控制每次操作后si，di的增减。</li><li>DF = 0：每次操作后si，di递增；</li><li>DF = 1：每次操作后si，di递减。</li></ul></li><li><p>串传送指令：<code>movsb</code>我们可以用汇编语法描述movsb的功能如下：</p><ul><li>mov es:[di],byte ptr ds:[si];8086并不支持这样的指令，这里只是个描述。</li><li>如果DF=0：inc si，inc di</li><li>如果DF=1：dec si，dec di</li><li><strong>就是ds:si 传到 es:di</strong></li></ul></li><li><p>rep movsb 用汇编语法来描述rep movsb的功能就是：<code>s : movsb</code> <code>loop s</code></p></li><li><p><strong>cld指令：将标志寄存器的DF位置0，std指令：将标志寄存器的DF位置1</strong></p></li><li><p>pushf ：将标志寄存器的值压栈；</p></li><li><p>popf ：从栈中弹出数据，送入标志寄存器中。</p></li><li><p>pushf和popf，为直接访问标志寄存 器提供了一种方法。</p></li></ol><h3 id="程序-1">程序</h3><ol type="1"><li>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">001EH</span> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0F000H</span> <br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <br> <span class="hljs-keyword">adc</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span> <br> <span class="hljs-keyword">adc</span> 指令执行后，也可能产生进位值，所以也会对CF位进行设置<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>计算003E1000H–00202000H，结果放在ax，bx中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序如下：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">003EH</span><br> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span><br> <span class="hljs-keyword">sbb</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br></code></pre></td></tr></table></figure><h2 id="第12章-内中断">第12章 内中断</h2><hr /><h3 id="基础概念-11">基础概念</h3><ol type="1"><li>我们更简洁的描述中断过程，如下：<ul><li>（1）取得中断类型码N；</li><li>（2） pushf</li><li>（3） TF = 0，IF = 0</li><li>（4） push CS</li><li>（5） push IP</li><li>（6）(IP) = (N * 4)，(CS) = (N * 4+2)</li><li>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</li></ul></li><li>iret指令的功能用汇编语法描述为：<ol type="1"><li>pop IP</li><li>pop CS</li><li>popf</li></ol></li><li>CPU当然不能让这种情况发生，解决的办法就是，<strong>在进入中断处理程序之前，设置TF=0</strong>。从而<strong>避免CPU在执行中断处理程序的时候发生单步中断</strong>。这就是为什么在中断过程中有 TF=0这个步骤。</li></ol><h2 id="第13章-int指令">第13章 int指令</h2><hr /><h3 id="程序-2">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程：在屏幕的5行12列显示字符串“welcome to masm!”。</span><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>data ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;置光标</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;第0页</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">5</span> <span class="hljs-comment">;dh中放行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">12</span> <span class="hljs-comment">;dl中放列号</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;ds:dx指向字符串的首地址data:0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">9</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br>code ends<br>end start<br></code></pre></td></tr></table></figure><h2 id="第14章-端口">第14章 端口</h2><hr /><h3 id="基本概念">基本概念</h3><ol type="1"><li><p><strong>in al,60h;从60h号端口读入一个字节</strong></p><ul><li>执行时与总线相关的操作：</li><li>① CPU通过地址线将地址信息60h发出；</li><li>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</li><li>③ 端口所在的芯片将60h端口中的数据通过数据线送入CPU。</li></ul></li><li><p>注意：在in和out 指令中，只能使用 ax 或al来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al，访问16 位端口时用ax 。</p></li><li><p>对0～255以内的端口进行读写：</p><ul><li><strong>in al,20h ;从20h端口读入一个字节</strong></li><li><strong>out 20h,al ;往20h端口写入一个字节</strong></li></ul></li><li><p>对256～65535的端口进行读写时，端口号放在dx中：</p><ul><li>mov dx,3f8h ;将端口号3f8送入dx</li><li>in al,dx ;从3f8h端口读入一个字节</li><li>out dx,al ;向3f8h端口写入一个字节</li></ul></li><li><p><strong>70h为地址端口</strong>，存放要访问的CMOSRAM单元的地址；<strong>71h为数据端口</strong>，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</p></li><li><p>shl逻辑左移指令，功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位；</li><li>将最后移出的一位写入CF中；</li><li>最低位用0补充。</li></ul></li><li><p>如果移动位数大于1时，必须将移动位数放在<strong>cl</strong>中。</p></li><li><p>shr逻辑右移指令</p></li></ol><h3 id="程序-3">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程，读CMOS RAM的2号单元的内容</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span>          <span class="hljs-comment">;从 71h 读出 2 号单元的内容</span><br><br><span class="hljs-comment">;编程，向CMOS RAM的2号单元写入0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">71h</span>,<span class="hljs-built_in">al</span>       <span class="hljs-comment">;向 2 号单元写入 0</span><br> <br><br></code></pre></td></tr></table></figure><h2 id="第15章-外中断">第15章 外中断</h2><hr /><h3 id="基本概念-1">基本概念</h3><ol type="1"><li><p>外设的输入不直接送入内存和CPU ，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</p></li><li><p>可屏蔽中断是CPU 可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</p><ul><li>当CPU 检测到可屏蔽中断信息时：</li><li>如果IF=1，则CPU 在执行完当前指令后响应中断，引发中断过程；</li><li>如果IF=0，则不响应可屏蔽中断。</li></ul></li><li><p>内中断所引发的中断过程：</p><ul><li>（1）取中断类型码n；</li><li>（2）标志寄存器入栈，IF=0，TF=0；</li><li>（3）CS 、IP 入栈；</li><li>（4）(IP)=(n* 4)，(CS)=(n* 4+2)，</li><li>由此转去执行中断处理程序。</li></ul></li><li><p>将IF置0的原因就是，<strong>在进入中断处理程序后，禁止其他的可屏蔽中断。</strong></p></li><li><p> 不可屏蔽中断是CPU <strong>必须响应</strong>的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</p></li><li><p>不可屏蔽中断的中断过程：</p><ul><li>1、标志寄存器入栈，IF=0，TF=0；</li><li>2、CS、IP入栈；</li><li>3、(IP)=(8)，(CS)=(0AH)。</li></ul></li><li><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p></li><li><p> 扫描码长度为一个字节，通码的第7 位为 0，断码的第7位为1，即：断码=通码＋80H</p></li></ol><h2 id="第16章-直接定址表">第16章 直接定址表</h2><hr /><h3 id="基本概念-2">基本概念</h3><ol type="1"><li>对于程序中的a db 1,2,3,4,5,6,7,8 ：<ul><li>指令：mov al,a [si]，，相当于：mov al,cs:0[si]，</li><li>指令：mov al,a[3]，，相当于：mov al,cs:0[3]</li><li>指令：mov al,a[bx+si+3] ，，相当于：mov al,cs:0[bx+si+3]</li></ul></li><li>以后，我们将这种标号称为数据标号。它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。</li></ol><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><ul><li>\(E=mc^2\)</li><li>(ax^2 + bx + c = 0)</li><li>$ C_n^2$</li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
