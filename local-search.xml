<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据结构 图</title>
    <link href="/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/"/>
    <url>/2023/11/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>图结构常用来存储逻辑关系为“多对多”的数据。比如说，一个学生可以同时选择多门课程，而一门课程可以同时被多名学生选择，学生和课程之间的逻辑关系就是“多对多”。</p></blockquote><h2 id="图的基本概念">图的基本概念</h2><h3 id="弧头和弧尾">1、弧头和弧尾</h3><p>有向图中，无箭头一端的顶点通常被称为"初始点"或"弧尾"，箭头一端的顶点被称为"终端点"或"弧头"。</p><h3 id="入度和出度">2、入度和出度</h3><p>对于有向图中的一个顶点 V 来说，箭头指向 V 的弧的数量为 V的入度（InDegree，记为 ID(V)）；箭头远离 V 的弧的数量为 V的出度（OutDegree，记为OD(V)）。</p><h3 id="v1v2-和-v1v2-的区别">3、(V1,V2) 和 &lt;V1,V2&gt; 的区别</h3><p>无向图中描述两顶点 V1 和 V2 之间的关系可以用 <code>(V1, V2)</code>来表示；有向图中描述从 V1 到 V2 的"单向"关系可以用<code>&lt;V1,V2&gt;</code> 来表示。</p><p>由于图存储结构中顶点之间的关系是用线来表示的，因此 (V1,V2)还可以用来表示无向图中连接 V1 和 V2 的线，又称为边；同样，&lt;V1,V2&gt;也可用来表示有向图中从 V1 到 V2 带方向的线，又称为弧。</p><h3 id="集合-vr">4、集合 VR</h3><p>图中习惯用 VR表示图中所有顶点之间关系的集合。例如，下图中有向图的集合<code>VR=&#123;&lt;v1,v2&gt;,&lt;v1,v3&gt;,&lt;v3,v4&gt;,&lt;v4,v1&gt;&#125;</code>。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101725825.png"alt="image-20231110172523787" /><figcaption aria-hidden="true">image-20231110172523787</figcaption></figure><h3 id="路径和回路">5、路径和回路</h3><p>无论是无向图还是有向图，从一个顶点到另一顶点途经的所有顶点组成的序列（包含这两个顶点），称为一条<strong>路径</strong>。如果路径中第一个顶点和最后一个顶点相同，则此路径称为<strong>"回路"</strong>（或<strong>"环"</strong>）。</p><p>在此基础上，若路径中各顶点都不重复，此路径被称为"简单路径"；若回路中的顶点互不重复，此回路被称为"简单回路"（或简单环）。</p><p>拿上图来说，从 V1 存在一条路径还可以回到 V1，此路径为<code>&#123;V1,V3,V4,V1&#125;</code>，这是一个回路（环），而且还是一个简单回路（简单环）。</p><blockquote><p>在有向图中，每条路径或回路都是有方向的。</p></blockquote><h3 id="权和网">6、权和网</h3><p>有些场景中，可能会为图中的每条边赋予一个实数表示一定的含义，这种与边（或弧）相匹配的实数被称为"权"，而<strong>带权的图</strong>通常称为<strong>网</strong>。例如，下图就是一个网结构：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101727237.png"alt="image-20231110172730210" /><figcaption aria-hidden="true">image-20231110172730210</figcaption></figure><h3 id="子图">7、子图</h3><p>指的是由图中一部分顶点和边构成的图，称为原图的子图。</p><h2 id="图存储结构的分类">图存储结构的分类</h2><p>根据不同的特征，图又可细分为完全图，连通图，稀疏图和稠密图：</p><ul><li><p>完全图：若图中各个顶点都与除自身外的其他顶点有直接关系，这样的无向图称为<strong>完全图</strong>（如图5a)）。同时，满足此条件的有向图则称为<strong>有向完全图</strong>（图5b)）。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311101728235.gif"alt="完全图示意图" /><figcaption aria-hidden="true">完全图示意图</figcaption></figure><blockquote><p>具有 n 个顶点的完全图，图中边的数量为 n(n-1)/2；而对于具有 n个顶点的有向完全图，图中弧的数量为 n(n-1)。</p></blockquote></li><li><p>稀疏图和稠密图：这两种图是相对存在的，即如果图中具有很少的边（或弧），此图就称为"稀疏图"；反之，则称此图为"稠密图"。</p><blockquote><p>稀疏和稠密的判断条件是：e&lt;nlogn，其中 e表示图中边（或弧）的数量，n表示图中顶点的数量。如果式子成立，则为稀疏图；反之为稠密图。</p></blockquote></li></ul><h2 id="连通图">连通图</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 3_运算符</title>
    <link href="/2023/11/08/Java%203_%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2023/11/08/Java%203_%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>运算符：一种特殊的符号，用于表示数据的运算、赋值和比较等。</p></blockquote><h2 id="算数运算符">3.1 算数运算符</h2><blockquote><p>算术运算符是对数值类型的变量进行运算的运算符，在 Java程序中使用得非常多。其运算结果是一个数值量。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081107099.png"alt="image-20231108110732994" /><figcaption aria-hidden="true">image-20231108110732994</figcaption></figure><ul><li><p><code>+</code> ; <code>-</code> ; <code>*</code> ; <code>/</code>：加（正）、减（负）、乘、除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArithmeticOperator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>System.out.println(<span class="hljs-number">10</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//从数学来看是 2.5, java 中 2</span><br>System.out.println(<span class="hljs-number">10.0</span> / <span class="hljs-number">4</span>); <span class="hljs-comment">//java 是 2.5</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">4</span>;    <span class="hljs-comment">//java 中 10 / 4 = 2, 2=&gt;2.0</span><br>System.out.println(d);<span class="hljs-comment">// 是 2.0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>%</code>：取模（求余数），结果和被取模数同号。本质是一个公式:<code>a % b == a - a / b * b;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -10 % 3 =&gt; -10 - (-10) / 3 * 3 = -10 + 9 = -1</span><br><span class="hljs-comment">// 10 % -3 = 10 - 10 / (-3) * (-3) = 10 - 9 = 1</span><br><br>System.out.println(<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % <span class="hljs-number">3</span>); <span class="hljs-comment">// -1</span><br>System.out.println(<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>); <span class="hljs-comment">//1</span><br>System.out.println(-<span class="hljs-number">10</span> % -<span class="hljs-number">3</span>);<span class="hljs-comment">//-1</span><br></code></pre></td></tr></table></figure></li><li><p><code>++</code> ：自增。</p><ul><li>作为独立的语句使用,<code>++i</code>和<code>i++</code>都完全等价于<code>i = i + 1</code></li><li>作为表达式使用:<code>++i</code> 先自增后赋值；<code>i++</code>先赋值后自增</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//++的使用</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>i++;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 11</span><br>++i;<span class="hljs-comment">//自增 等价于 i = i + 1; =&gt; i = 12</span><br>System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<span class="hljs-comment">//12</span><br><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> ++j; <span class="hljs-comment">//等价 j=j+1;k=j;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//9  9</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> j++; <span class="hljs-comment">// 等价 k=j;j=j+1;</span><br>System.out.println(<span class="hljs-string">&quot;k=&quot;</span> + k + <span class="hljs-string">&quot;j=&quot;</span> + j);<span class="hljs-comment">//8 9</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>练习</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//i-&gt;1</span><br>i = i++; <span class="hljs-comment">//规则使用临时变量: (1) temp=i;(2) i=i+1;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">// 1</span><br><br><span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;<br>i=++i; <span class="hljs-comment">//规则使用临时变量: (1) i=i+1;(2) temp=i;(3)i=temp;</span><br>System.out.println(i); <span class="hljs-comment">//2</span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> i1++;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//10</span><br>i = --i2;<br>System.out.print(<span class="hljs-string">&quot;i=&quot;</span>+i); <span class="hljs-comment">//19</span><br>System.out.println(<span class="hljs-string">&quot;i2=&quot;</span>+i2); <span class="hljs-comment">//19</span><br></code></pre></td></tr></table></figure><h2 id="关系运算符比较运算符">3.2 关系运算符（比较运算符）</h2><blockquote><p>关系运算符结果都为 <code>boolean</code> 型，要么是 <code>ture</code>要么是 <code>false</code>。其关系表达式经常用在 <code>if</code>结构的条件中或循环结构的条件中。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311081136572.png"alt="image-20231108113644487" /><figcaption aria-hidden="true">image-20231108113644487</figcaption></figure><h3 id="使用细节">3.2.1 使用细节</h3><ol type="1"><li>关系运算符结果都是 <code>boolean</code> 型，要么是 <code>ture</code>，要么是 <code>false</code></li><li>关系运算符的表达式，称为<em>关系表达式</em></li><li>比较运算符 <code>==</code> 不要误写为 <code>=</code></li></ol><h2 id="逻辑运算符">3.3 逻辑运算符</h2><blockquote><p>用于连接多个条件（多个关系表达式），最终的结果也是一个<code>boolean</code> 值。</p></blockquote><ul><li><p><code>&amp;&amp;</code> ：短路与。<code>a</code> <code>b</code>同时为 <code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>&amp;</code> ：逻辑与。<code>a</code> <code>b</code> 同时为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><p><code>&amp;&amp;</code> 与 <code>&amp;</code> 的区别，在于<code>a &amp;&amp; b</code> 的场合，<code>a = false</code> 时，则<code>b</code> 不判断。而 <code>&amp;</code> 会完成判断。开发中多用<code>&amp;&amp;</code> ，因为其效率更高。</p></li><li><p><code>||</code> ：短路或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p></li><li><p><code>|</code> ：逻辑或。<code>a</code> <code>b</code> 任一为<code>ture</code>，则结果为 <code>ture</code>，否则为<code>false</code>。</p><blockquote><p>两者的区别和<code>&amp;&amp;</code> 与 <code>&amp;</code>相似，若第一个为 <code>ture</code> ，则 <code>||</code>不会判断第二个。</p></blockquote></li><li><p><code>!</code> ：取反。<code>a</code> 为<code>ture</code>，则结果为 <code>false</code>。反之为<code>ture</code>。</p></li><li><p><code>^</code>：逻辑异或。<code>a</code> <code>b</code>不同，结果为 <code>ture</code>，否则为 <code>false</code>。</p></li></ul><h2 id="赋值运算符">3.4 赋值运算符</h2><blockquote><p>将某个运算后的值，赋给指定变量</p></blockquote><ul><li><p>基本赋值运算符：<code>=</code></p></li><li><p>复合赋值运算符：<code>+=</code> ; <code>-=</code> ;<code>*=</code> ; <code>/=</code> ; <code>%=</code> 等</p><blockquote><p><code>a += b</code> 等价于 <code>a = a + b</code>。其余同理。</p></blockquote></li></ul><h3 id="使用细节-1">3.4.1 使用细节</h3><ol type="1"><li><p>运算顺序从右往左。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> a + b + c;<span class="hljs-comment">// 先运行(a + b + c)，再结算int num =</span><br></code></pre></td></tr></table></figure></li><li><p>运算符左边只能是变量，右边可以是变量、表达式、常量值。</p></li><li><p>复合赋值运算符会进行类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; b += <span class="hljs-number">3</span>;<span class="hljs-comment">// 此时 b += 3 等价于 b = (byte)(b + 3)</span><br>b++;<span class="hljs-comment">// 同理</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="三元运算符">3.5 三元运算符</h2><blockquote><p>基本语法：<code>条件表达式 ? 表达式1 : 表达式2;</code></p><p>运算规则：如果条件表达式为 <code>ture</code>，运算的结果是表达式1；反之为表达式2。</p><p>口诀------一眼顶真</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">99</span>;<br><span class="hljs-comment">// 解读</span><br><span class="hljs-comment">// 1. a &gt; b 为 false</span><br><span class="hljs-comment">// 2. 返回 b--, 先返回 b 的值,然后再 b-1</span><br><span class="hljs-comment">// 3. 返回的结果是 99</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> a &gt; b ? a++ : b--;<br>System.out.println(<span class="hljs-string">&quot;result=&quot;</span> + result); <span class="hljs-comment">//99</span><br>System.out.println(<span class="hljs-string">&quot;a=&quot;</span> + a); <span class="hljs-comment">//10</span><br>System.out.println(<span class="hljs-string">&quot;b=&quot;</span> + b); <span class="hljs-comment">//98</span><br></code></pre></td></tr></table></figure><h3 id="使用细节-2">3.5.1 使用细节</h3><ol type="1"><li><p>表达式1 和 表达式2要为可以赋给接受变量的类型（或可以自动转换，或进行强制转换）</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-built_in">int</span> b = <span class="hljs-number">8</span>;<br><span class="hljs-built_in">int</span> c = a &gt; b ? (<span class="hljs-built_in">int</span>)<span class="hljs-number">1.1</span> : (<span class="hljs-built_in">int</span>)<span class="hljs-number">3.4</span>;<span class="hljs-comment">//可以的</span><br><span class="hljs-built_in">double</span> d = a &gt; b ? a : b + <span class="hljs-number">3</span>;<span class="hljs-comment">//可以的，满足 int -&gt; double</span><br></code></pre></td></tr></table></figure></li><li><p>三元运算符可以转成 <code>if--else</code></p></li><li><p>三元运算符是一个整体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">1</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Double</span>(<span class="hljs-number">2.2</span>);<br>System.out.print(obj)<br></code></pre></td></tr></table></figure><p>上例中，系统将会输出 <code>1.0</code></p><p>因为 三元运算符 是一个整体，所以根据 [2.8.1.1.1]发生了类型转换。</p></li></ol><h2 id="运算符优先级">3.6 运算符优先级</h2>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统-死锁</title>
    <link href="/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%AD%BB%E9%94%81/"/>
    <url>/2023/11/07/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E6%AD%BB%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="死锁的避免">死锁的避免</h2><h3 id="银行家算法">银行家算法</h3><blockquote><p>Dijkstra在1965年提出的银行家算法是著名的死锁避免算法，这个用于一个银行家给多个顾客贷款的算法可以直接用于操作系统给进程分配资源，这时只要把银行家换成操作系统，把顾客换成进程，把资金换成资源，把银行家决定是否放贷时所用的判断过程（即判断顾客是否有信誉和偿还能力）换成操作系统决定是否分配资源时所用的判断过程（即判断进程是否能及时归还资源）即可。</p></blockquote><p>银行家算法的实质就是<strong>要设法保证系统动态分配资源后不进入不安全状态，以避免可能产生的死锁。</strong></p><h4 id="银行家算法中的数据结构">银行家算法中的数据结构</h4><p>为了实现银行家算法，在系统中必须设置这样四个数据结构：</p><p>1）<strong>Available向量</strong>：系统中可利用的资源数目</p><p>2）<strong>Max矩阵</strong>：每个进程对每种资源的最大需求</p><p>3）<strong>Allocation矩阵</strong>：每个进程已分配的各类资源的数目</p><p>4）<strong>Need矩阵</strong>：每个进程还需要的各类资源数</p><p>其中三个矩阵间存在下述关系：</p><blockquote><p><strong>Need[i,j] = Max[i,j] - allocation[i, j]</strong></p></blockquote><h4 id="银行家算法的描述">银行家算法的描述</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071623169.png"alt="image-20231107162343038" /><figcaption aria-hidden="true">image-20231107162343038</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071623396.png"alt="image-20231107162358296" /><figcaption aria-hidden="true">image-20231107162358296</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628354.png"alt="image-20231107162817252" /><figcaption aria-hidden="true">image-20231107162817252</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071628465.png"alt="image-20231107162835370" /><figcaption aria-hidden="true">image-20231107162835370</figcaption></figure><h4 id="银行家算法流程图表示">银行家算法流程图表示</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311071626146.png"alt="image-20231107162637053" /><figcaption aria-hidden="true">image-20231107162637053</figcaption></figure><h4 id="银行家算法的程序实现">银行家算法的程序实现</h4><p><strong>数据结构：</strong></p><ol type="1"><li>可用资源向量<code>Available</code>,这是一个一维数组<code>Available[j],j=1,…m</code>，表示第<code>j</code>种资源的可用数量，其中<code>m</code>为资源的种类个数</li><li>最大资源需求矩阵<code>Max</code>,这是一个<code>n*m</code>的二维数组，其中<code>n</code>为进程个数。单元<code>Max[i,j]</code>存储的数值表示第<code>i</code>个进程最多需要多少第<code>j</code>种资源</li><li>分配矩阵<code>Allocation</code>，这是一个<code>n*m</code>的二维数组。单元<code>Allocation[i,j]</code>存储的是已经分配给第<code>i</code>个进程的第<code>j</code>种资源的数量</li><li>需求矩阵<code>Need</code>，这也是一个<code>n*m</code>的矩阵，单元<code>Need[i,j]</code>存储的数值表示进程<code>i</code>还需要多少第<code>j</code>种资源的数量才能完成退出。</li></ol><blockquote><p>参考：</p><p><ahref="https://www.zhihu.com/tardis/zm/art/384678500?source_id=1005">详解操作系统之银行家算法（附流程图）(zhihu.com)</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>密码学导论</title>
    <link href="/2023/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="公钥密码学">公钥密码学</h1><h2 id="公钥密码体制的基本原理">公钥密码体制的基本原理</h2><p>用抽象的观点来看，公钥密码体制就是一种陷门单向函数</p><ul><li><p><strong>单向函数</strong>是满足下列条件的函数：</p><p>它是定义域到值域的一个映射，同时还要满足下列条件：计算函数值是容易的，而从函数值计算原像是不可行的.</p></li><li><p><strong>陷门单向函数</strong>是这样的单向函数，存在一个附加信息，当不知道该附加信息时，从函数值求原像是困难的，但当知道该附加信息时，从函数值求原像就变得容易了。即陷门单向函数在附加信息未知时是单向函数，而当附加信息已知时，就不再是单向函数了。通常把附加信息称为陷门信息。</p></li></ul><p>公钥密码体制就是基于这一原理而设计的，利用一个陷门单向函数，将它作为公开密钥，而将陷门信息作为秘密密钥.。其安全强度取决于它所依据的问题的计算复杂度</p><h2 id="公钥密码体制的要求">公钥密码体制的要求</h2><ul><li>产生一对密钥在计算上是可行的</li><li>已知公钥和明文，产生密文是容易的</li><li>接收方利用私钥来解密密文在计算上是可行的</li><li>对于攻击者，利用公钥来推断私钥在计算上是不可行的</li><li>已知公钥和密文，在不知道私钥的情况下，恢复明文在计算上是不可行的</li></ul><h2 id="数论基础知识">数论基础知识</h2><p><a href="https://oi-wiki.org/math/number-theory/basic/">数论基础 - OIWiki (oi-wiki.org)</a></p><h3 id="群的相关概念">群的相关概念</h3><p>群的阶：<code>ord(G)</code>=群中元素的个数</p><p>群元素的阶：ord（g）</p><ul><li>群元素g做群的操作 i 次</li><li>最小的正整数 i 满足，<spanclass="math inline">\(g^i=1\)</span>（单位元）</li></ul><p><span class="math inline">\(g^{ord(G)} =1(单位元)\)</span>，证明如下：</p><p><span class="math display">\[\begin{align}∵ord(g) \ &amp;|\ ord(G)\\g^{ord(g)} &amp;= 1\\∴ord(G) &amp;= k*ord(g)\\∴g^{ord(G)} &amp;= 1\end{align}\]</span></p><p>对Zn* ，12</p><p>{a|gcd(a,N)=1} *mod N，元素的个数为φ(N)</p><p>当N为素数，{0,1,2,,,,,p-1} *mod p</p><p>例如p等于7，单位元：1</p><p>逆元（1-6的）：1，4，5，2，3，6</p><h2 id="rsa">RSA</h2><p>加密过程：</p><ul><li>选两个大质数p和q，且 <span class="math inline">\(p!=q\)</span>，计算<span class="math inline">\(N=p*q\)</span>，N就算出来了</li><li>然后计算N的欧拉函数 <spanclass="math inline">\(φ(N)=(p-1)(q-1)\)</span></li><li>然后你自己选个e， <spanclass="math inline">\(1&lt;e&lt;φ(N)\)</span>，且与φ(N)互质，<ul><li>为什么e与φ(N)互素：要存在d，互素才存在这样一个d</li></ul></li><li>由e和φ(N)互质，<spanclass="math inline">\((e,φ(N))=1\)</span>，再由辗转相除法，则一定有<spanclass="math inline">\(ed - φ(N)k = 1\)</span></li><li>那么由e就可以算出d，<span class="math inline">\(ed ≡ 1\quadmod(φ(N))\)</span><ul><li>pk（公钥）：N，e</li><li>sk（私钥）：d</li></ul></li></ul><p>加解密：</p><p><span class="math display">\[\begin{align}Enc（pk，m∈Z_N^*）:c = m^e\ mod \ N\\Dec（sk，c）： m = c^d\ mod\ N\end{align}\]</span></p><p>正确性证明：</p><p><span class="math display">\[\begin{align}&amp;即验证 c^d modN 是否等于 m\\&amp;∵ed ≡ 1\quad mod(φ(N))\\&amp;∴ed = kφ(N) + 1\\&amp;即验证m^{ed} mod N最后是等于m的\\&amp;m^{kφ(N) + 1} \quad mod \quad N \\&amp;m^{kφ(N)}*m \quad mod \quad N\\&amp;即求:m^{φ(N)}≡1modN\\&amp;∵m∈Z_N^*\\&amp;g^{ord(G)} = 1(单位元)\\&amp;∴m^{φ(N)}≡1modN&amp;\end{align}\]</span></p><p>对于</p><p><span class="math display">\[\begin{align}&amp;m∈Z_N（放大m的范围了）\\&amp;m \notin Z_N^*\\&amp;∵ N =p*q\\&amp;∴gcd(m,N)=p或q\\&amp;这里的情况N直接分解出来了\\&amp;若gcd(m,N)=p,m&lt;N,N=p*q\\&amp;得m=kp,1≤k&lt;q\\&amp;gcd(m,q)= 1\\&amp;相当于m∈Z_q^*，则m^{φ(q)}=1modq\\&amp;m^{q-1}=1modq\\&amp;ed = k^{&#39;}φ(N)+1=k^{&#39;}(p-1)(q-1)+1\\&amp;m^{k^{&#39;}(p-1)(q-1)} =1modq\\&amp;m^{k^{&#39;}φ(N)} =1modq\\&amp;即m^{k^{&#39;}φ(N)} =rq+1\\&amp;我们这里还是要求m^{ed}modN最后等于m\\&amp;m^{k^{&#39;}φ(N)}*m \quad mod N\\&amp;=(rq+1)m \quad modN\\&amp;=(rqm+m)\quad mod N\\&amp;=(rq*kp+m)\quad mod N\\&amp;=(rkN+m)\quad mod N\\&amp;=m\end{align}\]</span></p><p>RSA问题，给定N，e，<spanclass="math inline">\(y∈Z_N^*\)</span>，求x，满足<spanclass="math inline">\(x^e=y\ mod\ N\)</span></p><blockquote><p>一个密文对应一个明文，所以jzlaoshi不把RSA叫做一个加密方案，而是一个单向陷门置换</p></blockquote><h3 id="rsa公钥密码体制的安全性">RSA公钥密码体制的安全性</h3><p>RSA是建立在大整数分解的困难性之上的</p><p>大整数分解攻击：一旦分解出p和q，就可以得到n的欧拉数φ(N)，再利用欧几里德扩展算法求出RSA的私钥d.</p><p>因此，应当采用足够大的大整数n(至少应取1024位，最好为2048位)。此外，对素数p和q的选取应满足以下要求：</p><ul><li>p和q的长度应该相差不大</li><li>(p - 1)和(q - 1)都应该包含大的素因子</li><li>gcd(p - 1,q -1)应该尽可能小</li><li>d &lt; n，且<spanclass="math inline">\(d&lt;n^{0.294}\)</span>，特别是当<spanclass="math inline">\(d&lt;n^{1/4}\)</span>时，已经有办法攻破RSA</li></ul><h2 id="elgamal公钥密码体制">ElGamal公钥密码体制</h2><p>离散对数问题： <span class="math display">\[G，p，g，，，h∈G，求x∈Z_p，使得h = g^x\]</span></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311131908490.png"alt="image-20231113190856360" /><figcaption aria-hidden="true">image-20231113190856360</figcaption></figure><p><span class="math display">\[\begin{align}&amp;Z_p^*，群的阶为p-1，p-1=rq\\&amp;有一个q阶子群G_q\\&amp;在Z_p^*中取一个h，h^r∈G_q\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\\end{align}\]</span></p><p>下面是一个隐藏的公式： <span class="math display">\[\begin{align}&amp;1\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\&amp;\\\end{align}\]</span></p><blockquote><p>参考：</p><p><ahref="https://zhuanlan.zhihu.com/p/599518034">一文搞懂Diffie-Hellman密钥交换协议- 知乎 (zhihu.com)</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 1_绪论</title>
    <link href="/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/"/>
    <url>/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%201_%E7%BB%AA%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<p>凭借一句话获得图灵奖的Pascal语言之父——NicklausWirth，让他获得图灵奖的这句话就是他提出的著名公式： <spanclass="math display">\[程序 = 数据结构 + 算法\]</span></p><h2 id="基本概念和术语">基本概念和术语</h2><p>知识结构图： 数据 ——&gt; 数据元素 ——&gt; 数据项 ——&gt; 数据对象</p><p>数据：是对客观事物的符号表示</p><p>数据元素(dataelement)：是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。一个数据元素往往由若干数据项组成。</p><p>数据项(DataItem)：是组成数据元素的、有独立含义的、不可分割的最小单位</p><p>数据对象(data object)：是性质相同的数据元素的集合</p><p>数据结构(DataStructure)：是相互之间存在一种或多种特定关系的数据元素的集合。换句话说，数据结构是带”结构＂的数据元素的集合，“结构”就是指数据元素之间存在的关系。</p><p><strong>逻辑结构和物理结构</strong></p><p>逻辑结构：数据的逻辑结构是从逻辑关系上描述数据，它与数据的存储无关，是独立于计算机的。因此，数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的逻辑结构有两个要素：一是数据元素；二是关系。</p><p>四类基本逻辑结构</p><ul><li>集合</li><li>松散结构线性结构：一对一的关系</li><li>树形结构：一对多关系</li><li>图状结构：多对多关系</li></ul><p>物理结构/存储结构</p><p>物理结构：数据的逻辑结构在计算机中(内存)的存储形式。</p><p>分为顺序存储结构、链式存储结构、索引存储结构、散列存储结构。</p><p><strong>数据类型</strong></p><p>数据类型是一个值的集合和定义在值集上的一组操作的总称。</p><p>在使用高级程序设计语言编写程序时，必须对程序中出现的每个变量、常量或表达式、C语言中函数的参数、返回值，明确说明它们所属的数据类型。</p><p>C语言中：提供int,char,float,double等基本数据类型；数组、结构、共用体、枚举等构造数据类型；还有指针、空（void)类型，用户也可用typedef自己定义数据类型。而另一些常用的数据结构，如栈、队列、树、图等，不能直接用数据类型来表示。</p><p>在C语言中，数据类型可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型姿型数据组成的数组。</li></ul><p><strong>抽象数据类型(ADT)</strong></p><p>是指一个数据模型以及定义在该模型上的一组操作。和数据类型实质上是一个概念</p><p>形式化定义: (D, S, P)</p><ul><li>D是数据对象</li><li>S是D上的关系集</li><li>P是对D的基本操作</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">定义格式<br>      ADT 抽象数据类型名 &#123;<br>             数据对象: <span class="hljs-tag">&lt;<span class="hljs-name">数据对象的定义</span>&gt;</span><br>             数据关系: <span class="hljs-tag">&lt;<span class="hljs-name">数据关系的定义</span>&gt;</span><br>             基本操作: <span class="hljs-tag">&lt;<span class="hljs-name">基本操作的定义</span>&gt;</span><br>      &#125; ADT 抽象数据类型  <br><br></code></pre></td></tr></table></figure><p>对图形进行一个缩放n倍<code>scale(G(被操作的图形),n)</code>对图形进行缩放，它当然也会返回一个图形<code>G'=scale(G,n)</code>返回值要赋值给G写成<code>scale（&amp;G,n）</code>引用参数以"&amp;"打头，除可提供输入值外，还将返回操作结果。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构 2_线性表</title>
    <link href="/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202_%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2023/11/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%202_%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="线性表的定义和特点">2.1 线性表的定义和特点</h2><p>定义：<strong>由n(n ≥0)个数据特性相同的元素构成的有限序列称为线性表。</strong></p><p>特点：</p><ol type="1"><li>线性表中元素的个数n(n ≥ 0)定义为线性表的长度，n = 0时称为空表。</li><li>将非空的线性表(n &gt; 0)记作(a1，a2，a3，...，an)</li><li>这里的数据元素ai(1 ≤ i ≤n)只是个抽象的符号，其具体含义在不同情况下可以不同。</li><li>在非空的线性表，有且仅有一个开始结点a1,它没有直接前趋，而仅有一个直接后继a2；有且仅有一个终端结点an,它没有直接后继，而仅有一个直接前趋an-1；其余的内部结点ai,(2&lt; i &lt; n-1)都有且仅有一个直接前趋ai-1和一个直接后继ai+1</li></ol><h2 id="线性表的类型定义">2.2 线性表的类型定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c">ADT List &#123;<br>数据对象：D=&#123;ai| ai ∈ElemSet, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n, n≥<span class="hljs-number">0</span>&#125;<br>数据关系：R=&#123; &lt; ai<span class="hljs-number">-1</span> , ai&gt; | ai<span class="hljs-number">-1</span>, ai∈D, i=<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,…,n&#125; <br>基本操作： <br>InitList (&amp; L )      <br>    <span class="hljs-comment">//(Initialization) 形参或者定义时&amp;是引用，实参或者使用时&amp;是取地址！跟C语言还是C++没有关系！但是引用这个概念只存在于C++</span><br>操作结果：构造一个空的线性表L。 <br>DestroyList ( &amp;L )    <br>初始条件：线性表L已存在。     <br>操作结果：销毁线性表L。<br>ClearList ( &amp;L )   <br>初始条件：线性表L已存在。    <br>操作结果：将L重置为空表。<br>ListEmpty ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：若L为空表，则返回TRUE, 否则返回FALSE。  <br>Listlenght ( L )     <br>初始条件：线性表L已存在。     <br>操作结果：返回L中数据元素个数。  <br>GetElem (L, i, &amp;e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)。     <br>操作结果：用e返回L中第 i 个数据元素的值。<br>LocateElem (L, e, compare() )   <br>初始条件：线性表L已存在,compare()是数据元素判定函数。    <br>操作结果：返回L中第<span class="hljs-number">1</span>个与e满足关系compare()的数据元素的位序，  若这样的数据元素不存在，则返回值为<span class="hljs-number">0</span>。 <br>PriorElem (L, cur_e, &amp;pre_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是第一，则用pre_e返回它的前驱,否则操作失败,pre_e无定义。<br>NextElem (L, cur_e, &amp;next_e )     <br>初始条件：线性表L已存在。     <br>操作结果：若cur_e 是L中的数据元素，且不是最后一个，则用next_e返回它的后继，否则操作失败，next_e无定义。<br>ListInsert (&amp;L, i, e )     <br>初始条件：线性表L已存在,<span class="hljs-number">1</span> ≤i≤ListLength(L)+<span class="hljs-number">1</span>。     <br>操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加<span class="hljs-number">1</span>。 <br>ListDelete (&amp;L, i, &amp;e )     <br>初始条件：线性表L已存在且非空,<span class="hljs-number">1</span> ≤i≤ListLength(L)。     <br>操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减<span class="hljs-number">1</span>。  <br>ListTraverse (L, visit () )     <br>初始条件：线性表L已存在。     <br>操作结果：依次对L的每个数据元素调用函数visit( )。一旦visit( )失败，则操作失败。   <br>&#125;ADT List<br></code></pre></td></tr></table></figure><h2 id="线性表的顺序表示和实现">2.3 线性表的顺序表示和实现</h2><p>把线性表中的所有元素，按照其逻辑顺序依次存储到计算机中的从指定存储位置开始的一块连续的存储空间中</p><ul><li><p>是一种紧凑结构</p></li><li><p><spanclass="math inline">\(Loc(a_{i+1})=loc(a_i)+sizeof(ElemType)\)</span></p></li><li><p>是一种<strong>随机存储</strong>的结构</p></li><li><p>通常用数组来描述顺序存储结构</p></li><li><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311070000696.png"alt="image-20231107000041653" /><figcaption aria-hidden="true">image-20231107000041653</figcaption></figure></li><li><p>```c #define MAXSIZE 20 //储空间初始分配量 typedef int ElemType;//ElemType类型根据实际情况而定，这里假设为int typedef struct{ ElemTypedata[MAXSIZE]; //数组存储数据元素，最大值为MAXSIZE int length//线性表当前长度 }SqList;</p><p>/<em> 这里，我们就发现描述顺序存储结构需要三个属性:存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置线性表的最大存储容量：数组长度MaxSize。 线性表的当前长度：length。</em>/ <figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>  <br><br>- 计算地址只算一次与处理数据的规模无关数量级是O(<span class="hljs-number">1</span>)这种运算叫**随机存取**。<br><br><br><br>## <span class="hljs-number">2.4</span> 类c语言有关操作<br><br><br><br>### <span class="hljs-number">2.4</span><span class="hljs-number">.1</span> 元素类型说明<br><br>顺序表类型定义<br><br>```c<br>typedef struct&#123;<br>    ElemType data[];<br>    int length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure></p></li></ul><p><code>ElemType</code>是根据实际问题，你需要什么类型的数组就定义成什么，一般是根据问题定义一个结构体或者是<code>typedef char ElemType</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//比如，data[]中是abcde，那就能这样</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">char</span> data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br><br><span class="hljs-comment">//或者：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">char</span> ElemType<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType data[];<br>    <span class="hljs-type">int</span> length<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>如果表中元素类型不单一，可以定义一个复杂的结构类型（结构体的嵌套使用）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">float</span> p;<br>    <span class="hljs-type">int</span> e;<br>&#125;Polynomial;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>Polynomial *elem; <span class="hljs-comment">//首地址，elem保存地址，这行代码意思是定义了一个Polynomial型的指针变量</span><br><span class="hljs-type">int</span> length;<br>&#125;SqList;<br><br><br></code></pre></td></tr></table></figure><h3 id="数组定义">2.4.2 数组定义</h3><p>数组静态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span> <br>    ElemType data[MaxSize]; <br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>数组动态分配：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//数组名其实就是首元素的地址，所以也可以直接定义一个指针，也可以表示一个数组，用来存放数组首地址。数组的大小用相应的函数来动态分配内存</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    ElemType *data;<span class="hljs-comment">//数组首地址</span><br>    <span class="hljs-type">int</span> length;<br>&#125;SqList;<span class="hljs-comment">//顺序表类型</span><br></code></pre></td></tr></table></figure><p>这种方式我们不知道内存到底有多大，接下来将用内存分配函数来分配空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <span class="hljs-comment">//L就是要操作的顺序表，即SqList</span><br><span class="hljs-comment">//L就有两个成员L.data，用来存放顺序表的元素，另一个是L.length</span><br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><h3 id="c语言的内存动态分配">2.4.3 C语言的内存动态分配</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">SqList L; <br>L.data = (ElemType*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(ElemType)*MaxSize);<br></code></pre></td></tr></table></figure><ul><li><code>malloc(m)</code>函数，开辟m字节长度的地址空间，并返回这段空间的首地址，参数m要求是一个整数</li><li><code>sizeof(x)</code>运算，计算变量x的长度，即变量需占的字节数×变量个数</li><li><code>L.data</code>是数组的首地址（无空间），<code>ElemType*</code>使新分配的空间首地址的元素类型为数组的元素类型，一个“=”就能将放置数组元素类型的空间分配给L了</li><li><code>free(p)</code>函数，释放指针p所指变量的存储空间，即彻底删除一个变量</li><li><code>L.data = (ElemType*)malloc(sizeof(ElemType)*MaxSize);</code><ul><li>后面这个<code>*</code>意思是乘号</li><li>前面的<code>()</code>的意思是强制类型转换，<ul><li><code>(int)</code>强制转换为整数</li><li><code>(int *)</code>强制转换为指向整型的一个指针</li><li><code>(ElemType*)</code>意思是强制转换成指向数据元素类型<code>ElemType</code>的一个指针，</li></ul></li><li>后面的<code>ElemType</code>表示字节数，比如<code>char</code>需要1个字节，<code>int</code>需要8个字节，那如果<code>MaxSize</code>为100，为<code>char</code>时就需要开辟100字节长度的地址空间，<code>int</code>时就需要开辟800字节长度的地址空间</li><li>前面的<code>ElemType</code>是告诉计算机存成什么类型的，比如后面的<code>ElemType</code>为<code>int</code>，<code>MaxSize</code>为100，那一共800个字节要怎么分配呢，如果为<code>char</code>，就被分为800块，如果是<code>int</code>，就被分为200块，划分成什么类型看我们线性表里面的元素是什么类型</li></ul></li><li>需要加载的头文件：<code>&lt;stdlib.h&gt;</code></li></ul><h3 id="c内容">2.4.4 C++内容</h3><h4 id="c的动态存储分配">C++的动态存储分配</h4><p><code>new 类型名T（初值列表)</code></p><p>功能：申请用于存放T类型对象的内存空间，并依初值列表赋以初值</p><p>结果值：</p><ul><li>成功：T类型的指针，指向新分配的内存</li><li>失败：0（NULL)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>;  <span class="hljs-comment">//从内存当中动态的分配一块空间，放一个int型，赋给一个指针变量</span><br><span class="hljs-type">int</span> *p1 = new <span class="hljs-type">int</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">//给空间赋上初值</span><br></code></pre></td></tr></table></figure><p><code>delete 指针P</code></p><p>功能：释放指针P所指向的内存。P必须是new操作的返回值</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">delete p1<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="c-的参数传递">C++ 的参数传递</h4><p>传值方式（参数为整型、实型、字符型等）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> m,<span class="hljs-type">float</span> n)</span></span>&#123;<br>    <span class="hljs-type">float</span> temp;<br>    temp = m;<br>    m = n;<br>    n = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a, b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    <span class="hljs-built_in">swap</span>(a, b);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//Enter two numbers: 5 9</span><br><span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br><span class="hljs-comment">//After swapping: a = 5, b = 9</span><br></code></pre></td></tr></table></figure><ul><li>说明：函数修改的是形参的值，释放空间后，形参释放，实参的值不变</li></ul><p>传地址</p><ul><li><p>参数为指针变量</p><ol type="1"><li>形参变化影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> t;<br>    t = *m;<br>    *m = *n;<br>    *n = t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br>  <br>  <span class="hljs-comment">//Enter two numbers: 5 9</span><br>  <span class="hljs-comment">//Before swapping: a = 5, b = 9</span><br>  <span class="hljs-comment">//After swapping: a = 9, b = 5</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>形参变化不影响实参</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-type">float</span> *m,<span class="hljs-type">float</span> *n)</span></span>&#123;<br>    <span class="hljs-type">float</span> *t;<br>    t = m;<br>    m = n;<br>    n = t;<span class="hljs-comment">//交换的是m和n指向的地址不是地址中的内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">float</span> a,b,*p1,*p2;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two numbers: &quot;</span>;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Before swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>    p1 = &amp;a;p2 = &amp;b;  <span class="hljs-comment">//p1、p2分别指向变量a、b</span><br>    <span class="hljs-built_in">swap</span>(p1,p2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;After swapping: a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//swap(p1,p2)后没交换</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>参考资料：</p><p><ahref="https://www.zhihu.com/tardis/zm/art/421431276?source_id=1005">LinkListL、LinkList&amp; L、和LinkList *L这三者的区别 (zhihu.com)</a></p><p><ahref="https://www.bilibili.com/read/readlist/rl241105?share_medium=android&amp;share_plat=android&amp;share_source=COPY&amp;share_tag=s_i&amp;timestamp=1615722826&amp;unique_k=376Uh5">数据结构-文集 哔哩哔哩专栏 (bilibili.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-递归和分治策略</title>
    <link href="/2023/11/02/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/"/>
    <url>/2023/11/02/%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92%E5%92%8C%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="分治法的常用例子">分治法的常用例子</h2><h3 id="二分查找">二分查找</h3><h4 id="概述">1. 概述</h4><p>二分查找（Binary Search）算法，也叫折半查找算法</p><p>算法前件：待查找序列有序</p><p>基本思想：先将待查元素与中间元素比，若比中间元素大，则在序列的后一半继续查找；若比中间元素小，则在序列的前一半继续查找。</p><p>二分查找与顺序查找对比图：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311021339520.gif"alt="1" /><figcaption aria-hidden="true">1</figcaption></figure><h4 id="复杂度分析">2.复杂度分析</h4><p><strong>时间复杂度</strong></p><p>我们假设数据大小是n，每次查找后数据都会缩小为原来的一半，也就是会除以2。最坏情况下，直到查找区间被缩小为空，才停止。</p><blockquote><p>被查找区间的大小变化：n、n/2、n/4、n/8 ... n/2^k</p></blockquote><p>假设总共查找了 k 次，则剩余 <spanclass="math inline">\(n/2^k\)</span>个元素。最坏的情况是查找到最后一个元素，则有等式：<spanclass="math inline">\(n/2^k = 1\)</span>，即 <spanclass="math inline">\(2^k=n\)</span>，得：<span class="math inline">\(k= log_2n\)</span></p><p>忽略常数，则二分查找的时间复杂度为<code>O(log n)</code></p><p><strong>空间复杂度</strong></p><p>空间复杂度是很简单的，根据上面的流程可以得知，在整个二分搜索的过程中，只需要额外存储三个变量：最大值，最小值 和 中点，因此，空间复杂度是常量 <code>O(1)</code></p><h4 id="python实现">3. Python实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二分查找的递归与分治策略实现（python）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">binary_search</span>(<span class="hljs-params">arr, target, left, right</span>):<br>    <span class="hljs-keyword">if</span> left &lt;= right:<br>        mid = left + (right - left) // <span class="hljs-number">2</span>  <span class="hljs-comment"># 计算中间位置</span><br><br>        <span class="hljs-keyword">if</span> arr[mid] == target:<br>            <span class="hljs-keyword">return</span> mid  <span class="hljs-comment"># 找到目标元素，返回索引</span><br>        <span class="hljs-keyword">elif</span> arr[mid] &lt; target:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, mid + <span class="hljs-number">1</span>, right)  <span class="hljs-comment"># 在右半部分递归查找</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> binary_search(arr, target, left, mid - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 在左半部分递归查找</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>  <span class="hljs-comment"># 目标元素不在数组中，返回-1</span><br><br><span class="hljs-comment"># 输入数组</span><br>input_string = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入一个升序数组（以逗号分隔）: &quot;</span>)<br>arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, input_string.split(<span class="hljs-string">&#x27;,&#x27;</span>)))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;已创建好一个升序数组：&quot;</span>,arr)<br><br><span class="hljs-comment"># 输入要查找的数字</span><br>target = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要查找的数字: &quot;</span>))<br><br>result = binary_search(arr, target, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(arr) - <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> result != -<span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 在索引 <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;目标 <span class="hljs-subst">&#123;target&#125;</span> 不在数组中&quot;</span>)<br><br></code></pre></td></tr></table></figure><h4 id="应用场景及局限性">4. 应用场景及局限性</h4><ul><li><p>二分查找依赖顺序表结构，如数组；</p><blockquote><p>那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是O(1)，而链表随机访问的时间复杂度是O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。</p></blockquote></li><li><p>二分查找针对的是有序数据，如果无序，则要先排序；</p></li><li><p>数据量太小不适合二分查找；</p><blockquote><p>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为10的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。</p><p>只有数据量比较大的时候，二分查找的优势才会比较明显。不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过300的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p></blockquote></li><li><p>数据量太大也不适合二分查找。</p><blockquote><p>最后，数据量太大也不适合二分查找。</p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB大小的内存空间，那照样无法申请一个 1GB大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p></blockquote></li></ul><h4 id="二分查找算法的改进">5. 二分查找算法的改进</h4><blockquote><p>参考：</p><p><ahref="https://blog.csdn.net/Abysscarry/article/details/87388195?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-87388195-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">二分查找算法及其变种详解-CSDN博客</a></p><p><ahref="https://blog.csdn.net/weixin_42001592/article/details/128963283?ops_request_misc=%7B%22request%5Fid%22%3A%22169900884916800211543547%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169900884916800211543547&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-128963283-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=二分查找复杂度分析&amp;spm=1018.2226.3001.4187">算法笔记：二分查找_二分查找的时间复杂度-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法分析与设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 2_变量</title>
    <link href="/2023/11/01/Java%202_%E5%8F%98%E9%87%8F/"/>
    <url>/2023/11/01/Java%202_%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>变量：变量是程序的基本组成单位</p><p>变量的三个基本要素：类型 + 名称 + 值</p><p>示例：<code>int a = 1</code> 类型 int 名称 a 值 1</p></blockquote><p>变量相当于内存中的一个数据存储空间的表示</p><h2 id="变量使用注意事项">2.1 变量使用注意事项</h2><ol type="1"><li>变量表示内存中的一个存储区域。不同变量，不同类型，占用的空间大小不同。如<code>int</code> 有 4 byte，而 <code>double</code> 有 8 byte。</li><li>该区域有自己的名称 <code>变量名</code> 和类型<code>数据类型</code></li><li>变量必须先声明，后使用。</li><li>变量在同一作用域内不能重名。</li><li>该区域的数据/值可以在同一类型范围内变化。</li><li>变量的三个基本要素： 变量名 + 值 + 数据类型</li></ol><h2 id="程序中-的使用">2.2 程序中 <code>+</code> 的使用</h2><ol type="1"><li><p>当左右两边都是数值型，做加法运算</p></li><li><p>当左右两边任意一方为字符串，做拼接运算</p></li><li><p>运算顺序是从左到右的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">1</span> + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;hello&quot;</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span>);<span class="hljs-comment">// 输出 2hello89</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="java-数据类型">2.3 Java 数据类型</h2><h3 id="基本数据类型记住">基本数据类型（记住！）</h3><ul><li><strong>数值型</strong><ul><li>整数类型，存放整数：<ul><li>byte：占用 1 字节</li><li>short：占用 2 字节</li><li>int：占用 4 字节</li><li>long：占用 8 字节</li></ul></li><li>浮点（小数）类型：<ul><li>float：占用 4 字节</li><li>double：占用 8 字节</li></ul></li></ul></li><li><strong>字符型</strong><ul><li>char：存放单个字符，占用 2 字节</li></ul></li><li><strong>布尔型</strong><ul><li>boolean：存放 true（真），false（假）。占用 1 字节</li></ul></li></ul><h3 id="引用数据类型复合数据类型">引用数据类型（复合数据类型）</h3><ul><li><p><strong>类</strong>：class</p></li><li><p><strong>接口</strong>：interface</p></li><li><p><strong>数组</strong>：<code>[]</code></p></li></ul><p>字符串类型String实际上是一个”类“</p><h2 id="整数类型">2.4 整数类型</h2><blockquote><p>用于存放整数值</p></blockquote><ul><li><code>byte</code> 占用 1 字节，范围 -128 ~ 127</li><li><code>short</code> 占用 2 字节，范围 <spanclass="math inline">\(-2^{15} ～ 2^{15} -1\)</span>（-32768~32767）</li><li><code>int</code> 占用 4 字节，范围 <spanclass="math inline">\(-2^{31} ～ 2^{31} - 1\)</span></li><li><code>long</code> 占用 8 字节，范围 <spanclass="math inline">\(-2^{63} ～ 2^{63} - 1\)</span></li></ul><p><strong>使用细节：</strong></p><ol type="1"><li>Java 各整数类型有固定的范围和字符长度，不受具体OS（操作系统）影响，以保证 Java 程序的可移植性。</li><li>Java 默认整型常量为 <code>int</code> ，要声明 <code>long</code>型常量须后加<code>‘l’</code>或<code>‘L’</code></li><li>java程序中变量常声明为<code>int</code>型，除非不足以表示大数，才用<code>long</code></li></ol><p>如果基本的整数、浮点类型不能满足范围、精度的需求，可以使用“大数”（后面会讲）</p><h2 id="浮点类型">2.5 浮点类型</h2><blockquote><p>可以表示一个小数</p></blockquote><ul><li><code>float</code> 单精度（6 ~ 7 位有效数字），占用 4 字节，范围约-3.403E38 ~ 3.403E38</li><li><code>double</code> 双精度（15 位有效数字），占用 8 字节，范围约-1.798E308 ~ 1.798E308</li></ul><p>浮点数在机器中存放形式为：浮点数 = 符号位 + 指数位 + 尾数位</p><p>因此，尾数部分可能丢失，造成精度损失。所以，小数都是近似值</p><h3 id="使用细节">2.5.1 使用细节</h3><ol type="1"><li><p>与整数类型相似，Java浮点类型有固定的范围和字符长度，不受具体OS（操作系统）影响。</p></li><li><p>Java 默认浮点型常量为 <code>double</code> ，要声明<code>float</code> 型常量必须后加 <code>'f'</code> 或<code>'F'</code></p></li><li><p>浮点型常量有两种表示形式</p><ul><li>十进制数形式：<code>5.12</code>、<code>315.4F</code>、<code>.512</code></li><li>科学计数法：<code>5.12e2</code> 即[5.12 ×10的二次方]、<code>5.12E-2</code> 即[5.12 / 10的二次方]</li></ul></li><li><p>通常情况下，应该使用 <code>double</code>类型，因为它比<code>float</code>型更为精确。</p></li><li><p>浮点数使用陷阱：当我们对运算结果是小数的进行相等判断时，要小心。（因为<strong>小数都是近似值</strong>）</p><p>正确方法是：<strong>以两个数差值的绝对值，在某个精度范围内判断</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//num1 = 2.7</span><br><span class="hljs-comment">//num2 = 8.1 / 3</span><br><span class="hljs-keyword">if</span> (Math.abs(num1 - num2) &lt; <span class="hljs-number">0.000001</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;差值非常小，到我的规定精度，认为相等&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="java-api文档">2.6 Java API文档</h2><p>API（Application Programming Interface，应用程序编程接口）是 Java提供的基本编程接口（java提供的类还有相关的方法）。中文在线文档https://www.matools.com/api/java8</p><h2 id="字符类型">2.7 字符类型</h2><blockquote><p>可以表示单个字符，字符类型是char，两个字节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\t&#x27;</span>;   <span class="hljs-comment">//输出一个制表位</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;字&#x27;</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-number">97</span>;    <span class="hljs-comment">//输出一个a</span><br></code></pre></td></tr></table></figure></blockquote><h3 id="使用细节-1">2.7.1 使用细节</h3><ol type="1"><li><p>字符常量用<strong>单引号</strong>括起</p></li><li><p>字符允许使用转义符</p></li><li><p><code>char</code> 的本质是一个整数，默认输出时，输出的是 unicode码对应的字符。</p><p>要输出字符常量对应的整数，用 <code>int</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br>System.out.println((<span class="hljs-type">int</span>)c1);   <span class="hljs-comment">//输出97</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 是可以进行运算的，其相当于一个整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注：(int)&#x27;a&#x27; = 97</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">// 相当于 char c1 = &#x27;b&#x27;</span><br>System.out.println(<span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(<span class="hljs-type">int</span>(c1));    <span class="hljs-comment">// 这个代码输出 98</span><br>System.out.println(c1);        <span class="hljs-comment">// 这个代码输出 b</span><br>System.out.println(<span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>);<span class="hljs-comment">// 这个代码输出 a1</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="字符本质与编码表">2.7.2 字符本质与编码表</h3><ol type="1"><li><p>字符型 存储到计算机中，需要将字符对应的码值(整数)找出来，比如’a’</p><p>存储：’a’ ==&gt; 码值 97 ==&gt; 二进制(110 0001) ==&gt; 存储</p><p>读取：二进制(110 0001) ==&gt; 97 ==&gt; ’a’ ==&gt; 显示</p></li><li><p>字符与码值的对应关系是字符编码表规定的。</p><blockquote><p>ASCII 编码表，占用 1 byte（字节），共有 128个字符。缺点：不能表示所有的字符</p><p>Unicode 编码表，占用 2byte（2的16次方，最多65536个字符），字母汉字都占用 2byte，将世界上所有的符号都纳入其中，这样可能浪费空间（字母多汉字少时）。0- 127 的字符与 ASCII 相同，所以兼容 ASCII。</p><p>UTF-8 编码表，根据不同符号大小可变（1 - 6 byte），字母占用 1byte，汉字占用 3 byte。是 Unicode 的改进，是互联网上使用最广的 Unicode实现方式。</p><p>GBK 编码表，可以表示汉字，而且范围广，字母占用 1 byte，汉字占用 2byte。</p><p>GB2312 编码表，可以表示汉字，用的少（GB2312 &lt; GBK）</p><p>BIG5 编码表，可以存放繁体中文（香港，台湾）</p></blockquote></li></ol><h2 id="布尔类型">2.8 布尔类型</h2><blockquote><p><code>boolean</code> 只允许取值 <code>ture</code> 或<code>false</code> ，没有<code>null</code>。适用于逻辑运算，通常用于程序流程控制</p></blockquote><p><strong>使用细节：</strong></p><ol type="1"><li><p>不可以用 0 或 非0 的整数替代 <code>false</code> 或<code>ture</code> 。这点和 C语言 不同。</p></li><li><p>不能让布尔类型转换为其他类型。如需转换，请使用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> b ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><h2 id="基本数据类型转换">2.9 基本数据类型转换</h2><h3 id="自动类型转换">2.9.1 自动类型转换</h3><blockquote><p>自动类型转换：Java在进行赋值或运算时，精度（容量）小的类型自动转换为精度（容量）大的类型。</p><p>数据类型按精度（容量）大小排序为（<strong>背！</strong>）</p><p>左边精度小，右边精度大</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-function"><span class="hljs-title">char</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br><span class="hljs-function"><span class="hljs-title">byte</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">short</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">int</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">long</span> -&gt;</span> <span class="hljs-function"><span class="hljs-title">float</span> -&gt;</span> double<br></code></pre></td></tr></table></figure><p>例子：<code>int a = 'c'</code> 或者 <code>double b = 80</code></p></blockquote><h4 id="转换细节">2.9.1.1 转换细节</h4><ol type="1"><li><p>有多种类型数据混合运算时，系统会将所有数据转换成容量最大的那种，再进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//错误</span><br><span class="hljs-type">double</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1</span>; <span class="hljs-comment">//正确</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> n1 +<span class="hljs-number">1.1F</span>; <span class="hljs-comment">//正确</span><br></code></pre></td></tr></table></figure></li><li><p>如若把大精度（容量）数据赋值给小精度（容量）类型，就会报错（小数由于精度原因，大赋小会丢失精度，必不可用。但整数大赋小时：1.赋予具体数值时，判断范围。2.变量赋值时，判断类型。），反之进行自动类型转换。</p></li><li><p><code>byte</code> ，<code>short</code>和 <code>char</code>三者不会相互自动转换，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;  <span class="hljs-comment">//正确，当把具体数赋给 byte 时，先判断该数是否在byte范围内，如果是就可以。</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>; <span class="hljs-comment">//错误 </span><br><br><span class="hljs-type">int</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> n2; <span class="hljs-comment">//错误，如果是变量赋值，判断类型</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> b1; <span class="hljs-comment">//错误，不会自动转换</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>三者不会相互自动转换，但可以计算。计算时首先转化为<code>int</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> b2 + s1;  <span class="hljs-comment">//正确</span><br><span class="hljs-type">byte</span> <span class="hljs-variable">b4</span> <span class="hljs-operator">=</span> b2 + b3;  <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p><code>boolean</code> 类型不参与自动转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">pass</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> pass; <span class="hljs-comment">//错误</span><br></code></pre></td></tr></table></figure></li><li><p>自动提升原则：表达式结果的类型自动提升为操作数中最大的类型。❤</p></li></ol><h3 id="强制类型转换">2.9.2 强制类型转换</h3><blockquote><p>强制类型转换：自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时加上强制转换符<code>( )</code>，但<strong>可能造成精度降低或溢出</strong>，要格外注意。</p></blockquote><h4 id="使用细节-2">2.9.2.1 使用细节</h4><ol type="1"><li><p>当进行数据从大到小转换时，就要用强制转换。</p></li><li><p>强制转换只能对最近的操作数有效，往往会使用 <code>( )</code>提升优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>; <span class="hljs-comment">//编译错误：double -&gt;int</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">10</span> * <span class="hljs-number">3.5</span> + <span class="hljs-number">6</span> * <span class="hljs-number">1.5</span>);<span class="hljs-comment">// 编译正确：(int)44.0 -&gt; 44</span><br></code></pre></td></tr></table></figure></li><li><p><code>char</code> 可以保留 <code>int</code>的常量值，但不能保存其变量值。此时需要强制类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a;  <span class="hljs-comment">//错误</span><br><span class="hljs-type">char</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> (<span class="hljs-type">char</span>)a ;<span class="hljs-comment">//ok</span><br></code></pre></td></tr></table></figure></li><li><p><code>byte</code> <code>short</code> <code>char</code>在进行运算时，当作 <code>int</code> 处理。</p></li></ol><h4 id="练习">2.9.2.2 练习</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">12</span>; <span class="hljs-comment">//ok,12在short的范围内</span><br>s = s - <span class="hljs-number">9</span>;   <span class="hljs-comment">//错误，int -&gt; short</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//ok</span><br>b = b + <span class="hljs-number">11</span>; <span class="hljs-comment">//错误，int -&gt; byte</span><br>b = (<span class="hljs-type">byte</span>)(b + <span class="hljs-number">11</span>); <span class="hljs-comment">//ok</span><br><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;  <span class="hljs-comment">//ok</span><br><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">float</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">.314F</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> c + i + d; <span class="hljs-comment">//ok,float -&gt; double，自动转换</span><br><br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>; <span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">14</span>;<span class="hljs-comment">//ok</span><br><span class="hljs-type">short</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> s + b; <span class="hljs-comment">//错误，int -&gt; short </span><br></code></pre></td></tr></table></figure><h3 id="基本数据类型和-string-的转换">2.9.3 基本数据类型和<code>String</code> 的转换</h3><ul><li><p>基本类型转 <code>String</code>：基本数据类型加上<code>" "</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.1F</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> n1 + <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> f1 + <span class="hljs-string">&quot;&quot;</span>;<br>System.out.println(s1 + <span class="hljs-string">&quot;&quot;</span> + s2 + <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>String</code> 转基本数据类型：通过基本数据类型的包装类调用<code>parseXX</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">n1</span> <span class="hljs-operator">=</span> Integer.parseInt(s);<br><span class="hljs-type">double</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Double.parseDouble(s);<br><span class="hljs-type">float</span> <span class="hljs-variable">n2</span> <span class="hljs-operator">=</span> Float.parseFloat(s);<br></code></pre></td></tr></table></figure><p>特别的，把 <code>String</code> 转换为 <code>char</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">// 得到 s 字符串中的第一个字符。</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="使用细节-3">2.9.3.1 使用细节</h4><ol type="1"><li>将 <code>String</code>转成基本数据类型时，要保证其能转换为有效数据。比如：不能把<code>"Hello"</code> 转换成 <code>int</code>。</li><li>如果格式不正确，会抛出，程序会中止。（问题会在异常处理章节中处理）👓</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数学</title>
    <link href="/2023/11/01/%E6%95%B0%E5%AD%A6/"/>
    <url>/2023/11/01/%E6%95%B0%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<p>$$</p><p>定理3 如果有<span class="math inline">\(limf(x) = A\)</span>，<spanclass="math inline">\(limg(x) = B\)</span> ,那么</p><ul><li><span class="math inline">\(lim[f(x) ± g(x)] = limf(x) + limg(x) =A±B\)</span></li><li><span class="math inline">\(lim[f(x) * g(x)] = limf(x) * limg(x) = A* B\)</span></li><li>若又有<span class="math inline">\(B != 0\)</span>,则<ul><li><span class="math inline">\(limf(x)/g(x) = limf(x)/limg(x) =A/B\)</span></li></ul></li></ul><ol type="1"><li>数列单调有界，得出<spanclass="math inline">\(limx_n=limx_{n+1}=A\)</span>;</li><li>由定理：若<span class="math inline">\(limx_n\)</span>不为零，则<spanclass="math inline">\(lim(x_{n+1}/x_n)=limx_{n+1}/limx_n=A/A=1。\)</span>,而题中为1/2，∴<spanclass="math inline">\(limx_n=0\)</span></li></ol><p><strong>那么当n趋于无穷大时，设数列<spanclass="math inline">\(x_n\)</span>极限为a，那么<spanclass="math inline">\(x_{n+1}\)</span>的极限也为a吗，如何证明？</strong></p><p>①正常思考，当n等于任意合理值时<spanclass="math inline">\(x_n=a\)</span>一定成立。既然已经假定数列有极限，那么当n趋近无穷大时，<spanclass="math inline">\(x_{n+1}-x_n→0\)</span>，它们有相同的极限。</p><p>②证明: <imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311072152624.png"alt="image-20231107215208567" /></p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S13能夺冠吗？</title>
    <link href="/2023/10/31/S13/"/>
    <url>/2023/10/31/S13/</url>
    
    <content type="html"><![CDATA[<p>S13，LPL能夺冠吗？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NewStarCTF 2023 week2</title>
    <link href="/2023/10/27/NewStarCTF%202023%20week2/"/>
    <url>/2023/10/27/NewStarCTF%202023%20week2/</url>
    
    <content type="html"><![CDATA[<h2 id="滴啤">滴啤</h2><h3 id="main">main</h3><blockquote><p>不分解也能求</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_prime</span>(<span class="hljs-params">number</span>):<br>    p = getPrime(number//<span class="hljs-number">2</span>)<br>    q = getPrime(number//<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> p,q<br><br>m = bytes_to_long(flag.encode())<br>p,q = gen_prime(<span class="hljs-number">1024</span>)<br><span class="hljs-built_in">print</span>(p*q)<br>e = <span class="hljs-number">65537</span><br>d = gmpy2.invert(e,(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(d%(p-<span class="hljs-number">1</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">pow</span>(m,e,p*q))<br><span class="hljs-comment"># 93172788492926438327710592564562854206438712390394636149385608321800134934361353794206624031396988124455847768883785503795521389178814791213054124361007887496351504099772757164211666778414800698976335767027868761735533195880182982358937211282541379697714874313863354097646233575265223978310932841461535936931</span><br><span class="hljs-comment"># 307467153394842898333761625034462907680907310539113349710634557900919735848784017007186630645110812431448648273172817619775466967145608769260573615221635</span><br><span class="hljs-comment"># 52777705692327501332528487168340175436832109866218597778822262268417075157567880409483079452903528883040715097136293765188858187142103081639134055997552543213589467751037524482578093572244313928030341356359989531451789166815462417484822009937089058352982739611755717666799278271494933382716633553199739292089</span><br><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p><strong>考点</strong>：已知dp分解n</p><p>什么玩意,求助xenny呜呜呜😭</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>&lt;Java&gt; 1_概述</title>
    <link href="/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/10/18/Java%201_%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="java-历史">1.1 Java 历史</h2><ul><li><p>目前 Java 版权属于甲骨文公司。</p></li><li><p>长期支持的版本只有 Java8 与Java11。这两个版本也是最多使用的版本。</p></li><li><p>Java SE：标准版</p><p>Java EE：企业版（重要）</p><p>Java ME：小型版（少）</p></li></ul><h2 id="java-重要特点">1.2 Java 重要特点</h2><ol type="1"><li><p>Java 语言是<strong>面向对象的（oop）</strong></p><p>简单来说，面向对象是一种程序设计技术。其重点放在数据（对象）和对象的接口上。</p></li><li><p>Java语言是<strong>健壮的</strong>。其强类型机制、异常处理、垃圾自动收集是健壮性的保证。</p><p>Java强调早期问题检测、后期动态检测，及消除易出错的情况。其编译器能检测很多其他语言仅在运行时才会发现的问题。</p></li><li><p>Java 语言是<strong>跨平台性</strong>的：一个编译好的<code>.class</code>文件可以在多个不同系统（windows、Linux等）下直接运行。</p></li><li><p>Java 语言是<strong>解释型</strong>的：Java解释器能在任何移植了解释器的机器上直接执行 Java 字节码。</p><p>解释性语言：javascript，PHP，java等</p><p>编译性语言：c， c++等</p><p>区别是：</p><ul><li>解释性语言，编译后的代码，不能直接被机器执行，需要解释器来执行</li><li>编译性语言，编译后的代码，可以直接被机器执行</li></ul></li></ol><h2 id="java的开发工具">1.3 Java的开发工具</h2><ul><li>javac：Java 编译器。将 Java 程序编译成字节码</li><li>java：Java 解释器。执行已经转换为字节码的文件</li><li>jdb：Java 调试器。调试 Java 程序</li><li>javap：反编译。将类文件还原回方法和变量</li><li>javadoc：文档生成器。创建 HTML 文件</li></ul><h2 id="java-运行基础">1.4 Java 运行基础</h2><p>JVM：Java Virtual Machine（Java虚拟机）</p><ul><li>JVM 是–跨平台性的基础。被包含在 JDK 中。</li><li>不同平台有各自对应的不同 JVM</li><li>JVM 屏蔽了底层平台的区别。能做到 ”一次编译，到处运行”</li></ul><p>JDK ：全称：Java Development Kit（Java 开发工具包）</p><ul><li>JDK = JRE + Java 的开发工具（Java，Javac，Javadoc 等等）</li><li>给开发人员使用的，包括了 JRE</li></ul><p>JRE：Java Runtime Enviroment（Java 运行环境）</p><ul><li>JRE = JVM + Java SE 标准类库（Java 的核心类库）</li><li>如果想要运行一个开发好的 Java 程序，计算机中只需要安装JRE即可</li></ul><h2 id="java快速入门">1.5 Java快速入门</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//java第一个程序</span><br><br><span class="hljs-comment">//1. public class Hello 表示Hello是一个类，是一个public公有的类</span><br><span class="hljs-comment">//2. Hello&#123;&#125;表示一个类的开始和结束</span><br><span class="hljs-comment">//3. public static void main(String[] args)表示一个主方法</span><br><span class="hljs-comment">//4. main()&#123;&#125;表示方法的开始和结束</span><br><span class="hljs-comment">//5. System.out.println(&quot;hello,world~&quot;)表示输出hello,world~</span><br><span class="hljs-comment">//6. ;表示语句结束</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span>&#123;<br><br><span class="hljs-comment">//main方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;我的 hello,world~&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="java-执行流程分析">1.6 Java 执行流程分析</h2><blockquote><p><code>.Java</code> 文件（源文件） — javac（编译）—<code>.class</code> 文件（字节码文件） — java（运行）— 结果</p></blockquote><h3 id="编译">1.5.1 编译</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>源文件名.<span class="hljs-keyword">java</span><br></code></pre></td></tr></table></figure><ul><li>通过编译器将 Java 源文件编译成 JVM可识别的字节码文件。字节码文件是二进制格式的，其格式是统一的。</li><li>在源文件目录下使用 Javac 编译工具对 Java 文件进行编译。</li><li>如果没有错误将没有提示，当前目录会对应其中每一个类生成对应名称的<code>.class</code> 文件，该文件称为字节码文件，也是可执行的 Java程序。</li></ul><h3 id="运行">1.5.2 运行</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">java 程序名 <span class="hljs-selector-attr">[参数列表]</span><br></code></pre></td></tr></table></figure><ul><li>有了可执行的 Java 程序（例如Hello.class字节码文件）</li><li>通过运行工具<code>Java.exe</code> 对字节码文件进行执行，本质是将<code>.class</code> 文件装载到 JVM 机执行</li></ul><p><strong>注意，修改后的 .Java 源文件需要重新编译</strong></p><h2 id="java-开发细节">1.7 Java 开发细节</h2><p><strong>在控制台按 Tab 可以实现代码补齐。</strong></p><ol type="1"><li><p>源文件以 <code>.java</code>为扩展名，源文件的基本组成部分是类（class）</p></li><li><p>Java 应用程序的执行入口是 <code>main()</code>方法。其有固定的<strong>书写格式：</strong></p><p><code>public static void main(string[]args)&#123;…&#125;</code></p></li><li><p>Java 语言<strong>严格区分大小写</strong>。</p></li><li><p>Java 方法由一条条语句构成，<strong>每个语句都以 <code>;</code>结束</strong>。</p></li><li><p><strong>大括号 <code>&#123;</code> <code>&#125;</code>是成对出现的</strong>，缺一不可。习惯先写 <code>&#123;&#125;</code>再写代码</p></li><li><p>一个源文件中<strong>最多只有一个 public类</strong>，其余类不限。</p></li><li><p><strong>如果文件中包含 public类，则文件名必须按该类命名。</strong></p></li><li><p>也可以把 main 方法写在非 public 类中，然后运行指定非 public类，这样入口方法是非 public 类的主方法。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,world~&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//一个源文件中最多只有一个 public 类，其余类不限。</span><br><span class="hljs-comment">//Dog 是一个类</span><br><span class="hljs-comment">// 编译后，每一个类，都会生成一个.class</span><br><span class="hljs-comment">//这里就会生成三个.class文件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br>    <span class="hljs-comment">//也可以把 main 方法写在非 public 类中，然后运行指定非 public 类，这样入口方法是非 public 类的主方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小狗&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tiger</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;Hello,小老虎&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011227499.png"alt="image-20231101122753469" /><figcaption aria-hidden="true">image-20231101122753469</figcaption></figure><h2 id="java-转义字符">1.8 Java 转义字符</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//演示转义字符的使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangeChar2</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br><span class="hljs-comment">//     \t：一个制表位，实现对齐的功能</span><br>System.out.println(<span class="hljs-string">&quot;北京\t上海\t广州&quot;</span>);<br><br><span class="hljs-comment">//     \n：换行符</span><br>System.out.println(<span class="hljs-string">&quot;北京\n上海\n广州&quot;</span>);<br><br><span class="hljs-comment">//     \\：一个\</span><br>System.out.println(<span class="hljs-string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>);<br><br><span class="hljs-comment">//       \&#x27;：  一个&#x27;</span><br><span class="hljs-comment">//       \&quot;：  一个&quot;</span><br><span class="hljs-comment">//       \r：  一个回车</span><br>System.out.println(<span class="hljs-string">&quot;一起学习java\r我们&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311011508043.png"alt="image-20231101150805984" /><figcaption aria-hidden="true">image-20231101150805984</figcaption></figure><h2 id="代码规范">1.9 代码规范</h2><ol type="1"><li><p>类、方法的注释要以 Javadoc 的方式来写</p></li><li><p>非 Javadoc的注释，往往是给维护者看的，着重告诉读者为什么这样写，如何修改，注意什么问题等。</p></li><li><p>不要用 <code>a</code><code>b</code>，这种名称命名变量，尽量写得清楚<code>int age = 10;</code></p><p>另外，<strong>Java 源代码使用的是 Unicode码，因此汉语也能作为标识符</strong>。但不推荐使用汉语做标识符。</p></li><li><p>使用 tab 键操作，使代码右移。使用 shift+tab键，使代码左移。</p></li><li><p>运算符两边各加入空格。注意排版规范。</p></li><li><p>源文件使用 UTF-8 编码。</p></li><li><p>代码行宽度不要超过 80 个字符。超过时通过换行保持简洁。</p></li><li><p>代码编写<strong>次行风格</strong>及<strong>行尾风格</strong></p><blockquote><p>次行风格：换行输入<code>&#123;</code> <code>&#125;</code>，使其总在行头，√</p><p>行尾风格：在一行的末尾输入 <code>&#123;</code>，换行输入<code>&#125;</code></p></blockquote></li><li><p>一段代码完成一个小功能，尽量不要混合。这样更加灵活。</p></li></ol><h2 id="dos了解">1.10 DOS（了解）</h2><blockquote><p>DOS：Disk Operating System（磁盘操作系统）</p></blockquote><h3 id="dos-的基本原理">DOS 的基本原理</h3><blockquote><p>在 cmd（控制台）输入指令 — DOS系统 接受指令 — 解析指令 — 执行指令</p></blockquote><ul><li><p>相对路径和绝对路径（举例从 JDK8访问到 JDK8）</p><blockquote><p>相对路径：从当前目录开始定位，形成的路径 <code>..\jre\bin</code></p><p>返回上一级：<code>..\</code></p><p>绝对路径：从顶级目录开始定位，形成的路径<code>d:\Program\JDK8\jre\bin</code></p></blockquote></li></ul><h3 id="常用的-dos-命令">常用的 DOS 命令</h3><blockquote><p>查看帮助：<code>help</code> 或 <code>help cd</code> 等</p><p>查看目录内容：<code>dir</code> 查看当前目录 或<code>dir d:\Program\JDK8\bin</code> 查看指定目录</p><p>切换到其他盘：<code>cd /D d:</code> 从 C盘 切换至 D盘 （changedirectory）</p><p>切换到当前盘的其他目录：<code>cd d:\Program\JDK8\jre\bin</code></p><p>返回上级目录：<code>cd ..</code></p><p>切换至根目录：<code>cd \</code></p><p>查看子集目录：<code>tree</code> 当前目录 或<code>tree d:/Program</code> 指定目录</p><p>清屏：<code>cls</code></p><p>退出：<code>exit</code></p><p>创建目录：<code>md 目录名</code> 如：<code>md tom100</code></p><p>删除目录：<code>rd 目录名</code></p><p>:traffic_light:</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习</title>
    <link href="/2023/10/18/Java%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/10/18/Java%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>记事本乱码解决方案：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1697599757237.png"alt="1697599757237" /><figcaption aria-hidden="true">1697599757237</figcaption></figure><h3 id="类的封装">类的封装</h3><p>定义：类的封装，是指将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象的内部信息，而是通过该类所提供的方法来实现对内部信息的操作访问。</p><p>如何实现封装：在定义一个类时，将类中的属性私有化，即<strong>使用private关键字来修饰，私有属性只能在它所在类中被访问</strong>，如果外界想要访问私有属性，需要提供一些使用public修饰的公有方法，其中包括用于获取属性值的getXxx()方法和设置属性值的setXxx()方法。</p><h3 id="类的继承">类的继承</h3><p>定义：在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类或基类，子类会自动拥有父类所有可继承的属性和方法</p><h3 id="多态">多态</h3><p>定义：在Java中，多态是指不同类的对象在调用同一个方法时所呈现出的多种不同行为。</p><p>说明：通常来说，在一个类中定义的属性和方法被其他类继承或重写后，当把子类对象直接赋值给父类引用变量时，相同引用类型的变量调用同一个方法所呈现出的多种不同形态。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构实验</title>
    <link href="/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/10/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="哈夫曼编码">哈夫曼编码</h2><p><ahref="https://blog.csdn.net/qq_35852228/article/details/111192722?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=哈夫曼编码c&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-111192722.142%5Ev96%5Epc_search_result_base1&amp;spm=1018.2226.3001.4187">数据结构：霍夫曼（哈夫曼）编码（C语言）_数据结构求huffman编码-CSDN博客</a></p><p>今天刚学到（10.17）：</p><p>D.对给定的输入数值集合所生成的哈夫曼树深度是确定的 （×）</p><p>解释：当两个结点的和与另外两结点的值相同时，组合顺序不同生产的哈夫曼树深度不同，比如权分别为：1，1，2，2，</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NewStarCTF 2023 week1</title>
    <link href="/2023/10/02/NewStarCTF%202023%20week1/"/>
    <url>/2023/10/02/NewStarCTF%202023%20week1/</url>
    
    <content type="html"><![CDATA[<p>NewStarCTF 2023 week1 Crypto方向的一些题</p><h2 id="vigenère">Vigenère</h2><p>维吉尼亚密码解密</p><p>打开txt后就一段字符：</p><p>pqcq{qc_m1kt4_njn_5slp0b_lkyacx_gcdy1ud4_g3nv5x0}</p><p>前四个应该是对应flag，直接找就欧克了</p><p>下表<strong>上面一行是明文，左边一列是密钥</strong></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695730908860.png"alt="1695730908860" /><figcaption aria-hidden="true">1695730908860</figcaption></figure><p>这段字符害的我好苦，太傻了我，都找到key是kfck了，怎么就不能想到是key的长度是3呢</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695729736638.png"alt="1695729736638" /><figcaption aria-hidden="true">1695729736638</figcaption></figure><p>但是好像有什么更厉害的遍历网站/代码，可是我没找到😥（</p><h2 id="babyxor">babyxor</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> *<br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append(f ^ key)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><span class="hljs-comment"># e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><p>看了知道是异或</p><p><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></p><p>将f转换成对应的ASCII码，与0xe9进行异或就可以获得key</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1695732585874.png"alt="1695732585874" /><figcaption aria-hidden="true">1695732585874</figcaption></figure><p>得到key是143</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> binascii         <span class="hljs-comment"># 该模块包含了十六进制编码和解码的函数。</span><br>cipher = <span class="hljs-string">&quot;e9e3eee8f4f7bffdd0bebad0fcf6e2e2bcfbfdf6d0eee1ebd0eabbf5f6aeaeaeaeaeaef2&quot;</span><br>c = binascii.unhexlify(cipher)  <span class="hljs-comment"># 将十六进制字符串 cipher 解码为字节序列并将结果存储在变量 c 中</span><br>                                <span class="hljs-comment"># binascii.unhexlify() 函数用于将十六进制字符串转换为二进制数据。</span><br><br>key = <span class="hljs-number">143</span><br><br>result = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c:<br>    result += <span class="hljs-built_in">chr</span>(i^key)    <span class="hljs-comment"># chr() 函数用于将一个整数转换为对应的字符。</span><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h2 id="affine">Affine</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag, key<br><br>modulus = <span class="hljs-number">256</span><br><br>ciphertext = []<br><br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flag:<br>    ciphertext.append((key[<span class="hljs-number">0</span>]*f + key[<span class="hljs-number">1</span>]) % modulus)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">bytes</span>(ciphertext).<span class="hljs-built_in">hex</span>())<br><br><span class="hljs-comment"># dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064</span><br><br><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><p>仿射密码</p><p>exp是照着一个师傅的代码copy的</p><p><ahref="https://blog.csdn.net/qq_38798840/article/details/127206181?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Newstarctf&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-7-127206181.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">NewStarCTF公开赛week2密码学题目wp_ctf密码学题目_想要变强的47的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2<br><br>a = <span class="hljs-string">&quot;dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064&quot;</span><br><br><span class="hljs-comment"># 使用 bytes.fromhex() 方法将十六进制字符串转换为字节数据</span><br>byte_data = <span class="hljs-built_in">bytes</span>.fromhex(a)<br><br><span class="hljs-comment"># 打印字节数据</span><br><span class="hljs-built_in">print</span>(byte_data)<br><br><br><span class="hljs-comment"># f1=ord(&#x27;\xb1&#x27;)</span><br><span class="hljs-comment"># #f2=ord(&#x27;\x83&#x27;) #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br><span class="hljs-comment"># f3=ord(&#x27;\x82&#x27;)</span><br><span class="hljs-comment"># f4=ord(&#x27;T&#x27;)  #ord(&#x27;T&#x27;)=84，是g对应的密文</span><br><br>f1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xdd&#x27;</span>)<br><span class="hljs-comment">#f2=ord(&#x27;C&#x27;)   #因为&#x27;l&#x27;-&#x27;f&#x27;的值是6,6找不到模256的乘法逆元所以不能用f和l两个字母求解未知因数a</span><br>f3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\x88&#x27;</span>)<br>f4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;\xee&#x27;</span>) <br><br><br>m1=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;f&#x27;</span>)<br><span class="hljs-comment">#m2=ord(&#x27;l&#x27;)</span><br>m3=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br>m4=<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;g&#x27;</span>)  <span class="hljs-comment">#ord(&#x27;g&#x27;)=103，可以验证a=17,b=23时满足(103*a+b)%256 = 238 = ord(&#x27;\xee&#x27;)</span><br><br>a=(f3-f1)*gmpy2.invert(m3-m1,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span> <span class="hljs-comment">#可以用&#x27;f&#x27;和&#x27;a&#x27;求解出a</span><br><span class="hljs-built_in">print</span>(a)   <span class="hljs-comment">#a=17</span><br>b=(f1-a*m1)%<span class="hljs-number">256</span><br><span class="hljs-built_in">print</span>(b)   <span class="hljs-comment">#b=23</span><br><br><span class="hljs-comment"># c=&quot;\xb1\x83\x82T\x10\x80\xc9O\x84\xc9&lt;\x0f\xf2\x82\x9a\xc9\x9b8&#x27;\x9b&lt;\xdb\x9b\x9b\x82\xc8\xe0V&quot;</span><br><br>c=<span class="hljs-string">&quot;\xddC\x88\xeeB\x8b\xdd\xddXe\xccf\xaaX\x87\xff\xcc\xa9f\x10\x9cf\xed\xcc\xa9 fz\x881 d&quot;</span><br>flag=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> cc <span class="hljs-keyword">in</span> c:<br>    m=(<span class="hljs-built_in">ord</span>(cc)-b)*gmpy2.invert(a,<span class="hljs-number">256</span>)%<span class="hljs-number">256</span><br>    flag+=<span class="hljs-built_in">chr</span>(m)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><br></code></pre></td></tr></table></figure><blockquote><p>为什么是dd、C、88、ee这样组合呢？</p><p>我的想法是你可以看原来的十六进制的数据 a ="dd4388ee428bdddd5865cc66aa5887ffcca966109c66edcca920667a88312064"</p><p>因为一个字节由8个二进制位组成，表示成十六进制就是2个十六进制位组成，那么就是两个一组表示一个字节</p><p>也就是dd、43、88、ee，即下面的dd、C、88、ee，写的时候要写成''，</p></blockquote><blockquote><p><code>f1 = ord('\xdd')</code>这行代码的作用是将十六进制表示的字节序列 <code>'\xdd'</code>转换为对应的整数值，并将结果赋值给变量 <code>f1</code>。</p><ol type="1"><li><code>\xdd</code>: 这是一个字符串字面量，其中 <code>\x</code>是表示后面两个字符是十六进制值的转义序列，<code>dd</code>是两个十六进制数字，表示一个字节的十六进制值。在这里，<code>\xdd</code>表示一个字节，其十六进制值为 <code>0xdd</code>。</li><li><code>ord()</code>: 这是一个内置函数，用于获取给定字符的 Unicode码点（整数值）。在这里，<code>ord('\xdd')</code> 将返回<code>221</code>，因为十六进制 <code>0xdd</code> 对应的十进制值是<code>221</code>。</li><li><code>ord("a")</code> <strong>会返回字母 a对应的ASCII码：97</strong></li></ol><p>所以，<code>f1</code> 最终的值将是 <code>221</code>，因为它表示了字符<code>'\xdd'</code> 对应的 Unicode 码点。</p></blockquote><h2 id="babyaes">babyaes</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> data + <span class="hljs-string">b&quot;&quot;</span>.join([<span class="hljs-string">b&#x27;\x00&#x27;</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">16</span> - <span class="hljs-built_in">len</span>(data))])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    flag_ = pad(flag)<br>    key = os.urandom(<span class="hljs-number">16</span>) * <span class="hljs-number">2</span><br>    iv = os.urandom(<span class="hljs-number">16</span>)<br>    <span class="hljs-built_in">print</span>(bytes_to_long(key) ^ bytes_to_long(iv) ^ <span class="hljs-number">1</span>)<br>    aes = AES.new(key, AES.MODE_CBC, iv)<br>    enc_flag = aes.encrypt(flag_)<br>    <span class="hljs-built_in">print</span>(enc_flag)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br><span class="hljs-comment"># 3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>官方说法：</p><p>解密 flag 我们需要获取到 key 和 iv 的值，由条件：</p><p>key=os.urandom(16)*2</p><p>iv=os.urandom(16)</p><p>可知：key是32bytes,256bits ；iv是16bytes ,128bits</p><p>key^iv ，那么只有 iv 与 key 的低128位相异或，所以 key的高128位是固定不变的。所以 xor 的高128bits,就是 key的高128bits,进而可以得到 key 的所有值256bits。</p><p>之后 key 的低128bits，与 xor 的低128bits 相异或，所得结果就是 iv的值了</p><p>得到 key , iv 后就可以直接用aes.decrypt()来解密了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这是我的exp，没成功，（后来发现是做出来了😡</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-keyword">import</span> os<br> <br><br>out = <span class="hljs-number">3657491768215750635844958060963805125333761387746954618540958489914964573229</span><br><span class="hljs-comment"># 转换成为字节类型</span><br>out =long_to_bytes(out)<br><br>flag_encrypted = <span class="hljs-string">b&#x27;&gt;]\xc1\xe5\x82/\x02\x7ft\xf1B\x8d\n\xc1\x95i&#x27;</span><br> <br><span class="hljs-comment">#高十六位是key的高十六位 并且key是按照16位进行重复 所以得到高16位就能得到整个key</span><br>key = out[:<span class="hljs-number">16</span>]*<span class="hljs-number">2</span><br><br><br><span class="hljs-comment"># 把key的低十六位与out的低十六位做异或就能得到向量iv</span><br>iv = bytes_to_long(key[<span class="hljs-number">16</span>:]) ^ bytes_to_long(out[<span class="hljs-number">16</span>:])<br><br><span class="hljs-comment">#重新转换成为字节</span><br>iv = long_to_bytes(iv)<br><span class="hljs-comment">#创建aes解密器 需要秘钥key 解密模式 还有解密向量iv</span><br>aes = AES.new(key,AES.MODE_CBC,iv)<br><span class="hljs-comment">#使用解密器解密</span><br>flag = aes.decrypt(flag_encrypted)<br><br><span class="hljs-built_in">print</span>(flag)<br><br><span class="hljs-comment"># b&#x27;firsT_cry_Aes\x00\x00\x01&#x27;</span><br><span class="hljs-comment"># 然后flag&#123;firsT_cry_Aes&#125;，测！</span><br></code></pre></td></tr></table></figure><h2 id="babyrsa">babyrsa</h2><blockquote><p>提示：很容易分解的n</p></blockquote><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> flag <span class="hljs-keyword">import</span> flag<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">gen_prime</span>(<span class="hljs-params">n</span>):<br>    res = <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">15</span>):<br>        res *= getPrime(n)<br><br>    <span class="hljs-keyword">return</span> res<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    n = gen_prime(<span class="hljs-number">32</span>)<br>    e = <span class="hljs-number">65537</span><br>    m = bytes_to_long(flag)<br>    c = <span class="hljs-built_in">pow</span>(m,e,n)<br>    <span class="hljs-built_in">print</span>(n)<br>    <span class="hljs-built_in">print</span>(c)<br><span class="hljs-comment"># 17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br><span class="hljs-comment"># 14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><blockquote><p>跟MoeCTF 2023 factor_signin 一题一样</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br>n = <span class="hljs-number">17290066070594979571009663381214201320459569851358502368651245514213538229969915658064992558167323586895088933922835353804055772638980251328261</span><br>c = <span class="hljs-number">14322038433761655404678393568158537849783589481463521075694802654611048898878605144663750410655734675423328256213114422929994037240752995363595</span><br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P10 = 3831680819</span><br><span class="hljs-string">P10 = 2338725373</span><br><span class="hljs-string">P10 = 2370292207</span><br><span class="hljs-string">P10 = 2706073949</span><br><span class="hljs-string">P10 = 2970591037</span><br><span class="hljs-string">P10 = 2923072267</span><br><span class="hljs-string">P10 = 3654864131</span><br><span class="hljs-string">P10 = 2463878387</span><br><span class="hljs-string">P10 = 3939901243</span><br><span class="hljs-string">P10 = 2804303069</span><br><span class="hljs-string">P10 = 3207148519</span><br><span class="hljs-string">P10 = 4093178561</span><br><span class="hljs-string">P10 = 2217990919</span><br><span class="hljs-string">P10 = 2794985117</span><br><span class="hljs-string">P10 = 4278428893&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-comment"># b&#x27;flag&#123;us4_s1ge_t0_cal_phI&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="small-d">small d</h2><h3 id="main-4">main</h3><blockquote><p>提示: Michael J. Wiener 觉得很赞</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br>d = getPrime(<span class="hljs-number">32</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>n = p*q<br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><br><span class="hljs-built_in">print</span>(c)<br><span class="hljs-built_in">print</span>(e)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># c = 6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br><span class="hljs-comment"># e = 8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br><span class="hljs-comment"># n = 19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><blockquote><p>[RSA2]4(Wiener)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny师傅的库</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>c = <span class="hljs-number">6755916696778185952300108824880341673727005249517850628424982499865744864158808968764135637141068930913626093598728925195859592078242679206690525678584698906782028671968557701271591419982370839581872779561897896707128815668722609285484978303216863236997021197576337940204757331749701872808443246927772977500576853559531421931943600185923610329322219591977644573509755483679059951426686170296018798771243136530651597181988040668586240449099412301454312937065604961224359235038190145852108473520413909014198600434679037524165523422401364208450631557380207996597981309168360160658308982745545442756884931141501387954248</span><br>e = <span class="hljs-number">8614531087131806536072176126608505396485998912193090420094510792595101158240453985055053653848556325011409922394711124558383619830290017950912353027270400567568622816245822324422993074690183971093882640779808546479195604743230137113293752897968332220989640710311998150108315298333817030634179487075421403617790823560886688860928133117536724977888683732478708628314857313700596522339509581915323452695136877802816003353853220986492007970183551041303875958750496892867954477510966708935358534322867404860267180294538231734184176727805289746004999969923736528783436876728104351783351879340959568183101515294393048651825</span><br>n = <span class="hljs-number">19873634983456087520110552277450497529248494581902299327237268030756398057752510103012336452522030173329321726779935832106030157682672262548076895370443461558851584951681093787821035488952691034250115440441807557595256984719995983158595843451037546929918777883675020571945533922321514120075488490479009468943286990002735169371404973284096869826357659027627815888558391520276866122370551115223282637855894202170474955274129276356625364663165723431215981184996513023372433862053624792195361271141451880123090158644095287045862204954829998614717677163841391272754122687961264723993880239407106030370047794145123292991433</span><br><br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MoeCTF 2023</title>
    <link href="/2023/09/24/MoeCTF%202023/"/>
    <url>/2023/09/24/MoeCTF%202023/</url>
    
    <content type="html"><![CDATA[<h2 id="crypto-入门指北">Crypto 入门指北</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> secret <span class="hljs-keyword">import</span> flag <span class="hljs-comment"># 这个secret不是一个库，flag是你要自己求出来的，所以不要问为什么找不到这个库了（</span><br><br>p,q = getPrime(<span class="hljs-number">512</span>), getPrime(<span class="hljs-number">512</span>) <span class="hljs-comment"># 随机生成了两个质数</span><br>e = <span class="hljs-number">65537</span> <span class="hljs-comment"># 这是什么？</span><br>n = p*q<br>m = <span class="hljs-built_in">int</span>.from_bytes(flag.encode(),<span class="hljs-string">&quot;big&quot;</span>) <span class="hljs-comment"># 把flag编码成bytes，再转换成一个长整数</span><br>c = <span class="hljs-built_in">pow</span>(m,e,n) <span class="hljs-comment"># RSA加密！</span><br><br><span class="hljs-built_in">print</span>(p)<br><span class="hljs-built_in">print</span>(q)<br><span class="hljs-built_in">print</span>(c)<br><br><span class="hljs-comment"># p = 0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br><span class="hljs-comment"># q = 0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br><span class="hljs-comment"># c = 0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br></code></pre></td></tr></table></figure><blockquote><p><code>m = int.from_bytes(flag.encode(),"big")</code></p><p>这行代码的作用是将字符串 <code>flag</code> 转换成一个大整数<code>m</code>。具体解释如下：</p><ul><li><code>flag</code>:这是一个字符串，通常包含需要进行加密或其他操作的敏感信息，例如密码或标志。</li><li><code>flag.encode()</code>: 这是将字符串 <code>flag</code>转换为字节序列的操作。在计算机中，所有的数据最终都会以字节的形式表示。<code>encode()</code>方法将字符串编码为字节，使用默认的编码方式（通常是UTF-8）。</li><li><code>"big"</code>:这是一个参数，它告诉Python将字节序列视为一个大端（big-endian）的整数。在大端表示法中，高位字节在前，低位字节在后。这是一种常见的表示整数的方式。</li><li><code>int.from_bytes(...)</code>:这是一个方法，用于将字节序列转换为整数。它接受两个参数，第一个参数是要转换的字节序列，第二个参数是表示字节序列顺序的字符串，这里是<code>"big"</code>。它会将字节序列按照指定的顺序解释为一个整数。</li></ul><p>因此，<code>m</code> 将包含了从字符串 <code>flag</code>转换而来的整数表示。在加密算法中，通常会将明文消息转换成整数形式，以便进行数学运算，例如RSA加密中的指数运算。</p></blockquote><blockquote><p><code>c = pow(m,e,n)</code></p><p>这行代码实现了RSA（Rivest–Shamir–Adleman）加密的核心操作。具体解释如下：</p><ul><li><code>m</code>:这是明文消息的整数表示。在RSA加密中，明文消息通常首先被编码成一个整数，这个整数在加密过程中被处理。</li><li><code>e</code>:这是RSA加密算法中的公钥指数。它是一个正整数，通常是65537。公钥指数是用于加密消息的指数。</li><li><code>n</code>:这是RSA加密算法中的模数（或称为模ulus）。它是两个大素数 p 和 q的乘积。模数在RSA加密和解密过程中都会用到。</li><li><strong><code>pow(m, e, n)</code>: 这是Python中的一个函数，用于计算m 的 e 次方除以 n的余数</strong>。也就是说，它执行的是模指数运算。在RSA加密中，这等效于对明文消息m 进行加密操作。</li></ul><p>最终，<code>c</code>将包含加密后的密文，它是整数形式的，可以通过RSA私钥进行解密，从而还原为原始的明文消息<code>m</code>。RSA是一种非对称加密算法，公钥用于加密，私钥用于解密，这使得只有拥有私钥的人才能够解密密文。</p></blockquote><p><strong><em>哦~~，这里就是说flag是不知道的，就是让我们求一下flag</em></strong></p><h3 id="exp">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><br>p = <span class="hljs-number">0xe82a76eeb5ac63e054128e040171630b993feb33e0d3d38fbb7c0b54df3a2fb9b5589d1205e0e4240b8fcb4363acaa4c3c44dd6e186225ebf3ce881c7070afa7</span><br>q = <span class="hljs-number">0xae5c2e450dbce36c8d6d1a5c989598fc01438f009f9b4c29352d43fd998d10984d402637d7657d772fb9f5e4f4feee63b267b401b67704979d519ad7f0a044eb</span><br>c = <span class="hljs-number">0x4016bf1fe655c863dd6c08cbe70e3bb4e6d4feefacaaebf1cfa2a8d94051d21e51919ea754c1aa7bd1674c5330020a99e2401cb1f232331a2da61cb4329446a17e3b9d6b59e831211b231454e81cc8352986e05d44ae9fcd30d68d0ce288c65e0d22ce0e6e83122621d2b96543cec4828f590af9486aa57727c5fcd8e74bd296</span><br>e = <span class="hljs-number">65537</span><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>) * (q-<span class="hljs-number">1</span>) <span class="hljs-comment"># 你知道什么是 欧拉函数吗 [1]</span><br>d = <span class="hljs-built_in">pow</span>(e, -<span class="hljs-number">1</span>, phi) <span class="hljs-comment"># 什么是乘法逆元？ [2]</span><br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><p>相当于我们知道了p，q，c，e，然后求m，那就求出 n 和 d 即可</p><p>所以关键的就是求d</p><blockquote><p><code>d = pow(e, -1, phi)</code></p><p>这行代码计算了私钥 <code>d</code>，它是公钥指数 <code>e</code> 在模<code>phi</code> 下的乘法逆元。</p><p>因为 e 和 d之间一定满足：<code>(e * d) % phi(n) = 1</code>，即<code>e*d ≡ 1(mod φ(N))</code></p><p>这行代码其实跟之前 <em>[SWPUCTF 2021 新生赛]ez_rsa</em>解密代码中<code>d = gmpy2.invert(e, phi)</code>是一个意思</p></blockquote><ul class="task-list"><li><label><input type="checkbox" />由$ e*d ≡ 1(mod φ(N)) $可以得出 $e^{-1} ≡ d(mod φ(N)) $ 吗？</label></li></ul><p>答案是可以的，经过简单的运算即可得到</p><p>知识：<ahref="%5B乘法逆元%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/inverse/#定义)">乘法逆元</a>、<ahref="%5B欧拉函数%20-%20OI%20Wiki%20(oi-wiki.org)%5D(https://oi-wiki.org/math/number-theory/euler/)">欧拉函数</a>等</p><hr /><h2 id="baby_e">baby_e</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime,bytes_to_long<br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>e = <span class="hljs-number">7</span><br>n = p*q<br>m = bytes_to_long(<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>,<span class="hljs-string">&#x27;rb&#x27;</span>).read().strip())<br>c = <span class="hljs-built_in">pow</span>(m,e,n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c = &quot;</span>,c)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n = &quot;</span>,n)<br><br><span class="hljs-comment"># c =  147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br><span class="hljs-comment"># n =  553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br><br>c = <span class="hljs-number">147693154873835354725007152781732424355869776162377337823960431913672366269917723916891506269449726723757821517328874729037838600793748824028829185409932536014732765063216715033843955453706710187792772702199448156372644163429786386035008302836467605094954587157232829525150652611067567669525072625329634860065850520051628272535479197120008981979404760445193750864902244921407742155742716289495581989134730376783828846663464819337418977287363028738701414486788851136608957124505485242331701209645216580641917007780811842757125048746184068597664780265422321550909392419865169775282217442331295071069272774722564587602419768461231775480847018941840911357926330143045826277813722919121117172763493242590521245640828462665947672485094793188432098216701511715232654611338293295459889814699850788048985878279440740712956248569068077253790198036918598519191892836075254345518967666166925163908185663991353344555402397055977817370082929420443034626201745027965444069777059760865359310439815816749939498993014457995041394803598825093836045546578310632172636478575946653375857640993393714607308326474003446154152048840071034349831168612740218034679021240949747357214453636633636662650940968576792518622437627529244515229173</span><br>n = <span class="hljs-number">553409369582823237678532685244026647155180191225879439432235077135813123637186465008813830373646133388592395760175777499266561095087891764348044063111935877931069321764391883899483374576303169645488542398590564148654412004383012178107972880058460460806768779452529433458826925606225797078653905380530651390617109384086518728626571028089036812787671647095695947167204428442727185744172445701874820612799168887428075695751162763647868386879374037826876671079326544820609721731078985096813307183878793033824330869698508952853770794414757655681370862323768018291030331209143189638496644361618184164228294031490537429556439588954274708598530042700988138862000054458742762198052079867259365645914383561162796796952346445529346145323567650621600171442575319262718389389870407629339714751583360252884338116164466349449862781112019462555743429653595045695696967783338371470032332852204294900011651434678829104876529439166176589508898757122660322523937330848536715937381297551894198974459004139082562228022412335520195652419375915216074658463954339332593244483927157329404652516225481116614815221154229491846087288087715884363786672244655901308480290011237244562251084095684531716327141154558809471185132979704992609461470501119328696999713829</span><br>e = <span class="hljs-number">7</span>       <span class="hljs-comment"># 但是我们不知道p和q啊，这怎么求啊</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">7</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><span class="hljs-comment"># print(a)</span><br><br></code></pre></td></tr></table></figure><p>思路（very very very 感谢峰哥（<del>其实是学弟，惭愧</del>））：</p><p>小公钥指数攻击：</p><ul><li>因为 e 很小，n 很大</li><li>所以明文 m 乘了 e 次方也没到 n ，n 根本没用到</li><li>所以 c直接开7次根就是明文了，这里要用<code>gmpy2.iroot(c, 7)</code>，而不能<code>pow(c,1/7)</code>，后者算不动</li><li>找时间去看：<ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></li></ul><hr /><h2 id="bad_e">bad_E</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(p) <span class="hljs-comment"># 6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br><span class="hljs-built_in">print</span>(q) <span class="hljs-comment"># 11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>m = bytes_to_long(flag.encode())<br>c = <span class="hljs-built_in">pow</span>(m,e,p*q)<br><span class="hljs-built_in">print</span>(c) <span class="hljs-comment"># 63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><p>参考下面的博客：</p><p><ahref="https://blog.csdn.net/qq_57235775/article/details/132575196?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=e和phi不互素&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-132575196.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">e与phi不互素的情况_余切66的博客-CSDN博客</a></p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694699685619.png"alt="1694699685619" /><figcaption aria-hidden="true">1694699685619</figcaption></figure><p>e和phi不互素，本题是gcd(e,q-1)=1，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> * <span class="hljs-comment"># 一个非常好用的crypto库</span><br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">6853495238262155391975011057929314523706159020478084061020122347902601182448091015650787022962180599741651597328364289413042032923330906135304995252477571</span><br>q = <span class="hljs-number">11727544912613560398705401423145382428897876620077115390278679983274961030035884083100580422155496261311510530671232666801444557695190734596546855494472819</span><br><br>c = <span class="hljs-number">63388263723813143290256836284084914544524440253054612802424934400854921660916379284754467427040180660945667733359330988361620691457570947823206385692232584893511398038141442606303536260023122774682805630913037113541880875125504376791939861734613177272270414287306054553288162010873808058776206524782351475805</span><br>e = <span class="hljs-number">65537</span><br><br><span class="hljs-built_in">print</span>(gcd(e,q-<span class="hljs-number">1</span>))<br><br><br>phi = q-<span class="hljs-number">1</span><br>d = gmpy2.invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,q)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factor_signin">factor_signin</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip()<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(flag) == <span class="hljs-number">72</span><br><br>m1 = <span class="hljs-built_in">int</span>.from_bytes(flag[:<span class="hljs-number">36</span>],<span class="hljs-string">&quot;big&quot;</span>)<br>m2 = <span class="hljs-built_in">int</span>.from_bytes(flag[<span class="hljs-number">36</span>:],<span class="hljs-string">&quot;big&quot;</span>)<br><br>e = <span class="hljs-number">65537</span><br><br>p,q = getPrime(<span class="hljs-number">2048</span>),getPrime(<span class="hljs-number">2048</span>)<br>n1 = p*q<br>c1 = <span class="hljs-built_in">pow</span>(m1,e,n1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c1 = &quot;</span>,c1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n1 = &quot;</span>,n1)<br><br>primes = [getPrime(<span class="hljs-number">64</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">32</span>)]<br>n2 = prod(primes)<br>c2 = <span class="hljs-built_in">pow</span>(m2,e,n2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;c2 = &quot;</span>,c2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n2 = &quot;</span>,n2)<br><br><span class="hljs-comment"># c1 =  10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br><span class="hljs-comment"># n1 =  343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br><span class="hljs-comment"># c2 =  4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br><span class="hljs-comment"># n2 =  8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><p>前半部分：直接分解n1</p><p>后半部分：n2是多个素数的乘积，求欧拉函数，我教过你吧😋<del>（但是这个脚本我还真第一次见</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>e = <span class="hljs-number">65537</span><br><br>c1 =  <span class="hljs-number">10004937130983861141937782436252502991050957330184611684406783226971057978666503675149401388381995491152372622456604317681236160071166819028679754762162125904637599991943368450200313304999566592294442696755822585022667008378021280392976010576970877334159755332946926433635584313137140987588847077645814987268595739733550220882135750267567373532603503399428451548677091911410732474324157868011686641243202218731844256789044721309478991918322850448456919991540932206923861653518190974620161055008847475600980152660468279765607319838003177639654115075183493029803981527882155542925959658123816315099271123470754815045214896642428657264709805029840253303446203030294879166242867850331945166255924821406218090304893024711068773287842075208409312312188560675094244318565148284432361706108491327014254387317744284876018328591380705408407853404828189643214087638328376675071962141118973835178054884474523241911240926274907256651801384433652425740230755811160476356172444327762497910600719286629420662696949923799255603628210458906831175806791599965316549386396788014703044837917283461862338269599464440202019922379625071512100821922879623930069349084917919100015782270736808388388006084027673781004085620817521378823838335749279055639005125</span><br>n1 =  <span class="hljs-number">343504538870081878757729748260620800783581983635281373321527119223374418103340873199654926888439040391545101913132680017655039577253974802351999985470115474655124168592386965001556620077117966153475518658881140827499124290142523464795351995478153288872749817655925271395693435582010998996210909883510311066017237567799370371513462802547313382594409676803895262837061350017911885033133654781876923251129406855067993830824618637981136966134029212516871210627954762147349788788999116702635535406398258621926040887099782494271000823401788337120154104692934583729065189687995570122890809807661370008740283447636580308161498808092269041815719148127168137018600113465985504975054319601741498799761500526467431533990903047624407330243357514588557352746347337683868781554819821575385685459666842162355673947984514687068626166144076257334426612302554448774082488600083569900006274897032242821388126274957846236552373226099112200392102883351088570736254707966329366625911183721875374731791052229266503696334310835323523568132399330263642353927504971311717117370721838701629885670598853025212521537158141447625623337563164790788106598854822686494249848796441153496412236527242235888308435573209980270776407776277489669763803746640746378181948641</span><br>c2 =  <span class="hljs-number">4948422459907576438725352912593232312182623872749480015295307088166392790756090961680588458629287353136729331282506869598853654959933189916541367579979613191505226006688017103736659670745715837820780269669982614187726024837483992949073998289744910800139692315475427811724840888983757813069849711652177078415791290894737059610056340691753379065563574279210755232749774749757141836708161854072798697882671844015773796030086898649043727563289757423417931359190238689436180953442515869613672008678717039516723747808793079592658069533269662834322438864456440701995249381880745586708718334052938634931936240736457181295</span><br>n2 =  <span class="hljs-number">8582505375542551134698364096640878629785534004976071646505285128223700755811329156276289439920192196962008222418309136528180402357612976316670896973298407081310073283979903409463559102445223030866575563539261326076167685019121804961393115251287057504682389257841337573435085535013992761172452417731887700665115563173984357419855481847035192853387338980937451843809282267888616833734087813693242841580644645315837196205981207827105545437201799441352173638172133698491126291396194764373021523547130703629001683366722885529834956411976212381935354905525700646776572036418453784898084635925476199878640087165680193737</span><br><br>p1 = <span class="hljs-number">18055722101348711626577381571859114850735298658417345663254295930584841136416234624852520581982069555948490061840244710773146585295336094872892685938420880462305333393436098181186277450475949236132458958671804132443554885896037342335902958516394876382378829317303693655605215373555988755516058130500801822723195474873517960624159417903134580987202400855946137101429970119186394052011747475879598126195607938106163892658285305921071673588966184054026228745012993740035399652049777986535759039077634555909031397541116025395236871778797949216479130412500655359057128438928721459688727543057760739527720641179290282309741</span><br>q1 = <span class="hljs-number">19024691283015651666032297670418553586155390575928421823630922553034857624430114628839720683172187406577114034710093054198921843669645736474448836706112221787749688565566635453151716934583685087745112614898780150391513798368931496744574075511968933800467288441832780919514199410584786925010518564670786685241724643282580795568609339268652910564215887176803735675069372979560024792322029911970574914829712553975379661212645059271137916107885326625543090473004683836665262304916304580076748336858662108554591235698235221618061328251985929904075811056422186525179189846420226944944513865790999242309352900287977666792901</span><br><br>phi = (p1-<span class="hljs-number">1</span>)*(q1-<span class="hljs-number">1</span>)<br>d = invert(e,phi)<br>m = <span class="hljs-built_in">pow</span>(c1,d,n1)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><br><br>factor = <span class="hljs-string">&#x27;&#x27;&#x27;P20 = 14745811312384518031</span><br><span class="hljs-string">P20 = 18345408081492711641</span><br><span class="hljs-string">P20 = 14678737767649343977</span><br><span class="hljs-string">P20 = 14619040595108594017</span><br><span class="hljs-string">P19 = 9949603102225364603</span><br><span class="hljs-string">P20 = 12034779627328165471</span><br><span class="hljs-string">P20 = 10596280721192026229</span><br><span class="hljs-string">P20 = 15211380502610462057</span><br><span class="hljs-string">P20 = 14813953870710226847</span><br><span class="hljs-string">P20 = 13062839684118954553</span><br><span class="hljs-string">P20 = 15332916111580607077</span><br><span class="hljs-string">P20 = 16870346804576162551</span><br><span class="hljs-string">P20 = 11092420583960163379</span><br><span class="hljs-string">P20 = 14397830993057803133</span><br><span class="hljs-string">P20 = 16123604149048919099</span><br><span class="hljs-string">P20 = 13645878578452317313</span><br><span class="hljs-string">P20 = 17093292308638969889</span><br><span class="hljs-string">P20 = 17289161209347211817</span><br><span class="hljs-string">P20 = 15175734709842430433</span><br><span class="hljs-string">P20 = 15751974537676958401</span><br><span class="hljs-string">P20 = 10864078180916418691</span><br><span class="hljs-string">P20 = 17673334943789572513</span><br><span class="hljs-string">P20 = 18390046459144888243</span><br><span class="hljs-string">P20 = 12404642343676224637</span><br><span class="hljs-string">P20 = 18106525049998616747</span><br><span class="hljs-string">P20 = 11853704782834170959</span><br><span class="hljs-string">P20 = 17543713628803023199</span><br><span class="hljs-string">P20 = 10049235158029375571</span><br><span class="hljs-string">P20 = 12448177342966243757</span><br><span class="hljs-string">P20 = 17265001711647542137</span><br><span class="hljs-string">P20 = 10547615587767500213</span><br><span class="hljs-string">P20 = 16408421615173973083&#x27;&#x27;&#x27;</span><br><br>factor = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>,[i.split()[-<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> factor.split(<span class="hljs-string">&#x27;\n&#x27;</span>)]))<br>phin = reduce(<span class="hljs-keyword">lambda</span> a,b:a*(b-<span class="hljs-number">1</span>),[<span class="hljs-number">1</span>] + factor)<br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phin)<br>m2 = <span class="hljs-built_in">pow</span>(c2,d,n2)<br><br><span class="hljs-comment"># print(bytes.fromhex(hex(pow(c2,d,n2))[2:]))</span><br><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m2))<br><span class="hljs-comment"># b&#x27;moectf&#123;fACtord6_And_YAfu_Are_6oth_good_utils_to_fACtorize_num6ers_ff90S&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="feistel">feistel</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br><span class="hljs-built_in">round</span> = <span class="hljs-number">2</span><br>flag = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;./secret&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>).read().strip()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">m, key</span>):<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">4</span>)<br>    m = m ^ (m &lt;&lt; <span class="hljs-number">5</span>)<br>    m = m ^ (m &gt;&gt; <span class="hljs-number">8</span>)<br>    m ^= key<br>    m = (m * <span class="hljs-number">1145</span> + <span class="hljs-number">14</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * <span class="hljs-number">1919</span> + <span class="hljs-number">810</span>) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    m = (m * key) % <span class="hljs-number">2</span>**<span class="hljs-number">64</span><br>    <span class="hljs-keyword">return</span> m<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>(<span class="hljs-params">m, key, <span class="hljs-built_in">round</span></span>):<br>    key = bytes_to_long(key)<br>    left = bytes_to_long(m[:<span class="hljs-number">8</span>])<br>    right = bytes_to_long(m[<span class="hljs-number">8</span>:])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">round</span>):<br>        left, right = right, f(right, key) ^ left<br>    left, right = right, left<br>    <span class="hljs-keyword">return</span> long_to_bytes(left).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>) + long_to_bytes(right).rjust(<span class="hljs-number">8</span>, <span class="hljs-string">b&quot;\x00&quot;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">padding</span>(<span class="hljs-params">m</span>):<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    pad = <span class="hljs-number">16</span> - mlen % <span class="hljs-number">16</span><br>    <span class="hljs-keyword">return</span> m + pad * <span class="hljs-built_in">bytes</span>([pad])<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">ecb_enc</span>(<span class="hljs-params">m, key</span>):<br>    m = padding(m)<br>    mlen = <span class="hljs-built_in">len</span>(m)<br>    c = <span class="hljs-string">b&quot;&quot;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(mlen // <span class="hljs-number">16</span>):<br>        c += enc(m[i * <span class="hljs-number">16</span> : i * <span class="hljs-number">16</span> + <span class="hljs-number">16</span>], key, <span class="hljs-built_in">round</span>)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-built_in">print</span>(ecb_enc(flag, <span class="hljs-string">b&quot;wulidego&quot;</span>))<br><br><span class="hljs-comment"># b&#x27;\x0b\xa7\xc6J\xf6\x80T\xc6\xfbq\xaa\xd8\xcc\x95\xad[\x1e\&#x27;W5\xce\x92Y\xd3\xa0\x1fL\xe8\xe1&quot;^\xad&#x27;</span><br><br></code></pre></td></tr></table></figure><h2 id="nn">n&amp;n</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = getPrime(<span class="hljs-number">1024</span>)<br>q = getPrime(<span class="hljs-number">1024</span>)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;flag.txt&quot;</span>,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    flag = f.read().strip().encode()<br><br>m = bytes_to_long(flag)<br>n = p * q<br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br>c1 = <span class="hljs-built_in">pow</span>(m,e1,n)<br>c2 = <span class="hljs-built_in">pow</span>(m,e2,n)<br><span class="hljs-built_in">print</span>(c1) <br><span class="hljs-built_in">print</span>(c2)<br><span class="hljs-built_in">print</span>(n)<br><br><span class="hljs-comment"># 5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br><span class="hljs-comment"># 4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br><span class="hljs-comment"># 13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br></code></pre></td></tr></table></figure><h3 id="exp-4">exp</h3><p>共模攻击，用的脚本</p><p><u>这里十六进制的e1竟然不用转换</u></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> gmpy2<br> <br>c1 = <span class="hljs-number">5776799746376051463605370130675046329799612910435315968508603116759552095183027263116443417343895252766060748671845650457077393391989018107887540639775168897954484319381180406512474784571389477212123123540984850033695748142755414954158933345476509573211496722528388574841686164433315356667366007165419697987147258498693175698918104120849579763098045116744389310549687579302444264316133642674648294049526615350011916160649448726069001139749604430982881450187865197137222762758538645387391379108182515717949428258503254717940765994927802512049427407583200118969062778415073135339774546277230281966880715506688898978925</span><br>c2 = <span class="hljs-number">4664955020023583143415931782261983177552050757537222070347847639906354901601382630034645762990079537901659753823666851165175187728532569040809797389706253282757017586285211791297567893874606446000074515260509831946210526182765808878824360460569061258723122198792244018463880052389205906620425625708718545628429086424549277715280217165880900037900983008637302744555649467104208348070638137050458275362152816916837534704113775562356277110844168173111385779258263874552283927767924979691542028126412133709129601685315027689094437957165812994784648540588277901241854031439324974562449032290219652206466731675967045633360</span><br>e1 = <span class="hljs-number">0x114514</span><br>e2 = <span class="hljs-number">19198101</span><br><br><span class="hljs-comment"># e1 = int(str(e1), 16) </span><br><br><br>n = <span class="hljs-number">13612969130810965900902742090064423006385890357159609755971027204203418808937093492927060428980020085273603754747223030702684866992231913349067578014240319426522039068836171388168087260774376277346092066880984406890296520951318296354893551565670293486797637522297989653182109744864444697818991039473180752980752117041574628063002176339235126861152739066489620021077091941250365101779354009854706729448088217051728432010328667839532327286559570597994183126402340332924370812383312664419874352306052467284992411543921858024469098268800500500651896608097346389396273293747664441553194179933758992070398387066135330851531</span><br><br><br> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">RSA_ComModAtk</span>(<span class="hljs-params">e1, e2, c1, c2, n</span>):<br>    e1, e2, c1, c2, n = <span class="hljs-built_in">int</span>(e1), <span class="hljs-built_in">int</span>(e2), <span class="hljs-built_in">int</span>(c1), <span class="hljs-built_in">int</span>(c2), <span class="hljs-built_in">int</span>(n)<br>    <span class="hljs-keyword">if</span> gmpy2.gcd(e1,e2) ==<span class="hljs-number">1</span>:<br>        s = gmpy2.gcdext(e1, e2)  <span class="hljs-comment"># 扩展欧几里得算法-辗转相除法使得  x*e1+y*e2=1,求出t和z</span><br>        x = s[<span class="hljs-number">1</span>]<br>        y = s[<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:<br>            x = - x  <span class="hljs-comment"># 变指数为正值</span><br>            c1 = gmpy2.invert(c1, n)  <span class="hljs-comment"># 求c1的逆元</span><br>        <span class="hljs-keyword">if</span> y &lt; <span class="hljs-number">0</span>:<br>            y = -y  <span class="hljs-comment"># 变指数为正值</span><br>            c2 = gmpy2.invert(c2, n)  <span class="hljs-comment"># 求c2的逆元</span><br>        m = (<span class="hljs-built_in">pow</span>(c1, x, n) * <span class="hljs-built_in">pow</span>(c2, y, n)) % n  <span class="hljs-comment"># (c1^x*c2^y)%n=m^e1x*me2y%n=m^(e1x+e2y)%n=m%n=m</span><br>        <span class="hljs-keyword">return</span> m<br>    <span class="hljs-keyword">else</span> :<br>        <span class="hljs-keyword">return</span> bytes_to_long(<span class="hljs-string">b&#x27;e1 and e2 are not relatively prime&#x27;</span>) <span class="hljs-comment"># e1和e2不互质</span><br>    <br><br>m = RSA_ComModAtk(e1, e2, c1, c2, n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><h2 id="factorize_me">factorize_me!</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> getPrime<br><span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> prod<br><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> nextprime<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choices<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;flag.txt&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> fs:<br>    flag = fs.read().strip()<br><br>primes = [getPrime(<span class="hljs-number">512</span>) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">9</span>)]<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(primes) = &#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;prod(p - <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> primes) = &#125;</span>&quot;</span>)<br><br>primes2 = [nextprime(p) <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> choices(primes, k=<span class="hljs-number">3</span>)]<br>n = prod(primes2)<br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">int</span>.from_bytes(flag, <span class="hljs-string">&#x27;big&#x27;</span>), e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836866602305788131186220057989320357344904731322223310531945208433910803617954798258382169132907508787682006064930747033681966462568715421005454243255297306718356766130469885581576362173340673516476386201173298433892314145854649884922769732583885904512624543994675379894718657682146178638074984373206937523380103438050549181568015985546172618830480078894445808092527561363650503540062128543705172678754195578429520889784813733491180748361345720247750720179608752244490362713103319685024237941527268458213442611663415417005556439749055222361212059968254748751273361732365487788593341859760309778894350385339764442343374673786357175846291309425081492959910254127778240522152676060766139057453197528944251599979227271074508795482632471242983094008619339488744362509349734218480932255216087706001484182136783834973304870508270118505737767002256270427907341952256516206663258530300791364944105025764611810001781971638030661367630116818647252727909489405550104641122269772492252464714694507693447974171377200402508765841829763548525530878309985480248379655169722567051495205792089930014228403456098065971372039443284193603395249634283366194562380309469628114581468645669390610963076340643757972439104287127375438663839421605531570285615180251</span><br><span class="hljs-comment"># 363364907814244019888662301376841344262476227242899756862391470731421569394957444030214887114615748277199649349781524749919652160244484352285668794188836492373364350673588273863828369502073826782362255108313852264064760467561392054178047091483873483255491431451728274259516789065331176728192953741805933100379191778599394515981288225535175013258094287912195847642598436035132783919453991516358280321085873745330313812205910011387125778714795906023110368957596998222544234082487264006696812862179916726781327290284827659294751262185328816323311831349296593013038823107653943652771448719760448938995150646738377177532550757319539185878535087009904848382493668686831331474113789651777885239747000076063679062106375348803749466079052774597412239427050432901553466002731972993029311850718200685157193170716432600165476733200831046297530470544781309612128231925681374239849452623513538498417735984094919756374577623486416462101457492789215144166273775249387638107644634704270216130852885082174564648445147377239033930079759024399532146184753110240154062693457622208373371290126810856885343328090305620627668495081760346853701632815149478447405718664667978825807101325764916405446176183238866136433205933785973568759281210319422288153910340542098573782006262190181726245838857185687242960093445000287347616796984610291664809895901301187179157382169999966124177588884152267266994164841066291200</span><br><span class="hljs-comment"># n = 899081756851564072995842371038848265712822308942406479625157544735473115850983700580364485532298999127834142923262920189902691972009898741820291331257478170998867183390650298055916005944577877856728843264502218692432679062445730259562784479410120575777748292393321588239071577384218317338474855507210816917917699500763270490789679076190405915250953860114858086078092945282693720016414837231157788381144668395364877545151382171251673050910143023561541226464220441</span><br><span class="hljs-comment"># e = 65537</span><br><span class="hljs-comment"># c = 841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br></code></pre></td></tr></table></figure><h3 id="exp-5">exp</h3><p><strong>[RSA1]P7</strong>，直接分解n运算即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">841335863342518623856757469220437045493934999201203757845757404101093751603513457430254875658199946020695655428637035628085973393246970440054477600379027466651143466332405520374224855994531411584946074861018245519106776529260649700756908093025092104292223745612991818151040610497258923925952531383407297026038305824754456660932812929344928080812670596607694776017112795053283695891798940700646874515366341575417161087304105309794441077774052357656529143940010140</span><br><br>p = <span class="hljs-number">6991223361118904775931217829045348785013077549030883418924453538830605687999480005714979700653172534877541317997174968789510984315425270755055110913347349</span><br>q = <span class="hljs-number">9987009117206906203158749743824168660291275882852229158070368815160479543708376165641735042845357978292384303332559592302507789120810447986634662721490849</span><br>r = <span class="hljs-number">12876877424944854147075816504195994138450356002779004886384584287813869165469217718717854027672044903401715370348223932937626725119320180795716270261309141</span><br><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment"># 不知道上面给那两个大数是干啥的</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数学习</title>
    <link href="/2023/09/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/23/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>byd这个用markdown写着太麻烦了😡</p></blockquote><h2 id="lec01_方程组的几何解释">Lec01_方程组的几何解释</h2><p>线性代数的基本问题就是解n元一次方程组。</p><p>例如：二元一次方程组</p><p><span class="math display">\[\left\{ \begin{matrix}2x+y=0   \\-x+2y=3\end{matrix}\right.\]</span></p><p>写成矩阵形式就是：</p><p><span class="math display">\[\begin{bmatrix}2&amp;-1  \\-1&amp;2  \\\end{bmatrix}\begin{bmatrix}x \\y\end{bmatrix}=\begin{bmatrix}0 \\ 34\end{bmatrix}\]</span></p><p>其中<span class="math inline">\(A = \begin{bmatrix}  2&amp;-1\\  -1&amp;2 \\ \end{bmatrix}\)</span>被称为系数矩阵</p><p>未知数向量通常记为 <span class="math inline">\(X = \begin{bmatrix}x\\ y \end{bmatrix}\)</span></p><p>而等号右侧的向量记为<strong>b</strong>。线性方程组简记为<strong>Ax=b</strong>。</p><h3 id="行图像">行图像</h3><p>就是按行来画，跟我们之前的思维很像</p><p>行图像遵从解析几何的描述，每个方程在平面上的图像为一条直线。找到符合方程的两个数组，就可以确定出x-y平面上的两个点，</p><p>连接两点可以画出该方程所代表的直线。两直线交点即为方程组的解x=1,y=2。</p><h3 id="列图像">列图像</h3><p>在列图像中，我们将系数矩阵写成列向量的形式，则求解原方程变为寻找列向量的线性组合来构成向量<strong>b</strong>。</p><p><span class="math inline">\(x\begin{bmatrix}  2 \\  -1 \\\end{bmatrix}+y\begin{bmatrix}  -1 \\  -2 \\\end{bmatrix}=\begin{bmatrix}  0 \\  3 \\ \end{bmatrix}\)</span></p><p>向量线性组合是贯穿本课程的重要概念。对于给定的向量<strong>c</strong>和<strong>d</strong>以及标量<em>x</em>和<em>y</em>，我们将x<strong>c</strong>+y<strong>d</strong>称之为<strong>c</strong>和<strong>d</strong>的一个线性组合。</p><p>几何上讲，如下图：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230923165849317.png"alt="image-20230923165849317" /><figcaption aria-hidden="true">image-20230923165849317</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构学习</title>
    <link href="/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="第二章-线性表">第二章 线性表</h2><h3 id="section">2.5</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">L</span><span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">; P=L;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br>P-&gt;next<span class="hljs-operator">=</span>NULL<span class="hljs-comment">;</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">;i&gt;=1;i--) Ins_LinkList(L,i+1,i*2);</span><br>for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=3;i++) Del_LinkList(L,i);</span><br></code></pre></td></tr></table></figure><p><code>L=(LinkList)malloc(sizeof(LNode));</code></p><p>这行代码是C或C++中用于动态分配内存并创建一个链表（或链表的头节点）的代码。</p><p>这行代码作用的详细解释：</p><ol type="1"><li><code>malloc</code> 函数：<code>malloc</code>是C和C++中用于动态分配内存的函数。它的作用是在堆（heap）中分配一块指定大小的内存，并返回一个指向该内存块的指针。在这里，<code>malloc(sizeof(LNode))</code>分配了一块大小为 <code>sizeof(LNode)</code> 字节的内存。</li><li><code>sizeof(LNode)</code>：<code>sizeof</code>是一个运算符，用于获取数据类型或结构体的大小（以字节为单位）。<code>LNode</code>是链表节点的数据结构（或类型），因此 <code>sizeof(LNode)</code> 返回<code>LNode</code> 结构体的大小。</li><li><code>(LinkList)</code>强制类型转换：在C和C++中，<code>malloc</code> 返回一个 <code>void</code>指针，需要将其转换为所需的数据类型，这里是 <code>LinkList</code>类型。这样做是为了让指针指向正确的数据类型，以便后续操作。</li><li><code>L</code>：这是链表的头指针，它被分配了一块内存，并指向了链表的头节点。</li></ol><p>总结起来，这行代码的作用是创建一个链表，并将链表的头指针<code>L</code> 指向一个新分配的内存块，该内存块大小为<code>sizeof(LNode)</code> 字节，用来存储链表的头节点。</p><p>这是创建链表的起始步骤，通常会跟随其他操作来构建链表的节点和连接。在使用完链表后，需要记得使用<code>free</code>函数来释放分配的内存，以避免内存泄漏。例如：<code>free(L)</code>。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for(i<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">;i&lt;=4;i++)&#123;</span><br>    P-&gt;next<span class="hljs-operator">=</span>(LinkList)malloc(sizeof(LNode))<span class="hljs-comment">;</span><br>P<span class="hljs-operator">=</span>P-&gt;next<span class="hljs-comment">; </span><br>P-&gt;data<span class="hljs-operator">=</span>i*<span class="hljs-number">2</span>-<span class="hljs-number">1</span><span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个循环，它用于在链表中创建四个节点，并为每个节点赋值。解释如下：</p><ol type="1"><li><code>for(i=1;i&lt;=4;i++)</code>：这是一个循环，它会执行四次，<code>i</code>从1开始，每次递增1，直到 <code>i</code> 的值为4。</li><li><code>P-&gt;next=(LinkList)malloc(sizeof(LNode));</code>：这行代码分配了一个新的内存块，用于存储下一个节点，并将当前节点的<code>next</code>指针指向这个新节点。这意味着创建了一个新节点，并将其链接到链表中。</li><li><code>P=P-&gt;next;</code>：将指针 <code>P</code>移动到下一个节点。现在 <code>P</code>指向了新创建的节点，以便为它赋值。</li><li><code>P-&gt;data=i*2-1;</code>：为当前节点的 <code>data</code>成员赋值。这里应该是<code>P-&gt;data = i*2 - 1;</code>，将当前节点的数据设为 <code>i</code>乘以 2 减去 1 的结果。</li></ol><p>所以，这个循环会创建四个新的节点，并在每个节点的 <code>data</code>成员中存储一个奇数值（1、3、5、7）。</p><p>然后最后两行语句-----</p><ul><li><code>Ins_LinkList(L,i+1,i*2);</code>：调用了一个名为<code>Ins_LinkList</code> 的函数，将元素 <code>i*2</code> 插入到链表的第<code>i+1</code> 个位置。</li><li><code>Del_LinkList(L,i);</code>：调用了一个名为<code>Del_LinkList</code> 的函数，删除链表中的第 <code>i</code>个元素(<strong>这里是不算头节点的,因为头节点没有被赋予元素?????</strong>)。</li></ul><h3 id="section-1">2.6</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><code>while(P-&gt;next!=NULL) P=P-&gt;next;</code></label></li></ul><p>这行代码是一个 <code>while</code> 循环，其目的是在链表中移动指针<code>P</code> 直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。</p><p>解释如下：</p><ol type="1"><li><code>P-&gt;next != NULL</code>：这是一个条件表达式，它检查当前节点<code>P</code> 的下一个节点是否不等于<code>NULL</code>。条件表达式的结果是一个布尔值，如果当前节点的下一个节点不是<code>NULL</code>，则条件为真，继续执行循环体。</li><li><strong><code>P = P-&gt;next;</code>：如果条件为真，就执行这行代码。这行代码将指针<code>P</code> 移动到下一个节点，即将 <code>P</code>更新为当前节点的下一个节点，以便继续检查下一个节点是否为链表的末尾。(终于理解😭)</strong></li></ol><p>循环将一直执行，直到 <code>P</code> 的下一个节点为<code>NULL</code>，也就是链表的末尾节点。一旦链表末尾被找到，条件表达式为假，循环终止。这段代码通常用于遍历整个链表，直到到达链表的末尾节点。</p><p>总之，这段代码的目的是在链表中移动指针 <code>P</code>直到达到链表的末尾节点。</p><p>已知 L 是带表头结点的非空单链表，和已知 L是无表头结点的单链表，有什么区别</p><h3 id="section-2">2.7</h3><p><strong>带表头结点</strong>和<strong>无表头结点</strong>的单链表在数据结构中有一些重要区别：</p><ol type="1"><li><strong>存在与否：</strong><ul><li><strong>带表头结点的单链表：</strong>这种链表在头部有一个额外的结点，通常称为表头结点或者哨兵结点。这个结点不存储实际的数据，它的主要目的是使链表操作更容易实现，因为它可以避免对空链表的特殊处理。带表头结点的链表通常在操作上更加统一，因为头结点始终存在，即使链表为空。</li><li><strong>无表头结点的单链表：</strong>这种链表不包含表头结点，直接从第一个存储数据的结点开始。这意味着如果链表为空，那么链表头部就是一个空指针，需要特殊处理。</li></ul></li><li><strong>索引/遍历起始点：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，链表的第一个数据结点从头结点的下一个结点开始，索引为1。</li><li><strong>无表头结点的单链表：</strong>在没有头结点的情况下，链表的第一个数据结点通常是链表的头部，索引为0。</li></ul></li><li><strong>空链表处理：</strong><ul><li><strong>带表头结点的单链表：</strong>即使链表为空，头结点始终存在，因此对于空链表的处理与非空链表一样，不需要额外的特殊情况处理。</li><li><strong>无表头结点的单链表：</strong>如果链表为空，头部就是一个空指针，需要特殊处理，否则在访问链表时可能会引发错误。</li></ul></li><li><strong>操作实现的复杂性：</strong><ul><li><strong>带表头结点的单链表：</strong>由于头结点的存在，通常可以更容易地实现插入和删除操作，因为不需要特殊情况处理头部节点。</li><li><strong>无表头结点的单链表：</strong>操作实现可能稍微复杂一些，因为需要处理头部节点的特殊情况。</li></ul></li></ol><p>在实际应用中，选择使用带表头结点还是无表头结点的单链表取决于具体的需求和设计。带表头结点的链表通常在实现上更加统一和方便，而无表头结点的链表可能更节省一些内存空间。</p><p><strong>首元结点&amp;尾元结点</strong></p><p>判断:在带头结点的循环单链表中，尾元结点的next指针指向链表的首元结点。</p><blockquote><p>false</p><p>尾元结点的next值指向链表的头节点，而不是首元结点。</p><p>首元结点指的是链表中存储第一个数据元素的结点。头节点是在首元结点之前设置的一个结点。</p></blockquote><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230919200445761.png"alt="image-20230919200445761" /><figcaption aria-hidden="true">image-20230919200445761</figcaption></figure><p>这里的D是尾元结点</p><p><strong>【头结点】【头指针】【首元结点】</strong></p><p>头结点（不一定有），存在为了方便操作，头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义（但也可以用来存放链表的长度），对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了。</p><p>首元结点：实际记录数据的第一个节点；</p><p>头指针：指向第一个物理节点地址的指针，就是定义的链表名，这个头指针的意义在于，在访问链表时，总要知道链表存储在什么位置（从何处开始访问），由于链表的特性（next指针），知道了头指针，那么整个链表的元素都能够被访问，也就是说头指针是必须存在的。</p><h3 id="section-3">2.9</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 分析一下下面这段代码<br>Status A(LinkedList L) &#123; <span class="hljs-regexp">//</span>L 是无表头结点的单链表<br><span class="hljs-keyword">if</span>(L &amp;&amp; L-&gt;<span class="hljs-keyword">next</span>) &#123;<br>    Q=L; L=L-&gt;<span class="hljs-keyword">next</span>; P=L;<br>    <span class="hljs-keyword">while</span>(P-&gt;<span class="hljs-keyword">next</span>) P=P-&gt;<span class="hljs-keyword">next</span>;<br>    P-&gt;<span class="hljs-keyword">next</span>=Q; Q-&gt;<span class="hljs-keyword">next</span>=NULL;<br>&#125;<br>return OK;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码是一个函数<code>Status A(LinkedList L)</code>，其目的是将无表头结点的单链表<code>L</code> 中的首元素移到链表的末尾。以下是代码的逐行解释：</p><ol type="1"><li><code>if (L &amp;&amp; L-&gt;next)</code>：这是一个条件语句，确保链表<code>L</code>不为空且至少包含两个元素。如果链表为空或只包含一个元素，那么没有必要执行首元素移到末尾的操作。</li><li><code>Q = L;</code>：创建一个指向链表头结点的指针<code>Q</code>，用于暂时保存链表的首元素。</li><li><code>L = L-&gt;next;</code>：将链表头指针 <code>L</code>移动到链表的下一个元素，即跳过了原始的首元素。</li><li><code>P = L;</code>：创建一个指向链表头结点的新指针<code>P</code>，用于遍历链表并找到末尾元素。</li><li><code>while (P-&gt;next) P=P-&gt;next</code>：进入一个循环，该循环将<code>P</code> 移动到链表的最后一个元素，即当 <code>P</code>的下一个元素不为空时继续执行。</li><li><code>P-&gt;next = Q;</code>：将末尾元素的 <code>next</code>指针指向原始首元素 <code>Q</code>，这样就将首元素移到了链表的末尾。</li><li><code>Q-&gt;next = NULL;</code>：将原始首元素 <code>Q</code> 的<code>next</code> 指针设置为<code>NULL</code>，以确保它成为新链表的末尾元素。</li><li><code>return OK;</code>：函数返回 OK，表示操作成功完成。</li></ol><p>总之，这段代码的作用是将无表头结点的单链表 <code>L</code>中的首元素移到链表的末尾。如果链表为空或只包含一个元素，则不执行任何操作。否则，它将通过重新连接指针来实现首元素的移动。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//分析一下下面这段代码</span><br>void <span class="hljs-constructor">BB(LNode <span class="hljs-operator">*</span><span class="hljs-params">s</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">q</span>)</span> &#123;<br>    <span class="hljs-comment">// 声明指针 p，并将其初始化为 s</span><br>    p = s;<br>    <span class="hljs-comment">// 当 p 指向的结点的下一个结点不等于 q 时，执行循环</span><br>    <span class="hljs-keyword">while</span> (p-&gt;next != q) &#123;<br>        <span class="hljs-comment">// 将 p 移动到下一个结点</span><br>        p = p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">// 将 q 结点的 next 指针指向 s，形成闭环</span><br>    p-&gt;next = s;<br>&#125;<br>void <span class="hljs-constructor">AA(LNode <span class="hljs-operator">*</span><span class="hljs-params">pa</span>, LNode <span class="hljs-operator">*</span><span class="hljs-params">pb</span>)</span> &#123;<br>    <span class="hljs-comment">// 调用 BB 函数，将结点 pa 到 pb 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pa</span>, <span class="hljs-params">pb</span>)</span>;<br>    <span class="hljs-comment">// 再次调用 BB 函数，将结点 pb 到 pa 之间的结点闭环</span><br>    <span class="hljs-constructor">BB(<span class="hljs-params">pb</span>, <span class="hljs-params">pa</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="section-4">2.11</h3><ul class="task-list"><li><label><input type="checkbox" />2.11 设顺序表 va中的数据元素递增有序。试写一算法，将 x插入到顺序表的适当位置上，以保持该表的有序性。</label></li></ul><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs maxima">Status InsertOrderList(SqList &amp;va,ElemType x)<br>&#123;<br>//在非递减的顺序表 va 中插入元素 x 并使其仍成为顺序表的算法<br>int i;<br><span class="hljs-keyword">if</span>(va.<span class="hljs-built_in">length</span>==va.listsize)<span class="hljs-built_in">return</span>(OVERFLOW);<br><br><span class="hljs-keyword">for</span>(i=va.<span class="hljs-built_in">length</span>;i&gt;<span class="hljs-number">0</span>,x&lt;va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];i--)<br>va.<span class="hljs-built_in">elem</span>[i]=va.<span class="hljs-built_in">elem</span>[i-<span class="hljs-number">1</span>];<br><br>va.<span class="hljs-built_in">elem</span>[i]=x;<br>va.<span class="hljs-built_in">length</span>++;<br><span class="hljs-built_in">return</span> OK;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Status InsertOrderList(SqList &amp;va,ElemType x)</code></p><p>这行代码是一个函数的声明，具体解释如下：</p><ul><li><code>Status</code>：这是函数的返回类型。在C/C++中，函数通常会返回一个值，表示函数的执行结果或状态。在这里，函数返回类型是<code>Status</code>，这意味着该函数会返回一个表示操作状态的值。</li><li><code>InsertOrderList</code>：这是函数的名称。函数名用于标识和调用函数。在这个情境下，函数名是<code>InsertOrderList</code>，它表示这个函数的目的是将一个元素插入到一个顺序表中。</li><li><code>(SqList &amp;va, ElemType x)</code>：这是函数的参数列表。它指定了函数接受的输入参数。具体解释如下：<ul><li><code>SqList &amp;va</code>：这是第一个参数，它是一个引用（<code>&amp;</code>符号表示引用）。这意味着函数将接受一个名为 <code>va</code>的参数，这个参数是一个 <code>SqList</code>类型的顺序表。通过引用传递，函数可以直接修改传递给它的顺序表，而不需要复制整个数据结构，这可以提高性能并节省内存。</li><li><code>ElemType x</code>：这是第二个参数，它是一个名为 <code>x</code>的参数，表示要插入到顺序表中的元素。<code>ElemType</code>可能是一个在代码的其他地方定义的数据类型，用于表示元素的类型。</li></ul></li></ul><p>综上，这行代码的含义是声明一个名为 <code>InsertOrderList</code>的函数，该函数接受一个顺序表 <code>va</code> 和一个元素 <code>x</code>作为参数，并且会返回一个 <code>Status</code>类型的值，用于表示函数执行的状态或结果。</p><p><code>for (i = va.length; i &gt; 0 &amp;&amp; x &lt; va.elem[i - 1]; i--)    va.elem[i] = va.elem[i - 1];</code></p><ul><li><p>这是一个 <code>for</code>循环，从顺序表的最后一个元素开始向前遍历，同时检查元素 <code>x</code>是否小于当前位置的元素。循环条件包括两部分：<code>i &gt; 0</code>表示循环要继续直到遍历到顺序表的第一个元素；<code>x &lt; va.elem[i - 1]</code>表示只要元素 <code>x</code>小于当前位置的元素，就继续循环。这个循环的目的是找到插入位置。</p></li><li><p>在循环中，将当前位置的元素向后移动，以为新元素 <code>x</code>腾出位置。这是为了为新元素 <code>x</code>让路，为其找到适当的插入位置。</p></li></ul><h3 id="section-5">2.15</h3><ul class="task-list"><li><label><input type="checkbox" />2.15 已知指针 ha 和 hb分别指向两个单链表的头结点，并且已知两个链表的长度分别为 m 和n。试写一算法将这两个链表连接在一起，假设指针 hc指向连接后的链表的头结点，并要求算法以尽可能短的时间完成连接运算。</label></li></ul><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xl">void MergeList_L(LinkList &amp;ha,LinkList &amp;hb,LinkList &amp;hc) <br>&#123; <br>    LinkList pa,pb; <br>    pa=ha; <br>    pb=hb; <br>    <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>&amp;&amp;pb-&gt;</span>next)&#123; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>=pb-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-function"><span class="hljs-title">if</span>(!pa-&gt;</span>next)&#123;          <span class="hljs-comment">//pa到头了</span><br>        hc=hb; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pb-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pb=pb-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pb</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=ha-&gt;</span>next; <br>    &#125; <br>    <span class="hljs-keyword">else</span>&#123; <br>        hc=ha; <br>        <span class="hljs-function"><span class="hljs-title">while</span>(pa-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>) pa=pa-&gt;</span>next; <br>        <span class="hljs-function"><span class="hljs-title">pa</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">next</span>=hb-&gt;</span>next; <br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="section-6">2.16</h3><p>已知指针 la 和 lb分别指向两个无头结点单链表中的首元结点。写一个算法实现:</p><ul class="task-list"><li><label><input type="checkbox" />从表 la 中删除自第 i 个元素起共 len个元素后，将它们插入到表 lb 中第 i 个元素之前。</label></li></ul><h3 id="section-7">2.22</h3><ul class="task-list"><li><label><input type="checkbox"checked="" />试写一算法，对单链表实现就地逆置。</label></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> &#123;</span><br>    ElemType data; <br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Lnode</span> *<span class="hljs-title">next</span>;</span> <br>&#125; Lnode, *LinkList;<br><br><span class="hljs-comment">//Lnode，将 struct Lnode 重命名为 Lnode，这允许我们在代码中使用 Lnode 来声明结构体类型的变量。？？</span><br><span class="hljs-comment">//LinkList，将 struct Lnode* 重命名为 LinkList，这样我们可以使用 LinkList 来声明指向链表节点的指针变量。</span><br><br>Status <span class="hljs-title function_">ListOppose_L</span><span class="hljs-params">(LinkList &amp;L)</span> <br>&#123; <br>    LinkList p,q;   <span class="hljs-comment">//两个辅助指针</span><br>    p=L;       <span class="hljs-comment">//将 p 指针指向链表头节点。</span><br>    p=p-&gt;next;  <span class="hljs-comment">// 将 p 移动到链表的第一个真实节点，即跳过头节点。</span><br>    L-&gt;next=<span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 将头节点的 next 指针置空，即将逆置后的链表末尾节点的 next 指针指向空。</span><br>    <span class="hljs-keyword">while</span>(p)&#123; <br>        q=p;         <br>        p=p-&gt;next;   <span class="hljs-comment">//这两行就是把 q 指向 p，然后将 p 向后移动到下一个节点：</span><br>        q-&gt;next=L-&gt;next;  <br>        L-&gt;next=q;   <span class="hljs-comment">//这两行就是进行插入，即：将 q 所指的节点插入到现在的表 L 的头结点和首元结点中间：</span><br>    &#125; <br>    <span class="hljs-keyword">return</span> OK; <br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p><ahref="https://blog.csdn.net/qq_41109668/article/details/104636252?ops_request_misc=%7B%22request%5Fid%22%3A%22169519655816800227422429%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519655816800227422429&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-104636252-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=试写一算法，对单链表实现就地逆置。&amp;spm=1018.2226.3001.4187">试写一算法，对单链表进行逆置试写一算法,实现单链表的就地逆置(要求在原链表上进行)_白薇.的博客-CSDN博客</a></p><p>大佬！！！这篇博客解释的非常清楚</p><h2 id="第三章">第三章</h2><h3 id="section-8">3.19</h3><p>括号匹配</p><h2 id="第六章-树">第六章 树</h2><h3 id="section-9">6.24</h3><p>树转换成二叉树：</p><ol type="1"><li>加线，所有兄弟结点之间连接一条线；</li><li>去线，对树中的每个结点，只保留它与第一个孩子结点的连线，删除与其他孩子结点之间的连线；</li><li>层次调整，以树的根结点为轴心，将整个树调节一下（第一个孩子是结点的左孩子，兄弟转过来的孩子是结点的右孩子）；</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698111444872.png"alt="1698111444872" /><figcaption aria-hidden="true">1698111444872</figcaption></figure><p>二叉树转换成树：</p><ol type="1"><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。（即先将父节点与其所有非第一个孩子结点的结点相连）</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。例子如下：</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079388509.png"alt="1698079388509" /><figcaption aria-hidden="true">1698079388509</figcaption></figure><p>森林转换成二叉树：</p><p>森林是由若干棵树组成，可以将森林中的每棵树的根结点看作是兄弟，由于每棵树都可以转换为二叉树，所以森林也可以转换为二叉树。</p><ol type="1"><li>把每一棵树转换为二叉树</li><li>第一棵二叉树不动，第二棵树开始，以此把后一棵二叉树的根结点作为前一棵树的根结点的右子树连接起来</li></ol><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698112427431.png"alt="1698112427431" /><figcaption aria-hidden="true">1698112427431</figcaption></figure><p>二叉树转换成森林：</p><ul><li>看二叉树的根结点是否有右孩子，有右结点是森林，无右结点是树。（根据孩子兄弟表示法，一棵树的根结点转换为二叉树，其二叉树的根结点无右孩子）</li><li>若是森林：<ul><li>依次把与右孩子结点的连线删除，得到分离的二叉树</li><li>把分离后的每棵二叉树转换为树；</li><li>整理第（2）步得到的树，使之规范，这样得到森林。例子如下：</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1698079139900.png"alt="1698079139900" /><figcaption aria-hidden="true">1698079139900</figcaption></figure></li></ul></li><li>若是树：<ul><li>参照二叉树转换成树</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-动态规划</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="多段图最短路径问题">多段图最短路径问题</h2><h3 id="动态规划法">动态规划法</h3><p><strong>动态规划法</strong>将待求解问题分解成若干个相互重叠的子问题，每个子问题对应决策过程的一个阶段，一般来说，子问题的重叠关系表现在对给定问题求解的递推关系(<em>称为动态规划函数</em>)中，将子问题的解求解一次并填入表中，当需要再次求解此子问题时，可以通过查表获得该子问题的解，从而避免了大量重复计算。具体的动态规划法多种多样，但都具有相同的填表形式。一般来说，动态规划法的求解过程由以下三个阶段组成：</p><ol type="1"><li><strong>划分子问题</strong>：将原问题分解为若干个子问题，每个子问题对应一个决策阶段，并且子问题之间具有重叠关系。</li><li><strong>确定动态规划函数</strong>：根据子问题之间的重叠关系找到子问题满足的递推关系式即动态规划函数，这是动态规划法的关键。</li><li><strong>填写表格</strong>：设计表格，以自底向上的方式计算各个子问题的解并填表，实现动态规划过程。</li></ol><p>上述动态规划过程可以求得问题的最优值即目标函数的极值，如果要求出具体的最优解，通常在动态规划过程中记录必要的信息，再根据最优决策序列构造最优解。</p><h3 id="多段图最短路径问题-1">多段图最短路径问题</h3><p>设图 <span class="math inline">\(G =（V,E）\)</span>是一个带权有向图，如果把顶点集合 V 划分成 k 个互不相交的子集 <spanclass="math inline">\(V_i（2≤k≤n,1≤i≤k）\)</span>，使得 E 中的任何一条边&lt;u,v&gt;，必有 <span class="math inline">\(u∈V_i, v∈V_{i + m}(i&lt;k,1&lt;i+m≤k)\)</span>,则称图 G 为多段图，称 s∈V1 为源点，t∈Vk为终点。</p><p>多段图的最短路径问题为从源点到终点的最小代价路径，如下动图所示：</p><blockquote><p>多段图是一个有向的无环图。求解从起始点到终止点的最短路径的长度，首先看一下这个问题是否具有最优子结构的性质。对于每一点来说，从v0到它的最短路径有两种可能，分别是从v0直接到该点或者是从最短的前驱节点开始到该节点。从这里可以看出有递归的性质，所以使用回溯的方法也是可以解决的。即从终点开始，依次向前找到最短的路径。由于递归本身所用的时间较长，并且在回溯的过程中存在重复的工作，所以使用动态规划更好。</p></blockquote><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082106575.gif"alt="2" /><figcaption aria-hidden="true">2</figcaption></figure><h3 id="最优子结构证明">最优子结构证明</h3><p>适合采用动态规划方法的最优化问题中的两要素：</p><p>✓ <strong>最优子结构</strong></p><p>✓ <strong>重叠子问题</strong></p><p><strong>一、 最优子结构</strong></p><ul><li><p>如果问题的最优解是由其子问题的最优解来构造的，则称该问题具有最优子结构</p></li><li><p>在动态规划中，我们利用子问题的最优解来构造问题的一个最优解，因此必须确保在我们所考虑的子问题范围中，包含了用于一个最优解的那些子问题</p></li></ul><p><strong>二、重叠子问题</strong></p><ul><li>适用于动态规划求解的最优化问题的第二个要素是子问题的空间要小，使用来解原问题的递归算法可反复解同样的子问题，而不总在产生新的子问题。</li><li>不同的子问题数是输入规模的一个多项式。</li><li>递归算法求解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次，该性质称为子问题的重叠性质</li></ul><p>设s，s，s1，s2，……，sp，t是s到t的一条最短路径，且s到s1的路径已经求出，则问题转为s1到t的最短路径，因此s1，s2，……，sp，t构成一条最短路径，如果不是，则设s1，r1，r2，……，rp，t是一条从s1到t的最短路径，则s，s1，r1，r2，……，rp，t是一条从s到t的最短路径且比s，s1，s2，……，sp，t短，因此矛盾，所以多段图的最短路径问题满足最优性原理。</p><h3 id="问题分析">问题分析</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091126212.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091125642.png"alt="image-20231109112545467" /><figcaption aria-hidden="true">image-20231109112545467</figcaption></figure><h3 id="程序实现">程序实现</h3><p><code>c</code></p><p><code>arc[N] [N]</code>：图的邻接矩阵 <code>cost[N]</code>：一维数组存储到每个顶点的最小开销。</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147421.png"alt="image-20231109114707374" /><figcaption aria-hidden="true">image-20231109114707374</figcaption></figure><p><code>path[N]</code>：用来保存每个顶点的前驱顶点，注意这个前驱结点是最短路径上的</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091147374.png"alt="image-20231109114720321" /><figcaption aria-hidden="true">image-20231109114720321</figcaption></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX 999999</span><br><br><span class="hljs-type">int</span> arc[N][N];<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> vnum, arcnum;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入顶点的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;vnum);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的个数: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arcnum);<br>    <br>     <span class="hljs-comment">// 把arc初始化为一个vmun*vnum的矩阵，</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= vnum; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= vnum; j++) &#123;<br>            arc[i][j] = MAX;<br>        &#125;<br>        arc[i][i] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 顶点到自身的距离为0</span><br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入边的两个顶点和权值: \n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; arcnum; k++) &#123;<br>        <br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;i, &amp;j, &amp;weight);<br>        arc[i][j] = weight;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> vnum;<br>&#125;<br><br><span class="hljs-comment">//返回最短路径</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">BackPath</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-comment">//cost[N]是一个一维数组表，用来存储源点到每个顶点的最小开销</span><br>    <span class="hljs-comment">//path[N]保存每个结点的前驱</span><br>    <span class="hljs-type">int</span> cost[N], path[N];<br><br>    <span class="hljs-comment">//cost[i]初始化为长度为n的一维数组，值为arc[1][i]，即为源点到每个顶点的距离</span><br>    <span class="hljs-comment">//path[i]，用来保存每个顶点的前驱顶点，先都初始化为1，后面不更新的话就是1-&gt;n，注意这个前驱结点是最短路径上的</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cost[i] = arc[<span class="hljs-number">1</span>][i];<br>        path[i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br><span class="hljs-comment">//for i=2,因为第一行已经赋值给cost[i]了，所以只需要遍历n-1行即可</span><br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-comment">// 检查是否存在一条从源点1经过顶点 i 到达顶点 j 的路径，其开销小于当前的 cost[j]，小于的话就更新cost[j]</span><br>            <span class="hljs-keyword">if</span> (cost[i] + arc[i][j] &lt; cost[j]) &#123;<br>                cost[j] = arc[i][j] + cost[i];<br>                path[j] = i;   <span class="hljs-comment">// 更新路径上的前一个顶点</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从顶点1到顶点%d的最小开销为：%d，路径为：&quot;</span>, i, cost[i]);<br>        j = i;<br>        <span class="hljs-keyword">while</span> (j != <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &lt;- &quot;</span>, j);  <span class="hljs-comment">// 输出路径</span><br>            j = path[j];  <span class="hljs-comment">// 回溯路径上的前一个顶点</span><br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> vnum = CreateGraph();<br>    BackPath(vnum);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>c++</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++的代码的coppy，没学过c++，主要看思路，</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXV 11</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;    <span class="hljs-comment">//图的定义</span><br>    <span class="hljs-type">int</span> edges[MAXV][MAXV];    <span class="hljs-comment">//邻接矩阵</span><br>    <span class="hljs-type">int</span> n;    <span class="hljs-comment">//顶点数</span><br>&#125; MGraph;<br><br>MGraph topography;    <span class="hljs-comment">//保存城市关系的邻接矩阵 </span><br><span class="hljs-type">int</span> path[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到该顶点的最短路径对应的前驱 </span><br><span class="hljs-type">int</span> min_cost[MAXV] = &#123;&#125;;    <span class="hljs-comment">//保存到每个顶点的最短路径长 </span><br><br><span class="hljs-function">MGraph <span class="hljs-title">CreateMGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span>    <span class="hljs-comment">//建图 </span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// MGraph topography;</span><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> point1, point2;<br><span class="hljs-type">int</span> value;<br><br><span class="hljs-comment">//初始化边为不存在 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br>topography.edges[i][j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;请输入边数：&quot;</span>;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>cin &gt;&gt; point1 &gt;&gt; point2 &gt;&gt; value;<br>topography.edges[point1][point2] = value;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;\n建立的邻接矩阵为：&quot;</span> &lt;&lt; endl; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= num; j++)&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d &quot;</span>,topography.edges[i][j]);<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>cout &lt;&lt; endl;<br>topography.n = num;<br><span class="hljs-keyword">return</span> topography;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> cities_num = <span class="hljs-number">0</span>;    <span class="hljs-comment">//城市数量 </span><br><span class="hljs-type">int</span> a_cost;    <span class="hljs-comment">//当前路径的开销</span><br><span class="hljs-type">int</span> pre;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;城市数量为：&quot;</span>; <br>cin &gt;&gt; cities_num;<br><span class="hljs-comment">//建图</span><br>topography = <span class="hljs-built_in">CreateMGraph</span>(cities_num);<br>        <span class="hljs-comment">//初始化路径开销</span><br>min_cost[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= topography.n; i++) &#123;<br>min_cost[i] = <span class="hljs-number">99999</span>;<br>&#125;<br><span class="hljs-comment">//依次计算到达所有点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= cities_num; i++)&#123;<br><span class="hljs-comment">//遍历之前的所有点，计算到达该点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j++)&#123;<br><span class="hljs-keyword">if</span>(topography.edges[j][i] != <span class="hljs-number">0</span>)&#123;    <span class="hljs-comment">//若路径存在 </span><br>a_cost =  min_cost[j] + topography.edges[j][i];<br><span class="hljs-keyword">if</span>(a_cost &lt; min_cost[i])&#123;    <span class="hljs-comment">//更新最短路径长 </span><br>min_cost[i] = a_cost;<br>path[i] = j;    <span class="hljs-comment">//记录前驱顶点 </span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">//输出到所有顶点的最短路径 </span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= cities_num; i++)&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;到顶点&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;的最小开销为：&quot;</span> &lt;&lt; min_cost[i] &lt;&lt; <span class="hljs-string">&quot;，路径：&quot;</span> &lt;&lt; i;<br>pre = i;<br><span class="hljs-keyword">while</span>(path[pre])&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;&lt;-&quot;</span> &lt;&lt; path[pre];<br>pre = path[pre];<br>&#125;<br>cout &lt;&lt; endl;<br>&#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="测试样例">测试样例</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311082352054.png"alt="image-20231108235209001" /><figcaption aria-hidden="true">image-20231108235209001</figcaption></figure><h4 id="输入数据">输入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">10</span><br><span class="hljs-number">18</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">8</span><br><span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span><br><span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">4</span><br><span class="hljs-number">4</span> <span class="hljs-number">7</span> <span class="hljs-number">7</span><br><span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">5</span><br><span class="hljs-number">5</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">6</span> <span class="hljs-number">8</span> <span class="hljs-number">8</span><br><span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span><br><span class="hljs-number">7</span> <span class="hljs-number">9</span> <span class="hljs-number">5</span><br><span class="hljs-number">8</span> <span class="hljs-number">10</span> <span class="hljs-number">7</span><br><span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="输出数据">输出数据</h4><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311091132283.png"alt="image-20231109113255170" /><figcaption aria-hidden="true">image-20231109113255170</figcaption></figure><h3 id="算法分析">算法分析</h3><p>算法的时间复杂度主要由两部分组成：</p><p>第一部分是依次计算从源点到各个顶点的最短路径长度，由两层嵌套的循环组成，外层循环执行n-1次，内层循环对所有入边进行计算，并且在所有循环中，每条入边只计算一次。假定图的边数为m，则时间性能是 O(m)。</p><p>第二部分是输出最短路径经过的顶点，设多段图划分为 k 段，其时间性能是O(k)。</p><p>综上所述，<strong>时间复杂度为 O(m+k)</strong>。</p><blockquote><p>参考:</p><p><ahref="https://www.cnblogs.com/linfangnan/p/14059868.html#3295747898">动态规划法解多段图最短路径问题- 乌漆WhiteMoon - 博客园 (cnblogs.com)</a></p><p><ahref="https://developer.aliyun.com/article/1047074">【动态规划】多段图最短路径（动图演示）-阿里云开发者社区(aliyun.com)</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析-排序</title>
    <link href="/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/"/>
    <url>/2023/09/18/%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://blog.csdn.net/weixin_43586713/article/details/119820797?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=快速排序&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-9-119820797.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">快速排序(详细讲解)-CSDN博客</a></p><p><ahref="https://blog.csdn.net/justidle/article/details/104203958?ops_request_misc=%7B%22request%5Fid%22%3A%22169518266216800185894255%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169518266216800185894255&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-104203958-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=归并排序&amp;spm=1018.2226.3001.4187">排序——归并排序（Mergesort)-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>算法分析与设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习记录</title>
    <link href="/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/17/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-数据类型">C 数据类型</h2><p><em>C 中的类型可分为以下几种：</em></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100932882.png"alt="image-20231110092838613" /><figcaption aria-hidden="true">image-20231110092838613</figcaption></figure><h3 id="整数类型">整数类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100937438.png"alt="image-20231110093736344" /><figcaption aria-hidden="true">image-20231110093736344</figcaption></figure><blockquote><p><em>注意，各种类型的存储大小与系统位数有关，但目前通用的以64位系统为主。</em></p></blockquote><h3 id="浮点类型">浮点类型</h3><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100938962.png"alt="image-20231110093854912" /><figcaption aria-hidden="true">image-20231110093854912</figcaption></figure><h3 id="void类型">void类型</h3><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100939141.png"alt="image-20231110093933055" /><figcaption aria-hidden="true">image-20231110093933055</figcaption></figure><h2 id="c-变量">C 变量</h2><p>基本类型：</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311100940065.png"alt="image-20231110094029970" /><figcaption aria-hidden="true">image-20231110094029970</figcaption></figure><p>1.注意，赋值表达式有返回值，等于等号右边的值</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">int <span class="hljs-keyword">x</span><span class="hljs-punctuation">,</span> y<span class="hljs-comment">;</span><br><span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>y <span class="hljs-operator">=</span> (<span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span>)<span class="hljs-comment">;</span><br>//变量 y 的值就是赋值表达式（ <span class="hljs-keyword">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> * <span class="hljs-keyword">x</span> ）的返回值 <span class="hljs-number">2</span> 。<br></code></pre></td></tr></table></figure><p>2.头文件 stdbool.h 定义了另一个类型别名 bool ，并且定义了 true 代表 1、 false 代表 0 。只要加载 这个头文件，就可以使用这几个关键字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//加载头文件 stdbool.h 以后，就可以使用 bool 定义布尔值类型，以及 false 和 true 表示真伪。</span><br></code></pre></td></tr></table></figure><h2 id="c-数组">C 数组</h2><h3 id="数组的地址">数组的地址</h3><p>数组是一连串连续储存的同类型值，只要获得起始地址（首个成员的内存地址），就能推算出其他成员的地址。请看下面的例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p;<br>p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);   <span class="hljs-comment">//11</span><br><br><span class="hljs-comment">//&amp;a[0] 就是数组 a 的首个成员 11 的内存地址，也是整个数组的起始地址。反过来，从这个地址（ *p ），可以获得首个成员的值 11</span><br><br></code></pre></td></tr></table></figure><p>由于数组的起始地址是常用操作， <code>&amp;array[0]</code>的写法有点麻烦，C 语言提供了便利写法，数组名等同于起始地址，也就是说，数组名就是指向第一个成员（ <code>array[0]</code>）的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">0</span>];<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-type">int</span>* p = a;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>&amp;a[0]</code> 和数组名 <code>a</code>是等价的。</p><p>这样的话，如果把数组名传入一个函数，就等同于传入一个指针变量。在函数内部，就可以通过这个指针变量获得整个数组。</p><p>函数接受数组作为参数，函数原型可以写成下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span>;<br><span class="hljs-comment">// 写法二</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span>;<br><br></code></pre></td></tr></table></figure><p>上面示例中，传入一个整数数组，与传入一个整数指针是同一回事，数组符号<code>[]</code> 与指针符号 <code>*</code> 是可以互换的。下一个例子是通过数组指针对成员求和</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> len)</span> &#123;<br>  <span class="hljs-type">int</span> i;<br>  <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">// 假定数组有 10 个成员</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    total += arr[i];<br> &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-comment">//示例中，传入函数的是一个指针 arr （也是数组名）和数组长度，通过指针获取数组的每个成员，从而求和。</span><br></code></pre></td></tr></table></figure><p><code>*</code> 和 <code>&amp;</code> 运算符也可以用于多维数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">4</span>][<span class="hljs-number">2</span>];<br><span class="hljs-comment">// 取出 a[0][0] 的值</span><br>*(a[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 等同于</span><br>**a<br></code></pre></td></tr></table></figure><p>上面示例中，由于 <code>a[0]</code>本身是一个指针，指向第二维数组的第一个成员 <code>a[0][0]</code> 。所以，<code>*(a[0])</code> 取 出的是 <code>a[0][0]</code> 的值。至于<code>**a</code> ，就是对 <code>a</code> 进行两次 <code>*</code>运算，第一次取出的是 <code>a[0]</code> ，第二次取出的是<code>a[0][0]</code> 。同理，二维数组的 <code>&amp;a[0][0]</code> 等同于<code>*a</code> 。</p><blockquote><p>不能将一个数组名赋值给另外一个数组名。</p></blockquote><h3 id="数组指针的加减法">数组指针的加减法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *(a + i));<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，通过指针的移动遍历数组， <code>a + i</code>的每轮循环每次都会指向下一个成员的地址， <code>*(a +  i)</code>取出该地址的值，等同于 <code>a[i]</code> 。对于数组的第一个成员，<code>*(a + 0)</code> （即 <code>*a</code> ）等同于 <code>a[0]</code>。</p><p>由于数组名与指针是等价的，所以下面的等式总是成立。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[b]</span> == *(<span class="hljs-selector-tag">a</span> + b)<br></code></pre></td></tr></table></figure><p>上面代码给出了数组成员的两种访问方式，一种是使用方括号<code>a[b]</code> ，另一种是使用指针 <code>*(a + b)</code> 。</p><p>如果指针变量 <code>p</code> 指向数组的一个成员，那么 <code>p++</code>就相当于指向下一个成员，这种方法常用来遍历数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>, <span class="hljs-number">55</span>, <span class="hljs-number">999</span>&#125;;<br><span class="hljs-type">int</span>* p = a;<br><span class="hljs-keyword">while</span> (*p != <span class="hljs-number">999</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<br>  p++;<br>&#125;<br><span class="hljs-comment">//示例中，通过 p++ 让变量 p 指向下一个成员。</span><br><span class="hljs-comment">//注意，数组名指向的地址是不能变的，所以例中，不能直接对 a 进行自增，即 a++ 的写法是错的，必须将 a 的地址赋值给指针变量 p ，然后对 p 进行自增</span><br></code></pre></td></tr></table></figure><p>同一个数组的两个成员的指针相减时，返回它们之间的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span>* p = &amp;a[<span class="hljs-number">5</span>];<br><span class="hljs-type">int</span>* q = &amp;a[<span class="hljs-number">1</span>];<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, p - q); <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, q - p); <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><h2 id="c-流程控制">C 流程控制</h2><p>break 命令只能跳出循环体和 switch 结构，不能跳出 if 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 无效</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">//示例中， break 语句是无效的，因为它不能跳出外层的 if 结构。</span><br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><h3 id="main">main()</h3><p>C 语言规定， <code>main()</code>是程序的入口函数，即所有的程序一定要包含一个 <code>main()</code>函数。程序总是从这个函数开始执行，如果没有该函数，程序就无法启动。其他函数都是通过它引入程序的。</p><h3 id="函数指针">函数指针</h3><p>对于任意函数，都有五种调用函数的写法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 写法一</span><br>print(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法二</span><br>(*print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法三</span><br>(&amp;print)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法四</span><br>(*print_ptr)(<span class="hljs-number">10</span>)<br><span class="hljs-comment">// 写法五</span><br>print_ptr(<span class="hljs-number">10</span>)<br><br><span class="hljs-comment">//为了简洁易读，一般情况下，函数名前面都不加 * 和 &amp; 。</span><br></code></pre></td></tr></table></figure><h2 id="struct-结构">struct 结构</h2><p>C语言内置的数据类型，除了最基本的几种原始类型，只有数组属于复合类型，可以同时包含多个值，但是只能包含相同类型的数据，实际使用中并不够用。</p><p>实际使用中，主要有下面两种情况，需要更灵活强大的复合类型。</p><ul><li>复杂的物体需要使用多个变量描述，这些变量都是相关的，最好有某种机制将它们联系起来。</li><li>某些函数需要传入多个参数，如果一个个按照顺序传入，非常麻烦，最好能组合成一个复合结构传入。</li></ul><p>为了解决这些问题，C 语言提供了 <code>struct</code>关键字，允许自定义复合数据类型，将不同类型的值组合在一起。这样不仅为编程提供方便，也有利于增强代码的可读性。C语言没有其他语言的对象（object）和类（class）的概念，<code>struct</code>结构很大程度上提供了对象和类的功能。</p><p>下面是 struct 自定义数据类型的一个例子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> &#123;</span><br>  <span class="hljs-type">int</span> numerator;<br>  <span class="hljs-type">int</span> denominator;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面示例定义了一个分数的数据类型 struct fraction ，包含两个属性numerator 和 denominator 。</p><p>注意，作为一个自定义的数据类型，它的类型名要包括 struct关键字，比如上例是 struct fraction ，单独的 fraction没有任何意义，另外， struct 语句结尾的分号不能省略</p><p>定义了新的数据类型以后，就可以声明该类型的变量，这与声明其他类型变量的写法是一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fraction</span> <span class="hljs-title">f1</span>;</span><br>f1.numerator = <span class="hljs-number">22</span>;<br>f1.denominator = <span class="hljs-number">7</span>;<br><br><span class="hljs-comment">//这里先声明了一个 struct fraction 类型的变量 f1 ，这时编译器就会为 f1 分配内存，接着就可以为 f1 的不同属性赋值。struct 结构的属性通过点（ . ）来表示，比如 numerator 属性要写成 f1.numerator 。</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//除了逐一对属性赋值，也可以使用大括号，一次性对 struct 结构的所有属性赋值</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">float</span> price;<br>  <span class="hljs-type">int</span> speed;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;<span class="hljs-string">&quot;Saturn SL/2&quot;</span>, <span class="hljs-number">16000.99</span>, <span class="hljs-number">175</span>&#125;<br><span class="hljs-comment">//大括号里面的值的顺序，必须与 struct 类型声明时属性的顺序一致。否则，必须为每个值指定属性名。</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">car</span> <span class="hljs-title">saturn</span> =</span> &#123;.speed=<span class="hljs-number">172</span>, .name=<span class="hljs-string">&quot;Saturn SL/2&quot;</span>&#125;;<br>saturn.speed = <span class="hljs-number">168</span>;<br></code></pre></td></tr></table></figure><p><code>struct</code>的数据类型声明语句与变量的声明语句，可以合并为一个语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cell_phone</span> &#123;</span><br>  <span class="hljs-type">int</span> cell_no;<br>  <span class="hljs-type">float</span> minutes_of_charge;<br>&#125; phone;<br>phone p = &#123;<span class="hljs-number">5551234</span>, <span class="hljs-number">5</span>&#125;<br><br></code></pre></td></tr></table></figure><p>指针变量也可以指向 struct 结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;* b1;<br><span class="hljs-comment">// 或者写成两个语句</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span> &#123;</span><br>  <span class="hljs-type">char</span> title[<span class="hljs-number">500</span>];<br>  <span class="hljs-type">char</span> author[<span class="hljs-number">100</span>];<br>  <span class="hljs-type">float</span> value;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">book</span>* <span class="hljs-title">b1</span>;</span><br><span class="hljs-comment">//变量 b1 是一个指针，指向的数据是 struct book 类型的实例。</span><br></code></pre></td></tr></table></figure><h3 id="struct-指针">struct 指针</h3><p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> &#123;</span><br>  <span class="hljs-type">char</span>* name;<br>  <span class="hljs-type">char</span>* species;<br>  <span class="hljs-type">int</span> age;<br>&#125;;<br><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle t)</span> &#123;<br>  t.age = t.age + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">turtle</span> <span class="hljs-title">myTurtle</span> =</span> &#123;<span class="hljs-string">&quot;MyTurtle&quot;</span>, <span class="hljs-string">&quot;sea turtle&quot;</span>, <span class="hljs-number">99</span>&#125;;<br>  happy(myTurtle);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Age is %i\n&quot;</span>, myTurtle.age); <span class="hljs-comment">// 输出 99</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中，函数 <code>happy()</code> 传入的是一个<code>struct</code> 变量 <code>myTurtle</code>，函数内部有一个自增操作。但是，执行完 <code>happy()</code>以后，函数外部的 <code>age</code>属性值根本没变。原因就是函数内部得到的是 <code>struct</code>变量的副本， 改变副本影响不到函数外部的原始数据</p><p>通常，希望传入函数的是同一份数据，函数内部修改数据以后，会反映在函数外部。而且，传入的是同一份数据，也有利于提高程序性能。这时就需要将<code>struct</code> 变量的指针传入函数，通过指针来修改<code>struct</code> 属性，就可以影响到函数外部。</p><p><code>struct</code> 指针传入函数的写法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>&#125;<br>happy(&amp;myTurtle);<br><span class="hljs-comment">//这里 t 是 struct 结构的指针，调用函数时传入的是指针</span><br><span class="hljs-comment">//struct 类型跟数组不一样，类型标识符本身并不是指针，所以传入时，指针必须写成 &amp;myTurtle 。</span><br></code></pre></td></tr></table></figure><p>函数内部也必须使用 <code>(*t).age</code> 的写法，从指针拿到<code>struct</code> 结构本身：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br> (*t).age = (*t).age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例中， <code>(*t).age</code> 不能写成 <code>*t.age</code>，因为点运算符 <code>.</code> 的优先级高于 <code>*</code> 。<code>*t.age</code> 这种写法会将 <code>t.age</code>看成一个指针，然后取它对应的值，会出现无法预料的结果。</p><p>现在，重新编译执行上面的整个示例， <code>happy()</code> 内部对<code>struct</code> 结构的操作，就会反映到函数外部。</p><p><code>(*t).age</code> 这样的写法很麻烦。C语言就引入了一个<strong>新的箭头运算符</strong><code>-&gt;</code>，可以从<code>struct</code> 指针上直接 获取属性，大大增强了代码的可读性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">happy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> turtle* t)</span> &#123;<br>  t-&gt;age = t-&gt;age + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结一下，对于 <code>struct</code> 变量名，使用点运算符<code>.</code>获取属性；对于 <code>struct</code> 变量指针，使用箭头运算符<code>-&gt;</code> 获取属性。</p><p>以变量 <code>myStruct</code> 为例，假设 <code>ptr</code>是它的指针，那么下面三种写法是同一回事。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// ptr == &amp;myStruct</span><br>myStruct.prop == (*ptr).prop == ptr-&gt;prop<br></code></pre></td></tr></table></figure><h2 id="typedef-和-define-的区别">typedef 和 #define 的区别</h2><p>typedef 在表现上有时候类似于#define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。</p><ol type="1"><li>可以使用其他类型说明符对宏类型名进行扩展，但对 typedef所定义的类型名却不能这样做。如下所示：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> INTERGE int</span><br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//没问题</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> INTERGE;<br><span class="hljs-type">unsigned</span> INTERGE n;  <span class="hljs-comment">//错误，不能在 INTERGE 前面添加 unsigned</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>在连续定义几个变量的时候，typedef能够保证定义的所有变量均为同一类型，而 #define 则无法保证。例如：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTR_INT int *</span><br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>经过宏替换以后，第二行变为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">int</span> *<span class="hljs-built_in">p1</span>, <span class="hljs-built_in">p2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int类型。</p><p>相反，在下面的代码中：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">typedef<span class="hljs-built_in"> int </span>* PTR_INT<br>PTR_INT p1, p2;<br></code></pre></td></tr></table></figure><p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p><h2 id="其他">其他</h2><p>如果在<code>int</code>型变量的声明中为变量赋应该实数值的初始值（如3.14或5.7等）会怎么样？</p><ul><li>会直接舍去小数部分，只保留整数部分</li></ul><p>单目运算符&amp;（取值运算符）</p><ul><li>&amp;a，取得a的地址（生产指向a的指针）</li></ul><p>单目运算符*（指针运算符）</p><ul><li>*a，a指向的对象</li></ul><p>赋值表达式的左操作数不可以是数组名。</p><p><code>p</code>指向<code>x</code>时，<code>*p</code>是<code>x</code>的别名</p><p>指针<code>p</code>指向数组中的元素<code>e</code>时</p><ul><li><code>p + i</code>为指向元素<code>e</code>后第<code>i</code>个元素的指针</li><li><code>p - i</code>为指向元素<code>e</code>前第<code>i</code>个元素的指针</li><li>指向元素<code>e</code>后第<code>i</code>个元素的<code>*(p + i)</code>，可以写为<code>p[i]</code></li><li>指向元素<code>e</code>前第<code>i</code>个元素的<code>*(p - i)</code>，可以写为<code>p[-i]</code></li></ul><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142303857.png"alt="image-20230917142303857" /><figcaption aria-hidden="true">image-20230917142303857</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230917142327597.png"alt="image-20230917142327597" /><figcaption aria-hidden="true">image-20230917142327597</figcaption></figure><p><code>c</code>语言编译阶段出现如下的问题：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgc00e0930273a652d2e9d0d0b218eb41.png"alt="c00e0930273a652d2e9d0d0b218eb41" /><figcaptionaria-hidden="true">c00e0930273a652d2e9d0d0b218eb41</figcaption></figure><p>可以检查一下是不是有正在运行的端口没关闭！！！</p>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（二）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>2023.09.14-</p><p>2023.10.27,重拾,感觉还是要跟着兴趣走吧😥😭😭😭😭😭😭😭</p><h2 id="rsa21小明文攻击">[RSA2]1(小明文攻击)</h2><h3 id="main">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">5120</span>)<br>q = getPrime(<span class="hljs-number">5120</span>)<br><br>n = p*q<br>e = <span class="hljs-number">97</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br><span class="hljs-string">e = 97</span><br><span class="hljs-string">c = 79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>小明文攻击</strong></label></li></ul><p><strong>加密指数指的是e，e一般取65535，但当e很小时，可直接解密</strong></p><p>这里<strong>$ m^{e} &lt; c$</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">1392208858696945158251408085300402884210409327605255122395601049457847957306648819174395014931778575812308192875319127224095733396726388842605854427013313599830150182564652493067830031524869535522568868597852507293377043240832819715539722122306829543983051745406887140154364256267942350230636870212935356815475345989038318923389132101208917912083817520799490534351545373438629367819085151041702754019127891155542476560972125790519584018715794669416759039955180436830478697704458250990786586357019211642837879273967620287257818400267757312623543898635740200839249361087580046496969637043238450499583879116276661827372750638403042213043389905183760455450595752578482968202040860053524276678108325784161897719093223308370971388068813420487879756084379519128232693549989942550047529174783976176943482484756074638704076740157397067892580297182979526978967352014250386678155843772313996171396582929433057131989693861316408604436872931427368192437680361830753162284661119995125858203931094922686321756465463988790748131178263745308042820480140189644732824717255521633534750635979508673908361269979175726073254050574688259969290376926807033728165164896588540691889207252105903436659968119091774687841336252628343233161941187968365128093917171537997137001140227677728923114895809278926486615010954871408034272872411042537353956193868948909981683850857262457369506288525323882308421700421661036191853577105238753230479541719001794464585534292774768292358961920606891227776349593589481547577148801600196035588544512224775960892265021565124673788852875005526313525709353599584812394138968970647681759439523307392275602626903789154682706839530654070108096741181206975334567778238856983205004289416400671597321919876279909765650782227834097342294844294386380646928266942749144240020420237153276705785759403019072953506982997681174635673907151856644499332322321579088035719680421458310273802481031746012298208449699089203065699598926690947025679591160106357130634946357609420125223580319677387654711233585375013067828291928349946599077331636017784447090096340360087970540477975170379810969501197027775838769222713506443846417124839450184827707739588007707714623211453528342755023849716924694572679150284882978804641986457119009272574734697043321033091757474387114449914271460113979531460465175717705674905568446670579332667139075523255580471183372714211547822093365025438653384719374474230360983878837077517864405475258349436531094649276628214288499716485354283135575921258757214288792410583835467572916298688718758374714560819702413058421373661892101033513816116981698045524150518509405086125781764762145577981637953775680403132163846782252745029783387112660812179706752454175492501665442704630131729362621965258498471247871904163412798544329515689112368523703890083138721480476796720323855371775568097188216621368341228806795058046403892301673157631331636430392885315997250027372621883549649614866115616619234953579196607399899485002042456482969222428121605212017146571466818179341621066715472184636758016242256725063854155219754299817717414423725704356940589670902509021070871847017199593680033</span><br>e = <span class="hljs-number">97</span><br>c = <span class="hljs-number">79418540691422578656139651796213224829563266521211325595707569487401417030874358531413674275017334363641194166574500833916574827523075402219754470871728896772312056257743844227927800121160288525434484105786180547178403828613331285574461293211150728313415280329153597549251599876668080073528625299164784405291297754331374420687599875173508778209038236713812747215157059659564867241144529476211694011692007565732793105429228730285249025627762831080251661835294067942958070742202862164086250986988784472568266652325462247009294865764533077164470382743735937483173523682749295196383707694876943634298051820105410771024861599560176707940488888601355473498847493259474613261665538825299531665650233837474894442826242097663456648233384047622152817959729025415665280499618951478005159820575701483220155180955748454167435711033379910310483689839303198822665341421591234243891877857520663120183063591818656508336831518527692847950877186870610083654117153248336928856886934232488927132245720058243202637258025864487122393335118118013444397135476780564523166548571927547341556616683070253790368891423731046742936358877118104790084195711730135202600692806999992373490439385845158780392894927697171401722699273071306493916233696254958735540772870249139252741670476667099529502282392011715616110876451102234600267482991583515122052976378641894214562203326290939184469206074418127906704847146567350085797480500249400491003993809769407575997740985283755035509654310797061339563655229926356893455738361409861102662109994984398860070584568014471082484198504331014073023689622378943694856212172718725529473812336321642429261822836311084518735006587545920946664595488768239633950124822001162595168106106356115962424210028401369438479550293237915944302351566624339603616714683958384871326105542659559877758488581425288668613061792514360263277530824203967659102107889148367539858141289229124274098921748855341045565232484417195620758495861456624842263649414501657786484816662971421962216348340311859717286253287173293151613310383128702607971580042308515018120559903265609733911340589091613087560931098833849573462572181625894166772788435459280323623477689159384354671220634694792005231505741029567734616435905915192606539962414882105254409847885996949466940350184140166614950171110955365828033747003120697209120916652982201967537088553504504252785632280900095976870510754563400828951684036526240669112248351928072177486091157562600003336544767896806392523395037345770580482363058065676920013089896399387769312374871419827762872050800055872960573607645266626972865053489632548224840580503746879607167797904430560935476705014800973841917939689270919224595772574781478285359220463175042728750523639669204218676238297875644055563803457896409252533724486937378974745777400567080239687055154021761534918106133195512030935957251049812753269173090858930245212145938555697547499155977225759702066548720079477737104010668116693232798415289735481194922014811945312893853446826780868861295203942063380964100360870361328125</span><br><br><br>a, b = gmpy2.iroot(c, <span class="hljs-number">97</span>)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))<br><br></code></pre></td></tr></table></figure><p>也能用 <strong>[RSA2]P2</strong>的方法，可以得到k是等于0的，也验证了$ m^{e}= c$,也就是在取模的过程中没有丢失任何信息，我们可以直接开方从而获得m</p><h2 id="rsa22低加密指数攻击">[RSA2]2(低加密指数攻击)</h2><h3 id="main-1">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>n = p*q<br>e = <span class="hljs-number">3</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br><span class="hljs-string">e = 3</span><br><span class="hljs-string">c = 90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-1">exp</h3><ul class="task-list"><li><label><input type="checkbox"checked="" /><strong>低加密指数攻击</strong></label></li></ul><p>yafu和<ahref="http://factordb.com/">factordb.com</a>都没分解成功，<strong>这里的n也不大，怎么就没成功呢🙄</strong></p><p>那只能看看原理了</p><p>直接使用上题的方式开方并不行，则说明$ m^{e}&gt; c$，不能直接开方。</p><p>我们考虑原理： <span class="math display">\[c \equiv m^{e} (mod\quad n)\]</span> 消去取模，有： <span class="math display">\[m^{e} = c + k\cdot n\]</span> 因为本题中加密指数e很小，我们可以考虑<spanclass="math inline">\(m^{e}\)</span>的值并不是特别大，则我们可以通过遍历<code>k</code>的方式将取模后丢失的信息找回来，</p><p>遍历到何时停止呢？当<span class="math inline">\(c + k\cdotn\)</span>是一个完全e次方数时，则说明我们得到了正确的答案，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>n = <span class="hljs-number">111573371787314339229652810703380127177507745009618224416171957526984270337589283887959174610818933914845556276472159360153787395638087723501889651641965684241070152541291185349571453536221312112508437223801640552330390095266644485311958102687735113533739324296417077804219395793942670324182191309872918900717</span><br>e = <span class="hljs-number">3</span><br>c = <span class="hljs-number">90782646242308381145716338972639920044710403094882163620436540965475107006005657722222634294458956650085252212452241377251397323707019480880284004845674260662647720809672266571040936376737882878688872281858048646517100139303896804340224961592424635124272549514473232731744884837572128596217771005209683966262</span><br><br><span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>):<br>    cc = c + k*n<br>    res = iroot(cc, e)<br>    <span class="hljs-keyword">if</span> res[<span class="hljs-number">1</span>]:             <span class="hljs-comment">#如果第二个参数返回的是true，则m等于第一个参数</span><br>        m = res[<span class="hljs-number">0</span>]<br>        <span class="hljs-keyword">break</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;k:&#x27;</span>,k)                <span class="hljs-comment"># k=11</span><br></code></pre></td></tr></table></figure><h2 id="rsa23rabin">[RSA2]3(Rabin)</h2><h3 id="main-2">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br><span class="hljs-keyword">assert</span> p%<span class="hljs-number">4</span> == <span class="hljs-number">3</span> <span class="hljs-keyword">and</span> q%<span class="hljs-number">4</span> == <span class="hljs-number">3</span><br><br>n = p*q<br>e = <span class="hljs-number">2</span><br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br><span class="hljs-string">q = 91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br><span class="hljs-string">e = 2</span><br><span class="hljs-string">c = 5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp-2">exp</h3><ul class="task-list"><li><label><input type="checkbox" /><strong>RSA衍生算法——Rabin算法</strong></label></li></ul><p><ahref="https://ctf-wiki.org/crypto/asymmetric/rsa/rsa_e_attack/#rsa-rabin">公钥指数相关攻击- CTF Wiki (ctf-wiki.org)</a></p><p>exp完全copy的xenny佬的，还不懂原理😔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">67711062621608175960173275013534737889372437946924512522469843485353704013203</span><br>q = <span class="hljs-number">91200252033239924238625443698357031288749612243099728355449192607988117291739</span><br>e = <span class="hljs-number">2</span><br>c = <span class="hljs-number">5251890478898826530186837207902117236305266861227697352434308106457554098811792713226801824100629792962861125855696719512180887415808454466978721678349614</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">rabin_attack</span>(<span class="hljs-params">c, n, p, q</span>):<br>    c1 = powmod(c, (p+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, p)<br>    c2 = powmod(c, (q+<span class="hljs-number">1</span>)//<span class="hljs-number">4</span>, q)<br>    cp1 = p - c1<br>    cp2 = q - c2<br><br>    t1 = invert(p, q)<br>    t2 = invert(q, p)<br><br>    m1 = (q*c1*c2 + p*c2*t1) % n<br>    m2 = (q*c1*t2 + p*cp2*t1) % n<br>    m3 = (q*cp1*t2 + p*c2*t1) % n<br>    m4 = (q*cp1*t2 + p*cp2*t1) % n<br><br>    <span class="hljs-keyword">return</span> m1, m2, m3, m4<br><br>ms = rabin_attack(c, p*q, p, q)<br><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> ms:<br>    <span class="hljs-built_in">print</span>(long_to_bytes(m))    <span class="hljs-comment"># 四个只有一个是</span><br></code></pre></td></tr></table></figure><h2 id="rsa24wiener">[RSA2]4(Wiener)</h2><h3 id="main-3">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>d = getPrime(<span class="hljs-number">128</span>)<br>e = inverse(d, (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>))<br>m = bytes_to_long(flag)<br><br>c = powmod(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br><span class="hljs-string">e = 3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br><span class="hljs-string">c = 1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="exp1">exp1</h3><ul class="task-list"><li><label><inputtype="checkbox" /><strong>Wiener攻击</strong></label></li></ul><p><strong>已知（e，n，c），求m。d很小且e很大，可知是低解密指数攻击（Wiener攻击）。</strong></p><p><strong>这里相当于是反过来了，先生成了d，再由d去求e</strong>，当我们发现<strong>e很大或者说很接近n</strong>时，便可以考虑使用连分数展开的方式，遍历每一个系数，测试是否是解题中需要用到的关键因子，</p><p><ahref="https://blog.csdn.net/XiongSiqi_blog/article/details/130515028">RSA--维纳攻击--代码和题目分析_维纳攻击脚本_Emmaaaaaaaaaa的博客-CSDN博客</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接用xenny师傅的库</span><br><span class="hljs-keyword">import</span> libnum<br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> long_to_bytes<br><span class="hljs-keyword">from</span> xenny.ctf.crypto.modern.asymmetric.rsa <span class="hljs-keyword">import</span> wiener<br><span class="hljs-comment"># e很大 wiener攻击</span><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br> <br>d, p, q = wiener.attack(n, e)<br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br>flag = libnum.n2s(<span class="hljs-built_in">int</span>(m))<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-comment"># print(long_to_bytes(m))</span><br></code></pre></td></tr></table></figure><h3 id="exp2">exp2</h3><ul class="task-list"><li><label><input type="checkbox" />用原理写的，还没理解</label></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">6969872410035233098344189258766624225446081814953480897731644163180991292913719910322241873463164232700368119465476508174863062276659958418657253738005689</span><br>e = <span class="hljs-number">3331016607237504021038095412236348385663413736904453330557803644384818257225138777641344877202234881627514102078530507171735156112302207979925588113589669</span><br>c = <span class="hljs-number">1754994938947260364311041300467524420957926989584983693004487724099773647229373820465164193428679197813476633649362998772470084452129370353136199193923837</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ContinuedFraction</span>():<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        self.numberlist = []  <span class="hljs-comment"># number in continued fraction</span><br>        self.fractionlist = []  <span class="hljs-comment"># the near fraction list</span><br>        self.GenerateNumberList(numerator, denumerator)<br>        self.GenerateFractionList()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateNumberList</span>(<span class="hljs-params">self, numerator, denumerator</span>):<br>        <span class="hljs-keyword">while</span> numerator != <span class="hljs-number">1</span>:<br>            quotient = numerator // denumerator<br>            remainder = numerator % denumerator<br>            self.numberlist.append(quotient)<br>            numerator = denumerator<br>            denumerator = remainder<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">GenerateFractionList</span>(<span class="hljs-params">self</span>):<br>        self.fractionlist.append([self.numberlist[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(self.numberlist)):<br>            numerator = self.numberlist[i]<br>            denumerator = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i):<br>                temp = numerator<br>                numerator = denumerator + numerator * self.numberlist[i - j - <span class="hljs-number">1</span>]<br>                denumerator = temp<br>            self.fractionlist.append([numerator, denumerator])<br><br><br>a = ContinuedFraction(e, n)<br><span class="hljs-keyword">for</span> k, d <span class="hljs-keyword">in</span> a.fractionlist:<br>    m = powmod(c, d, n)<br>    flag = long_to_bytes(m)<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-string">b&#x27;NSSCTF&#x27;</span> <span class="hljs-keyword">in</span> flag:<br>        <span class="hljs-built_in">print</span>(flag)<br></code></pre></td></tr></table></figure><h2 id="rsa25低加密指数广播攻击">[RSA2]5(低加密指数广播攻击)</h2><h3 id="main-4">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> os<br><br>flag = os.getenv(<span class="hljs-string">&#x27;FLAG&#x27;</span>)<br>m = bytes_to_long(flag.encode())<br>e = <span class="hljs-number">127</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">enc</span>():<br>    p = getPrime(<span class="hljs-number">512</span>)<br>    q = getPrime(<span class="hljs-number">512</span>)<br>    n = p*q<br>    c = <span class="hljs-built_in">pow</span>(m, e, n)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;n: <span class="hljs-subst">&#123;n&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;c: <span class="hljs-subst">&#123;c&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        opt = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input&gt; &#x27;</span>))<br>        <span class="hljs-keyword">if</span> opt == <span class="hljs-number">1</span>:<br>            enc()<br><br>main()<br></code></pre></td></tr></table></figure><h3 id="exp-3">exp</h3><hr /><p>1、低加密指数</p><p>​所谓<strong>低加密指数</strong>，指的是RSA加密过程中使用的参数e的值很小，这样往往会产生安全隐患，导致低加密指数攻击的发生。</p><p>2、广播、</p><p>​所谓<strong>广播</strong>，就是发送方将一份明文进行多份加密，但是每份使用不同的密钥，即密钥中的模数n不同，但是指数e相同且很小，因此我们只要得到多份密文和对应的模数n就可以利用中国剩余定理进行解密。</p><p>3、低加密指数广播攻击</p><p> 实现<strong>低加密指数广播攻击</strong>需要满足以下三个条件：</p><p>（1）加密指数e非常小。</p><p>（2）同一份明文使用不同的模数n，相同的加密指数e进行多次加密。</p><p>（3）攻击者可以得到每一份加密后的密文和对应的模数n、加密指数e。</p><hr /><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310271642498.png"alt="image-20231027164245430" /><figcaption aria-hidden="true">image-20231027164245430</figcaption></figure><h2 id="rsa26p-1光滑">[RSA2]6(p-1光滑)</h2><h3 id="main-5">main</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">getMyPrime</span>(<span class="hljs-params">nbits</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        p = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> p.bit_length() &lt;= nbits:<br>            p *= choice(sieve_base)<br>        <br>        <span class="hljs-keyword">if</span> isPrime(p+<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">return</span> p+<span class="hljs-number">1</span><br><br>p = getMyPrime(<span class="hljs-number">256</span>)<br>q = getMyPrime(<span class="hljs-number">256</span>)<br><br>n = p*q<br>e = <span class="hljs-number">65537</span><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53763529836257082401813045869248978487210852880716446938539970599235060144454914000042178896730979463959004404421520555831136502171902051936080825853063287829</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 50368170865606429432907125510556310647510431461588875539696416879298699197677994843344925466156992948241894107250131926237473102312181031875514294014181272618</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="section"></h3>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Crypto系列——RSA（一）</title>
    <link href="/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/09/14/Crypto%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94RSA%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>不知道为啥就对密码学感兴趣了，上学期学了半天pwn没搞懂，或许就不适合学pwn吧😭</p><p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>在探姬的建议下，还是买了这套课程，开干！</p><h2 id="rsa1p1">[RSA1]P1</h2><h3 id="main_py">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br><span class="hljs-string">q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py">decrypt.py</h3><p><strong>已知p,q,e,c,可直接求出d,然后求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951</span><br>q = <span class="hljs-number">8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <span class="hljs-comment"># b&#x27;NSSCTF&#123;now!you_know_rsa&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>关于类型的转换，pepper师傅这里说的很好，我就直接copy了</p><p>本题需要理解明文和密文的类型及其类型转换函数。<strong>long类型为一串数字</strong>，<strong>bytes是字符</strong>。</p><p>在下列示例中，message表示bytes类型明文，m表示long类型明文，c表示long类型密文。</p><p>在rsa.py函数中：</p><ol type="1"><li><p>输入 message 明文为 bytes 类型,加密 c=pow(m,e,n) 中明文 m 为 long类型，输出密文 c 是 long 类型。</p><p>message 到 m 需要通过 bytes_to_long(message) 方法进行转换</p></li><li><p>解密 m= pow(c, d, n) 中 m 为 long 类型，c 为 long 类型。</p><p>打印输出的明文 message 需要 bytes 类型，通过 long_to_bytes(m)方法进行转换</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">m = bytes_to_long(message) <span class="hljs-built_in">bytes</span>转long<br>message = long_to_bytes(m) long转<span class="hljs-built_in">bytes</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p2">[RSA1]P2</h2><h3 id="main_py-1">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-1">decrypt.py</h3><p><strong>已知n,e,c,分解n，得到p,q</strong></p><p>本题意思是只知道了n，而p和q都不知道，那么我们就要把n这个大整数分解，用到网站<ahref="http://factordb.com/">factordb.com</a></p><p>得到分解的两个数p和q，即可写出decrypt.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>n = <span class="hljs-number">7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557</span><br><br>p = <span class="hljs-number">70538125404512947763739093348083497980212021962975762144416432920656660487657</span><br>q = <span class="hljs-number">104660876276442216612517835199819767034152013287345576481899196023866133215633</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p3">[RSA1]P3</h2><h3 id="main_py-2">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">128</span>)<br>q = getPrime(<span class="hljs-number">128</span>)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 53690629441472827148854210396580805205350972614395425306316047967905824330731</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 22130296334673852790451396673112575082637108306697684532954477845025885087040</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-2">decrypt.py</h3><p><strong>已知n,e,c,yafu分解n，得到p,q</strong></p><p>虽然它说是要让用yafu，命令为：<code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><p><ahref="https://wiki.mrskye.cn/Crypto/yafu安装及使用/">yafu安装及使用 -SkYe Wiki (mrskye.cn)</a></p><p>但我寻思这个数比上面的数还小，直接<ahref="http://factordb.com/">factordb.com</a>不就行辣😋</p><p>求出p和q后，解密函数跟<strong>[RSA1]P2</strong>一样</p><hr /><h2 id="rsa1p4">[RSA1]P4</h2><h3 id="main_py-3">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-3">decrypt.py</h3><p><strong>已知n,e,c，且p,q相差不大（特例款）。</strong></p><p>直接copy了xenny师傅的wp，😰😢</p><ul><li>本题的关键是<code>q = gmpy2.next_prime(p)</code>，相当于q是p的下一个素数</li><li>然后这里采用了一个$ <span class="math inline">\(，因为\)</span>n =p*q<span class="math inline">\(，考虑n的算术平方根为\)</span>sn = <spanclass="math inline">\(，同时 sn也是p和q的几何平均值。所以有\)</span>p&lt;sn&lt;q$</li><li>又有p，q是相邻的素数，p的下一个素数为q，同理也有sn的下一个素数也应该是q，</li><li>然后由q求出p即可</li></ul><p>这里附上一篇文章：<ahref="https://www.freebuf.com/articles/database/290623.html">浅析RSA因子大小相近时分解因子攻击方法- FreeBuf网络安全行业门户</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p)<br><br>n = <span class="hljs-number">115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730</span><br><br>sn = isqrt(n)      <span class="hljs-comment">#或者sn = gmpy2.iroot(n,2)</span><br>q = next_prime(sn)<br>p = n // q<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br>m = <span class="hljs-built_in">pow</span>(c, d, n)<br><span class="hljs-built_in">print</span>(long_to_bytes(m))<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p5">[RSA1]P5</h2><h3 id="main_py-4">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> gmpy2<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br>n = p*q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>m = bytes_to_long(flag)<br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n = <span class="hljs-subst">&#123;n&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n = 148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt1.py">decrypt1.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>直接yafu分解：</p><p>但是不能用[RSA1]P4里面的方法，因为根号n的下一个素数不一定是q哦😡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>P = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815375891425102591939094029941691738405035324548070063226677838530633694428729829</span><br>q = <span class="hljs-number">12200065120379104459630695224710181907653841921369674962900093531339421658815305905822146210878434959851438079877557401145694064756239882458467901042367473</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br>n = p * q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>文章 - <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><h3 id="decrypt2.py">decrypt2.py</h3><p><strong>已知n,e,c，且p,q相差不大（经典款）。</strong></p><p>费马分解： <a href="https://www.nssctf.cn/note/set/3025">RSA1]P5pepper的WriteUp | NSSCTF</a></p><p>看懂了，只有一个问题：为什么从a从根号n开始加</p><ul><li>因为b要从0，a等于根号n时b才等于0😋</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br>p = getPrime(<span class="hljs-number">512</span>)<br>q = gmpy2.next_prime(p - getPrime(<span class="hljs-number">256</span>))<br><br>n = <span class="hljs-number">148841588941490812589697505975986386226158446072049530534135525236572105309550985274214825612079495930267744452266230141871521931612761645600600201983605957650711248808703757693378777706453580124982526368706977258199152469200838211055230241296139605912607613807871432800586045262879581100319519318390454452117</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">69038543593219231496623016705860610154255535760819426453485115089535439537440188692852514795648297200067103841434646958466720891016026061658602312900242658759575613625726750416539176437174502082858413122020981274672260498423684555063381678387696096811975800995242962853092582362805345713900308205654744774932</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">fermat_attack</span>(<span class="hljs-params">n</span>):<br>    a = isqrt(n)<br>    b2 = a*a - n<br>    b = isqrt(n)    <span class="hljs-comment">#这里只是对b进行一个初始化，b=1，2，3，，，等于几应该都行</span><br>    count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> b*b != b2:          <br>        a = a + <span class="hljs-number">1</span><br>        b2 = a*a - n<br>        b = isqrt(b2)<br>        count += <span class="hljs-number">1</span><br>    p = a+b<br>    q = a-b<br>    <span class="hljs-keyword">assert</span> n == p * q<br>    <span class="hljs-keyword">return</span> p, q<br><br><br>p, q = fermat_attack(n)<br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br><br><br>msg = <span class="hljs-built_in">pow</span>(c, d, n)<br>message = long_to_bytes(msg)<br><br><span class="hljs-built_in">print</span>(message)<br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p6">[RSA1]P6</h2><h3 id="main_py-5">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p1 = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>p2 = getPrime(<span class="hljs-number">512</span>)<br><br>n1 = p1*q<br>n2 = p2*q<br><br>e = <span class="hljs-number">65537</span><br><br>m = bytes_to_long(flag)<br>c1 = <span class="hljs-built_in">pow</span>(m, e, n1)<br>c2 = <span class="hljs-built_in">pow</span>(m, e, n2)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n1 = <span class="hljs-subst">&#123;n1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;n2 = <span class="hljs-subst">&#123;n2&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c1 = <span class="hljs-subst">&#123;c1&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c2 = <span class="hljs-subst">&#123;c2&#125;</span>&#x27;</span>)<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">n1 = 143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br><span class="hljs-string">n2 = 138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c1 = 54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br><span class="hljs-string">c2 = 122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-4">decrypt.py</h3><p><strong>已知（e,n1,c1,n2,c1），求m</strong></p><p><strong>两组数中e相同，n,c不同，n1和n2的最大公因数即为p,之后就能求出q、d,继而求出m</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>n1 = <span class="hljs-number">143348646254804947818644803938588739009782265465565896704788366218178523508874903492905378927641178487821742289009401873633609987818871281146199303052141439575438691652893995423962176259643151111739185844059243400387734688275416379337335777994990138009973618431459431410429980866760075387393812720247541406893</span><br>n2 = <span class="hljs-number">138110854441015362783564250048191029327770295545362614687087481715680856350219966472039006526758450117969049316234863489558254565946242898336924686721846675826468588471046162610143748100096038583426519355288325214365299329095841907207926280081868726568947436076663762493891291276498567791697978693639037765169</span><br>e = <span class="hljs-number">65537</span><br>c1 = <span class="hljs-number">54957154834913405861345262613986460384513988240935244315981524013378872930144117440787175357956479768211180412158274730449811947349624843965933828130932856052315165316154486515277625404352272475136003785605985702495858150662789554694910771308456687676791434476722168247882078861234982509648037033827107552029</span><br>c2 = <span class="hljs-number">122221335585005390437769701090707585780333874638519916373585594040154234166935881089609641995190534396533473702495240511296379249872039728112248708182969185010334637138777948970821974238214641235158623707766980447918480715835847907220219601467702961667091318910582445444058108454023108157805147341928089334736</span><br><br><span class="hljs-comment"># p1 = getPrime(512)</span><br><span class="hljs-comment"># q = getPrime(512)</span><br><span class="hljs-comment"># p2 = getPrime(512)            byd你写解代码的时候加上这一段干什么</span><br><br><span class="hljs-comment"># n1 = p1*q</span><br><span class="hljs-comment"># n2 = p2*q</span><br><br>q = gcd(n1,n2)        <span class="hljs-comment"># 最关键的一句，看出q是n1和n2的最大公因数，然后求出q，后面就常规</span><br><span class="hljs-comment"># print(q)</span><br>p1 = n1 // q<br><br>phi = (q-<span class="hljs-number">1</span>)*(p1-<span class="hljs-number">1</span>)<br>d1 = invert(e, phi) <br><br>m1 = <span class="hljs-built_in">pow</span>(c1, d1, n1)<br><br><br><span class="hljs-comment"># m1=hex(m1).replace(&#x27;0x&#x27;,&#x27;&#x27;)</span><br><span class="hljs-comment"># flag = bytes.fromhex(m1)</span><br><span class="hljs-comment"># print(flag)</span><br><br><span class="hljs-built_in">print</span>(long_to_bytes(m1))<br><span class="hljs-comment"># 但是有个小问题啊，为什么n1和n2解出来是一样的捏🤒</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p7">[RSA1]P7</h2><h3 id="main_py-6">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">170</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br>r = getPrime(<span class="hljs-number">512</span>)<br>n = p*q*r<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br><span class="hljs-string">q = 8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br><span class="hljs-string">r = 12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-5">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（特例款）</strong></p><p>相当于多了一个参数r，还是一样，加上r就行了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">10666139331774428325755287635566473140804481321882464031499529816800186578792308674238646794969384836340484775213796013129603472328582005363876462361316357</span><br>q = <span class="hljs-number">8419311673449738061914489023962717718536471719688567807316495262754711350004888752049108347226115000749280146228195893953964759818878155006622123533942989</span><br>r = <span class="hljs-number">12875078327453384158245832541544758526474680184252540739652077682353277702054275525591573258723948221345537075374635382175740236093131628077747126356403959</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">424552463648937499189041230155623101311087334789253159440707211761796081289342164253743235182597460622581134089949035117444838205449163269030784233435435681797627188717450074808905561404960693227573181548281296514743775615606388692910356320667720308219275107443303501165027740512539959960217657836317351146520079753390346207659007421416917274795119021374032194294225350901136669304225010974617136606299060486198480556729770211945777266366417547752798441211059402</span><br><br>n = p * q * r<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)*(r-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br><span class="hljs-comment">#b&#x27;NSSCTF&#123;3th_number!&#125;11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111&#x27;</span><br><span class="hljs-comment"># 不过至于本题为何要添加上大量的字符1作为填充内容，这个问题待到P9时我们便会知晓。</span><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p8">[RSA1]P8</h2><h3 id="main_py-7">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span> + <span class="hljs-string">b&#x27;1&#x27;</span>*<span class="hljs-number">100</span><br><br>p = getPrime(<span class="hljs-number">256</span>)<br>q = getPrime(<span class="hljs-number">256</span>)<br>n = (p**<span class="hljs-number">3</span>) * q<br>e = <span class="hljs-number">65537</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br><span class="hljs-string">q = 67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-6">decrypt.py</h3><p><strong>已知（e，p，q，r），求m（经典款）</strong></p><p>byd欧拉公式都不知道是吧：</p><p>对于： <span class="math display">\[n = p_{1}^{k_{1}}p_{2}^{k_{2}}p_{3}^{k_{3}}\cdots p_{r}^{k_{r}}\]</span></p><p>欧拉函数等于：</p><p><span class="math display">\[\varphi (n) = \prod_{i=1}^{r} p_{i}^{k_{i}-1}(p_{i}-1)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">80505091208742938705306670241621545375764148093711243653439069254008824979403</span><br>q = <span class="hljs-number">67599990875658931406915486208971556223245451500927259766683936131876689508521</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">7958690969908064264211283192959937430539613460471121984649054121171267262097603091410178042319139582772142226087020110084551158367679146616732446561228522673699836019156243452069036383047309578614662564794584927846163157472211089368697387945469398750955336949678910159585015004994620777231073804301249774041</span><br><br>n = p * p * p * q<br>phi = (p**<span class="hljs-number">2</span>)*(p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = <span class="hljs-built_in">pow</span>(e,-<span class="hljs-number">1</span>,phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))  <br><br></code></pre></td></tr></table></figure><hr /><h2 id="rsa1p9">[RSA1]P9</h2><h3 id="main_py-8">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    r = <span class="hljs-number">2</span>*getPrime(<span class="hljs-number">100</span>)*e+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> isPrime(r):<br>        <span class="hljs-keyword">break</span><br><br>n = p*q*r<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;r = <span class="hljs-subst">&#123;r&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br><span class="hljs-string">q = 9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br><span class="hljs-string">r = 102909133680612532601801231903654039</span><br><span class="hljs-string">e = 65537</span><br><span class="hljs-string">c = 142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-7">decrypt.py</h3><p><strong>已知（e，p，q，r)，且m已知很短</strong></p><p>总结：</p><p>满足以下情况时，可以不使用题中给的n=pqr计算公式，自己重新计算n，再进一步计算公私钥：</p><ol type="1"><li>明文m比较简短<ul><li>flag = b’NSSCTF{ $$}’ + b’1’ * 100 不行</li><li>flag = b’NSSCTF{ <span class="math inline">\(\cdots \cdots\)</span>}’ 可以</li></ul></li><li>分析发现使用给定的n无法计算d，原因可能是d = inverse(e,phi)中e、phi不互素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br><br>p = <span class="hljs-number">7478755670255767435237487693415479182290330775502792675052667363676831056436638619069277770540533350723045234676443621124912287506103439704868369839725279</span><br>q = <span class="hljs-number">9232828888049557325429111621080998490274442347556398052322580869768941301413255711626092627273543579067597113958627672298942570149816938335701615759283713</span><br>r = <span class="hljs-number">102909133680612532601801231903654039</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">142893174944324070830219394465469685943669308818639857030565389839224452373848570577201378981080333784852764502832587008270072323948511579823852437852643609820245476634896477031076952735298279618952398460203032125853063235638358942643559551563899381032067185778629120272032518475352761100115057449043142848203976076694124978394099839339406197</span><br><br>n = p * q    <span class="hljs-comment"># 相当于直接把r给忽略掉了，但原理还没懂，xenny师傅的wp有点没看懂</span><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(m))   <br></code></pre></td></tr></table></figure><p>Xenny师傅的wp：<ahref="https://www.nssctf.cn/problem/sheet/7142">Crypto系列——RSA（一） |NSSCTF</a></p><hr /><h2 id="rsa1p10">[RSA1]P10</h2><h3 id="main_py-9">main_py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><br>flag = <span class="hljs-string">b&#x27;NSSCTF&#123;******&#125;&#x27;</span><br><br>p = getPrime(<span class="hljs-number">512</span>)<br>q = getPrime(<span class="hljs-number">512</span>)<br><br>e = <span class="hljs-number">65537</span>*<span class="hljs-number">2</span><br><br>n = p*q<br><br>m = bytes_to_long(flag)<br><br>c = <span class="hljs-built_in">pow</span>(m, e, n)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;p = <span class="hljs-subst">&#123;p&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;q = <span class="hljs-subst">&#123;q&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;e = <span class="hljs-subst">&#123;e&#125;</span>&#x27;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;c = <span class="hljs-subst">&#123;c&#125;</span>&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">p = 9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br><span class="hljs-string">q = 9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br><span class="hljs-string">e = 131074</span><br><span class="hljs-string">c = 68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="decrypt.py-8">decrypt.py</h3><p><strong>已知(e，p，q，c），但是e和phi不互素</strong></p><p>因为p−1或q−1都是偶数，e也是偶数，他们显然不互素。</p><p><strong>关键の公式</strong>： <span class="math display">\[c\equiv m^{e}\equiv (m^{2})^{65537}  (mod \quad n)\]</span> 把 <spanclass="math inline">\(m^{2}\)</span>看成一个整体即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> gmpy2 <span class="hljs-keyword">import</span> *<br><br>p = <span class="hljs-number">9927950299160071928293508814174740578824022211226572614475267385787727188317224760986347883270504573953862618573051241506246884352854313099453586586022059</span><br>q = <span class="hljs-number">9606476151905841036013578452822151891782938033700390347379468858357928877640534612459734825681004415976431665670102068256547092636766287603818164456689343</span><br>e = <span class="hljs-number">65537</span><br>c = <span class="hljs-number">68145285629092005589126591120307889109483909395989426479108244531402455690717006058397784318664114589567149811644664654952286387794458474073250495807456996723468838094551501146672038892183058042546944692051403972876692350946611736455784779361761930869993818138259781995078436790236277196516800834433299672560</span><br><br><br>n = p*q<br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c, d, p*q)<br><br><span class="hljs-built_in">print</span>(long_to_bytes(isqrt(m)))<br><br><br><span class="hljs-comment"># 后面这部分也能写出下面这样：</span><br><br><br>n = p * q    <br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><span class="hljs-comment"># print(gcd(e, phi))</span><br><br>d = invert(e, phi)<br>m = <span class="hljs-built_in">pow</span>(c,d,n)<br>a,b = gmpy2.iroot(m,<span class="hljs-number">2</span>) <br><br><span class="hljs-built_in">print</span>(long_to_bytes(a))   <br></code></pre></td></tr></table></figure><p>2023.09.10-2023.09.14</p>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA学习总结</title>
    <link href="/2023/09/12/RSA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2023/09/12/RSA%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><code>from Crypto.Util.number import *</code><code>from gmpy2 import *</code></p><ul><li>导入两个经典的模块</li></ul><p><code>d = inverse(e, phi)</code></p><p><code>d = invert(e, phi)</code></p><ul><li><code>inverse</code>函数，<code>invert</code>函数，函数有两个参数<code>(a,p)</code>，作用便是求解<code>a</code>在模<code>p</code>意义下的乘法逆元，</li><li>这里我们便是求解<code>e</code>在模<code>phi</code>下面的乘法逆元，结果为<code>d</code></li><li>即满足$ e* d ≡ 1(modφ(n)) $</li><li>即满足$ (d * e) % phi = 1 $，%的意思是取余</li><li>这个语句使用的是 <code>Crypto.Util.number</code> 模块中的<code>inverse()</code> 函数</li></ul><p><code>d = gmpy2.invert(e, phi)</code></p><ul><li>该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得$ (d * e) %phi = 1 $</li><li>也即是<code>d * e ≡ 1 (mod phi)</code></li><li>这个语句使用的是外部库 <code>gmpy2</code> 的 <code>invert()</code>函数来计算乘法逆元，<del>gmpy2和Crypto中的数学函数相比：二者速度不是一个量级。</del></li></ul><p><code>d = pow(e,-1,phi)</code></p><ul><li>当传递三个参数时，<code>pow(x, y, z)</code> 用于计算 <code>x</code>的 <code>y</code> 次幂模 <code>z</code> 的结果。在这里，<code>e</code>是底数，<code>-1</code> 是指数，<code>phi</code>是模数。通过将指数设置为 <code>-1</code>，<code>pow(e, -1, phi)</code>计算了 <code>e</code> 的模 <code>phi</code> 的乘法逆元。</li><li>这个语句使用的是内置函数 <code>pow()</code>来执行指数运算和模计算。</li></ul><p><code>gmpy2.iroot(x, n)</code></p><ul><li>其中，<code>x</code> 是待计算根号的整数，<code>n</code>是根号类型的整数值。<code>irrot（c,e）</code>表示 对c开e次根号，</li><li>如果 <code>x</code>的根号为整数，函数将返回一个<strong>元组（tuple）</strong>，返回值为<code>(mpz(2), False)</code>，第一个参数表示返回的结果，<code>mpz</code>为<code>gmpy2</code>包中对整数的封装类，看作一个整数即可；第二个参数代表这个数是否能被完全开e次方，true表示能。</li><li>例如10开3次方并不是一个整数，但<code>gmpy2</code>只会返回取整后的整数值，故通过第二项我们能够知道是否为完全k次方数。</li><li>例如<code>iroot(9, 2)</code>返回<code>(mpz(3), True)</code>代表9是一个完全平方数。</li><li>如果想获得根号的整数值，可以通过访问元组的第一个元素来实现，例如：<ul><li><code>m1 = gmpy2.iroot(m, 2)[0]</code></li><li><code>print(long_to_bytes(m[0]))</code></li></ul></li><li>也能直接赋值的时候就赋给两个变量，这里a就是取平方根后的整数值<ul><li><code>a, b = gmpy2.iroot(m,2)</code></li></ul></li></ul><p><code>.\yafu-x64.exe "factor(@)" -batchfile 1.txt</code></p><ul><li>分解1.txt中的整数</li></ul><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><hr /><hr /><p>第一个RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-img1694707420490.png"alt="1694707420490" /><figcaption aria-hidden="true">1694707420490</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915000454756.png"alt="image-20230915000454756" /><figcaption aria-hidden="true">image-20230915000454756</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001215482.png"alt="image-20230915001215482" /><figcaption aria-hidden="true">image-20230915001215482</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230915001234755.png"alt="image-20230915001234755" /><figcaption aria-hidden="true">image-20230915001234755</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><blockquote><p>数学公式里面的空格</p><p>% 意思是打出一个%符号</p><p>% 单独输入这个可以把后面的都注释掉</p><p>写数学公式换行：</p><p><span class="math inline">\(p=q\)</span>，$ p=q$，后面这个就显示错误，不能有空格</p><p>行的中间也不能有空行</p><p>[<ahref="https://blog.csdn.net/bendanban/article/details/77336206">CSDN_Markdown]数学公式对齐_markdown 数学公式对齐-CSDN博客</a></p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202311062156645.png"alt="image-20231106215632596" /><figcaption aria-hidden="true">image-20231106215632596</figcaption></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NSSCTF-Crypto（1~15）</title>
    <link href="/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/"/>
    <url>/2023/09/09/NSSCTF-Crypto%EF%BC%881~15%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>《从0开始的密码学世界生活》😋慢慢学密码方向</p><p>有两个有各种加解密的网站</p><p><a href="http://www.hiencode.com/">在线工具</a></p><p><a href="https://ctf.bugku.com/tools">Bugku CTF</a></p><h2 id="鹤城杯-2021easy_crypto">[鹤城杯 2021]easy_crypto</h2><p>解压后文件内容是社会主义核心价值观，查了一下竟然有<strong>核心价值观编码</strong>，有点逆天，那就直接用工具解码即可。</p><p>下面贴上两个网站</p><p><ahref="http://www.hiencode.com/cvencode.html">核心价值观编码-加解密1</a></p><p><ahref="https://ctf.bugku.com/tool/cvecode">核心价值观编码-加解密2</a></p><hr /><h2 id="强网拟态-2021拟态签到题">[强网拟态 2021]拟态签到题</h2><p>打开txt文件，发现看不懂，这什么东西？</p><p><a href="https://freeimage.host/i/J95ihaR"><imgsrc="https://iili.io/J95ihaR.md.png" alt="2309061" /></a></p><p>GPT一下</p><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><p>GPT倒是一眼看出来了，base64编码，直接解码即可，仍然上面的两个网站任意一个即可</p><hr /><h2 id="swpuctf-2021-新生赛crypto8">[SWPUCTF 2021 新生赛]crypto8</h2><p>打开txt后又是一段乱码：73E-30U1&amp;&gt;V-H965S95]I&lt;U]P;W=E&lt;GT`</p><p>根据题目上面的标签提示，推测是UUencode加密</p><p>用工具解密即可</p><p>NSSCTF{cheese_is_power}</p><blockquote><p><strong>有个小问题哈，这些编码的具体实现方式我们不用具体了解吗难道🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔🤔，直接用工具就行了吗？</strong></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛crypto7">[SWPUCTF 2021 新生赛]crypto7</h2><p>打开txt，原文如下</p><p><code>69f7906323b4f7d1e4e972acf4abfbfc,得到的结果用NSSCTF&#123;&#125;包裹。</code></p><p>根据标签，发现是MD5加密</p><p>直接解密即可，<a href="https://www.cmd5.com/">MD5解密</a></p><p>NSSCTF{md5yyds}</p><hr /><h2 id="swpuctf-2021-新生赛crypto6">[SWPUCTF 2021 新生赛]crypto6</h2><p>打开txt，原文如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">var=<span class="hljs-string">&quot;************************************&quot;</span><br>flag=<span class="hljs-string">&#x27;NSSCTF&#123;&#x27;</span> + base64<span class="hljs-selector-class">.b16encode</span>(base64<span class="hljs-selector-class">.b32encode</span>(base64<span class="hljs-selector-class">.b64encode</span>(<span class="hljs-selector-tag">var</span><span class="hljs-selector-class">.encode</span>()))) + <span class="hljs-string">&#x27;&#125;&#x27;</span><br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(flag)</span></span><br><br>小明不小心泄露了源码，输出结果为：<span class="hljs-number">4</span>A5A4C564B36434E4B5241544B5432454E4E32465552324E47424758534D44594C4657564336534D4B5241584F574C4B4B463245365643424F35485649534C584A5A56454B4D4B5049354E47593D3D3D，你能还原出var的正确结果吗？<br></code></pre></td></tr></table></figure><ul><li>可以看出加密是先base64，再base32，再base16</li><li>所以解密我们就先反过来即可，16 → 32 → 64，用上面的解密网站</li><li>得到5e110989-dc43-1bd3-00b4-9009206158fe</li><li>所以flag为NSSCTF{5e110989-dc43-1bd3-00b4-9009206158fe}</li></ul><hr /><h2 id="swpuctf-2021-新生赛ez_caesar">[SWPUCTF 2021新生赛]ez_caesar</h2><p>打开后是一个.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">caesar</span>(<span class="hljs-params">plaintext</span>):<br>    str_list = <span class="hljs-built_in">list</span>(plaintext)<br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(plaintext):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> str_list[i].isalpha():<br>            str_list[i] = str_list[i]<br>        <span class="hljs-keyword">else</span>:<br>            a = <span class="hljs-string">&quot;A&quot;</span> <span class="hljs-keyword">if</span> str_list[i].isupper() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;a&quot;</span><br>            str_list[i] = <span class="hljs-built_in">chr</span>((<span class="hljs-built_in">ord</span>(str_list[i]) - <span class="hljs-built_in">ord</span>(a) + <span class="hljs-number">5</span>) % <span class="hljs-number">26</span> + <span class="hljs-built_in">ord</span>(a) <span class="hljs-keyword">or</span> <span class="hljs-number">5</span>)<br>        i = i + <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>.join(str_list)<br><br>flag = <span class="hljs-string">&quot;*************************&quot;</span><br><span class="hljs-built_in">str</span> = caesar(flag)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">str</span>)<br><br><span class="hljs-comment">#str=&quot;U1hYSFlLe2R0em1mYWpwc3RiaGZqeGZ3fQ==&quot;</span><br></code></pre></td></tr></table></figure><p>这，有点看不懂，GPT一下吧，下面是GPT的解释 &gt;这段代码首先导入了base64模块，然后定义了一个名为caesar的函数，该函数接受一个明文字符串作为输入，并返回加密后的字符串。在函数内部，首先将明文字符串转换为字符列表str_list，然后使用while循环遍历明文字符串的每个字符。在每次循环中，首先检查当前字符是否为字母。如果不是字母，则将字符保持不变。如果是字母，则根据字母的大小写确定字母表的起始位置（大写字母从'A'开始，小写字母从'a'开始），然后使用凯撒密码的规则对字母进行替换。替换的规则是将字母的Unicode码减去起始位置的Unicode码，再加上一个固定的位移量5，然后对26取模，最后再加上起始位置的Unicode码或者5。这样可以确保替换后的字符仍然是一个字母。循环结束后，将字符列表转换回字符串，并将加密后的字符串打印出来。最后一行的注释掉的代码是一个经过base64编码的字符串，你可以在需要时将其解码。</p><p>那我就懂了，嘻嘻</p><ul><li>凯撒密码（Caesar cipher），原来就是凯撒密码</li><li>最后一行注释掉的是base64编码后的结果</li><li>那我们就先base64解码，再凯撒解码应该就行</li><li>注意凯撒解码还需要一个偏移量，这里的偏移量就是5</li><li>最后得到 NSSCTF{youhaveknowcaesar}</li></ul><hr /><h2 id="swpuctf-2021-新生赛crypto10">[SWPUCTF 2021 新生赛]crypto10</h2><p>txt中的内容为：<code>AFFPGS&#123;pbatenghyngvbaf!!!&#125;,建议直接秒了</code></p><p>观察标签可以看出是个什么ROT加密，直接搜工具解密即可</p><p>NSSCTF{congratulations!!!}</p><hr /><h2 id="鹤城杯-2021a_crypto">[鹤城杯 2021]A_CRYPTO</h2><p>逆天文本：4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35</p><p>从此知道了<strong>ciphey</strong>的存在，准备配置啊啊啊啊</p><p><ahref="https://blog.csdn.net/Dome_/article/details/120689591?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120689591-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">全自动解密解码神器— Ciphey</a></p><p><ahref="https://blog.csdn.net/ntrybw/article/details/131516319?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169401549316800211566878%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169401549316800211566878&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-7-131516319-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ciphey&amp;spm=1018.2226.3001.4187">Windows安装ciphey编码工具，编码工具战神，cry简单题绝对克星！</a></p><p>不知道为啥，就安装成功了，但是只能在windows下的cmd中使用，等会还要在kali里面再下一个<strong>ciphey</strong></p><p>解密命令为：</p><p><code>ciphey -t "4O595954494Q32515046324757595N534R52415653334357474R4N575955544R4O5N4Q46434S4O59474253464Q5N444R4Q51334557524O5N4S424944473542554O595N44534O324R49565746515532464O49345649564O464R4R494543504N35"</code></p><figure><img src="https://iili.io/J9lb0js.png" alt="202309071.png" /><figcaption aria-hidden="true">202309071.png</figcaption></figure><p>所以flag为："NSSCTF{W0w_y0u_c4n_rea11y_enc0d1ng!}"</p><blockquote><p>0 0 0 下面的东西可以忽略，byd配环境配了将近一上午都没在kali里面配好，不是python版本问题就是什么PATH路径问题，到最后也没解决，草！这里由于百度网盘下载的太慢，一顿搜索后发现了其他的方法，怎么没早点发现啊😭<ahref="https://greasyfork.org/zh-CN/scripts/463707-%E5%B0%B1%E6%98%AF%E5%8A%A0%E9%80%9F-%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E6%97%A0%E9%99%90%E9%80%9F%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD-%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E8%BD%BD">不多说好吧，要是有有缘人看到算是你赚了🤭</a>下面就是kali中ciphey的配置 <ahref="http://old.kali.org/virtual-images/kali-2021.2/">http://old.kali.org/virtual-images/kali-2021.2/</a><a href="https://kali.download/">https://kali.download/</a></p></blockquote><hr /><h2 id="swpuctf-2021-新生赛pigpig">[SWPUCTF 2021 新生赛]pigpig</h2><p>根据提示是一个什么猪圈密码</p><p><a href="http://www.hiencode.com/pigpen.html">在线解密即可</a></p><p>NSSCTF{whenthepigwanttoeat}</p><p>什么时候🐖想吃？🐷</p><hr /><h2 id="swpuctf-2021-新生赛ez_rsa">[SWPUCTF 2021 新生赛]ez_rsa</h2><p>打开txt内容如下，搜了一下确实是最最基础的RSA，</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233108248.png"alt="image-20230908233108248" /><figcaption aria-hidden="true">image-20230908233108248</figcaption></figure><p>那就了解一下RSA是什么吧，嘻嘻😍</p><p>一个简单的介绍视频<ahref="https://www.bilibili.com/video/av73858330/?vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">RSA算法基本原理_哔哩哔哩_bilibili</a></p><p>简单来说就是：</p><ul><li><p>A把一个公钥(e,N)给B，B把想发给A的信息 m 用(e,N)加密成 c后发给A，A有个私钥(d,N)，用私钥解密即可，这里的 d只有A掌握，别人很难知道（涉及大整数分解问题），所以方案安全。</p></li><li><p>就是保证了信息加密是容易的，而反向解密是困难的</p></li><li><p>过程再稍微稍微详细一点就是：</p><ul><li>选两个大质数p和q，且p!=q，计算N=p*q，N就算出来了</li><li>然后计算N的欧拉函数 φ(N)=(p-1)(q-1)</li><li>然后你自己选个e， 1&lt;e&lt;φ(N)，且与φ(N)互质，</li><li>由e和φ(N)互质，(e,φ(N))=1，再由辗转相除法，则一定有ed - φ(N)k =1</li><li>那么由e就可以算出d，如下图（下图中的p1，p2就是p，q）</li><li><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908235228225.png"alt="image-20230908235228225" /><figcaption aria-hidden="true">image-20230908235228225</figcaption></figure></li><li>enmmmm，就是这样🐌</li></ul></li></ul><p>下面是视频里面的一个小实例，帮助理解</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908233527952.png"alt="image-20230908233527952" /><figcaption aria-hidden="true">image-20230908233527952</figcaption></figure><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908234751944.png"alt="image-20230908234751944" /><figcaption aria-hidden="true">image-20230908234751944</figcaption></figure><p>虽然有些原理还不太清楚，但学到现在这题基本就能解决了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gmpy2   <span class="hljs-comment">#一个库，就是能算很多数学运算的 </span><br><span class="hljs-keyword">from</span> hashlib <span class="hljs-keyword">import</span> md5  <span class="hljs-comment">#hashlib 模块是 Python 中用于进行哈希计算的标准库模块之一。这里使用了 md5 哈希算法，这是其中的一种，通常用于生成数据的 MD5 哈希值。</span><br><br>p = <span class="hljs-number">1325465431</span><br>q = <span class="hljs-number">152317153</span><br>e = <span class="hljs-number">65537</span><br><br>phi = (p-<span class="hljs-number">1</span>)*(q-<span class="hljs-number">1</span>)<br><br>d = gmpy2.invert(e, phi)  <span class="hljs-comment">#非常的关键❤，该函数计算了一个整数 e 的模逆，也就是找到一个整数 d，使得 (d * e) % phi = 1 成立。%表示取余操作</span><br><br>flag = md5(<span class="hljs-built_in">str</span>(d).encode())<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;flag is : NSSCTF&#123;%s&#125;&quot;</span>%flag.hexdigest())<br><br></code></pre></td></tr></table></figure><p>flag is : NSSCTF{08bb8fb628da85923e5734a75ac19ffe}</p><hr /><h2 id="bjdctf-2020base">[BJDCTF 2020]base??</h2><p>打开后是这串东西</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909003141021.png"alt="image-20230909003141021" /><figcaption aria-hidden="true">image-20230909003141021</figcaption></figure><p>直接赛博厨子解决了😂，相当于换表操作，查了一下，写python代码还有点复杂🤔，等会再看一下（</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909005020849.png"alt="image-20230909005020849" /><figcaption aria-hidden="true">image-20230909005020849</figcaption></figure><hr /><h2 id="swpuctf-2021-新生赛traditional">[SWPUCTF 2021新生赛]traditional</h2><p>打开后是个什么东西，不懂，明天再看吧，byd已经1点力，还没刷牙😭</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230909010611371.png"alt="image-20230909010611371" /><figcaption aria-hidden="true">image-20230909010611371</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>CTF-Crypto</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
      <tag>Crypto</tag>
      
      <tag>NSSCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求解1²+2²+3²+……+n²</title>
    <link href="/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/"/>
    <url>/2023/09/05/%E6%B1%82%E8%A7%A31%C2%B2+2%C2%B2+3%C2%B2+%E2%80%A6%E2%80%A6+n%C2%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="一种简单的方法">一种简单的方法</h2><p>在做数据结构第一章的习题时遇见这个问题，感觉很有意思，就写了下来</p><p>这种方法把1²+2²+3²+……+n²写成三个式子，相加除以3得到结果，如下：</p><p>1</p><p>2 2</p><p>3 3 3</p><p>...........................</p><p>n n .................n n ①</p><hr /><p>n</p><p>..............n</p><p>3 ...................n</p><p>2 3 ...... ...........n</p><p>1 2 3....................n ②</p><hr /><p>n</p><p>n .........</p><p>n .................. 3</p><p>n ..........................3 2</p><p>n ..................................3 2 1 ③</p><p>这三个式子都表示1²+2²+3²+……+n²，把他们相加</p><p>①+②+③得</p><p>2n+1</p><p>2n+1 2n+1</p><p>....................................</p><p>2n+1 2n+1 2n+1...........................2n+1 2n+1 2n+1 ①+②+③</p><p>3 ∑n² = n(n+1)(2n+1)/2</p><p>故 1²+2²+······+n² = n（n+1）（2n+1）/6</p>]]></content>
    
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>各种软件安装，环境配置</title>
    <link href="/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/09/03/%E5%90%84%E7%A7%8D%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%EF%BC%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="在vscode中配置python开发环境">在VScode中配置Python开发环境</h2><p><ahref="https://blog.csdn.net/weixin_43737995/article/details/125690015?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169362300616800182129289%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169362300616800182129289&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-125690015-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=vscode%20python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE&amp;spm=1018.2226.3001.4187">在VScode中配置Python开发环境</a></p><h2 id="git安装">Git安装</h2><p><ahref="https://blog.csdn.net/mukes/article/details/115693833?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169205886716800188579548%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169205886716800188579548&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-115693833-null-null.142%5Ev92%5EchatgptT0_1&amp;utm_term=git%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">Git详细安装教程</a></p><h2 id="java安装">JAVA安装</h2><p><ahref="https://blog.csdn.net/qq_48988285/article/details/125593715?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169396267216800182147901%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169396267216800182147901&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-125593715-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=java%E5%AE%89%E8%A3%85&amp;spm=1018.2226.3001.4187">超详细Java安装教程，小白速来！！！</a></p><h2 id="dev-c安装">Dev C++安装</h2><p><ahref="https://blog.csdn.net/m0_54158068/article/details/124080083?ops_request_misc=%7B%22request%5Fid%22%3A%22169519422116800213087590%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169519422116800213087590&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-124080083-null-null.142%5Ev94%5EchatsearchT3_1&amp;utm_term=devc%2B%2B&amp;spm=1018.2226.3001.4187">DevC++软件下载及安装教程（详细、具体）_devc++下载_等日出看彩虹的博客-CSDN博客</a></p><h2 id="pycharm安装">Pycharm安装</h2><p><ahref="https://blog.csdn.net/m0_46374969/article/details/131292897?ops_request_misc=%7B%22request%5Fid%22%3A%22169819294316800213022638%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=169819294316800213022638&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-4-131292897-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=pycharm安装教程&amp;spm=1018.2226.3001.4187">PyCharm安装教程(图文结合，超详细，小白安装必看)_王同学要努力的博客-CSDN博客</a></p><h2 id="vscode配置c语言环境">vscode配置C语言环境</h2><p><ahref="https://www.bilibili.com/video/BV1Hj411F7eW/?spm_id_from=333.999.0.0&amp;vd_source=39f0a6c7a4d98748bb31fcf1e1a3ab7f">啰啰嗦嗦地手把手教你vscode 配置_哔哩哔哩_bilibili</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo建站过程</title>
    <link href="/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/08/16/hexo%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>b站yyds！！！</p><p><ahref="https://www.bilibili.com/video/BV1Eg41157tL/?spm_id_from=333.337.search-card.all.click&amp;vd_source=445ce756d899a4cef51cfb6b148ba121">hexo加GitHub搭建网站教程</a></p><p>评论区的搭建感谢大佬的博客<ahref="https://ltyzzzxxx.github.io/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/">周三不Coding</a></p><blockquote><p>图床的搭建暂时感谢<ahref="https://blog.csdn.net/Godlichangwu/article/details/127331738?ops_request_misc=%7B%22request%5Fid%22%3A%22169417712716800197059093%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169417712716800197059093&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-127331738-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=Github仓库%20%2B%20Picgo%20&amp;spm=1018.2226.3001.4187">搭建免费图床——github+picGo+jsdelivr_github图床token获取_chunis的博客-CSDN博客</a>（bye~~~）</p></blockquote><p>图床的搭建感谢<ahref="https://zhuanlan.zhihu.com/p/653227146">Typora+PicGo+阿里云OSS搭建博客图床- 知乎 (zhihu.com)</a></p><p>网站统计量的设置：<ahref="https://blog.csdn.net/qq_48759664/article/details/119460188?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo%20fluid访客量&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-5-119460188.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">Hexo-fluid主题设置统计博客阅读量_给fluid主题设置统计数量_codeacg的博客-CSDN博客</a>（注意还要配置一下RESTAPI 服务器地址）</p><p>这个是加上网站的运行时间：<ahref="https://blog.csdn.net/qq_36852780/article/details/120943120?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=hexo主题fluid怎么在下面加上运行时间&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-120943120.142%5Ev94%5EchatsearchT3_1&amp;spm=1018.2226.3001.4187">HexoFluid主题 细节优化_hexo fluid美化-CSDN博客</a></p><p>数学公式的显示问题参考：<ahref="https://blog.csdn.net/qq_52466006/article/details/126924064?ops_request_misc=%7B%22request%5Fid%22%3A%22169745488716800192255314%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=169745488716800192255314&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-2-126924064-null-null.142%5Ev96%5Epc_search_result_base1&amp;utm_term=博客数学公式显示错误&amp;spm=1018.2226.3001.4187">Hexo显示Latex公式最新解决方案_hexo公式-CSDN博客</a></p><hr /><hr /><p><strong>下面是遇到的一些问题</strong></p><h2 id="数学公式问题">数学公式问题</h2><p>记得打公式的时候”$$“，</p><p>这里前面的 "$"，以及后面的，记得跟公式的正文紧密挨着，不要留空格，如：</p><p><span class="math inline">\(X = \begin{bmatrix} x\\ y\end{bmatrix}\)</span>，就能显示成功</p><p>而：</p>$ X =<span class="math display">\[\begin{bmatrix}x\\ y\end{bmatrix}\]</span><p>$，就直接显示失败</p><h2 id="hexo-d-总是报错"><code>hexo d</code> 总是报错</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">Error: </span>Spawn failed<br>这错误烦死人，一直报<br></code></pre></td></tr></table></figure><h3 id="解决方案">解决方案</h3><ul><li>重新配置一下SSH，把下面的<strong>write</strong>那个选项给它勾上！！！！！！！！！！！！</li><li>不知道为啥，下面竟然还有个选项，不勾上的话就是readonly，然后就会一直报那个错误😡😡</li></ul><h2id="bash-hexo-command-not-found"><code>bash: hexo: command not found</code></h2><h3 id="解决方案-1">解决方案</h3><p>将<code>D:\blog\myblog\node_modules\.bin</code>,添加到Path中</p><h2 id="错误如下">错误如下</h2><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs subunit">ssh: Could not resolve hostname github.com: Name or service not known<br>fatal: Could not read from remote repository.<br><br>Please make sure you have the correct access rights<br>and the repository exists.<br>FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/d<br>ocs/troubleshooting.html<br><span class="hljs-keyword">Error: </span>Spawn failed<br>    at ChildProcess.&lt;anonymous&gt; (D:\blog\myblog\node_modules\hexo-util\lib\spawn<br>.js:51:21)<br>    at ChildProcess.emit (node:events:514:28)<br>    at cp.emit (D:\blog\myblog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>    at ChildProcess._handle.onexit (node:internal/child_process:291:12)<br>    <br></code></pre></td></tr></table></figure><p>不知道为什么会报这个错误，可能是我总是翻墙的问题吧，不太懂，草，一会一个错误md😡</p><h3 id="解决方案-2">解决方案</h3><p><ahref="https://blog.csdn.net/li_001/article/details/70245006?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169400980416800225586698%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169400980416800225586698&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-70245006-null-null.142%5Ev93%5EchatgptT3_1&amp;utm_term=ssh%3A%20Could%20not%20resolve%20hostname%20github.com%3A%20Name%20or%20service%20not%20known%20fatal%3A%20Could%20not%20read%20from%20remote%20repository.&amp;spm=1018.2226.3001.4187">CSDN解决方案</a></p><p>方案一亲测有效，CSDNyyds！😭</p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/08/14/hello-world/"/>
    <url>/2023/08/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试博客</title>
    <link href="/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/08/03/%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>title: Crypto系列——RSA（二） date: 2023-09-14 21:57:30 tags:[CTF,Crypto,RSA] categories: CTF-Crypto math: true excerpt:《从0开始的密码学世界生活2》😋 updated: 2023-10-03 22:20:49</p><h3 id="pwn1">pwn1</h3><h3 id="pwn2">pwn2</h3><p><a href="https://freeimage.host/i/J9YVHSj"><imgsrc="https://iili.io/J9YVHSj.md.png" alt="2309062" /></a></p><figure><img src="https://freeimage.host/i/J9YVHSj" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="https://iili.io/J9YVHSj.md.png" alt="2309062" /><figcaption aria-hidden="true">2309062</figcaption></figure><figure><img src="http://static.runoob.com/images/runoob-logo.png"title="RUNOOB" alt="RUNOOB 图标" /><figcaption aria-hidden="true">RUNOOB 图标</figcaption></figure><p><sub>撒旦哈市风口浪尖</sub></p><p>测试一下，看能不能直接传图片</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210230931.png"alt="image-20230908210230931" /><figcaption aria-hidden="true">image-20230908210230931</figcaption></figure><p>看来 jsDelivr CDN确实被墙了，那只能试一下阿里云了，测</p><p>哦？？这过了几分钟（2023.09.08 21:07），怎么又行了：</p><figure><imgsrc="https://cdn.jsdelivr.net/gh/viper2383/blogimages/blog-imgimage-20230908210813336.png"alt="image-20230908210813336" /><figcaption aria-hidden="true">image-20230908210813336</figcaption></figure><p>行吧，那先用着</p><h3 id="section">2023.10.27</h3><p>b jsDelivrCDN总是出错，换成了阿里云OSS，花了我九块大米，试一下能不能上传成功（目前还行，果然“<strong>免费的才是最贵的</strong>”吗？😥）</p><figure><imgsrc="https://wiper3.oss-cn-guangzhou.aliyuncs.com/blogimage/202310270011249.png"alt="image-20231027001155106" /><figcaption aria-hidden="true">image-20231027001155106</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言检测点</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-基础知识">第一章 基础知识</h2><h3 id="检测点-1.1">检测点 1.1</h3><p><a href="https://freeimage.host/i/HrT21vs"><imgsrc="https://iili.io/HrT21vs.md.png" alt="HrT21vs.md.png" /></a></p><p>（1）<strong>13</strong></p><ul><li>寻址能力：一个CPU有N根地址线，则这个CPU的地址总线的宽度为N，最多可以寻找2的N次方个内存单元。</li><li>地址总线的宽度决定了CPU 的寻址能力。</li><li>\( 2^{N} = 8KB = 8*1024B = 2^{13}B \)，N为地址总线宽度，N=13</li></ul><p>（2）<strong>1024，0，1023</strong> -一个存储单元占一个字节（即1B），故1KB的存储器有1024个存储单元，存储单元编号从0~1023。</p><p>（3）<strong>8192，1024</strong> - 1千字节（KB）= 1024字节（B） -1字节（Byte）= 8比特（bit）</p><p>（4）<strong>\( 2^{30}， 2^{20}， 2^{10}\)</strong></p><p>（5）<strong>64KB，1MB，16MB，4GB</strong> -8080CPU地址总线宽度为16，寻址能力为\(2^{16} = 2^6KB = 64KB\) -其余同理</p><p>（6）<strong>1，1，2，2，4</strong> -8根数据总线一次可传送一个8位二进制数据（即一个字节）</p><p>（7）<strong>512，256</strong> - 8086CPU数据总线16根，一次可读2个字节,1024/2=512</p><p>（8）<strong>二进制</strong></p><h2 id="第二章-寄存器">第二章 寄存器</h2><h3 id="检测点-2.1">检测点 2.1</h3><p><a href="https://freeimage.host/i/H4naDZb"><imgsrc="https://iili.io/H4naDZb.md.png" alt="H4naDZb.md.png" /></a></p><ol type="1"><li><p>有点简单，注意溢出即可，如：C5H+93H=158H，而al只有8位，所以al=58H，从而AX=0058H</p></li><li><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mov</span> ax,<span class="hljs-number">2</span>     ;<span class="hljs-number">2</span>的<span class="hljs-number">1</span>次方 = <span class="hljs-number">2</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">2</span>次方 = <span class="hljs-number">2</span> + <span class="hljs-number">2</span> = <span class="hljs-number">4</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">3</span>次方 = <span class="hljs-number">4</span> + <span class="hljs-number">4</span> = <span class="hljs-number">8</span><br><span class="hljs-attribute">add</span> ax,ax    ;<span class="hljs-number">2</span>的<span class="hljs-number">4</span>次方 = <span class="hljs-number">8</span> + <span class="hljs-number">8</span> = <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><h3 id="检测点-2.2">检测点 2.2</h3><p><a href="https://freeimage.host/i/H4pjm0v"><imgsrc="https://iili.io/H4pjm0v.md.png"alt="H4pjm0v.md.png" /></a></p></li></ol><p>（1）<strong>00010H到1000FH</strong> - 基础地址（段地址*16）+偏移地址 = 物理地址 -偏移地址16位，变化范围为0~FFFFH，仅用偏移地址最多可寻址64KB -给定段地址为0001H，寻址范围为（0001H×16）+0到（0001H×16）+FFFFH，即寻址范围为0010H到1000FH</p><p>（2）<strong>最小为 1001H ，最大为 2000H</strong></p><ul><li>段地址<em>16+偏移地址=物理地址，即SA</em>16+EA=20000H；偏移地址16位，变化范围为0~FFFFH；</li><li>当偏移地址取最大值FFFFH时，段地址最小，SA=(20000H-FFFFH)/16=1001H（<strong>取上界</strong>）</li><li>当偏移地址取最小值0H时，段地址最大，SA=(20000H-0H)/16=2000H。</li></ul><p>思考：当段地址给定为小于1001H或大于2000H时，CPU无论怎么变化偏移地址都无法寻到20000H单元。</p><h3 id="检测点-2.3">检测点 2.3</h3><p><a href="https://freeimage.host/i/H4pvW0u"><imgsrc="https://iili.io/H4pvW0u.md.png" alt="H4pvW0u.md.png" /></a></p><ul><li><p>一共修改了4次。</p></li><li><p>读取 mov ax,bx 指令后，第一次修改IP</p></li><li><p>读取 sub ax,ax 指令后，第二次修改IP</p></li><li><p>读取 jmp ax 指令后，第三次修改IP</p></li><li><p>执行 jmp ax 指令时，第四次修改IP，最后IP=ax=0</p><p><strong>略了，有时间再补，最近期末复习时间太紧了</strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言实验</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="loop双层循环">loop双层循环</h2><hr /><p><a href="https://freeimage.host/i/H655pWu"><imgsrc="https://iili.io/H655pWu.md.png" alt="H655pWu.md.png" /></a></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">10</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">     b:</span> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">cx</span><br>    <br>        <span class="hljs-keyword">loop</span> b<br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span>    <br>        <span class="hljs-keyword">loop</span> s  <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><ul><li>两层循环解决</li></ul><hr /><h2 id="实验4-bx和loop的使用">实验4 [bx]和loop的使用</h2><hr /><p>1.编程，向内存0:200-0:23F依次传送数据0-63（3FH)。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;八条指令的</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>],<span class="hljs-built_in">bx</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code         <span class="hljs-comment">;九条指令的，书上现在还规定指令数</span><br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">64</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">bl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>   <span class="hljs-keyword">loop</span> s<br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验5-编写调试具有多个段的程序">实验5编写、调试具有多个段的程序</h2><hr /><p>1.程序如下，编写code段中的代码，将a段和b段中的数据依次相加，将结果保存到c段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>a ends<br>b <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span><br>b ends<br>c <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>c ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br>   <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">   </span><br><span class="hljs-symbol">s:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span><br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">add</span> <span class="hljs-built_in">dl</span>,[<span class="hljs-number">16</span>+<span class="hljs-built_in">si</span>]<br>   <span class="hljs-keyword">mov</span> [<span class="hljs-number">32</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">dl</span><br>   <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>   <span class="hljs-keyword">loop</span> s<br>   <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><p>2.程序如下，编写code段代码，用push指令将a段中的前8个字型数据，逆序存储到b段中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code <br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>?<br>code ends<br>end start<br><br><br>补充后的代码如下：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>a <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0bh</span>,<span class="hljs-number">0ch</span>,<span class="hljs-number">0dh</span>,<span class="hljs-number">0eh</span>,<span class="hljs-number">0fh</span>,<span class="hljs-number">0ffh</span><br>a ends<br><br>b <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>b ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,a<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,b<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">8</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">push</span> [<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s <br><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验6-实践课程中的程序">实验6 实践课程中的程序</h2><hr /><p>将下面的程序补充完整，实现将 datasg 段中的每个单词的前 4个字母改为大写字母。【要求：仅能修改 codesg segment 的代码】</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>codesg ends<br>end start<br><br><br><br>修改后的代码：<br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg, <span class="hljs-built_in">ss</span>:stacksg, <span class="hljs-built_in">ds</span>:datasg<br><br>stacksg <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">dw</span> <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>stacksg ends<br><br>datasg <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1. display      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;2. brows        &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;3. replace      &#x27;</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;4. modify       &#x27;</span><br>datasg ends<br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stacksg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">16</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,datasg<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s0:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">4</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">       s1:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>]<br>            <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">11011111b</span><br>            <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">3</span>+<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span><br><br>            <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">loop</span> s1<br><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> s0 <br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验7-寻址方式在结构化数据访问中的应用">实验7寻址方式在结构化数据访问中的应用</h2><hr /><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:codesg<br><br>data <span class="hljs-meta">segment</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1975&#x27;</span>,<span class="hljs-string">&#x27;1976&#x27;</span>,<span class="hljs-string">&#x27;1977&#x27;</span>,<span class="hljs-string">&#x27;1978&#x27;</span>,<span class="hljs-string">&#x27;1979&#x27;</span>,<span class="hljs-string">&#x27;1980&#x27;</span>,<span class="hljs-string">&#x27;1981&#x27;</span>,<span class="hljs-string">&#x27;1982&#x27;</span>,<span class="hljs-string">&#x27;1983&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1984&#x27;</span>,<span class="hljs-string">&#x27;1985&#x27;</span>,<span class="hljs-string">&#x27;1986&#x27;</span>,<span class="hljs-string">&#x27;1987&#x27;</span>,<span class="hljs-string">&#x27;1988&#x27;</span>,<span class="hljs-string">&#x27;1989&#x27;</span>,<span class="hljs-string">&#x27;1990&#x27;</span>,<span class="hljs-string">&#x27;1991&#x27;</span>,<span class="hljs-string">&#x27;1992&#x27;</span><br>        <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;1993&#x27;</span>,<span class="hljs-string">&#x27;1994&#x27;</span>,<span class="hljs-string">&#x27;1995&#x27;</span><br>        <span class="hljs-comment">;以上是表示21年的21个字符串</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">16</span>,<span class="hljs-number">22</span>,<span class="hljs-number">382</span>,<span class="hljs-number">1356</span>,<span class="hljs-number">2390</span>,<span class="hljs-number">8000</span>,<span class="hljs-number">16000</span>,<span class="hljs-number">24486</span>,<span class="hljs-number">50065</span>,<span class="hljs-number">97479</span>,<span class="hljs-number">140417</span>,<span class="hljs-number">197514</span><br>        <span class="hljs-built_in">dd</span> <span class="hljs-number">345980</span>,<span class="hljs-number">590827</span>,<span class="hljs-number">803530</span>,<span class="hljs-number">1183000</span>,<span class="hljs-number">1843000</span>,<span class="hljs-number">2759000</span>,<span class="hljs-number">3753000</span>,<span class="hljs-number">4649000</span>,<span class="hljs-number">5937000</span><br>        <span class="hljs-comment">;以上是表示21年公司总收的21个dword型数据</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">28</span>,<span class="hljs-number">38</span>,<span class="hljs-number">130</span>,<span class="hljs-number">220</span>,<span class="hljs-number">476</span>,<span class="hljs-number">778</span>,<span class="hljs-number">1001</span>,<span class="hljs-number">1442</span>,<span class="hljs-number">2258</span>,<span class="hljs-number">2793</span>,<span class="hljs-number">4037</span>,<span class="hljs-number">5635</span>,<span class="hljs-number">8226</span><br>        <span class="hljs-built_in">dw</span> <span class="hljs-number">11542</span>,<span class="hljs-number">14430</span>,<span class="hljs-number">15257</span>,<span class="hljs-number">17800</span><br>        <span class="hljs-comment">;以上是表示21年公司雇员人数的21个word型数据</span><br>data ends<br><br><br>table <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">21</span> dup (<span class="hljs-string">&#x27;year summ ne ?? &#x27;</span>)<br>table ends<br><br><br>codesg <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,table<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>       <span class="hljs-comment">;初始化年份和收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>   <span class="hljs-comment">;初始化雇员数和人均收入的具体位置</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">21</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的低16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>] <span class="hljs-comment">;加54h是因为21*4=84=54h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>]           <span class="hljs-comment">;年份和收入的高16bit，占两个字节</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">2h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">si</span>+<span class="hljs-number">54h</span>]<br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>],<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>+<span class="hljs-number">0a8h</span>]      <span class="hljs-comment">;雇员数，占两个字节，加0a8h是因为84*2=168=a8h</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>],<span class="hljs-built_in">ax</span>          <br><span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">5h</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,[<span class="hljs-built_in">bx</span>+<span class="hljs-number">7h</span>]<br><span class="hljs-keyword">div</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0ah</span>]   <span class="hljs-comment">;除法算人均收入</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">0dh</span>],<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">16</span><br><span class="hljs-keyword">loop</span> s<br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>codesg ends<br><br><br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验9-根据材料编程">实验9 根据材料编程</h2><hr /><p>1.将你的姓名和学号在屏幕上中间显示出来。字符属性要求如下： 学号尾号为1，3，5，7，9 的为黑底绿色；学号尾号为 0，2，4，6，8 的为黑底红色。</p><ul><li><p>BL（闪烁） R G B（背景） I （高亮） R G B （前景）</p></li><li><p>80x25彩色字符模式显示缓冲区(以下简称为显示缓冲区)的结构:</p><ul><li>内存地址空间中，B8000H~BFFFFH 共32KB的空间，为80X25彩色字符模式的显示缓冲区。向这个地址空间写入数据，写入的内容将立即出现在显示器上。</li><li>在 80x25 彩色字符模式下，显示器可以显示 25行，每行80个字符，每个字符可以有256种属性(背景色、前景色、闪、高亮等合信息)。</li><li>这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。</li><li>80x25模式下，一屏的内容在显示缓冲区中共占4000个字节。</li><li>显示缓冲区分为 8页，每页4KB(4000B)，显示器可以显示任意一页的内容。一般情况下，显示第0页的内容。也就是说通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。</li></ul></li><li><p>在一页显示缓冲区中:</p><ul><li>偏移000~09F对应显示器上的第1行(80个字符占160个字节);</li><li>偏移0A0~13F对应显示器上的第2行;</li><li>偏移140~1DF对应显示器上的第3行;</li><li>依此类推，可知，偏移FOO~F9F 对应显示器上的第25 行。</li></ul></li><li><p>在一行中，<strong>一个字符占两个字节的存储空间(一个字)，低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节</strong>。即在一行中:</p><ul><li>00~01单元对应显示器上的第 1列:</li><li>02~03单元对应显示器上的第2列</li><li>04~05单元对应显示器上的第3 列</li><li>依此类推，可知，9E~9F 单元对应显示器上的第 80 列</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;ID: 2021100001, Name: Lu Shuaichao&#x27;</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>                <span class="hljs-comment">;es 控制打印到屏幕上</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">070eh</span>    <br><br><span class="hljs-comment">;bp 控制打印在屏幕上具体的位置。显示器中间的位置为第 12 行（一共25行嘛），对应的偏移为06e0h（11*160）。</span><br><span class="hljs-comment">;要打印的内容共 34 个字符，每个字符占两字节，每行占 160个字节，所以要从与行首位置偏移为 46（002eh）的位置写入，这个位置刚好为中间的位置。</span><br><span class="hljs-comment">;06e0h + 002eh 最终可得出应从偏移为 070eh 的位置开始写入。</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">00000100b</span>          <span class="hljs-comment">;dl 寄存器存放颜色属性</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">34</span>                <span class="hljs-comment">;一次打印循环次数</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s2:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bp</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">dl</span>          <span class="hljs-comment">;每次向显存中写入一个字符（两个字节）</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span>                   <span class="hljs-comment">;下一个字符</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bp</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">loop</span> s2<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s0:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br></code></pre></td></tr></table></figure><hr /><h2 id="实验10-编写子程序">实验10 编写子程序</h2><hr /><p>1.显示字符串</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-number">0</span><br>data ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>           <span class="hljs-comment">;指定行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>           <span class="hljs-comment">;指定列号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>   <span class="hljs-comment">;指定颜色</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> show_str<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">show_str:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;设置es为显示区段地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>       <span class="hljs-comment">;每行80个字符，一共占160个字节</span><br><span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span>             <span class="hljs-comment">;设置字符显示在哪行</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>          <span class="hljs-comment">;加两次是因为一个字符占两个字节，</span><br> <span class="hljs-comment">;比如屏幕上的一个字母a，它就占两个字节，一个字节是ascii码，一个字节是属性</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>          <span class="hljs-comment">;bx是显示区的偏移地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>         <span class="hljs-comment">;颜色属性存入al</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">a:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]     <span class="hljs-comment">;ds:[si]是当前指向的字符</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jcxz</span> ok           <span class="hljs-comment">;读到0就退出循环</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span>     <span class="hljs-comment">;第一个是字母</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;第二个是属性</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">jmp</span> short a<br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ok:</span> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br><span class="hljs-keyword">ret</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><p>2.数值显示（加上判断溢出后的代码没看懂）</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code,<span class="hljs-built_in">ds</span>:data,<span class="hljs-built_in">ss</span>:stack<br>data <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">db</span> <span class="hljs-number">10</span> dup(<span class="hljs-number">0</span>)<br>data ends<br> <br>stack <span class="hljs-meta">segment</span><br>    <span class="hljs-built_in">dw</span> <span class="hljs-number">16</span> dup(<span class="hljs-number">0</span>)    <span class="hljs-comment">;32字节</span><br>stack ends<br> <br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,data    <span class="hljs-comment">;设置ds段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,stack    <span class="hljs-comment">;设置栈顶</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">20H</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">12666</span>     <span class="hljs-comment">;要显示的数据</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span>         <span class="hljs-comment">;ds:si指向字符串首地址</span><br>    <span class="hljs-keyword">call</span> dtoc        <span class="hljs-comment">;将数据转为十进制字符</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">8</span>    <span class="hljs-comment">;在屏幕第几行开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">3</span>    <span class="hljs-comment">;在屏幕第几列开始显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">2</span>    <span class="hljs-comment">;显示的字符的颜色</span><br>    <span class="hljs-keyword">call</span> show_str<br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00H</span>    <span class="hljs-comment">;程序返回</span><br>    <span class="hljs-keyword">int</span> <span class="hljs-number">21H</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">dtoc:</span>    <span class="hljs-comment">;功能：将给定的word型数据转为十进制字符形式，存入data段，首地址ds:si</span><br>            <span class="hljs-comment">;参数：ax 指定的word数据 </span><br>            <span class="hljs-comment">;返回：ds:si指向data段字符串首地址</span><br>    <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;    ;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><span class="hljs-comment">;</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">000aH</span>    <span class="hljs-comment">;bl = 除数，bh = 一共除了几次</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;即将进行除法，dx是高16位，低16位在ax中</span><br><span class="hljs-symbol">pushyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">bl</span>    <span class="hljs-comment">;cx = 除数</span><br>    <span class="hljs-keyword">call</span> divdw    <span class="hljs-comment">;调用不会溢出的除法函数，结果的商的高16位，在dx中，</span><br>                    <span class="hljs-comment">;低16位在ax中，余数在cx中，余数一定&lt;10</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;cx=余数，这个余数在显示的时候要倒序显示，因此先压入栈</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-number">bh</span>         <span class="hljs-comment">;记录将余数压入栈的次数</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">ax</span>      <span class="hljs-comment">;cx = ax = 结果的商的低16位</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>      <span class="hljs-comment">;dx是结果的商的高16位，ax和dx一定都是非负数</span><br>    <span class="hljs-keyword">jcxz</span> popyushu        <span class="hljs-comment">;若cx=0，则说明除法计算已经完毕，跳转下一步执行</span><br>    <span class="hljs-keyword">jmp</span> short pushyushu<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">popyushu:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">bh</span>    <span class="hljs-comment">;ch=0，所以cx = 将余数压入栈的次数，也就是接下来的循环次数</span><br><span class="hljs-symbol">s1:</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><span class="hljs-comment">;            ;从栈中pop出一个余数</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">30H</span>         <span class="hljs-comment">;从数字转为对应的数字字符</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>],<span class="hljs-built_in">al</span>     <span class="hljs-comment">;用al就够了</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">loop</span> s1<br>    <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span>    <span class="hljs-comment">;子程序结束，将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><span class="hljs-comment">;    </span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><span class="hljs-comment">;</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><span class="hljs-comment">;</span><br>    <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">divdw:</span>      <span class="hljs-comment">;功能：计算word型被除数与byte型除数的除法</span><br>            <span class="hljs-comment">;参数：  ax=被除数低16位，dx=被除数高16位，cx = 除数</span><br>            <span class="hljs-comment">;返回：  ax=商的低16位，dx=商的高16位，cx = 余数</span><br> <br>    <span class="hljs-comment">;计算公式： X/N = int( H/N ) * 65536 + [rem( H/N) * 65536 + L]/N  </span><br>    <span class="hljs-comment">;其中X为被除数，N为除数，H为被除数的高16位，L为被除数的低16位，</span><br>    <span class="hljs-comment">;int()表示结果的商，rem()表示结果的余数。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>      <span class="hljs-comment">;bx是额外用到的寄存器，要压入栈</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx=L</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span>    <span class="hljs-comment">;ax=H</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>     <span class="hljs-comment">;dx=0</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算H/N，结果的商即int(H/N)保存在ax，余数即rem(H/N)保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要计算int(H/N)*65536，思考一下，65536就是0001 0000 H，</span><br>                    <span class="hljs-comment">;因此计算结果就是，高16位=int(H/N)，低16位为0000H。</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的高16位，即int(H/N)，压入栈</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span>         <span class="hljs-comment">;将int(H/N)*65536结果的低16位，即0000H，压入栈</span><br> <br>                    <span class="hljs-comment">;接下来要计算 rem(H/N)*65536 ，同理可得，</span><br>                    <span class="hljs-comment">;计算结果为 高16位=  rem(H/N)*65536 ，即此时dx的值，</span><br>                    <span class="hljs-comment">;低16位为 0000H。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">bx</span>     <span class="hljs-comment">;ax = bx = L ，即 [rem(H/N)*65536 + L]的低16位</span><br>    <span class="hljs-keyword">div</span> <span class="hljs-built_in">cx</span>        <span class="hljs-comment">;计算 [rem( H/N) * 65536 + L]/N ，结果的商保存在ax，余数保存在dx</span><br> <br>                    <span class="hljs-comment">;接下来要将两项求和。  左边项的高、低16位都在栈中，</span><br>                    <span class="hljs-comment">;其中高16位就是最终结果的高16位，低16位是0000H。</span><br>                    <span class="hljs-comment">;右边项的商为16位，在ax中，也就是最终结果的低16位，</span><br>                    <span class="hljs-comment">;余数在dx中，也就是最终结果的余数。</span><br> <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-built_in">dx</span>     <span class="hljs-comment">;cx = 最终结果的余数</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>        <span class="hljs-comment">;cx = int(H/N)*65536结果的低16位，即0000H。</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;bx = int(H/N)*65536结果的高16位，即最终结果的高16位</span><br> <br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span>    <span class="hljs-comment">;还原bx的值</span><br> <br>    <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">show_str:</span><br>                <span class="hljs-comment">;功能：将data段中首地址为ds:si的字符，以指定颜色显示在屏幕指定位置</span><br>                <span class="hljs-comment">;参数：dh 行号， dl 列号 ，cl 颜色</span><br>                <span class="hljs-comment">;返回：无</span><br> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">dx</span>        <span class="hljs-comment">;将子程序用到的寄存器压入栈</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0B800H</span>    <span class="hljs-comment">;设置es为显示区段地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">00A0H</span>    <span class="hljs-comment">;设置首字符显示的地址</span><br>    <span class="hljs-keyword">mul</span> <span class="hljs-number">dh</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span> <br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">dx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span>    <span class="hljs-comment">;bx是显示区的偏移地址</span><br>        <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span>    <span class="hljs-comment">;用al存储属性字节</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-number">ch</span>,<span class="hljs-number">0</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol">    s:</span>                <span class="hljs-comment">;循环读取字符并显示</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>    <span class="hljs-keyword">jcxz</span> ok            <span class="hljs-comment">;若读到0，就退出循环</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">jmp</span> short s<br><span class="hljs-symbol"> </span><br><span class="hljs-symbol">    ok:</span>        <span class="hljs-comment">;将寄存器的值pop出来</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">dx</span><br>    <br>    <span class="hljs-keyword">ret</span>    <span class="hljs-comment">;返回</span><br> <br> <br>code ends<br>end start<br> <br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验12-编写0号中断的处理程序">实验12 编写0号中断的处理程序</h2><hr /><p>1.编写 0 号中断的处理程序并将其安装在 0:200处，使得在除法溢出发生时，屏幕中间自动显示字符串“divideoverflow!”,然后返回到DOS。安装完中断处理程序后，编写针对该中断处理程序的测试程序，并运行测试程序，检查是否正确触发中断处理程序。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset do0                <span class="hljs-comment">;设置ds:si指向源地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>                      <span class="hljs-comment">;设置es:di指向目的地址</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset do0end-offset do0  <span class="hljs-comment">;cx为传输长度</span><br><span class="hljs-keyword">cld</span>                              <span class="hljs-comment">;传输方向为正</span><br><span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将do0的代码送入0:200处</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">0</span>],<span class="hljs-number">200h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">2</span>],<span class="hljs-number">0h</span>     <span class="hljs-comment">;设置中断向量</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   do0:</span><span class="hljs-keyword">jmp</span> short do0start       <span class="hljs-comment">;EB10 占两个字节，所以下面是202h，不是200h</span><br><span class="hljs-built_in">db</span> <span class="hljs-string">&quot;divide overflow!&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> do0start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>      <span class="hljs-comment">;设置ds:si指向字符串</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">12</span>*<span class="hljs-number">160</span>+<span class="hljs-number">33</span>*<span class="hljs-number">2</span>    <span class="hljs-comment">;设置es:di指向显存空间的中间位置</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">16</span>             <span class="hljs-comment">;cx为字符串长度</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">s:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-built_in">al</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">di</span>],<span class="hljs-number">2H</span>  <br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">di</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><span class="hljs-keyword">loop</span> s<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">do0end:</span><span class="hljs-keyword">nop</span><br><br>   <br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">1000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">1h</span><br><span class="hljs-keyword">div</span> <span class="hljs-number">bh</span><br><br><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><br>code ends<br>end start<br><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验13-编写0号中断的处理程序">实验13 编写0号中断的处理程序</h2><hr /><p>编写并安装 int 7ch 中断例程，功能为以“年/月/日时:分:秒”的格式，在屏幕中间显示当前的日期、时间。中断例程安装在 0:200处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset a           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset aend-offset a      <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                               <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                        <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>  <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">7ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   a:</span>   <span class="hljs-keyword">jmp</span> short astart<br>   <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;9/8/7 4:2:0&quot;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">astart:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">202h</span>     <span class="hljs-comment">;ds:si指向数据段</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">160</span>*<span class="hljs-number">12</span>+<span class="hljs-number">30</span>*<span class="hljs-number">2</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span>              <span class="hljs-comment">;es:di指向显示缓冲区</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">11</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   s:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">si</span>]<br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span><br>    <span class="hljs-keyword">jb</span> no      <br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">57</span><br>    <span class="hljs-keyword">ja</span> no  <span class="hljs-comment">;ASCII码值小于48或大于57则转移至no,即不是数字就直接显示</span><br><br>    <span class="hljs-keyword">call</span> yes          <span class="hljs-comment">;是数字就转移到yes处执行</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>    <span class="hljs-keyword">loop</span> s<br><br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>  <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   no:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-built_in">cl</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">jmp</span> <span class="hljs-built_in">far</span> <span class="hljs-built_in">ptr</span> s    <span class="hljs-comment">;段间转移至s处</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">   yes:</span> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">48</span> <span class="hljs-comment">;字符转换为整数</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">shr</span> <span class="hljs-number">ah</span>,<span class="hljs-built_in">cl</span><br>        <span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">00001111b</span><br><br>        <span class="hljs-keyword">add</span> <span class="hljs-number">ah</span>,<span class="hljs-number">30h</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">30h</span><br><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>],<span class="hljs-number">ah</span>     <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-built_in">di</span>+<span class="hljs-number">2</span>],<span class="hljs-built_in">al</span>     <br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">4</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">si</span><br><br>        <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">      aend:</span> <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br><br>测试程序：<br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">7ch</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>code ends<br>end start<br><br><span class="hljs-comment">;问题：刚开始没注意到 db 中，即数据段中的数字是 ascii 码。</span><br><span class="hljs-comment">;解决办法：sub cl,48 ;将字符转换为整数</span><br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验15-安装新的-int9-中断例程">实验15 安装新的 int9中断例程</h2><hr /><p>安装一个新的 int 9 中断例程，功能：在 DOS下，按下“A”键后，如果松开，则显示满屏幕的“A”（字符显示属性为蓝底高亮红色），其他键照常处理。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-comment">;(有点8懂)</span><br><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>stack <span class="hljs-meta">segment</span><br>  <span class="hljs-built_in">db</span> <span class="hljs-number">128</span> dup (<span class="hljs-number">0</span>)<br>stack ends<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,stack<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ss</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">sp</span>,<span class="hljs-number">128</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int9<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int9end-offset int9     <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                   <span class="hljs-comment">;设置传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">200h</span>]<br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>]<br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">202h</span>]             <span class="hljs-comment">;将原int 9中断例程的入口地址保存在0:200单元处</span><br><br>        <span class="hljs-keyword">cli</span>                            <span class="hljs-comment">;设置IF=0，不响应可屏蔽中断</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>],<span class="hljs-number">204h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">9</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>      <span class="hljs-comment">;将新的int 9中断例程安装在0:204处</span><br>        <span class="hljs-keyword">sti</span>                            <span class="hljs-comment">;设置IF=1，响应可屏蔽中断</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br><br>        <span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">60h</span>                     <span class="hljs-comment">;从端口60h读出键盘的输入</span><br><br>        <span class="hljs-keyword">pushf</span><br>        <span class="hljs-keyword">call</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">cs</span>:[<span class="hljs-number">200h</span>]      <span class="hljs-comment">;调用BIOS的int 9中断例程</span><br><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">9eh</span><br>        <span class="hljs-keyword">jne</span> int9ret<br>    <br>        <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-string">&#x27;A&#x27;</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">1ch</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">ah</span> <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>+<span class="hljs-number">1</span>],<span class="hljs-built_in">al</span><br>        <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>        <span class="hljs-keyword">loop</span> s<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9ret:</span><span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">iret</span>  <span class="hljs-comment">;前面没call就险先写iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int9end:</span><span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><hr /><h2 id="实验16-编写包含多个功能子程序的中断例程">实验16编写包含多个功能子程序的中断例程</h2><hr /><ul><li>安装一个新的 int 7ch 中断例程，为显示输出提供如下功能子程序。<ul><li>（1）清屏；</li><li>（2）设置前景色；</li><li>（3）设置背景色；</li><li>（4）向上滚动一行。</li></ul></li><li>入口参数说明如下：<ul><li>（1） 用 ah 寄存器传递功能号：0 表示清屏；1 表示设置前景色；2表示设置背景色；3 表示向上滚动一行；</li><li>（2） 对于 1、2 号功能，用 al 传递颜色值，(al)∈{0,1,2,3,4,5,6,7}。</li></ul></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-built_in">cs</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,offset int7c           <span class="hljs-comment">;设置ds:si指向源地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">200h</span>               <span class="hljs-comment">;设置es:di指向目的地址</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,offset int7cend-offset int7c            <span class="hljs-comment">;cx为传输长度</span><br>        <span class="hljs-keyword">cld</span>                                            <span class="hljs-comment">;传输方向为正</span><br>        <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span>                                      <span class="hljs-comment">;用movsb指令，将a的代码送入0:200处</span><br>    <br>        <span class="hljs-keyword">cli</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>],<span class="hljs-number">200h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-number">07ch</span>*<span class="hljs-number">4</span>+<span class="hljs-number">2</span>],<span class="hljs-number">0</span>    <span class="hljs-comment">;设置中断向量</span><br>        <span class="hljs-keyword">sti</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><span class="hljs-symbol">        </span><br><span class="hljs-symbol">int7c:</span>  <span class="hljs-keyword">jmp</span> short setscreen<br><br><span class="hljs-comment">; 这里要注意，在安装程序中的sub1是一串数据，在中断例程安装在0:200h中时 如果仍然按照第十六章那样设置，是无法成功调用子程序的，</span><br><span class="hljs-comment">; 因为主程序运行完毕以后,主程序所占的内存可能会被其他内容覆盖，所以我们要把子程序安装在中断例程之后的内存中</span><br><span class="hljs-comment">; 当然这样会存在一个问题，如果中断例程并没有安装在0:200处，则table中的值也要相应改动</span><br><span class="hljs-comment">; 至于为什么子程序中的sub1s,sub2s以及loop指令还能正常工作，是因为这是基于位移的跳转</span><br><span class="hljs-comment">; 即在主程序中，相应的loop/jmp指令已经编译为回退/前进xx字节的指令，因此不会受位置移动的影响</span><br><br>  table<span class="hljs-built_in">dw</span> sub1-int7c+<span class="hljs-number">200h</span>,sub2-int7c+<span class="hljs-number">200h</span>,sub3-int7c+<span class="hljs-number">200h</span>,sub4-int7c+<span class="hljs-number">200h</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"> setscreen:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>  <br>  <span class="hljs-keyword">cmp</span> <span class="hljs-number">ah</span>,<span class="hljs-number">3</span><span class="hljs-comment">; 判断功能号是否大于3</span><br>  <span class="hljs-keyword">ja</span> sret<br>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,<span class="hljs-number">ah</span><br>  <span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span><br>  <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">bx</span><span class="hljs-comment">; 根据ah提供的功能号找到对应子程序在table中的偏移</span><br>  <br>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cs</span><br>  <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>  <span class="hljs-keyword">call</span> <span class="hljs-built_in">word</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">bx</span>+<span class="hljs-number">200h</span>+<span class="hljs-number">2</span>]<span class="hljs-comment">; 调用</span><br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">  sret:</span>   <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>  <span class="hljs-keyword">iret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub1:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                 <span class="hljs-comment">;1号子程序,清屏</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub1s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub1s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub2:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>              <span class="hljs-comment">;2号子程序,设置前景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub2s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">11111000b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub2s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub3:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span>                <span class="hljs-comment">;3号子程序,设置背景色</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cl</span>,<span class="hljs-number">4</span><br>            <span class="hljs-keyword">shl</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">cl</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">2000</span><br><span class="hljs-symbol">    sub3s:</span>  <span class="hljs-keyword">and</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-number">10001111b</span><br>            <span class="hljs-keyword">or</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub3s<br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">bx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    sub4:</span>   <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span>            <span class="hljs-comment">;4号子程序,向上滚动一行</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">push</span> <span class="hljs-built_in">ds</span><br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0b800h</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">di</span>,<span class="hljs-number">0</span><br>            <span class="hljs-keyword">cld</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">24</span><br><span class="hljs-symbol">    sub4s:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">160</span><br>            <span class="hljs-keyword">rep</span> <span class="hljs-keyword">movsb</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">loop</span> sub4s<br><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">80</span><br>            <span class="hljs-keyword">mov</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">0</span><br><span class="hljs-symbol">    sub4s1:</span> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-number">160</span>*<span class="hljs-number">24</span>+<span class="hljs-built_in">si</span>],<span class="hljs-string">&#x27; &#x27;</span><br>            <span class="hljs-keyword">add</span> <span class="hljs-built_in">si</span>,<span class="hljs-number">2</span><br>            <span class="hljs-keyword">loop</span> sub4s1<br>            <br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ds</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">es</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">di</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span><br>            <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br>            <span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">int7cend:</span>  <span class="hljs-keyword">nop</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言知识点复习</title>
    <link href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/"/>
    <url>/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://freeimage.host/i/H4BEW1R"><imgsrc="https://iili.io/H4BEW1R.md.jpg" alt="H4BEW1R.md.jpg" /></a></p><h2 id="tips">tips</h2><ul><li><p><strong>使用debug××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。</strong></p></li><li><p>inc bx 等价于add bx,1</p></li><li><p>XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusiveor。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XORAX, AX 可以将 AX 寄存器中的值清零。</p></li><li><p>在汇编源程序中，数据不能以字母开头</p></li><li><p>遇到loop指令时，使用P命令来执行。Debug就会自动重复执行循环中的指令，直到(cx)=0为止</p></li><li><p>DOSBOX中，int 21 后面要用 p 指令来结束。</p></li><li><p>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p><ul><li><strong>“dw”</strong>的含义是定义字型数据。dw即“define word”。</li><li>在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节</li></ul></li><li><p>db 字节型，dd双字型</p></li><li><p>通过<strong>DS=0B2D</strong>，可以知道程序从<strong>0B3D:0000</strong>开始存放</p></li><li><p>NOT 实现按位取反，例如(AL)=00010010B，则 NOT AL使得（AL）=11101101B。XOR 为异或运算。</p></li><li><p><strong>var dd 252 dup(10)</strong></p><ul><li>var dd 252 dup(10) 是一种伪指令，用于在汇编语言中定义一个名为 var的变量，并初始化它为重复出现的值。</li><li>根据这个伪指令的语法，252 是要重复的次数，dup(10) 表示要重复的值为10。因此，该指令的作用是将值为 10 的双字型数据重复 252次，然后存储到名为 var 的变量中。</li></ul></li><li><p>VAR3 DB 'HOW ARE YOU?','$'，，，VAR3 = 13 字节 (12 + 1)</p></li><li><p>VAR2 DW 5DUP(?),0，，，，，VAR2 = 12 字节 (5 * 2 + 2)</p></li><li><p>段地址（SA）Segment Address 和 偏移地址（EA）EffectiveAddress</p></li><li><p>要用八位二进制表示 -9 的补码，可以按照以下步骤进行计算：</p><ul><li>将 -9 的<strong>绝对值</strong>转换为二进制。9 的二进制表示为00001001。</li><li>获取 9 的反码。即将二进制数的每一位取反，得到 11110110。</li><li>将反码加 1 得到补码。在这种情况下，11110110 + 1 = 11110111。</li><li>因此，-9 在八位二进制补码表示中为 11110111。十六进制为F7</li></ul></li><li><p>dec bx ;dec指令和inc指令的功能相反，dec bx 进行操作为：(bx) =(bx) - 1</p></li><li><p><strong>mul是乘法指令</strong>，使用 mul 做乘法的时候：</p><ul><li>相乘的两个数：要么都是8位，要么都是16位。<ul><li>8 位：一个默认放在 AL中 ，另一个放在8位寄存器或内存字节单元中；</li><li>16 位： 一个默认放在AX中，另一个放在16 位寄存器或内存字单元中。</li></ul></li><li>结果<ul><li>8位：AX中；</li><li>16位：DX（高位）和AX（低位）中。</li></ul></li><li>格式如下：<ul><li>mul reg</li><li>mul 内存单元</li></ul></li><li>比如：mul byte ptr ds:[0]<ul><li>含义为： (ax)=(al) * ((ds) * 16+0)</li></ul></li><li>mul word ptr [bx+si+8]<ul><li>含义为：</li><li>(ax)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的低16位；</li><li>(dx)=(ax) * ((ds) * 16+(bx)+(si)+8)结果的高16位；</li></ul></li></ul></li><li><p>小写字母的ASCII码范围61H-7AH</p></li><li><p>一般情况下：从<strong>0000:0200至0000:02FF</strong>的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用</p></li><li><p>(IP) = 5，说明 ss:sp = 5，</p></li></ul><h2 id="第1章-基础知识">第1章 基础知识</h2><hr /><h3 id="基础概念">基础概念</h3><ol type="1"><li><p>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</p></li><li><p>汇编语言的主体是汇编指令。</p></li><li><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。汇编指令是机器指令的助记符。</p></li><li><p>汇编语言由以下3类指令组成：</p><ol type="1"><li>汇编指令：机器码的助记符，有对应的机器码。</li><li>伪指令：由编译器执行，没有对应的机器码，计算机并不执行。</li><li>其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。</li></ol></li><li><p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p><ol type="1"><li>存储单元的地址（地址信息）；</li><li>器件的选择，读或写命令（控制信息）；</li><li>读或写的数据（数据信息）。</li></ol></li><li><p>CPU是通过<strong>地址总线</strong>来指定存储器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</p></li><li><p>CPU与内存或其它器件之间的数据传送是通过<strong>数据总线</strong>来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。</p></li><li><p>8088CPU数据总线宽度为8，<strong>8086CPU</strong>数据总线宽度为16。</p></li><li><p><strong>控制总线</strong>：有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p></li></ol><ul class="task-list"><li><label><input type="checkbox"checked="" />前面所讲的内存读或写命令是由几根控制线综合发出的：其中有一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出<strong>低电平</strong>表示将要读取数据；</label></li></ul><ol start="10" type="1"><li><p>b：bit，B：Byte</p></li><li><p>1B = 8b，1KB = 1024B，1MB = 1024KB，1GB = 1024MB</p></li><li><p>将各类存储器看作一个逻辑存储器：所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p></li><li><p>8086PC机的内存地址空间分配：<ahref="https://freeimage.host/cn"><img src="https://iili.io/H4BhK0b.png"alt="H4BhK0b.png" /></a></p></li><li><p>图 1.9 告诉我们，从地址 0 ~ 9FFFF的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000~ BFFFF的内存单元中写数据，就是向显存中写入数据,这些数据会被显示卡输出到显示器上；我们向地址CO00O ~ FFFFF的内存单元中写入数据的操作是<em>无效的</em>，因为这等于改写只读存储器中的内容。</p></li><li><p>内存地址空间：最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的<em>内存地址空间</em>。😭</p></li></ol><h2 id="第2章-寄存器">第2章 寄存器</h2><hr /><h3 id="基础概念-1">基础概念</h3><ol type="1"><li><p>8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。&gt;AX：accumulator register，累加器寄存器 &gt; &gt;BX： baseregister，基数寄存器 &gt; &gt;CX： count register，计数寄存器 &gt;&gt;DX：data register，通用数据寄存器 &gt; &gt;SI：sourceindex，源变址寄存器 &gt; &gt;DI：destination index，目的变址寄存器 &gt;&gt;SP：stack pointer，堆栈指针寄存器 &gt; &gt;BP：basepointer，基址指针寄存器，指示堆栈段中一个数据区的基址位置，通常与SS配对&gt; &gt;IP：instruction pointer，码段地址指针寄存器 &gt; &gt;CS：codesegment，代码段寄存器 &gt; &gt;SS：stacksegment，堆栈段~，存放当前堆栈段的段地址，一般和SP连用 &gt; &gt;DS：datasegment，数据段~，存放当前数据段的段地址 &gt; &gt;ES：extrasegment，附加段~ &gt; &gt;PSW：program state word，标志~</p></li><li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p></li><li><p>AX、BX、CX、DX通常用来存放一般性数据，被称为通用寄存器。</p></li><li><p>一个16位寄存器所能存储的数据的最大值为多少？<br />答案：2^16-1=65535。</p></li><li><p>汇编指令不区分大小写。</p></li><li><p>8086有20位地址总线，可传送20位地址，寻址能力为1M。</p></li><li><p>地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位。</p></li><li><p>“段地址×16+偏移地址=物理地址”的本质含义是： CPU在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p></li><li><p>有两点需要注意：段地址✖16 必然是 16的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16位地址的寻址能力为 64KB，所以<em>一个段的长度最大为 64KB</em>。</p></li><li><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p></li><li><p>8086PC工作过程的简要描述</p><ol type="1"><li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</li><li>IP = IP + 所读取指令的长度，从而指向下一条指令；</li><li>执行指令。 转到步骤 （1），重复这个过程。</li></ol></li><li><p><strong>mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。</strong></p></li></ol><h2 id="第3章-寄存器内存访问">第3章 寄存器（内存访问）</h2><hr /><h3 id="基础概念-2">基础概念</h3><ol type="1"><li>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）</li></ol><ul><li>mov ds,1000H 是非法的。</li><li>数据 → 一般的寄存器 → 段寄存器</li></ul><ol start="2" type="1"><li><p><strong>字在内存中存储时，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。</strong></p></li><li><p>合法格式：</p></li></ol><ul><li>mov 寄存器，寄存器/内存单元/段寄存器/立即数</li><li>mov 内存单元，寄存器/段寄存器/立即数</li><li>mov 段寄存器，寄存器/内存单元 ~注意：</li><li>mov指令中的目的操作数不能是立即数、IP和CS寄存器；</li><li>mov指令中不允许在两个存储单元之间直接传送数据；</li><li>mov指令中不允许在两个段寄存器之间直接传送数据；</li><li>mov指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）。</li></ul><ol start="4" type="1"><li>栈：</li></ol><ul><li><p>8086CPU提供了栈操作机制，方案如下：在SS，SP中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，他们根据SS:SP指示的地址，按照栈的方式访问内存单元。</p></li><li><p><strong>push指令的执行步骤</strong>：</p><ol type="1"><li>SP=SP-2；</li><li>向SS:SP指向的字单元中送入数据。</li></ol></li><li><p><strong>pop指令的执行步骤</strong>：</p><ol type="1"><li>从SS:SP指向的字单元中读取数据；</li><li>SP=SP+2。</li></ol></li><li><p>任意时刻，SS:SP指向栈顶元素。</p></li><li><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p></li><li><p>用栈来暂存以后需要恢复的寄存器的内容时 ，寄存器出栈的顺序要和入栈的顺序相反。</p></li><li><p>push、pop实质上是一种内存传送指令，注意它们的灵活应用。</p></li></ul><ol start="5" type="1"><li><p>一个栈段的容量最大为64KB。</p></li><li><p>如果我们将10000H~1FFFFH这段空间当作栈段，初始状态是空的，此时，SS=1000H，SP=？、、、答案：0，（SP原来为FFFEH，加2后SP=0，所以，当栈为空的时候，SS=1000H，SP=0。）</p></li><li><p><strong>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。</strong></p><ul><li>我们可以用一个段存放数据，将它定义为“数据段”</li><li>我们可以用一个段存放代码，将它定义为“代码段”</li><li>我们可以用一个段当作栈，将它定义为“栈段”</li></ul><p>我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：</p><ul><li>对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li><li>对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li><li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP中，这样CPU在需要进行栈操作的时候，比如执行 push、pop指令等，就将我们定义的栈段当作栈空间来用。</li><li>可见，不管我们如何安排 ，CPU 将内存中的某段内存当作代码，是因为CS:IP指向了那里；CPU将某段内存当作栈 ，是因为 SS:SP指向了那里。</li></ul></li></ol><h2 id="第4章-第一个程序">第4章 第一个程序</h2><hr /><h3 id="基础概念-3">基础概念</h3><ol type="1"><li><p>DOS系统中.EXE文件中的程序的加载过程： <ahref="https://freeimage.host/i/H6suidv"><imgsrc="https://iili.io/H6suidv.md.png"alt="H6suidv.md.png" /></a></p></li><li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0 ，则<strong>程序所在的内存区的地址为：ds:0</strong>；这个内存区的前256个字节中存放的是PSP，dos用来和程序进行通信。 从256字节处向后的空间存放的是程序。</p></li><li><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0。因为PSP占256（100H）字节，所以<strong>程序的物理地址</strong>是：<em>SA×16+0+256=SA×16+16×16=（SA+16）×16+0</em>可用段地址和偏移地址表示为：<strong>SA+10:0</strong>。</p><ul><li>如：DS=129E，则PSP的的地址为129E:0，程序的地址为12AE:0。</li></ul></li><li><p>一个源程序从写出到执行的过程：<strong>编写、编译、连接、执行</strong>（使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。）</p></li><li><p>说明<strong>伪指令和汇编指令的区别</strong>：汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，是由编译器来执行的。</p></li><li><p>说明汇编语言程序中<strong>标号的作用</strong>：汇编源程序中一个标号指代了一个地址，比如codesg在segment的前面，作一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p></li></ol><h2 id="第5章-bx和loop指令">第5章 [bx]和loop指令</h2><hr /><h3 id="基础概念-4">基础概念</h3><ol type="1"><li><p>描述性符号“()”，例如：对于push ax的功能，我们可以这样来描述：</p><ul><li>(sp) = (sp)-2</li><li>((ss) * 16＋(sp))=(ax)</li></ul></li><li><p>(2000:0)、((ds):1000H)等是错误的用法</p></li><li><p>(ax)、(ds)、(al)、(2000H)、((ds) *16+(bx))等是正确的用法</p></li><li><p>指令的格式是：loop 标号，CPU执行loop指令的时候，要进行两步操作：</p><ol type="1"><li>(cx)=(cx)-1；</li><li>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li></ol></li><li><p>ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间</p></li><li><p><strong>我们在Debug中写过类似的指令：<code>mov ax,[0]</code>表示将ds:0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>处理。</strong></p></li><li><p>为防止上述情况发生，在源程序中，可采用两种方法访问2000:0单元：</p></li></ol><ul><li><p>方法一： <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br></code></pre></td></tr></table></figure></p></li><li><p>方法二： <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]                 一般用第二种方法<br></code></pre></td></tr></table></figure></p></li></ul><ol start="8" type="1"><li><p>DOS方式下，一般情况， 0:200 ~ 0:2FF空间中没有系统或其他程序的数据或代码；以后，我们需要直接向一段内存中写入内容时，就使用0:200~ 0:2FF这段空间。</p></li><li><p>利用栈对CX寄存器内容进行保护push和恢复pop可以实现多重loop循环。如：</p></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, m<br><span class="hljs-symbol">s1:</span>          <span class="hljs-comment">;循环体1</span><br> <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,n<br><span class="hljs-symbol">s2:</span>          <span class="hljs-comment">;循环体2</span><br> <span class="hljs-keyword">loop</span> s2<br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">loop</span> s1<br></code></pre></td></tr></table></figure><h3 id="程序">程序</h3><ol type="1"><li>将内存ffff:0~ffff:b段单元中的数据拷贝到 0:200~0:20b单元中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offffh<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;al作为中转寄存器</span><br><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">loop</span> s<br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编写程序片断，利用 loop 指令，实现斐波那契数列前 9 个数字1、1、2、3、5、8、13、21、34 的求和，并将求和结果保存到内存字单元 0:200中</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;ax中的值依次为1、1、2、3、5、8、13、21、34      </span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;来存最后的计算结果</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">9</span>    <span class="hljs-comment">;循环次数</span><br><span class="hljs-symbol"> s:</span><span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">ax</span><br><br> <span class="hljs-keyword">loop</span> s<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">200h</span>],<span class="hljs-built_in">dx</span><br> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br> <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure><h2 id="第6章-包含多个段的程序">第6章 包含多个段的程序</h2><hr /><h3 id="基础概念-5">基础概念</h3><ol type="1"><li><p>我们在源程序中用伪指令 “assumecs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连。这样做了之后，CPU是否就会将cs指向ode，ds 指向 data，ss指向stack，从而按照我们的意图来处理这些段呢？</p></li><li><p>当然也不是，要知道 assume是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。我们不必深究assume的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。</p></li><li><p>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。</p></li><li><p>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p></li></ol><h2 id="第7章-更灵活的定位内存地址的的方法">第7章更灵活的定位内存地址的的方法</h2><hr /><h3 id="基础概念-6">基础概念</h3><ol type="1"><li><p>（1）and 指令：逻辑与指令，按位进行与运算。（2）or指令：逻辑或指令，按位进行或运算。</p></li><li><p>在ASCII编码方案中，用61H 表示“a”，62H表示“b”。用41H表示“A”，42H表示“B”。</p></li><li><p>就ASCII码的二进制形式来看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。大写字母ASCII码的第5位（位数从0开始计算）为0，小写字母的第5位为1。</p></li><li><p>or al,00100000b;将al中的ASCII码的第5位置为1，变为小写字母</p></li><li><p>and al,11011111b ;将al中的ASCII码的第5位置为0，变为大写字母</p><ul><li><strong>and byte ptr[si],11011111b</strong>，等到了后面就是这样了</li></ul></li><li><p>指令<strong>movax,[bx+200]也可以写成如下格式（常用）</strong>：</p><ul><li>mov ax,[200+bx]</li><li><strong>mov ax,200[bx]</strong></li><li>mov ax,[bx].200</li></ul></li><li><p>SI(source index register)和DI(destination indexregister)是8086CPU中和bx功能相近的寄存器，<strong>SI和DI不能够分成两个8位寄存器来使用</strong>。</p></li><li><p>指令mov ax,[bx+si]的数学化的描述为：(ax)=( (ds) * 16+(bx)+(si))。 该指令也可以写成如下格式（常用）：mov ax,[bx][si]</p></li><li><p>指令mov ax,[bx+si+200]，该指令也可以写成如下格式（常用）：</p><ul><li>mov ax,[bx+200+si]</li><li>mov ax,[200+bx+si]</li><li>mov ax,200[bx][si]</li><li>mov ax,[bx].200[si]</li><li>mov ax,[bx][si].200</li></ul></li></ol><h2 id="第8章-数据处理的两个基本问题">第8章 数据处理的两个基本问题</h2><hr /><h3 id="基础概念-7">基础概念</h3><ol type="1"><li><p>我们将使用reg来表示一个寄存器，用sreg表示一个段寄存器。reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；sreg的集合包括：ds、ss、cs、es。</p></li><li><p>在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]”中来进行内存单元的寻址。</p></li><li><p>在“[…]”中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p></li><li><p><strong>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</strong>。</p></li><li><p>mov ax,1 对应机器码：B80100；mov ax,076a的机器码？B86A07</p></li><li><p>在没有寄存器名存在的情况下，用操作符<strong>Xptr</strong>指明内存单元的长度，X在汇编指令中可以为word或byte。</p></li><li><p>push指令只进行字操作</p></li><li><p>div是除法指令，使用div作除法的时候：</p><ul><li>除数：8位或16位，在寄存器或内存单元中</li><li>被除数：（默认）放在AX 或 DX（高16位）和AX（低16位）中</li><li>结果：如果除数为8位，商：AL，余数：AH；<strong>如果除数为16位，商：AX，余数：DX</strong>；</li></ul></li><li><p>div指令格式： div reg div 内存单元</p></li><li><p>div byte ptr ds:[0]</p><ul><li>含义为：(al)=(ax)/((ds) * 16+0)的商；</li><li>(ah)=(ax)/((ds) * 16+0)的余数</li></ul></li><li><p>div word ptr [bx+si+8]</p><ul><li>含义为：(ax)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的商；</li><li>(dx)=[(dx) * 10000H+(ax)]/((ds) * 16+(bx)+(si)+8)的余数</li></ul></li><li><p>dd 1，数据为00000001H，占2个字；</p></li><li><p><strong>dup</strong>是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。 它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。</p><ul><li>db 3 dup (0) 定义了3个字节，它们的值都是0，相当于 db 0,0,0</li><li>db 3 dup(0,1,2)定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于 db0,1,2,0,1,2,0,1,2</li><li>db 3 dup(‘abc’,’ABC’)定义了18个字节，它们是‘abcABCabcABCabcABC’，相当于db‘abcABCabcABCabcABC’</li></ul></li></ol><h2 id="第9章-转移指令的原理">第9章 转移指令的原理</h2><hr /><h3 id="基础概念-8">基础概念</h3><ol type="1"><li><p>jmp指令要给出两种信息： 转移的目的地址，转移的距离（段间转移jmp far、段内短转移jmp short，段内近转移jmpnear）</p></li><li><p><strong>jmp short 标号</strong>（转到标号处执行指令）这种格式的jmp 指令实现的是<strong>段内短转移，它对IP的修改范围为-128~127</strong>，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p></li><li><p>在“jmp short标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。这个位移，是编译器根据汇编指令中的“标号”计算出来的。</p></li><li><p>实际上，指令“jmp short 标号”的功能为(IP)=(IP)+8位位移。</p><ul><li><strong>8位位移=“标号”处的地址-jmp指令后的第一个字节的地址</strong>；</li><li>short指明此处的位移为8位位移；</li><li>8位位移的范围为-128~127，用补码表示。</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li><p><strong>jmp near ptr</strong>标号它实现的时<strong>段内近转移</strong>。<strong>IP修改范围为：-32768~32767</strong>。</p></li><li><p>指令 <strong>jmp far ptr</strong> 标号实现的是<strong>段间转移，又称为远转移</strong>。farptr指明了指令用标号的段地址和偏移地址修改CS和IP。IP修改范围：随意。</p></li><li><p>jmp far ptr s所对应的机器码：EA 0B 01 BD 0B，其中包含转移的目的地址</p></li><li><p>转移地址在内存中的jmp指令有两种格式：</p><ul><li>jmp word ptr 内存单元地址（段内转移）<ul><li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li></ul></li><li>jmp dword ptr 内存单元地址（段间转移）<ul><li>功能：从内存单元地址处开始存放着两个字，<strong>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</strong>。</li><li>(CS)=(内存单元地址+2)</li><li>(IP)=(内存单元地址)</li><li>内存单元地址可用寻址方式的任一格式给出。</li></ul></li></ul></li><li><p>jcxz指令（jump if cx equalszero）为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。<strong>指令格式：jcxz标号 （如果(cx)=0，则转移到标号处执行。）</strong></p></li><li><p>jcxz 标号 指令操作：</p><ul><li>当(cx)=0时，(IP)=(IP)+8位位移）<ul><li><strong>8位位移=“标号”处的地址-jcxz指令后的第一个字节的地址；</strong></li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位位移由编译程序在编译时算出。</li></ul></li><li>当(cx)不为0时，什么也不做（程序向下执行）。</li></ul></li><li><p>loop指令为循环指令，<strong>所有的循环指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。指令格式：loop标号</p></li></ol><h2 id="第10章-call和ret指令">第10章 CALL和RET指令</h2><hr /><h3 id="基础概念-9">基础概念</h3><ol type="1"><li><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p><ul><li>CPU执行ret指令时，相当于进行：pop IP</li></ul></li><li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p><ul><li>CPU执行retf指令时，相当于进行：<ul><li>pop IP（<strong>注意！这是违法的，只是效果</strong>）</li><li>pop CS</li></ul></li></ul></li><li><p>CPU执行call指令，进行两步操作：</p><ul><li>将当前的 IP 或 CS 和 IP 压入栈中；</li><li>转移。</li></ul></li><li><p>CPU 执行指令“call 标号”时，相当于进行：</p><ul><li>push IP</li><li>jmp near ptr 标号</li></ul></li><li><p>call s在指令缓冲器时，IP已经改变了，指向了下一条指令，suoooooo以，<strong>call指令指向时将下一条指令的IP入栈</strong>。</p></li><li><p>CPU 执行指令 “call far ptr 标号”时，相当于进行：</p><ul><li>push CS</li><li>push IP</li><li>jmp far ptr 标号</li></ul></li><li><p>CPU执行call 16位reg时，相当于进行：</p><ul><li>push IP</li><li>jmp 16位寄存器</li></ul></li><li><p>call word ptr 内存单元地址， 汇编语法解释：</p><ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li><li><p>call dword ptr 内存单元地址， 汇编语法解释：</p><ul><li>push CS</li><li>push IP</li><li>jmp dword ptr 内存单元地址</li></ul></li></ol><h2 id="第11章-标志寄存器">第11章 标志寄存器</h2><hr /><h3 id="基础概念-10">基础概念</h3><ol type="1"><li><p>flag的第6位是<strong>ZF（zeroflag），零标志位</strong>。它记录相关指令执行后，其结果是否为0</p><ul><li>结果为0 ，ZF = 1</li><li>结果不为0，ZF = 0</li></ul></li><li><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：<strong>add、sub、mul、div、inc、or、and</strong>等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p></li><li><p>flag的第2位是<strong>PF，奇偶标志位</strong>。它记录指令执行后，结果的所有<strong>二进制位（低8位）中</strong>1的个数：</p><ul><li>为偶数，PF = 1；</li><li>为奇数，PF = 0。</li></ul></li><li><p>flag的第7位是<strong>SF，符号标志位</strong>。它记录指令执行后，其结果是否为负</p><ul><li>结果为负，SF = 1；</li><li>结果为正，SF = 0。</li><li>与有符号数的符号位规定一致</li><li>SF 标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。</li><li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li><li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li></ul></li><li><p>比如指令subal,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。</p></li><li><p>flag的第0位是<strong>CF，进位标志位。</strong></p><ul><li>一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</li><li>比如：<ul><li>mov al,98H</li><li>add al,al ;</li><li>执行后： (al)=30H，CF=1，CF记录了最高有效位向更高位的进位值</li></ul></li></ul></li><li><p>flag的第11位是<strong>OF，溢出标志位。</strong></p><ul><li>一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</li><li>如果发生溢出，OF=1，</li><li>如果没有，OF=0。</li><li><strong>CF是对无符号数运算有意义的标志位；而OF是对有符号数运算有意义的标志位。</strong></li></ul></li><li><p>对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU用 OF 位来记录是否产生了溢出。当然，还要用SF位来记录结果的符号。</p><ul><li>对于无符号数运算，98+99没有进位，CF=0；</li><li>对于有符号数运算，98+99发生溢出，OF=1。</li></ul></li><li><p><strong>adc是带进位加法指令，它利用了CF位上记录的进位值。</strong></p><ul><li>格式： adc 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1+操作对象2+CF</li><li>比如：adc ax,bx 实现的功能是：(ax)=(ax)+(bx)+CF</li></ul></li><li><p>下面的指令和add ax , bx具有相同的结果：add al,bl ，adcah,bh，看来CPU提供 adc指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p></li><li><p><strong>sbb是带借位减法指令，它利用了CF位上记录的借位值。</strong></p><ul><li>格式：sbb 操作对象1,操作对象2</li><li>功能：操作对象1=操作对象1–操作对象2–CF</li><li>比如：sbb ax,bx,实现功能： (ax) = (ax) – (bx) – CF</li></ul></li><li><p><strong>cmp指令</strong></p><ul><li>格式：cmp 操作对象1,操作对象2</li><li>功能：计算操作对象1–操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</li></ul></li><li><p>比如：cmpax,ax做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：</p><ul><li>ZF=1，</li><li>PF=1，0是偶数</li><li>SF=0，</li><li>CF=0，</li><li>OF=0。</li><li>根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</li></ul></li><li><p>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</p></li><li><p>虽然 je的逻辑含义是“相等则转移”，但它进行的操作是，ZF=1时则转移。“相等则转移”这种逻辑含义，是通过和cmp 指令配合使用来体现的，因为是cmp指令为“ZF=1”赋予了“两数相等”的含义。虽然我们分别讨论了cmp指令和与其比较结果相关的有条件转移指令，但是它们经常在一起配合使用。所以我们在联合应用它们的时候，不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测。我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。<strong>意思就是说je可以直接用，je就是等于则转移</strong></p></li><li><p><strong>jb 含义是低于则转移，ja含义是高于则转移。</strong></p></li><li><p><strong>jna 含义是不高于则转移，即小于等于则转移；jnb含义是不低于则转移，即大于等于则转移。</strong></p></li></ol><p><a href="https://freeimage.host/i/HPSgh7e"><imgsrc="https://iili.io/HPSgh7e.md.png" alt="HPSgh7e.md.png" /></a></p><ol start="18" type="1"><li><p>flag的第10位是<strong>DF，方向标志位。</strong></p><ul><li>在串处理指令中，控制每次操作后si，di的增减。</li><li>DF = 0：每次操作后si，di递增；</li><li>DF = 1：每次操作后si，di递减。</li></ul></li><li><p>串传送指令：<code>movsb</code>我们可以用汇编语法描述movsb的功能如下：</p><ul><li>mov es:[di],byte ptr ds:[si];8086并不支持这样的指令，这里只是个描述。</li><li>如果DF=0：inc si，inc di</li><li>如果DF=1：dec si，dec di</li><li><strong>就是ds:si 传到 es:di</strong></li></ul></li><li><p>rep movsb 用汇编语法来描述rep movsb的功能就是：<code>s : movsb</code> <code>loop s</code></p></li><li><p><strong>cld指令：将标志寄存器的DF位置0，std指令：将标志寄存器的DF位置1</strong></p></li><li><p>pushf ：将标志寄存器的值压栈；</p></li><li><p>popf ：从栈中弹出数据，送入标志寄存器中。</p></li><li><p>pushf和popf，为直接访问标志寄存 器提供了一种方法。</p></li></ol><h3 id="程序-1">程序</h3><ol type="1"><li>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">001EH</span> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0F000H</span> <br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <br> <span class="hljs-keyword">adc</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span> <br> <span class="hljs-keyword">adc</span> 指令执行后，也可能产生进位值，所以也会对CF位进行设置<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>计算003E1000H–00202000H，结果放在ax，bx中。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序如下：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">003EH</span><br> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span><br> <span class="hljs-keyword">sbb</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br></code></pre></td></tr></table></figure><h2 id="第12章-内中断">第12章 内中断</h2><hr /><h3 id="基础概念-11">基础概念</h3><ol type="1"><li>我们更简洁的描述中断过程，如下：<ul><li>（1）取得中断类型码N；</li><li>（2） pushf</li><li>（3） TF = 0，IF = 0</li><li>（4） push CS</li><li>（5） push IP</li><li>（6）(IP) = (N * 4)，(CS) = (N * 4+2)</li><li>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</li></ul></li><li>iret指令的功能用汇编语法描述为：<ol type="1"><li>pop IP</li><li>pop CS</li><li>popf</li></ol></li><li>CPU当然不能让这种情况发生，解决的办法就是，<strong>在进入中断处理程序之前，设置TF=0</strong>。从而<strong>避免CPU在执行中断处理程序的时候发生单步中断</strong>。这就是为什么在中断过程中有 TF=0这个步骤。</li></ol><h2 id="第13章-int指令">第13章 int指令</h2><hr /><h3 id="程序-2">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程：在屏幕的5行12列显示字符串“welcome to masm!”。</span><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span> <br><span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>data ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> <span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;置光标</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;第0页</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">5</span> <span class="hljs-comment">;dh中放行号</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">12</span> <span class="hljs-comment">;dl中放列号</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;ds:dx指向字符串的首地址data:0</span><br><span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">9</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br><span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br>code ends<br>end start<br></code></pre></td></tr></table></figure><h2 id="第14章-端口">第14章 端口</h2><hr /><h3 id="基本概念">基本概念</h3><ol type="1"><li><p><strong>in al,60h;从60h号端口读入一个字节</strong></p><ul><li>执行时与总线相关的操作：</li><li>① CPU通过地址线将地址信息60h发出；</li><li>②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</li><li>③ 端口所在的芯片将60h端口中的数据通过数据线送入CPU。</li></ul></li><li><p>注意：在in和out 指令中，只能使用 ax 或al来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al，访问16 位端口时用ax 。</p></li><li><p>对0～255以内的端口进行读写：</p><ul><li><strong>in al,20h ;从20h端口读入一个字节</strong></li><li><strong>out 20h,al ;往20h端口写入一个字节</strong></li></ul></li><li><p>对256～65535的端口进行读写时，端口号放在dx中：</p><ul><li>mov dx,3f8h ;将端口号3f8送入dx</li><li>in al,dx ;从3f8h端口读入一个字节</li><li>out dx,al ;向3f8h端口写入一个字节</li></ul></li><li><p><strong>70h为地址端口</strong>，存放要访问的CMOSRAM单元的地址；<strong>71h为数据端口</strong>，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。</p></li><li><p>shl逻辑左移指令，功能为：</p><ul><li>将一个寄存器或内存单元中的数据向左移位；</li><li>将最后移出的一位写入CF中；</li><li>最低位用0补充。</li></ul></li><li><p>如果移动位数大于1时，必须将移动位数放在<strong>cl</strong>中。</p></li><li><p>shr逻辑右移指令</p></li></ol><h3 id="程序-3">程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程，读CMOS RAM的2号单元的内容</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span>          <span class="hljs-comment">;从 71h 读出 2 号单元的内容</span><br><br><span class="hljs-comment">;编程，向CMOS RAM的2号单元写入0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">71h</span>,<span class="hljs-built_in">al</span>       <span class="hljs-comment">;向 2 号单元写入 0</span><br> <br><br></code></pre></td></tr></table></figure><h2 id="第15章-外中断">第15章 外中断</h2><hr /><h3 id="基本概念-1">基本概念</h3><ol type="1"><li><p>外设的输入不直接送入内存和CPU ，而是送入相关的接口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</p></li><li><p>可屏蔽中断是CPU 可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</p><ul><li>当CPU 检测到可屏蔽中断信息时：</li><li>如果IF=1，则CPU 在执行完当前指令后响应中断，引发中断过程；</li><li>如果IF=0，则不响应可屏蔽中断。</li></ul></li><li><p>内中断所引发的中断过程：</p><ul><li>（1）取中断类型码n；</li><li>（2）标志寄存器入栈，IF=0，TF=0；</li><li>（3）CS 、IP 入栈；</li><li>（4）(IP)=(n* 4)，(CS)=(n* 4+2)，</li><li>由此转去执行中断处理程序。</li></ul></li><li><p>将IF置0的原因就是，<strong>在进入中断处理程序后，禁止其他的可屏蔽中断。</strong></p></li><li><p> 不可屏蔽中断是CPU <strong>必须响应</strong>的外中断。当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。对于8086CPU不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</p></li><li><p>不可屏蔽中断的中断过程：</p><ul><li>1、标志寄存器入栈，IF=0，TF=0；</li><li>2、CS、IP入栈；</li><li>3、(IP)=(8)，(CS)=(0AH)。</li></ul></li><li><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p></li><li><p> 扫描码长度为一个字节，通码的第7 位为 0，断码的第7位为1，即：断码=通码＋80H</p></li></ol><h2 id="第16章-直接定址表">第16章 直接定址表</h2><hr /><h3 id="基本概念-2">基本概念</h3><ol type="1"><li>对于程序中的a db 1,2,3,4,5,6,7,8 ：<ul><li>指令：mov al,a [si]，，相当于：mov al,cs:0[si]，</li><li>指令：mov al,a[3]，，相当于：mov al,cs:0[3]</li><li>指令：mov al,a[bx+si+3] ，，相当于：mov al,cs:0[bx+si+3]</li></ul></li><li>以后，我们将这种标号称为数据标号。它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。</li></ol><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><hr /><ul><li>\(E=mc^2\)</li><li>(ax^2 + bx + c = 0)</li><li>$ C_n^2$</li></ul>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
