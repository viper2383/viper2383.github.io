

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/1.jpg">
  <link rel="icon" href="/img/1.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="wuuuu">
  <meta name="keywords" content="">
  
    <meta name="description" content="tips 使用debug ××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。  inc bx 等价于add bx,1  XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusive or。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XOR AX, AX 可以将 AX 寄存器中的值清零。  在汇编源程序中，数据不能以字母开头">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言知识点复习">
<meta property="og:url" content="http://example.com/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Viper3">
<meta property="og:description" content="tips 使用debug ××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。  inc bx 等价于add bx,1  XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusive or。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XOR AX, AX 可以将 AX 寄存器中的值清零。  在汇编源程序中，数据不能以字母开头">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://iili.io/H4BEW1R.md.jpg">
<meta property="og:image" content="https://iili.io/H4BhK0b.png">
<meta property="og:image" content="https://iili.io/H6suidv.md.png">
<meta property="og:image" content="https://iili.io/HPSgh7e.md.png">
<meta property="article:published_time" content="2023-05-27T14:20:49.000Z">
<meta property="article:modified_time" content="2023-08-05T03:04:24.026Z">
<meta property="article:author" content="wuuuu">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://iili.io/H4BEW1R.md.jpg">
  
  
  
  <title>汇编语言知识点复习 - Viper3</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.5","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Viper3</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="汇编语言知识点复习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-27 22:20" pubdate>
          2023年5月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          15k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          94 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">汇编语言知识点复习</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://freeimage.host/i/H4BEW1R"><img src="https://iili.io/H4BEW1R.md.jpg" srcset="/img/loading.gif" lazyload alt="H4BEW1R.md.jpg"></a></p>
<h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><ul>
<li><p><strong>使用debug ××.exe调试时，首次进入调试界面时，寄存器CX中存放的是可执行文件长度。</strong></p>
</li>
<li><p>inc bx 等价于add bx,1</p>
</li>
<li><p>XOR操作是一种逻辑运算符，用于执行异或操作，英文全称是 exclusive or。XOR 操作的结果是两个二进制位相同则结果为 0，否则结果为 1。例如 XOR AX, AX 可以将 AX 寄存器中的值清零。</p>
</li>
<li><p>在汇编源程序中，数据不能以字母开头</p>
</li>
<li><p>遇到loop指令时，使用P命令来执行。Debug就会自动重复执行循环中的指令，直到(cx)&#x3D;0为止</p>
</li>
<li><p>DOSBOX中，int 21 后面要用 p 指令来结束。</p>
</li>
<li><p>dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</p>
<ul>
<li><strong>“dw”</strong>的含义是定义字型数据。dw即“define word”。</li>
<li>在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节</li>
</ul>
</li>
<li><p>db 字节型，dd双字型</p>
</li>
<li><p>通过<strong>DS&#x3D;0B2D</strong>，可以知道程序从<strong>0B3D:0000</strong>开始存放</p>
</li>
<li><p>NOT 实现按位取反，例如(AL)&#x3D;00010010B，则 NOT AL 使得（AL）&#x3D;11101101B。XOR 为异或运算。</p>
</li>
<li><p><strong>var dd 252 dup(10)</strong></p>
<ul>
<li>var dd 252 dup(10) 是一种伪指令，用于在汇编语言中定义一个名为 var 的变量，并初始化它为重复出现的值。</li>
<li>根据这个伪指令的语法，252 是要重复的次数，dup(10) 表示要重复的值为 10。因此，该指令的作用是将值为 10 的双字型数据重复 252 次，然后存储到名为 var 的变量中。</li>
</ul>
</li>
<li><p>VAR3 DB ‘HOW ARE YOU?’,’$’，，，VAR3 &#x3D; 13 字节 (12 + 1)</p>
</li>
<li><p>VAR2 DW 5DUP(?),0，，，，，VAR2 &#x3D; 12 字节 (5 * 2 + 2)</p>
</li>
<li><p>段地址（SA）Segment Address 和 偏移地址（EA）Effective Address</p>
</li>
<li><p>要用八位二进制表示 -9 的补码，可以按照以下步骤进行计算：</p>
<ul>
<li>将 -9 的<strong>绝对值</strong>转换为二进制。9 的二进制表示为 00001001。</li>
<li>获取 9 的反码。即将二进制数的每一位取反，得到 11110110。</li>
<li>将反码加 1 得到补码。在这种情况下，11110110 + 1 &#x3D; 11110111。</li>
<li>因此，-9 在八位二进制补码表示中为 11110111。十六进制为F7</li>
</ul>
</li>
<li><p>dec bx      ;dec指令和inc指令的功能相反，dec bx 进行操作为：(bx) &#x3D; (bx) - 1</p>
</li>
<li><p><strong>mul是乘法指令</strong>，使用 mul 做乘法的时候：</p>
<ul>
<li>相乘的两个数：要么都是8位，要么都是16位。<ul>
<li>8 位：一个默认放在 AL中 ，另一个放在 8位寄存器或内存字节单元中；</li>
<li>16 位： 一个默认放在AX中，另一个放在16 位寄存器或内存字单元中。</li>
</ul>
</li>
<li>结果<ul>
<li>8位：AX中；</li>
<li>16位：DX（高位）和AX（低位）中。</li>
</ul>
</li>
<li>格式如下：<ul>
<li>mul reg</li>
<li>mul 内存单元</li>
</ul>
</li>
<li>比如：mul byte ptr ds:[0]<ul>
<li>含义为： (ax)&#x3D;(al) * ((ds) * 16+0)</li>
</ul>
</li>
<li>mul word ptr [bx+si+8]<ul>
<li>含义为： </li>
<li>(ax)&#x3D;(ax) * ((ds) * 16+(bx)+(si)+8)结果的低16位；</li>
<li>(dx)&#x3D;(ax) * ((ds) * 16+(bx)+(si)+8)结果的高16位；</li>
</ul>
</li>
</ul>
</li>
<li><p>小写字母的ASCII码范围61H-7AH </p>
</li>
<li><p>一般情况下： 从<strong>0000:0200至0000:02FF</strong>的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用</p>
</li>
<li><p>(IP) &#x3D; 5，说明 ss:sp &#x3D; 5，</p>
</li>
</ul>
<h2 id="第1章-基础知识"><a href="#第1章-基础知识" class="headerlink" title="第1章 基础知识"></a>第1章 基础知识</h2><hr>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>每一种微处理器，由于硬件设计和内部结构的不同，就需要用不同的电平脉冲来控制，使它工作。所以每一种微处理器都有自己的机器指令集，也就是机器语言。</p>
</li>
<li><p>汇编语言的主体是汇编指令。</p>
</li>
<li><p>汇编指令和机器指令的差别在于指令的表示方法上，汇编指令是机器指令便于记忆的书写格式。汇编指令是机器指令的助记符。</p>
</li>
<li><p>汇编语言由以下3类指令组成：</p>
<ol>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：由编译器执行，没有对应的机器码，计算机并不执行。</li>
<li>其他符号：如+、-、*、&#x2F;等，由编译器识别，没有对应的机器码。</li>
</ol>
</li>
<li><p>CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p>
<ol>
<li>存储单元的地址（地址信息）；</li>
<li>器件的选择，读或写命令（控制信息）；</li>
<li>读或写的数据（数据信息）。</li>
</ol>
</li>
<li><p>CPU是通过<strong>地址总线</strong>来指定存储器单元的。地址总线上能传送多少个不同的信息，CPU就可以对多少个存储单元进行寻址。</p>
</li>
<li><p>CPU与内存或其它器件之间的数据传送是通过<strong>数据总线</strong>来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。</p>
</li>
<li><p>8088CPU数据总线宽度为8，<strong>8086CPU</strong>数据总线宽度为16。</p>
</li>
<li><p><strong>控制总线</strong>：有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制。所以，控制总线的宽度决定了CPU对外部器件的控制能力。</p>
</li>
</ol>
<ul>
<li><input checked="" disabled="" type="checkbox"> 前面所讲的内存读或写命令是由几根控制线综合发出的：其中有一根名为读信号输出控制线负责由CPU 向外传送读信号，CPU 向该控制线上输出<strong>低电平</strong>表示将要读取数据；</li>
</ul>
<ol start="10">
<li><p>b：bit，B：Byte </p>
</li>
<li><p>1B &#x3D; 8b，1KB &#x3D; 1024B，1MB &#x3D; 1024KB，1GB &#x3D; 1024MB </p>
</li>
<li><p>将各类存储器看作一个逻辑存储器： 所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间； CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</p>
</li>
<li><p>8086PC机的内存地址空间分配：<a target="_blank" rel="noopener" href="https://freeimage.host/cn"><img src="https://iili.io/H4BhK0b.png" srcset="/img/loading.gif" lazyload alt="H4BhK0b.png"></a></p>
</li>
<li><p>图 1.9 告诉我们，从地址 0 ~ 9FFFF 的内存单元中读取数据，实际上就是在读取主随机存储器中的数据；向地址 A0000 ~ BFFFF 的内存单元中写数据，就是向显存中写入数据,这些数据会被显示卡输出到显示器上；我们向地址 CO00O ~ FFFFF 的内存单元中写入数据的操作是<em>无效的</em>，因为这等于改写只读存储器中的内容。</p>
</li>
<li><p>内存地址空间：最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。  对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。这个逻辑存储器即是我们所说的<em>内存地址空间</em>。😭</p>
</li>
</ol>
<h2 id="第2章-寄存器"><a href="#第2章-寄存器" class="headerlink" title="第2章 寄存器"></a>第2章 寄存器</h2><hr>
<h3 id="基础概念-1"><a href="#基础概念-1" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>8086CPU有14个寄存器，它们的名称为：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PSW。</p>
<blockquote>
<p>AX：accumulator register，累加器寄存器</p>
<p>BX： base register，基数寄存器</p>
<p>CX： count register，计数寄存器 </p>
<p>DX：data register，通用数据寄存器</p>
<p>SI：source index，源变址寄存器</p>
<p>DI：destination index，目的变址寄存器</p>
<p>SP：stack pointer，堆栈指针寄存器</p>
<p>BP：base pointer，基址指针寄存器，指示堆栈段中一个数据区的基址位置，通常与SS配对</p>
<p>IP：instruction pointer，码段地址指针寄存器</p>
<p>CS：code segment，代码段寄存器</p>
<p>SS：stack segment，堆栈段~，存放当前堆栈段的段地址，一般和SP连用</p>
<p>DS：data segment，数据段~，存放当前数据段的段地址</p>
<p>ES：extra segment，附加段~</p>
<p>PSW：program state word，标志~</p>
</blockquote>
</li>
<li><p>8086CPU所有的寄存器都是16位的，可以存放两个字节。</p>
</li>
<li><p>AX、BX、CX、DX 通常用来存放一般性数据，被称为通用寄存器。</p>
</li>
<li><p>一个16位寄存器所能存储的数据的最大值为多少？<br>   答案：2^16-1&#x3D;65535。</p>
</li>
<li><p>汇编指令不区分大小写。</p>
</li>
<li><p>8086有20位地址总线，可传送20位地址，寻址能力为1M。</p>
</li>
<li><p>地址加法器如何完成段地址×16的运算？就是将以二进制形式存放的段地址左移4位。</p>
</li>
<li><p>“段地址×16+偏移地址&#x3D;物理地址”的本质含义是： CPU 在访问内存时，用一个基础地址(段地址x16)和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。</p>
</li>
<li><p>有两点需要注意：段地址✖16 必然是 16 的倍数，所以一个段的起始地址也一定是 16 的倍数；偏移地址为 16 位，16 位地址的寻址能力为 64KB，所以<em>一个段的长度最大为 64KB</em>。</p>
</li>
<li><p>CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p>
</li>
<li><p>8086PC工作过程的简要描述</p>
<ol>
<li>从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；</li>
<li>IP &#x3D; IP + 所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。 转到步骤 （1），重复这个过程。</li>
</ol>
</li>
<li><p><strong>mov指令不能用于设置CS、IP的值，8086CPU没有提供这样的功能。</strong></p>
</li>
</ol>
<h2 id="第3章-寄存器（内存访问）"><a href="#第3章-寄存器（内存访问）" class="headerlink" title="第3章 寄存器（内存访问）"></a>第3章 寄存器（内存访问）</h2><hr>
<h3 id="基础概念-2"><a href="#基础概念-2" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li>8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器。（硬件设计的问题）</li>
</ol>
<ul>
<li>mov ds,1000H 是非法的。</li>
<li>数据 → 一般的寄存器 → 段寄存器</li>
</ul>
<ol start="2">
<li><p><strong>字在内存中存储时 ，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放再高地址单元中。</strong></p>
</li>
<li><p>合法格式：</p>
</li>
</ol>
<ul>
<li>mov 寄存器，寄存器&#x2F;内存单元&#x2F;段寄存器&#x2F;立即数</li>
<li>mov 内存单元，寄存器&#x2F;段寄存器&#x2F;立即数</li>
<li>mov 段寄存器，寄存器&#x2F;内存单元<br>~注意：</li>
<li>mov指令中的目的操作数不能是立即数、IP和CS寄存器；</li>
<li>mov指令中不允许在两个存储单元之间直接传送数据；</li>
<li>mov指令中不允许在两个段寄存器之间直接传送数据；</li>
<li>mov指令中立即数不能直接传送给段寄存器（CS、DS、SS、ES）。</li>
</ul>
<ol start="4">
<li>栈：</li>
</ol>
<ul>
<li><p>8086CPU提供了栈操作机制，方案如下：在SS，SP中存放栈顶的段地址和偏移地址；提供入栈和出栈指令，他们根据SS:SP指示的地址，按照栈的方式访问内存单元。</p>
</li>
<li><p><strong>push指令的执行步骤</strong>：</p>
<ol>
<li>SP&#x3D;SP-2；</li>
<li>向SS:SP指向的字单元中送入数据。</li>
</ol>
</li>
<li><p><strong>pop指令的执行步骤</strong>：</p>
<ol>
<li>从SS:SP指向的字单元中读取数据；</li>
<li>SP&#x3D;SP+2。</li>
</ol>
</li>
<li><p>任意时刻，SS:SP指向栈顶元素。</p>
</li>
<li><p>8086CPU只记录栈顶，栈空间的大小我们要自己管理。</p>
</li>
<li><p>用栈来暂存以后需要恢复的寄存器的内容时 ，寄存器出栈的顺序要和 入栈的顺序相反。</p>
</li>
<li><p>push、pop实质上是一种内存传送指令，注意它们的灵活应用。</p>
</li>
</ul>
<ol start="5">
<li><p>一个栈段的容量最大为64KB。</p>
</li>
<li><p>如果我们将10000H~1FFFFH这段空间当作栈段，初始状态是空的，此时，SS&#x3D;1000H，SP&#x3D;？、、、答案：0，（SP原来为FFFEH，加2后SP&#x3D;0，所以，当栈为空的时候，SS&#x3D;1000H，SP&#x3D;0。）</p>
</li>
<li><p><strong>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排。</strong></p>
<ul>
<li>我们可以用一个段存放数据，将它定义为“数据段”</li>
<li>我们可以用一个段存放代码，将它定义为“代码段”</li>
<li>我们可以用一个段当作栈，将它定义为“栈段”</li>
</ul>
<p> 我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：</p>
<ul>
<li>对于数据段，将它的段地址放在 DS中，用mov、add、sub等访问内存单元的指令时，CPU就将我们定义的数据段中的内容当作数据来访问；</li>
<li>对于代码段，将它的段地址放在 CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令；</li>
<li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地置放在 SP 中，这样CPU在需要进行栈操作的时候，比如执行 push、pop 指令等，就将我们定义的栈段当作栈空间来用。</li>
<li>可见，不管我们如何安排 ，CPU 将内存中的某段内存当作代码 ，是因为CS:IP指向了那里；CPU将某段内存当作栈 ，是因为 SS:SP 指向了那里。</li>
</ul>
</li>
</ol>
<h2 id="第4章-第一个程序"><a href="#第4章-第一个程序" class="headerlink" title="第4章 第一个程序"></a>第4章 第一个程序</h2><hr>
<h3 id="基础概念-3"><a href="#基础概念-3" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>DOS系统中.EXE文件中的程序的加载过程：<br><a target="_blank" rel="noopener" href="https://freeimage.host/i/H6suidv"><img src="https://iili.io/H6suidv.md.png" srcset="/img/loading.gif" lazyload alt="H6suidv.md.png"></a></p>
</li>
<li><p>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为 0 ，则<strong>程序所在的内存区的地址为：ds:0</strong>；这个内存区的前256 个字节中存放的是PSP，dos用来和程序进行通信。 从 256字节处向后的空间存放的是程序。</p>
</li>
<li><p>所以，我们从ds中可以得到PSP的段地址SA，PSP的偏移地址为 0，则物理地址为SA×16+0。因为PSP占256（100H）字节，所以<strong>程序的物理地址</strong>是：<em>SA×16+0+256&#x3D; SA×16+16×16&#x3D;（SA+16）×16+0</em>可用段地址和偏移地址表示为：<strong>SA+10:0</strong>。</p>
<ul>
<li>如：DS&#x3D;129E，则PSP的的地址为129E:0，程序的地址为12AE:0。</li>
</ul>
</li>
<li><p>一个源程序从写出到执行的过程：<strong>编写、编译、连接、执行</strong>（使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。）</p>
</li>
<li><p>说明<strong>伪指令和汇编指令的区别</strong>：汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。而伪指令没有对应的机器指令，最终不被CPU所执行，是由编译器来执行的。</p>
</li>
<li><p>说明汇编语言程序中<strong>标号的作用</strong>：汇编源程序中一个标号指代了一个地址，比如codesg在segment的前面，作一个段的名称，这个段的名称最终将被编译、连接程序处理为一个段的段地址。</p>
</li>
</ol>
<h2 id="第5章-bx-和loop指令"><a href="#第5章-bx-和loop指令" class="headerlink" title="第5章 [bx]和loop指令"></a>第5章 [bx]和loop指令</h2><hr>
<h3 id="基础概念-4"><a href="#基础概念-4" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>描述性符号“()”，例如：对于push ax的功能，我们可以这样来描述：</p>
<ul>
<li>(sp) &#x3D; (sp)-2 </li>
<li>((ss) * 16＋(sp))&#x3D;(ax)</li>
</ul>
</li>
<li><p>(2000:0)、((ds):1000H)等是错误的用法</p>
</li>
<li><p>(ax)、(ds)、(al)、(2000H)、((ds) * 16+(bx))等是正确的用法</p>
</li>
<li><p>指令的格式是：loop 标号，CPU 执行loop指令的时候，要进行两步操作：</p>
<ol>
<li>(cx)&#x3D;(cx)-1；</li>
<li>判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。</li>
</ol>
</li>
<li><p>ffff:0006 单元中的数是一个字节型的数据，范围在0~255之间</p>
</li>
<li><p><strong>我们在Debug中写过类似的指令：<code>mov ax,[0]</code> 表示将ds:0处的数据送入ax中。但是在汇编源程序中，指令<code>mov ax,[0]</code>被编译器当作指令<code>mov ax,0</code>处理。</strong></p>
</li>
<li><p>为防止上述情况发生，在源程序中，可采用两种方法访问2000:0单元：</p>
</li>
</ol>
<ul>
<li><p>方法一： </p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0</span> <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,[<span class="hljs-built_in">bx</span>]<br></code></pre></td></tr></table></figure>
</li>
<li><p>方法二：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">2000h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-number">0</span>]                 一般用第二种方法<br></code></pre></td></tr></table></figure></li>
</ul>
<ol start="8">
<li><p>DOS方式下，一般情况， 0:200 ~ 0:2FF 空间中没有系统或其他程序的数据或代码；以后，我们需要直接向一段内存中写入内容时，就使用0:200 ~ 0:2FF这段空间。</p>
</li>
<li><p>利用栈对CX寄存器内容进行保护push和恢复pop可以实现多重loop循环。如：</p>
</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>, m<br><span class="hljs-symbol">s1:</span>          <span class="hljs-comment">;循环体1</span><br> <span class="hljs-keyword">push</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,n<br><span class="hljs-symbol">s2:</span>          <span class="hljs-comment">;循环体2</span><br> <span class="hljs-keyword">loop</span> s2<br> <span class="hljs-keyword">pop</span> <span class="hljs-built_in">cx</span><br> <span class="hljs-keyword">loop</span> s1<br></code></pre></td></tr></table></figure>


<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><ol>
<li>将内存ffff:0<del>ffff:b段单元中的数据拷贝到 0:200</del>0:20b单元中。</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br><br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,offffh<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020h</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>,<span class="hljs-built_in">ax</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span><br><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">12</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    s:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">ds</span>:[<span class="hljs-built_in">bx</span>]<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">es</span>:[<span class="hljs-built_in">bx</span>],<span class="hljs-built_in">al</span>    <span class="hljs-comment">;al作为中转寄存器</span><br><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">bx</span><br>        <span class="hljs-keyword">loop</span> s<br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>        <span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>编写程序片断，利用 loop 指令，实现斐波那契数列前 9 个数字 1、1、2、3、5、8、13、21、34 的求和，并将求和结果保存到内存字单元 0:200 中</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">start:</span><br>	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;ax中的值依次为1、1、2、3、5、8、13、21、34      </span><br>	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1</span><br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span>    <span class="hljs-comment">;来存最后的计算结果</span><br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">cx</span>,<span class="hljs-number">9</span>    <span class="hljs-comment">;循环次数</span><br><span class="hljs-symbol"> s:</span>	<span class="hljs-keyword">push</span> <span class="hljs-built_in">bx</span><br>	<span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-built_in">ax</span><br> 	<span class="hljs-keyword">pop</span> <span class="hljs-built_in">ax</span><br> 	<span class="hljs-keyword">add</span> <span class="hljs-built_in">dx</span>,<span class="hljs-built_in">ax</span><br>	<br> 	<span class="hljs-keyword">loop</span> s<br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0</span><br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>:[<span class="hljs-number">200h</span>],<span class="hljs-built_in">dx</span><br> <br> 	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br> 	<span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br><br>code ends<br>end start<br><br></code></pre></td></tr></table></figure>

<h2 id="第6章-包含多个段的程序"><a href="#第6章-包含多个段的程序" class="headerlink" title="第6章 包含多个段的程序"></a>第6章 包含多个段的程序</h2><hr>
<h3 id="基础概念-5"><a href="#基础概念-5" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>我们在源程序中用伪指令 “assume cs:code,ds:data,ss:stack”将cs、ds和ss分别和code、data、stack段相连。这样做了之后，CPU是否就会将 cs指向ode，ds 指向 data，ss 指向stack，从而按照我们的意图来处理这些段呢？</p>
</li>
<li><p>当然也不是，要知道 assume 是伪指令，是由编译器执行的，也是仅在源程序中存在的信息，CPU并不知道它们。我们不必深究 assume 的作用，只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。 </p>
</li>
<li><p>若要CPU按照我们的安排行事，就要用机器指令控制它，源程序中的汇编指令是CPU要执行的内容。</p>
</li>
<li><p>总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，还是当作栈空间，完全是靠程序中具体的汇编指令，和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。</p>
</li>
</ol>
<h2 id="第7章-更灵活的定位内存地址的的方法"><a href="#第7章-更灵活的定位内存地址的的方法" class="headerlink" title="第7章 更灵活的定位内存地址的的方法"></a>第7章 更灵活的定位内存地址的的方法</h2><hr>
<h3 id="基础概念-6"><a href="#基础概念-6" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>（1）and 指令：逻辑与指令，按位进行与运算。（2）or 指令：逻辑或指令，按位进行或运算。</p>
</li>
<li><p>在ASCII编码方案中，用61H 表示“a”，62H表示“b”。用41H 表示“A”，42H表示“B”。</p>
</li>
<li><p>就ASCII码的二进制形式来看，除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。大写字母ASCII码的第5位（位数从0开始计算）为0，小写字母的第5位为1。</p>
</li>
<li><p>or al,00100000b        ;将al中的ASCII码的第5位置为1，变为小写字母</p>
</li>
<li><p>and al,11011111b      ;将al中的ASCII码的第5位置为0，变为大写字母</p>
<ul>
<li><strong>and byte ptr [si],11011111b</strong>，等到了后面就是这样了</li>
</ul>
</li>
<li><p>指令<strong>mov ax,[bx+200]也可以写成如下格式（常用）</strong>：</p>
<ul>
<li>mov ax,[200+bx]</li>
<li><strong>mov ax,200[bx]</strong></li>
<li>mov ax,[bx].200</li>
</ul>
</li>
<li><p>SI(source index register)和DI(destination index register)是8086CPU中和bx功能相近的寄存器，<strong>SI和DI不能够分成两个8 位寄存器来使用</strong>。</p>
</li>
<li><p>指令mov ax,[bx+si]的数学化的描述为：(ax)&#x3D;( (ds) * 16+(bx)+(si) )。<br> 该指令也可以写成如下格式（常用）：mov ax,[bx][si]</p>
</li>
<li><p>指令mov ax,[bx+si+200]，该指令也可以写成如下格式（常用）：</p>
<ul>
<li>mov ax,[bx+200+si] </li>
<li>mov ax,[200+bx+si]</li>
<li>mov ax,200[bx][si]</li>
<li>mov ax,[bx].200[si]</li>
<li>mov ax,[bx][si].200</li>
</ul>
</li>
</ol>
<h2 id="第8章-数据处理的两个基本问题"><a href="#第8章-数据处理的两个基本问题" class="headerlink" title="第8章 数据处理的两个基本问题"></a>第8章 数据处理的两个基本问题</h2><hr>
<h3 id="基础概念-7"><a href="#基础概念-7" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>我们将使用reg来表示一个寄存器，用sreg表示一个段寄存器。reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；sreg的集合包括：ds、ss、cs、es。</p>
</li>
<li><p>在8086CPU 中，只有这4个寄存器（bx、bp、si、di）可以用在“[…]” 中来进行内存单元的寻址。</p>
</li>
<li><p>在“[…]” 中，这4个寄存器（bx、bp、si、di）可以单个出现，或只能以四种组合出现：bx和si、bx和di、bp和si、bp和di</p>
</li>
<li><p><strong>只要在[…]中使用寄存器bp，而指令中没有显性的给出段地址，段地址就默认在ss中</strong>。</p>
</li>
<li><p>mov ax,1 对应机器码：B80100；mov ax,076a的机器码？B86A07</p>
</li>
<li><p>在没有寄存器名存在的情况下，用操作符<strong>X ptr</strong>指明内存单元的长度，X在汇编指令中可以为word或byte。</p>
</li>
<li><p>push指令只进行字操作</p>
</li>
<li><p>div是除法指令，使用div作除法的时候：</p>
<ul>
<li>除数：8位或16位，在寄存器或内存单元中</li>
<li>被除数：（默认）放在AX 或 DX（高16位）和AX（低16位）中</li>
<li>结果：如果除数为 8位，商：AL，余数：AH；<strong>如果除数为16位，商：AX，余数：DX</strong>；</li>
</ul>
</li>
<li><p>div指令格式： div reg div 内存单元</p>
</li>
<li><p>div byte ptr ds:[0]</p>
<ul>
<li>含义为：(al)&#x3D;(ax)&#x2F;((ds) * 16+0)的商；</li>
<li>(ah)&#x3D;(ax)&#x2F;((ds) * 16+0)的余数</li>
</ul>
</li>
<li><p>div word ptr [bx+si+8]</p>
<ul>
<li>含义为：(ax)&#x3D;[(dx) * 10000H+(ax)]&#x2F;((ds) * 16+(bx)+(si)+8)的商；</li>
<li>(dx)&#x3D;[(dx) * 10000H+(ax)]&#x2F;((ds) * 16+(bx)+(si)+8)的余数</li>
</ul>
</li>
<li><p>dd 1，数据为00000001H，占2个字；</p>
</li>
<li><p><strong>dup</strong>是一个操作符，在汇编语言中同db、dw、dd 等一样，也是由编译器识别处理的符号。 它是和db、dw、dd 等数据定义伪指令配合使用的，用来进行数据的重复。</p>
<ul>
<li>db 3 dup (0) 定义了3个字节，它们的值都是0，相当于 db 0,0,0</li>
<li>db 3 dup (0,1,2)定义了9个字节，它们是0、1、2、0、1、2、0、1、2，相当于 db 0,1,2,0,1,2,0,1,2</li>
<li>db 3 dup (‘abc’,’ABC’)定义了18个字节，它们是‘abcABCabcABCabcABC’，相当于db ‘abcABCabcABCabcABC’</li>
</ul>
</li>
</ol>
<h2 id="第9章-转移指令的原理"><a href="#第9章-转移指令的原理" class="headerlink" title="第9章 转移指令的原理"></a>第9章 转移指令的原理</h2><hr>
<h3 id="基础概念-8"><a href="#基础概念-8" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>jmp指令要给出两种信息： 转移的目的地址， 转移的距离（段间转移jmp far、段内短转移jmp short，段内近转移jmp near）</p>
</li>
<li><p><strong>jmp short 标号</strong>（转到标号处执行指令）这种格式的 jmp 指令实现的是<strong>段内短转移，它对IP的修改范围为 -128~127</strong>，也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。</p>
</li>
<li><p>在“jmp short 标号”指令所对应的机器码中，并不包含转移的目的地址，而<strong>包含的是转移的位移</strong>。 这个位移，是编译器根据汇编指令中的“标号”计算出来的。</p>
</li>
<li><p>实际上，指令“jmp short 标号”的功能为(IP)&#x3D;(IP)+8位位移。</p>
<ul>
<li><strong>8位位移&#x3D;“标号”处的地址-jmp指令后的第一个字节的地址</strong>；</li>
<li>short指明此处的位移为8位位移；</li>
<li>8位位移的范围为-128~127，用补码表示。</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
</li>
<li><p><strong>jmp near ptr</strong> 标号它实现的时<strong>段内近转移</strong>。<strong>IP修改范围为：-32768~32767</strong>。</p>
</li>
<li><p>指令 <strong>jmp far ptr</strong> 标号 实现的是<strong>段间转移，又称为远转移</strong>。far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。IP修改范围：随意。</p>
</li>
<li><p>jmp far ptr s所对应的机器码：EA 0B 01 BD 0B ，其中包含转移的目的地址</p>
</li>
<li><p>转移地址在内存中的jmp指令有两种格式：</p>
<ul>
<li>jmp word ptr 内存单元地址（段内转移）<ul>
<li>功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。</li>
</ul>
</li>
<li>jmp dword ptr 内存单元地址（段间转移）<ul>
<li>功能：从内存单元地址处开始存放着两个字，<strong>高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址</strong>。</li>
<li>(CS)&#x3D;(内存单元地址+2)</li>
<li>(IP)&#x3D;(内存单元地址)</li>
<li>内存单元地址可用寻址方式的任一格式给出。</li>
</ul>
</li>
</ul>
</li>
<li><p>jcxz指令（jump if cx equals zero）为有条件转移指令，<strong>所有的有条件转移指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。<strong>指令格式：jcxz 标号 （如果(cx)&#x3D;0，则转移到标号处执行。）</strong></p>
</li>
<li><p>jcxz 标号 指令操作：</p>
<ul>
<li>当(cx)&#x3D;0时，(IP)&#x3D;(IP)+8位位移）<ul>
<li><strong>8位位移&#x3D;“标号”处的地址-jcxz指令后的第一个字节的地址；</strong></li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ul>
</li>
<li>当(cx)不为0时，什么也不做（程序向下执行）。</li>
</ul>
</li>
<li><p>loop指令为循环指令，<strong>所有的循环指令都是短转移</strong>，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为-128~127。指令格式：loop 标号</p>
</li>
</ol>
<h2 id="第10章-CALL和RET指令"><a href="#第10章-CALL和RET指令" class="headerlink" title="第10章 CALL和RET指令"></a>第10章 CALL和RET指令</h2><hr>
<h3 id="基础概念-9"><a href="#基础概念-9" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移；</p>
<ul>
<li>CPU执行ret指令时，相当于进行：pop IP</li>
</ul>
</li>
<li><p>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p>
<ul>
<li>CPU执行retf指令时，相当于进行：<ul>
<li>pop IP（<strong>注意！这是违法的，只是效果</strong>）</li>
<li>pop CS</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU执行call指令，进行两步操作：</p>
<ul>
<li>将当前的 IP 或 CS 和 IP 压入栈中；</li>
<li>转移。</li>
</ul>
</li>
<li><p>CPU 执行指令“call 标号”时，相当于进行：</p>
<ul>
<li>push IP</li>
<li>jmp near ptr 标号</li>
</ul>
</li>
<li><p>call s 在指令缓冲器时，IP已经改变了，指向了下一条指令，suoooooo以，<strong>call指令指向时将下一条指令的IP入栈</strong> 。</p>
</li>
<li><p>CPU 执行指令 “call far ptr 标号”时，相当于进行：</p>
<ul>
<li>push CS</li>
<li>push IP</li>
<li>jmp far ptr 标号</li>
</ul>
</li>
<li><p>CPU执行call 16位reg时，相当于进行：</p>
<ul>
<li>push IP </li>
<li>jmp 16位寄存器</li>
</ul>
</li>
<li><p>call word ptr 内存单元地址， 汇编语法解释：</p>
<ul>
<li>push CS</li>
<li>push IP</li>
<li>jmp dword ptr 内存单元地址</li>
</ul>
</li>
<li><p>call dword ptr 内存单元地址， 汇编语法解释：</p>
<ul>
<li>push CS</li>
<li>push IP</li>
<li>jmp dword ptr 内存单元地址</li>
</ul>
</li>
</ol>
<h2 id="第11章-标志寄存器"><a href="#第11章-标志寄存器" class="headerlink" title="第11章 标志寄存器"></a>第11章 标志寄存器</h2><hr>
<h3 id="基础概念-10"><a href="#基础概念-10" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>flag的第6位是<strong>ZF（zero flag），零标志位</strong>。它记录相关指令执行后，其结果是否为0</p>
<ul>
<li>结果为0 ，ZF &#x3D; 1</li>
<li>结果不为0，ZF &#x3D; 0</li>
</ul>
</li>
<li><p>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如：<strong>add、sub、mul、div、inc、or、and</strong>等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如：mov、push、pop等，它们大都是传送指令。</p>
</li>
<li><p>flag的第2位是<strong>PF，奇偶标志位</strong>。它记录指令执行后，结果的所有<strong>二进制位（低8位）中</strong>1的个数：</p>
<ul>
<li>为偶数，PF &#x3D; 1；</li>
<li>为奇数，PF &#x3D; 0。</li>
</ul>
</li>
<li><p>flag的第7位是<strong>SF，符号标志位</strong>。它记录指令执行后，其结果是否为负</p>
<ul>
<li>结果为负，SF &#x3D; 1；</li>
<li>结果为正，SF &#x3D; 0。</li>
<li>与有符号数的符号位规定一致</li>
<li>SF 标志，就是CPU对有符号数运算结果的一种记录 ，它记录数据的正负。</li>
<li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li>
<li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li>
</ul>
</li>
<li><p>比如指令sub al,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。</p>
</li>
<li><p>flag的第0位是<strong>CF，进位标志位。</strong></p>
<ul>
<li>一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。</li>
<li>比如：<ul>
<li>mov al,98H</li>
<li>add al,al ;</li>
<li>执行后： (al)&#x3D;30H，CF&#x3D;1，CF记录了最高有效位向更高位的进位值</li>
</ul>
</li>
</ul>
</li>
<li><p>flag的第11位是<strong>OF，溢出标志位。</strong></p>
<ul>
<li>一般情况下，OF记录了有符号数运算的结果是否发生了溢出。</li>
<li>如果发生溢出，OF&#x3D;1，</li>
<li>如果没有，OF&#x3D;0。</li>
<li><strong>CF是对无符号数运算有意义的标志位；而OF是对有符号数运算有意义的标志位。</strong></li>
</ul>
</li>
<li><p>对于无符号数运算，CPU用CF位来记录是否产生了进位；对于有符号数运算，CPU 用 OF 位来记录是否产生了溢出。当然，还要用SF位来记录结果的符号。</p>
<ul>
<li>对于无符号数运算，98+99没有进位，CF&#x3D;0；</li>
<li>对于有符号数运算，98+99发生溢出，OF&#x3D;1。</li>
</ul>
</li>
<li><p><strong>adc是带进位加法指令 ，它利用了CF位上记录的进位值。</strong></p>
<ul>
<li>格式： adc 操作对象1,操作对象2</li>
<li>功能：操作对象1&#x3D;操作对象1+操作对象2+CF</li>
<li>比如：adc ax,bx 实现的功能是：(ax)&#x3D;(ax)+(bx)+CF</li>
</ul>
</li>
<li><p>下面的指令和add ax , bx具有相同的结果：add al,bl ，adc ah,bh，看来CPU提供 adc 指令的目的，就是来进行加法的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p>
</li>
<li><p><strong>sbb是带借位减法指令，它利用了CF位上记录的借位值。</strong></p>
<ul>
<li>格式：sbb 操作对象1,操作对象2</li>
<li>功能：操作对象1&#x3D;操作对象1–操作对象2–CF</li>
<li>比如：sbb ax,bx,实现功能： (ax) &#x3D; (ax) – (bx) – CF</li>
</ul>
</li>
<li><p><strong>cmp指令</strong></p>
<ul>
<li>格式：cmp 操作对象1,操作对象2</li>
<li>功能：计算操作对象1–操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。</li>
</ul>
</li>
<li><p>比如：cmp ax,ax做(ax)–(ax)的运算，结果为0，但并不在ax中保存，仅影响flag的相关各位。指令执行后：</p>
<ul>
<li>ZF&#x3D;1，</li>
<li>PF&#x3D;1，0是偶数</li>
<li>SF&#x3D;0，</li>
<li>CF&#x3D;0，</li>
<li>OF&#x3D;0。</li>
<li>根据cmp指令执行后ZF的值，就可以知道两个数据是否相等。</li>
</ul>
</li>
<li><p>如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。所以，我们应该在考察SF（得知实际结果的正负）的同时考察OF（得知有没有溢出），就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。</p>
</li>
<li><p>虽然 je 的逻辑含义是“相等则转移”，但它进行的操作是，ZF&#x3D;1时则转移。“相等则转移”这种逻辑含义，是通过和 cmp 指令配合使用来体现的，因为是cmp 指令为“ZF&#x3D;1”赋予了“两数相等”的含义。虽然我们分别讨论了cmp指令和与其比较结果相关的有条件转移指令，但是它们经常在一起配合使用。所以我们在联合应用它们的时候，不必再考虑cmp指令对相关标志位的影响和je 等指令对相关标志位的检测。我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。<strong>意思就是说je可以直接用，je就是等于则转移</strong></p>
</li>
<li><p><strong>jb 含义是低于则转移，ja 含义是高于则转移。</strong></p>
</li>
<li><p><strong>jna 含义是不高于则转移，即小于等于则转移；jnb 含义是不低于则转移，即大于等于则转移。</strong></p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://freeimage.host/i/HPSgh7e"><img src="https://iili.io/HPSgh7e.md.png" srcset="/img/loading.gif" lazyload alt="HPSgh7e.md.png"></a></p>
<ol start="18">
<li><p>flag的第10位是<strong>DF，方向标志位。</strong></p>
<ul>
<li>在串处理指令中，控制每次操作后si，di的增减。</li>
<li>DF &#x3D; 0：每次操作后si，di递增；</li>
<li>DF &#x3D; 1：每次操作后si，di递减。</li>
</ul>
</li>
<li><p>串传送指令：<code>movsb</code> 我们可以用汇编语法描述movsb的功能如下：</p>
<ul>
<li>mov es:[di],byte ptr ds:[si];8086 并不支持这样的指令，这里只是个描述。</li>
<li>如果DF&#x3D;0：inc si，inc di</li>
<li>如果DF&#x3D;1：dec si，dec di</li>
<li><strong>就是ds:si 传到 es:di</strong></li>
</ul>
</li>
<li><p>rep movsb 用汇编语法来描述rep movsb的功能就是：<br>  <code>s : movsb</code><br>  <code>loop s</code></p>
</li>
<li><p><strong>cld指令：将标志寄存器的DF位置0，std指令：将标志寄存器的DF位置1</strong></p>
</li>
<li><p>pushf ：将标志寄存器的值压栈；</p>
</li>
<li><p>popf ：从栈中弹出数据，送入标志寄存器中。</p>
</li>
<li><p>pushf和popf，为直接访问标志寄存<br>器提供了一种方法。</p>
</li>
</ol>
<h3 id="程序-1"><a href="#程序-1" class="headerlink" title="程序"></a>程序</h3><ol>
<li>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">001EH</span> <br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">0F000H</span> <br> <span class="hljs-keyword">add</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span> <br> <span class="hljs-keyword">adc</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span> <br> <span class="hljs-keyword">adc</span> 指令执行后，也可能产生进位值，所以也会对CF位进行设置<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>计算003E1000H–00202000H，结果放在ax，bx中。</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序如下：<br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">1000H</span><br> <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">003EH</span><br> <span class="hljs-keyword">sub</span> <span class="hljs-built_in">bx</span>,<span class="hljs-number">2000H</span><br> <span class="hljs-keyword">sbb</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">0020H</span><br></code></pre></td></tr></table></figure>


<h2 id="第12章-内中断"><a href="#第12章-内中断" class="headerlink" title="第12章 内中断"></a>第12章 内中断</h2><hr>
<h3 id="基础概念-11"><a href="#基础概念-11" class="headerlink" title="基础概念"></a>基础概念</h3><ol>
<li><p>我们更简洁的描述中断过程，如下：</p>
<ul>
<li>（1）取得中断类型码N；</li>
<li>（2） pushf</li>
<li>（3） TF &#x3D; 0，IF &#x3D; 0</li>
<li>（4） push CS</li>
<li>（5） push IP</li>
<li>（6）(IP) &#x3D; (N * 4)，(CS) &#x3D; (N * 4+2)</li>
<li>在最后一步完成后，CPU 开始执行由程序员编写的中断处理程序。</li>
</ul>
</li>
<li><p>iret指令的功能用汇编语法描述为：</p>
<ol>
<li>pop IP</li>
<li>pop CS</li>
<li>popf</li>
</ol>
</li>
<li><p>CPU当然不能让这种情况发生，解决的办法就是，<strong>在进入中断处理程序之前，设置TF&#x3D;0</strong>。从而<strong>避免CPU在执行中断处理程序的时候发生单步中断</strong>。 这就是为什么在中断过程中有 TF&#x3D;0这个步骤。</p>
</li>
</ol>
<h2 id="第13章-int指令"><a href="#第13章-int指令" class="headerlink" title="第13章 int指令"></a>第13章 int指令</h2><hr>
<h3 id="程序-2"><a href="#程序-2" class="headerlink" title="程序"></a>程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程：在屏幕的5行12列显示字符串“welcome to masm!”。</span><br><span class="hljs-meta">assume</span> <span class="hljs-built_in">cs</span>:code<br>data <span class="hljs-meta">segment</span> <br>	<span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;Welcome to masm!&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>data ends<br>code <span class="hljs-meta">segment</span><br><span class="hljs-symbol">start:</span> 	<span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">2</span> <span class="hljs-comment">;置光标</span><br>		<span class="hljs-keyword">mov</span> <span class="hljs-number">bh</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;第0页</span><br>		<span class="hljs-keyword">mov</span> <span class="hljs-number">dh</span>,<span class="hljs-number">5</span> <span class="hljs-comment">;dh中放行号</span><br>		<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>,<span class="hljs-number">12</span> <span class="hljs-comment">;dl中放列号</span><br>		<span class="hljs-keyword">int</span> <span class="hljs-number">10h</span><br>		<br>		<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,data<br>		<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ds</span>,<span class="hljs-built_in">ax</span><br>		<span class="hljs-keyword">mov</span> <span class="hljs-built_in">dx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">;ds:dx指向字符串的首地址data:0</span><br>		<span class="hljs-keyword">mov</span> <span class="hljs-number">ah</span>,<span class="hljs-number">9</span><br>		<span class="hljs-keyword">int</span> <span class="hljs-number">21h</span><br>		<br>	<span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>,<span class="hljs-number">4c00h</span><br>	<span class="hljs-keyword">int</span> <span class="hljs-number">21h</span> <br>code ends<br>end start<br></code></pre></td></tr></table></figure>


<h2 id="第14章-端口"><a href="#第14章-端口" class="headerlink" title="第14章 端口"></a>第14章 端口</h2><hr>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p><strong>in al,60h;从60h号端口读入一个字节</strong></p>
<ul>
<li>执行时与总线相关的操作：</li>
<li>① CPU通过地址线将地址信息60h发出；</li>
<li>② CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；</li>
<li>③ 端口所在的芯片将60h端口中的数据通过数据线送入CPU。</li>
</ul>
</li>
<li><p>注意：在in和out 指令中，只能使用 ax 或al 来存放从端口中读入的数据或要发送到端口中的数据。访问8 位端口时用al ，访问16 位端口时用ax 。</p>
</li>
<li><p>对0～255以内的端口进行读写：</p>
<ul>
<li><strong>in al,20h          ;从20h端口读入一个字节</strong></li>
<li><strong>out 20h,al         ;往20h端口写入一个字节</strong></li>
</ul>
</li>
<li><p>对256～65535的端口进行读写时，端口号放在dx中：</p>
<ul>
<li>mov dx,3f8h  ;将端口号3f8送入dx</li>
<li>in al,dx  ;从3f8h端口读入一个字节</li>
<li>out dx,al  ;向3f8h端口写入一个字节</li>
</ul>
</li>
<li><p><strong>70h为地址端口</strong>，存放要访问的CMOS RAM单元的地址；<strong>71h为数据端口</strong>，存放从选定的CMOS RAM 单元中读取的数据，或要写入到其中的数据。</p>
</li>
<li><p>shl逻辑左移指令，功能为：</p>
<ul>
<li>将一个寄存器或内存单元中的数据向左移位；</li>
<li>将最后移出的一位写入CF中；</li>
<li>最低位用0补充。</li>
</ul>
</li>
<li><p>如果移动位数大于1时，必须将移动位数放在<strong>cl</strong>中。</p>
</li>
<li><p>shr逻辑右移指令</p>
</li>
</ol>
<h3 id="程序-3"><a href="#程序-3" class="headerlink" title="程序"></a>程序</h3><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-comment">;编程，读CMOS RAM的2号单元的内容</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">in</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">71h</span>          <span class="hljs-comment">;从 71h 读出 2 号单元的内容</span><br><br><span class="hljs-comment">;编程，向CMOS RAM的2号单元写入0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">2</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">70h</span>,<span class="hljs-built_in">al</span>        <span class="hljs-comment">;将 2 送入端口 70h</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">out</span> <span class="hljs-number">71h</span>,<span class="hljs-built_in">al</span>       <span class="hljs-comment">;向 2 号单元写入 0</span><br> <br><br></code></pre></td></tr></table></figure>


<h2 id="第15章-外中断"><a href="#第15章-外中断" class="headerlink" title="第15章 外中断"></a>第15章 外中断</h2><hr>
<h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>外设的输入不直接送入内存和CPU ，而是送入相关的接口芯片的端口中； CPU 向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。</p>
</li>
<li><p>可屏蔽中断是CPU 可以不响应的外中断。CPU 是否响应可屏蔽中断，要看标志寄存器的IF 位的设置。</p>
<ul>
<li>当CPU 检测到可屏蔽中断信息时：</li>
<li>如果IF&#x3D;1，则CPU 在执行完当前指令后响应中断，引发中断过程；</li>
<li>如果IF&#x3D;0，则不响应可屏蔽中断。</li>
</ul>
</li>
<li><p>内中断所引发的中断过程：</p>
<ul>
<li>（1）取中断类型码n；</li>
<li>（2）标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；</li>
<li>（3）CS 、IP 入栈；</li>
<li>（4）(IP)&#x3D;(n* 4)，(CS)&#x3D;(n* 4+2)，</li>
<li>由此转去执行中断处理程序。</li>
</ul>
</li>
<li><p>将IF置0的原因就是，<strong>在进入中断处理程序后，禁止其他的可屏蔽中断。</strong></p>
</li>
<li><p> 不可屏蔽中断是CPU <strong>必须响应</strong>的外中断。当CPU 检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。 对于8086CPU 不可屏蔽中断的中断类型码固定为2。所以中断过程中，不需要取中断类型码。</p>
</li>
<li><p>不可屏蔽中断的中断过程：</p>
<ul>
<li>1、标志寄存器入栈，IF&#x3D;0，TF&#x3D;0；</li>
<li>2、CS、IP入栈；</li>
<li>3、(IP)&#x3D;(8)，(CS)&#x3D;(0AH)。</li>
</ul>
</li>
<li><p>一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。</p>
</li>
<li><p> 扫描码长度为一个字节，通码的第7 位为 0 ，断码的第7位为1，即：断码&#x3D;通码＋80H</p>
</li>
</ol>
<h2 id="第16章-直接定址表"><a href="#第16章-直接定址表" class="headerlink" title="第16章 直接定址表"></a>第16章 直接定址表</h2><hr>
<h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ol>
<li><p>对于程序中的a db 1,2,3,4,5,6,7,8 ：</p>
<ul>
<li>指令：mov al,a [si]，，相当于：mov al,cs:0[si]，</li>
<li>指令：mov al,a[3]，，相当于：mov al,cs:0[3]</li>
<li>指令：mov al,a[bx+si+3] ，，相当于：mov al,cs:0[bx+si+3]</li>
</ul>
</li>
<li><p>以后，我们将这种标号称为数据标号。它标记了存储数据的单元的地址和长度。它不同于仅仅表示地址的地址标号。</p>
</li>
</ol>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<ul>
<li>\(E&#x3D;mc^2\)</li>
<li>(ax^2 + bx + c &#x3D; 0) </li>
<li>$ C_n^2$</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%B1%87%E7%BC%96/" class="category-chain-item">汇编</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%B1%87%E7%BC%96/" class="print-no-link">#汇编</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>汇编语言知识点复习</div>
      <div>http://example.com/2023/05/27/汇编语言知识点复习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>wuuuu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AE%9E%E9%AA%8C/" title="汇编语言实验">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">汇编语言实验</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/27/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%A3%80%E6%B5%8B%E7%82%B9/" title="汇编语言检测点">
                        <span class="hidden-mobile">汇编语言检测点</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
